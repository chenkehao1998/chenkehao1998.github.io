(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{786:function(t,r,e){"use strict";e.r(r);var s=e(3),a=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"内存屏障的由来"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障的由来"}},[t._v("#")]),t._v(" 内存屏障的由来")]),t._v(" "),r("p",[t._v("对于CPU的写，目前主流策略有两种：")]),t._v(" "),r("p",[t._v("1、write back：即CPU向内存写数据时，先把真实数据放入store buffer中，待到某个合适的时间点，CPU才会将store buffer中的数据刷到内存中，而且这两个操作是异步的。这在多线程环境中，有些情况下是可以接受的，但是有些情况是不可接受的，为了让程序员有能力根据业务需要达到同步完成，就设计了内存屏障。关于内存屏障，后面会细讲。")]),t._v(" "),r("p",[t._v("2、write through：即CPU向内存写数据时，同步完成写store buffer与内存。")]),t._v(" "),r("p",[t._v("当前"),r("strong",[t._v("CPU大多数采用的是write back策略")]),t._v("。因为大多数情况下，CPU异步完成写内存产生的部分延迟是可以接受的，而且这个延迟极短。\n只有在多线程环境下需要严格保证内存可见等极少数特殊情况下才需要保证CPU的写在外界看来是同步完成的，"),r("strong",[t._v("需要借助CPU提供的内存屏障实现")]),t._v("。如果直接采用策略2：write through，那每次写内存都需要等待数据刷入内存，极大影响了CPU的执行效率。")]),t._v(" "),r("h1",{attrs:{id:"内存屏障到底是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障到底是什么"}},[t._v("#")]),t._v(" 内存屏障到底是什么？")]),t._v(" "),r("p",[t._v("内存屏障什么都不是，它只是一个抽象概念，就像OOP。如果这样说你不理解，那你把他理解成一堵墙，这堵墙正面与反面的指令无法被CPU乱序执行及这堵墙正面与反面的读写操作需有序执行。")])])}),[],!1,null,null,null);r.default=a.exports}}]);