(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{601:function(s,e,i){s.exports=i.p+"assets/img/image-20200422075753772_d3bf2906ac6e4c9689dd43169c.197207f4.png"},602:function(s,e,i){s.exports=i.p+"assets/img/image-20200422080013776_06163880d1a8449b89c2f43908.f812f02c.png"},603:function(s,e,i){s.exports=i.p+"assets/img/image-20200422083709495_ed20d490edd74245b716616b92.ea6d4f34.png"},604:function(s,e,i){s.exports=i.p+"assets/img/image-20200422083910566_626ba6f9d9894e16bec5294390.dd3ce90d.png"},605:function(s,e,i){s.exports=i.p+"assets/img/image-20200422085957064_7b62a210d4eb4f1b8c245dd55b.08b4de9e.png"},606:function(s,e,i){s.exports=i.p+"assets/img/image-20200422093446392_813149c87ac541dd8451533234.1a827b6f.png"},915:function(s,e,i){"use strict";i.r(e);var _=i(3),a=Object(_.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"redis持久化的意义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化的意义"}},[s._v("#")]),s._v(" Redis持久化的意义")]),s._v(" "),e("p",[s._v("Redis持久化的意义，在于故障恢复，也属于高可用的一个环节。例如")]),s._v(" "),e("p",[s._v("当存放在内存中数据，会因为Redis的突然挂掉，而导致数据丢失")]),s._v(" "),e("img",{attrs:{width:"941",height:"447",src:i(601)}}),s._v(" "),e("p",[s._v("Redis的持久化，就是将内存中的数据，持久化到磁盘上中，然后将磁盘上的数据放到阿里云ODPS中")]),s._v(" "),e("img",{attrs:{width:"941",height:"272",src:i(602)}}),s._v(" "),e("p",[s._v("通过持久化将数据存储在磁盘中，然后定期比如说同步和备份到一些云存储服务上去。")]),s._v(" "),e("h1",{attrs:{id:"redis中的rdb和aof两种持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis中的rdb和aof两种持久化机制"}},[s._v("#")]),s._v(" Redis中的RDB和AOF两种持久化机制")]),s._v(" "),e("p",[s._v("当出现Redis宕机时，我们需要做的是重启redis，尽快让他对外提供服务，缓存全部无法命中，在redis里根本找不到数据，这时候就会出现缓存雪崩的问题。所有的请求，没有在Redis中命中，就会去MySQL数据库这种数据源头中找，一下子MySQL无法承受高并发，那么系统将直接宕机。这个时候MySQL宕机，因为没办法从MySQL中将缓存恢复到Redis中，因为Redis中的数据是从MySQL中来的。")]),s._v(" "),e("h2",{attrs:{id:"rdb持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化机制"}},[s._v("#")]),s._v(" RDB持久化机制")]),s._v(" "),e("p",[s._v("简单来说RDB：就是将Redis中的数据，每个一段时间，进行数据持久化")]),s._v(" "),e("p",[e("img",{attrs:{src:i(603),alt:"image-20200422083709495"}})]),s._v(" "),e("h2",{attrs:{id:"aof持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化机制"}},[s._v("#")]),s._v(" AOF持久化机制")]),s._v(" "),e("p",[s._v("Redis将内存中的数据，存放到一个AOF文件中，但是因为Redis只会写一个AOF文件，因此这个AOF文件会越来越大。")]),s._v(" "),e("p",[s._v("AOF机制对每条写入命令作为日志，以append-only的模式写入一个日志文件中，在Redis重启的时候，可以通过回放AOF日志中的写入指令来重新构建整个数据集。")]),s._v(" "),e("p",[e("img",{attrs:{src:i(604),alt:"image-20200422083910566"}})]),s._v(" "),e("p",[s._v("因为Redis中的数据是有一定限量的，不可能说Redis内存中的数据不限量增长，进而导致AOF无限量增长。")]),s._v(" "),e("p",[s._v("内存大小是一定的，到一定时候，Redis就会用缓存淘汰算法，LRU，自动将一部分数据从内存中给清除。")]),s._v(" "),e("p",[s._v("AOF，是存放每条写命令的，所以会不断的膨胀，当大到一定的时候，AOF做rewrite操作。")]),s._v(" "),e("p",[s._v("AOF rewrite操作，就会基于当时redis内存中的数据，来重新构造一个更小的AOF文件，然后将旧的膨胀的很大的文件给删了。")]),s._v(" "),e("img",{attrs:{width:"941",height:"367",src:i(605)}}),s._v(" "),e("p",[s._v("如果我们想要Redis仅仅作为纯内存的缓存来使用，那么可以禁止RDB和AOF所有的持久化机制")]),s._v(" "),e("p",[s._v("通过AOF和RDB，都可以将Redis内存中的数据给持久化到磁盘上面来，然后可以将这些数据备份到其它地方去，例如阿里云的OOS。")]),s._v(" "),e("p",[s._v("如果Redis挂了，服务器上的内存和磁盘上的数据都丢了，可以从云服务上拷贝回来之前的数据，放到指定的目录下，然后重新启动Redis，Redis就会自动根据持久化数据文件，去恢复内存中的数据，继续对外提供服务。")]),s._v(" "),e("p",[s._v("如果同时使用RDB和AOF两种持久化机制，那么在Redis重启的时候，会使用AOF来重新构建数据，因为AOF中的数据更加完整。")]),s._v(" "),e("h2",{attrs:{id:"rdb持久化机制的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化机制的优点"}},[s._v("#")]),s._v(" RDB持久化机制的优点")]),s._v(" "),e("ul",[e("li",[s._v("RDB会生成多个数据文件，每个数据文件都代表了某个时刻中Redis的数据，这种多个数据文件的方式，非常适合做冷备份，可以将这种完整的数据文件发送到一些远程的安全存储上去，例如阿里云ODPS分布式存储上，以预定好的备份策略来定期备份Redis中的数据\n"),e("ul",[e("li",[s._v("RDB也可以做冷备份，生成多个文件，每个文件代表了某个时刻的完整的数据快照")]),s._v(" "),e("li",[s._v("AOF也可以做冷备，只有一个文件，但是你可以每隔一段时间，去copy一份文件出来")]),s._v(" "),e("li",[s._v("RDB做冷备份的优势在于，可以由Redis去控制固定时长生成快照文件的事情，比较方便。AOF还需要自己写一些脚本去做这个事情，各种定时。")])])]),s._v(" "),e("li",[s._v("RDB对Redis对外提供的读写服务，影响非常小，可以让Redis保持高性能，因为Redis主进程只需要fork一个子进程，让子进程执行磁盘IO操作来进行RDB持久化即可。\n"),e("ul",[e("li",[s._v("RDB每次写都是些Redis内存的，只是在一定的时间内，才将数据写入磁盘")]),s._v(" "),e("li",[s._v("AOF每次都要写文件，虽然可以快速写入 OS Cache中，但是还是会有一定的时间开销，速度肯定比RDB略慢一点。")])])]),s._v(" "),e("li",[s._v("相对于AOF持久化机制来说，直接基于RDB数据文件来重启和恢复Redis进程，更加快速。\n"),e("ul",[e("li",[s._v("RDB数据做冷备份，在最坏的情况下，提供数据恢复的时候，速度比AOF快。")]),s._v(" "),e("li",[s._v("AOF，存放的指令日志，做数据恢复的时候，其实是要回放和执行所有的指令日志，来恢复出来内存中的所有数据的，而RDB就是一份数据文件，恢复的时候，直接加载进内存即可。")])])])]),s._v(" "),e("p",[s._v("综合上面可以知道：RDB特别适合做冷备份")]),s._v(" "),e("h2",{attrs:{id:"rdb持久化的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb持久化的缺点"}},[s._v("#")]),s._v(" RDB持久化的缺点")]),s._v(" "),e("ul",[e("li",[s._v("如果想要在Redis故障时，尽可能的少丢失数据，那么RDB没有AOF好，一般来说，RDB数据快照文件，都是每隔5分钟，或者更长时间生成一次，这个时候就得接受一旦Redis经常宕机，那么丢失最近5分钟的数据。")])]),s._v(" "),e("p",[e("img",{attrs:{src:i(606),alt:"image-20200422093446392"}})]),s._v(" "),e("p",[s._v("​ 这个文件也是RDB最大的缺点，就是不适合做第一优先级的恢复方案，如果你依赖RDB做第一优先级方案，会导致数据丢失的比较多。")]),s._v(" "),e("ul",[e("li",[s._v("RDB每次在fork子进程来执行RDB快照数据生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒\n"),e("ul",[e("li",[s._v("一般不要让RDB的间隔太长，否则每次生成的RDB文件太长，会对Redis本身的性能会有影响")])])])]),s._v(" "),e("h2",{attrs:{id:"aof持久化的优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化的优点"}},[s._v("#")]),s._v(" AOF持久化的优点")]),s._v(" "),e("ul",[e("li",[s._v("AOF可以更好的保护数据不丢失，一般AOF会间隔一秒，通过一个后台线程执行一次fsync操作，最多丢失1秒")]),s._v(" "),e("li",[s._v("AOF日志文件以append-only模式写入，所有没有任何磁盘寻址开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易快速修复。")]),s._v(" "),e("li",[s._v("AOF日志文件及时过大的时候，出现后台的重写操作，也不会影响客户端的读写，因为rewrite log 的时候，会对其中的数据进行压缩，创建出一份需要恢复数据的最小日志出来，再创建新日志文件的时候，老的日志文件还是照常写入，当新的merge后的日志文件ready的时候，再交换新老日志文件即可。")]),s._v(" "),e("li",[s._v("AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复，比如某人不小心用了 flushall命令，清空了整个Redis数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令删除了，然后再将该AOF文件放回去，就可以通过恢复机制，自动回复所有的数据。")])]),s._v(" "),e("h2",{attrs:{id:"aof持久化机制的缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aof持久化机制的缺点"}},[s._v("#")]),s._v(" AOF持久化机制的缺点")]),s._v(" "),e("ul",[e("li",[s._v("对于同一份数据来说，AOF日志通常比RDB数据快照文件更大")]),s._v(" "),e("li",[s._v("AOF开启后，支持写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，因此这也就造成了性能不是很高。\n"),e("ul",[e("li",[s._v("如果你要保证一条数据都不丢，也可以的，AOF的fsync设置成每次写入一条数据，fsync一次，这样Redis的QPS会大降。")])])]),s._v(" "),e("li",[s._v("AOF这种较为复杂的基于命令日志/merge/回放的方式，比基于RDB每次持久化一份完整的数据快照的方式，更加脆弱一些，容易有BUG，不过AOF就是为了避免rewrite过程导致的BUG，因此每次rewrite并不是基于旧的指令来进行merge的，而是基于当时内存中数据进行指令的重新构建，这与健壮性会好一些。")]),s._v(" "),e("li",[s._v("唯一的缺点：就是做数据恢复的时候，会比较慢，还有做冷备，定期的被封，不太方便，可能要自己手动写复杂的脚本去做。")])]),s._v(" "),e("h2",{attrs:{id:"rdb和aof的选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rdb和aof的选择"}},[s._v("#")]),s._v(" RDB和AOF的选择")]),s._v(" "),e("ul",[e("li",[s._v("不要仅仅使用RDB，因为那样会导致你丢失很多的数据")]),s._v(" "),e("li",[s._v("也不要仅仅使用AOF，因为这样有两个问题\n"),e("ul",[e("li",[s._v("AOF做冷备，没有RDB冷备恢复快")]),s._v(" "),e("li",[s._v("RDB每次简单粗暴的生成数据快照，更加健壮，可以避免AOF这种复杂的被封和恢复机制的BUG")])])]),s._v(" "),e("li",[s._v("综合使用AOF和RDB两种持久化机制，用AOF来保证数据不丢失，作为数据恢复的第一选择，用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，可以使用RDB来进行快速的数据恢复。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);