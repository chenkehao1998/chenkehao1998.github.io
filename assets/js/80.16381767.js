(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{378:function(a,t,e){a.exports=e.p+"assets/img/1fcccbce6602f3a4376962ba6b65cfee.dd156e32.png"},732:function(a,t,e){"use strict";e.r(t);var v=e(3),s=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树 "),t("RouterLink",{attrs:{to:"/数据结构与算法/树/Hash树.html"}},[a._v("Hash树")]),a._v(" 的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。")],1),a._v(" "),t("p",[a._v("Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。")]),a._v(" "),t("p",[a._v("它有3个基本性质：")]),a._v(" "),t("ul",[t("li",[a._v("根节点不包含字符，除根节点外每一个节点都只包含一个字符。")]),a._v(" "),t("li",[a._v("从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。")]),a._v(" "),t("li",[a._v("每个节点的所有子节点包含的字符都不相同。")])]),a._v(" "),t("h1",{attrs:{id:"作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[a._v("#")]),a._v(" 作用")]),a._v(" "),t("ol",[t("li",[a._v("能够保存一些字符串->值的对应关系。基本上，它跟 Java 的 HashMap 功能相同，都是 key-value 映射，"),t("strong",[a._v("只不过 Trie 的 key 只能是字符串")]),a._v("。")]),a._v(" "),t("li",[a._v("前缀查询")]),a._v(" "),t("li",[a._v("查询")])]),a._v(" "),t("h1",{attrs:{id:"优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),t("p",[a._v("Trie 的强大之处就在于它的时间复杂度。它的插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度，与 Trie 中保存了多少个元素无关。Hash 表号称是 O(1) 的，但在计算 hash 的时候就确定会是 O(k) ，并且还有碰撞之类的问题；Trie 的缺点是空间消耗很高。")]),a._v(" "),t("h1",{attrs:{id:"例子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[a._v("#")]),a._v(" 例子")]),a._v(" "),t("p",[a._v("题目：给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。")]),a._v(" "),t("p",[a._v("分析：这题当然可以用hash来解决，但是本文重点介绍的是trie树，因为在某些方面它的用途更大。比如说对于某一个单词，我们要询问它的前缀是否出现过。这样hash就不好搞了，而用trie还是很简单。")]),a._v(" "),t("p",[a._v("如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于100000的范围难以接受。\n假设我要查询的单词是abcd，那么在他前面的单词中，以b，c，d，f之类开头的我显然不必考虑。而只要找以a开头的中是否存在abcd就可以了。同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。")]),a._v(" "),t("p",[a._v("假设有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们构建的树就是如下图这样的：\n"),t("img",{attrs:{src:e(378),alt:"1fcccbce6602f3a4376962ba6b65cfee.png"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);