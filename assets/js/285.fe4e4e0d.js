(window.webpackJsonp=window.webpackJsonp||[]).push([[285],{986:function(v,_,t){"use strict";t.r(_);var p=t(3),n=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("方法一：单次支付请求，也就是直接支付了，不需要额外的数据库操作了，这个时候发起异步请求创建一个唯一的ticketId，就是门票，这张门票只能使用一次就作废，具体步骤如下：")]),v._v(" "),_("p",[v._v("1、异步请求获取门票")]),v._v(" "),_("p",[v._v("2、调用支付，传入门票")]),v._v(" "),_("p",[v._v("3、根据门票ID查询此次操作是否存在，如果存在则表示该操作已经执行过，直接返回结果；如果不存在，支付扣款，保存结果")]),v._v(" "),_("p",[v._v("4、返回结果到客户端")]),v._v(" "),_("p",[v._v("如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的.")]),v._v(" "),_("p",[v._v("方法二：分布式环境下各个服务相互调用")]),v._v(" "),_("p",[v._v("这边就要举例我们的系统了，我们支付的时候先要扣款，然后更新订单，这个地方就涉及到了订单服务以及支付服务了。用户调用支付，扣款成功后，更新对应订单状态，然后再保存流水。而在这个地方就没必要使用门票ticketId了，因为会比较闲的麻烦（支付状态：未支付，已支付）")]),v._v(" "),_("p",[v._v("步骤：")]),v._v(" "),_("p",[v._v("1、查询订单支付状态")]),v._v(" "),_("p",[v._v("2、如果已经支付，直接返回结果")]),v._v(" "),_("p",[v._v("3、如果未支付，则支付扣款并且保存流水")]),v._v(" "),_("p",[v._v("4、返回支付结果")]),v._v(" "),_("p",[v._v("如果步骤4通信失败，用户再次发起请求，那么最终结果还是一样的")]),v._v(" "),_("p",[v._v("对于做过支付的朋友，幂等也可以称之为冲正，保证客户端与服务端的交易一致性，避免多次扣款。")])])}),[],!1,null,null,null);_.default=n.exports}}]);