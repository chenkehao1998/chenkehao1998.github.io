(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{805:function(t,v,_){"use strict";_.r(v);var n=_(3),s=Object(n.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("⽐如， A 进程要给 B 进程发送消息， A 进程把数据放在对应的消息队列后就可以正常返回了， B 进程需要的时候再去读取数据就可以了。同理， B 进程要给 A 进程发送消息也是如此。")]),t._v(" "),v("p",[v("strong",[t._v("消息队列是保存在内核中的消息链表")]),t._v("，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送⽅和接收⽅要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。")]),t._v(" "),v("p",[v("strong",[t._v("消息队列生命周期随内核")]),t._v("，如果没有释放消息队列或者没有关闭操作系统，"),v("strong",[t._v("消息队列会⼀直存在")]),t._v("，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。")]),t._v(" "),v("h1",{attrs:{id:"消息队列的缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列的缺点"}},[t._v("#")]),t._v(" 消息队列的缺点")]),t._v(" "),v("ol",[v("li",[t._v("通信不及时")]),t._v(" "),v("li",[t._v("附件也有大小限制\n"),v("strong",[t._v("消息队列不适合大数据的传输")]),t._v("，因为在内核中每个消息体都有⼀个最⼤长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB ，它们以字节为单位，分别定义了⼀条消息的最大长度和⼀个队列的最大长度。")]),t._v(" "),v("li",[t._v("消息队列通信过程中，"),v("strong",[t._v("存在用户态与内核态之间的数据复制开销")]),t._v("，因为进程写⼊数据到内核中的消息队列时，会发生从⽤户态复制数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发生从内核态复制数据到用户态的过程")])])])}),[],!1,null,null,null);v.default=s.exports}}]);