(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{914:function(t,a,s){"use strict";s.r(a);var r=s(3),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应\n（2）更新的时候，先删除缓存，然后再更新数据库")]),t._v(" "),a("h1",{attrs:{id:"为什么是删除-而不是更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是删除-而不是更新"}},[t._v("#")]),t._v(" 为什么是删除，而不是更新")]),t._v(" "),a("p",[t._v("因为缓存可能并不是某单张表的一条直接读取出来的 而是读取多个表的多条数据计算得到的")]),t._v(" "),a("p",[t._v("那么因为如果是更新的话，假设这个数据并不是经常被访问，每次更新都要在数据库好几个表，而删除的话，只是需要读取的时候，访问数据库")]),t._v(" "),a("h1",{attrs:{id:"单机模式分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单机模式分析"}},[t._v("#")]),t._v(" 单机模式分析")]),t._v(" "),a("p",[t._v("为什么选择先删除缓存，再更新数据库？")]),t._v(" "),a("p",[t._v("如果先更新数据库，再操作缓存，如果缓存操作缓存失败，则会导致双写不一致")]),t._v(" "),a("p",[t._v("如果删除缓存，即使后面操作数据库失败了，那也就是数据库里保存的是旧数据，但是缓存和数据库依然是一致的")]),t._v(" "),a("h1",{attrs:{id:"并发模式分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发模式分析"}},[t._v("#")]),t._v(" 并发模式分析")]),t._v(" "),a("p",[t._v("当一个线程需要更新，直接删除了缓存，准备操作数据库，此时又来了一个线程，发现缓存没数据了，又去数据库里读到缓存，缓存有数据之后，第一个线程才修改好数据库，此时就发生了缓存和数据库双写不一致的问题")]),t._v(" "),a("p",[t._v("这个时候需要根据数据hash到对应的队列里，在队列里以此执行，使得对数据操作能够串行化，然后等操作完成，就去回调之后的方法，用异步的方式解决问题")])])}),[],!1,null,null,null);a.default=v.exports}}]);