(window.webpackJsonp=window.webpackJsonp||[]).push([[288],{999:function(a,t,n){"use strict";n.r(t);var o=n(3),r=Object(o.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"random-loadbalance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#random-loadbalance"}},[a._v("#")]),a._v(" random loadbalance")]),a._v(" "),t("p",[a._v("默认情况下，dubbo是random load balance随机调用实现负载均衡，可以对provider不同实例设置不同的权重，会按照权重来负载均衡，权重越大分配流量越高，一般就用这个默认的就可以了。")]),a._v(" "),t("h2",{attrs:{id:"roundrobin-loadbalance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#roundrobin-loadbalance"}},[a._v("#")]),a._v(" roundrobin loadbalance")]),a._v(" "),t("p",[a._v("还有roundrobin loadbalance，这个的话默认就是均匀地将流量打到各个机器上去，但是如果各个机器的性能不一样，容易导致性能差的机器负载过高。所以此时需要调整权重，让性能差的机器承载权重小一些，流量少一些。")]),a._v(" "),t("h2",{attrs:{id:"leastactive-loadbalance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#leastactive-loadbalance"}},[a._v("#")]),a._v(" leastactive loadbalance")]),a._v(" "),t("p",[a._v("这个就是自动感知一下，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给不活跃的性能差的机器更少的请求")]),a._v(" "),t("h2",{attrs:{id:"consistanthash-loadbalance"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#consistanthash-loadbalance"}},[a._v("#")]),a._v(" consistanthash loadbalance")]),a._v(" "),t("p",[a._v("一致性Hash算法，相同参数的请求一定分发到一个provider上去，provider挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果你需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性hash策略。")])])}),[],!1,null,null,null);t.default=r.exports}}]);