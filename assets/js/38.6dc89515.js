(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{492:function(s,a,e){s.exports=e.p+"assets/img/446c148246644ce737778455dbc35285.737a272d.png"},493:function(s,a,e){s.exports=e.p+"assets/img/ac24f35d736ac15a17934bf276d543d3.f62d0fa3.png"},494:function(s,a,e){s.exports=e.p+"assets/img/8e68f4074e1871190a790d35140216aa.2dadd362.png"},495:function(s,a,e){s.exports=e.p+"assets/img/a010a143b46611a2eb8e5290e87744d0.f6a64f1e.png"},804:function(s,a,e){"use strict";e.r(a);var t=e(3),n=Object(t.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"匿名管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#匿名管道"}},[s._v("#")]),s._v(" 匿名管道")]),s._v(" "),a("p",[s._v("如果你学过 Linux 命令，那你肯定很熟悉「 "),a("code",[s._v("|")]),s._v(" 」这个竖线。")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("ps")]),s._v(" -ef "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("grep")]),s._v(" java\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("上⾯命令⾏⾥的「"),a("code",[s._v("|")]),s._v(" 」"),a("strong",[s._v("竖线就是⼀个管道")]),s._v("，它的功能是将前⼀个命令（ "),a("code",[s._v("ps -ef")]),s._v(" ）的输出，作为后⼀个命令（ "),a("code",[s._v("grep java")]),s._v(" ）的输⼊，从这功能描述，可以看出"),a("strong",[s._v("管道传输数据是单向的，如果想相互通信，我们需要创建两个管道。")]),s._v("\n同时，我们得知上⾯这种管道是没有名字，所以「 "),a("code",[s._v("|")]),s._v(" 」表示的管道称为匿名管道，⽤完了就销毁。")]),s._v(" "),a("h1",{attrs:{id:"命名管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名管道"}},[s._v("#")]),s._v(" 命名管道")]),s._v(" "),a("p",[s._v("管道还有另外⼀个类型是命名管道，也被叫做 FIFO ，因为数据是先进先出的传输⽅式。\n在使⽤命名管道前，先需要通过 "),a("code",[s._v("mkfifo")]),s._v(" 命令来创建，并且指定管道名字：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("mkfifo")]),s._v(" myPipe\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("myPipe 就是这个管道的名称，基于 Linux ⼀切皆⽂件的理念，所以管道也是以⽂件的⽅式存在，我们可以⽤ ls 看⼀下，这个⽂件的类型是 p，也就是 pipe（管道） 的意思：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("ls")]),s._v(" -l\nprw-r--r--. "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" root root "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" Jul "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("17")]),s._v(" 02:45 myPipe\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("接下来，我们往 myPipe 这个管道写⼊数据：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"hello"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" myPipe // 将数据写进管道\n// 停住了 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("操作了后，你会发现命令执⾏后就停在这了，这是因为管道⾥的内容没有被读取，只有当管道⾥的数据被读完后，命令才可以正常退出。")]),s._v(" "),a("p",[s._v("于是，我们"),a("strong",[s._v("执行另外⼀个命令")]),s._v("来读取这个管道⾥的数据：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("cat")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v(" myPipe // 读取管道⾥的数据\nhello\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("可以看到，管道⾥的内容被读取出来了，并打印在了终端上，另外⼀⽅⾯， echo 那个命令也正常退出了。")]),s._v(" "),a("p",[s._v("我们可以看出， "),a("strong",[s._v("管道这种通信方式效率低")]),s._v("，"),a("strong",[s._v("不适合进程间频繁地交换数据")]),s._v("。当然，它的好处，⾃然就是简单，同时也我们很容易得知管道⾥的数据已经被另⼀个进程读取了。")]),s._v(" "),a("h1",{attrs:{id:"背后原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背后原理"}},[s._v("#")]),s._v(" 背后原理")]),s._v(" "),a("h2",{attrs:{id:"父子进程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#父子进程通信"}},[s._v("#")]),s._v(" 父子进程通信")]),s._v(" "),a("p",[s._v("匿名管道的创建，需要通过这个系统调⽤：\n"),a("code",[s._v("int pipe(int fd[2])")]),s._v("\n这⾥表示创建⼀个匿名管道，并返回了两个描述符，⼀个是管道的读取端描述符"),a("code",[s._v("fd[0]")]),s._v(" ，另⼀个是管道的写入端描述符 "),a("code",[s._v("fd[1]")]),s._v(" 。注意，这个匿名管道是特殊的⽂件，只存在于内存，不存于⽂件系统中。\n"),a("img",{attrs:{src:e(492),alt:"446c148246644ce737778455dbc35285.png"}}),s._v("\n其实， "),a("strong",[s._v("所谓的管道，就是内核里面的一串缓存")]),s._v("。从管道的⼀段写入的数据，实际上是缓存在内核中的，另⼀端读取，也就是从内核中读取这段数据。另外，"),a("strong",[s._v("管道传输的数据是⽆格式的流且大小受限。")])]),s._v(" "),a("p",[s._v("这两个描述符都是在⼀个进程⾥⾯，并没有起到进程间通信的作⽤，怎么样才能使得管道是跨过两个进程的呢？\n我们"),a("strong",[s._v("可以使用 fork 创建子进程， 创建的子进程会复制父进程的文件描述符")]),s._v("，这样就做到了两个进程各有两个 "),a("code",[s._v("fd[0]")]),s._v(" 与 "),a("code",[s._v("fd[1]")]),s._v("，两个进程就可以"),a("strong",[s._v("通过各自的 fd 写⼊和读取同一个管道文件实现跨进程通信")]),s._v("了。\n"),a("img",{attrs:{src:e(493),alt:"ac24f35d736ac15a17934bf276d543d3.png"}}),s._v("\n管道只能⼀端写⼊，另⼀端读出，所以上⾯这种模式容易造成混乱，因为⽗进程和⼦进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是：")]),s._v(" "),a("ul",[a("li",[s._v("⽗进程关闭读取的 "),a("code",[s._v("fd[0]")]),s._v("，只保留写⼊的"),a("code",[s._v("fd[1]")])]),s._v(" "),a("li",[s._v("⼦进程关闭写⼊的 "),a("code",[s._v("fd[1]")]),s._v("，只保留读取的"),a("code",[s._v("fd[0]")]),s._v(" "),a("img",{attrs:{src:e(494),alt:"8e68f4074e1871190a790d35140216aa.png"}}),s._v("\n所以说如果需要双向通信，则应该创建两个管道。")])]),s._v(" "),a("h2",{attrs:{id:"shell进程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shell进程通信"}},[s._v("#")]),s._v(" shell进程通信")]),s._v(" "),a("p",[s._v("上面仅仅解析了使用管道进行父进程和子进程之间的通信，但是在我们 shell里面并不是这样的\n在 shel里面执行 "),a("code",[s._v("A | B")]),s._v("命令的时候， A 进程和 B 进程都是 shell 创建出来的⼦进程， A 和 B 之间不存在父子关系，它俩的⽗进程都是 shell。\n"),a("img",{attrs:{src:e(495),alt:"a010a143b46611a2eb8e5290e87744d0.png"}}),s._v("\n所以说，在 shell里通过「 | 」匿名管道将多个命令连接在⼀起，实际上也就是创建了多个⼦进程，那么在我们编写 shell 脚本时，能使用1个管道搞定的事情，就不要多用一个管道，这样可以减少创建⼦进程的系统开销。")]),s._v(" "),a("blockquote",[a("p",[s._v("总结：\n对于匿名管道，它的"),a("strong",[s._v("通信范围是存在父子关系的进程")]),s._v("。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd文件描述符，来达到通信的目的。")]),s._v(" "),a("p",[s._v("对于命名管道，它"),a("strong",[s._v("可以在不相关的进程间也能相互通信")]),s._v("。因为命令管道，提前创建了⼀个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。\n不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另⼀个进程读取数据时候自然也是从内核中获取，同时通信数据都"),a("strong",[s._v("遵循先进先出原则")]),s._v("，不支持 lseek 之类的⽂件定位操作。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);