(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{703:function(a,t,s){a.exports=s.p+"assets/img/f3f1ce72b295d733ac377663f33211c1.95bf5350.png"},704:function(a,t,s){a.exports=s.p+"assets/img/2a6b14a0765746f42983d0f791d65c7a.5f066470.png"},992:function(a,t,s){"use strict";s.r(t);var _=s(3),r=Object(_.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_1-异步通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-异步通信"}},[a._v("#")]),a._v(" 1.异步通信")]),a._v(" "),t("p",[a._v("有些业务不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。\n"),t("img",{attrs:{src:s(703),alt:"f3f1ce72b295d733ac377663f33211c1.png"}})]),a._v(" "),t("h1",{attrs:{id:"_2-缓冲"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓冲"}},[a._v("#")]),a._v(" 2. 缓冲")]),a._v(" "),t("p",[a._v("在任何重要的系统中，都会有需要不同的处理时间的元素。消息队列通过一个缓冲层来帮助任务最高效率的执行，该缓冲有助于控制和优化数据流经过系统的速度。以调节系统响应时间。")]),a._v(" "),t("h1",{attrs:{id:"_3-解耦"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-解耦"}},[a._v("#")]),a._v(" 3. 解耦")]),a._v(" "),t("p",[a._v("降低工程间的强依赖程度，针对异构系统进行适配。在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。通过消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口，当应用发生变化时，可以独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。\n"),t("img",{attrs:{src:s(704),alt:"2a6b14a0765746f42983d0f791d65c7a.png"}})]),a._v(" "),t("h1",{attrs:{id:"_4-冗余"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-冗余"}},[a._v("#")]),a._v(" 4. 冗余")]),a._v(" "),t("p",[a._v("有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。")]),a._v(" "),t("h1",{attrs:{id:"_5-扩展性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-扩展性"}},[a._v("#")]),a._v(" 5. 扩展性")]),a._v(" "),t("p",[a._v("因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。便于分布式扩容。")]),a._v(" "),t("h1",{attrs:{id:"_6-可恢复性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-可恢复性"}},[a._v("#")]),a._v(" 6. 可恢复性")]),a._v(" "),t("p",[a._v("系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。")]),a._v(" "),t("h1",{attrs:{id:"_7-顺序保证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-顺序保证"}},[a._v("#")]),a._v(" 7. 顺序保证")]),a._v(" "),t("p",[a._v("在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。")]),a._v(" "),t("h1",{attrs:{id:"_8-过载保护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-过载保护"}},[a._v("#")]),a._v(" 8. 过载保护")]),a._v(" "),t("p",[a._v("在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量无法提取预知；如果以为了能处理这类瞬间峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。")]),a._v(" "),t("h1",{attrs:{id:"_9-数据流处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-数据流处理"}},[a._v("#")]),a._v(" 9. 数据流处理")]),a._v(" "),t("p",[a._v("分布式系统产生的海量数据流，如：业务日志、监控数据、用户行为等，针对这些数据流进行实时或批量采集汇总，然后进行大数据分析是当前互联网的必备技术，通过消息队列完成此类数据收集是最好的选择。")])])}),[],!1,null,null,null);t.default=r.exports}}]);