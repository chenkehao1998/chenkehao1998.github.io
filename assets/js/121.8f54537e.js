(window.webpackJsonp=window.webpackJsonp||[]).push([[121],{731:function(t,n,s){"use strict";s.r(n);var a=s(3),r=Object(a.a)({},(function(){var t=this,n=t._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("理想的状况是但愿不通过任何比较，一次存取便能获得所查的记录， 那就必须在记的存储位置和它的关键字之间创建一个肯定的对应关系f，使每一个关键字和一个惟一的存储位置相对应。于是在查找时，只要根据这个对应关系f找到 给定值K的像f(K)。由此，不须要进行比较即可直接取得所查记录。在此，咱们称这个对应关系为哈希（Hash）函数，按这个思想创建的表为哈希表。")]),t._v(" "),n("p",[t._v("在哈希表中对于不一样的关键字可能获得同一哈希地址，这种现象称作冲突。在通常状况下，冲突只能尽量地减小，而不能彻底避免。由于哈希函数是从关键字集合 到地址集合的映像。一般关键字的集合比较大，它的元素包括全部可能的关键字，而地址集合的元素仅为哈希表中的地址值。在通常状况下，哈希函数是一个压缩映像函数，这就不可避免的要产生冲突。")]),t._v(" "),n("h1",{attrs:{id:"哈希树的理论基础"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#哈希树的理论基础"}},[t._v("#")]),t._v(" 哈希树的理论基础")]),t._v(" "),n("p",[t._v("【质数分辨定理】\n简单地说就是：n个不一样的质数能够“分辨”的连续整数的个数和他们的乘积相等。“分辨”就是指这些连续的整数不可能有彻底相同的余数序列。")]),t._v(" "),n("p",[t._v("例如：\n从2起的连续质数，连续10个质数就能够分辨大约"),n("code",[t._v("M(10) =2*3*5*7*11*13*17*19*23*29= 6464693230")]),t._v("个数，已经超过计算机中经常使用整数（32bit）的表达范围。连续100个质数就能够分辨大约"),n("code",[t._v("M(100) = 4.711930")]),t._v("乘以10的219次方。")]),t._v(" "),n("h1",{attrs:{id:"插入"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#插入"}},[t._v("#")]),t._v(" 插入")]),t._v(" "),n("p",[t._v("咱们选择质数分辨算法来创建一棵哈希树。\n选择从2开始的连续质数来创建一个十层的哈希树。第一层结点为根结点，根结点下有2个结点；第二层的每一个结点下有3个结点；依此类推，即每层结点的子节点数目为连续的质数。到第十层，每一个结点下有29个结点。\n同一结点中的子结点，从左到右表明不一样的余数结果。\n例如：第二层结点下有三个子节点。那么从左到右分别表明：除3余0，除3余1，除3余2.\n对质数进行取余操做获得的余数决定了处理的路径。")])])}),[],!1,null,null,null);n.default=r.exports}}]);