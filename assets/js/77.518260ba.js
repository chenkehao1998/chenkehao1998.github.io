(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{691:function(t,a,b){t.exports=b.p+"assets/img/6fc0072950a3c88078086c5877c42c17.a77c17a0.png"},692:function(t,a,b){t.exports=b.p+"assets/img/b9c4d90d2c2ec082eba17764421a0a52.9bac2984.png"},987:function(t,a,b){"use strict";b.r(a);var e=b(3),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"_1-为什么会丢数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-为什么会丢数据"}},[t._v("#")]),t._v(" 1. 为什么会丢数据")]),t._v(" "),a("p",[a("img",{attrs:{src:b(691),alt:"6fc0072950a3c88078086c5877c42c17.png"}})]),t._v(" "),a("h1",{attrs:{id:"_2-解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决办法"}},[t._v("#")]),t._v(" 2. 解决办法")]),t._v(" "),a("h2",{attrs:{id:"_2-1-生产者弄丢了数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-生产者弄丢了数据"}},[t._v("#")]),t._v(" 2.1 生产者弄丢了数据")]),t._v(" "),a("p",[t._v("生产者将数据发送到RabbitMQ的时候，可能数据就在半路给搞丢了，因为网络啥的问题，都有可能。")]),t._v(" "),a("p",[t._v("方法1 ： 用RabbitMQ提供的事务功能（同步）\n生产者发送数据之前，开启RabbitMQ事务（channel.txSelect），然后发送消息，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，那么可以提交事务，但是问题是，RabbitMQ事务机制一搞，基本上吞吐量会下来，因为太损耗性能。\n"),a("img",{attrs:{src:b(692),alt:"b9c4d90d2c2ec082eba17764421a0a52.png"}}),t._v("\n方法2：confirm机制（异步回调）")]),t._v(" "),a("h2",{attrs:{id:"_2-2-rabbitmq丢失数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-rabbitmq丢失数据"}},[t._v("#")]),t._v(" 2.2 RabbitMQ丢失数据")]),t._v(" "),a("p",[t._v("这个就是RabbitMQ自己丢失数据，这个时候就必须开启RabbitMQ的"),a("strong",[t._v("持久化")]),t._v("，就是消息写入之后，同时需要持久化到磁盘中，哪怕是RabbitMQ自己宕机了，也能够从磁盘中读取之前存储的消息，这样数据一般就不会丢失了，但是存在一个极端的情况，就是RabbitMQ还没持久化的时候，就已经宕机了，那么可能会造成少量的数据丢失，但是这个概率是比较小的。")]),t._v(" "),a("p",[t._v("设置持久化的两个步骤，第一个是创建queue的时候，将其持久化的，这样就保证了RabbitMQ持久化queue的元数据，但是不会持久化queue中的数据，第二个就是发送消息的时候，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ将会将消息持久化到磁盘上，必须同时设置两个持久化才行，哪怕是Rabbit挂了，也会从磁盘中恢复queue 和 queue中的数据。")]),t._v(" "),a("p",[t._v("而且持久化可以跟生产者那边的confirm机制配置起来，只有消息被持久化到磁盘后，才会通知生产者ACK了，所以哪怕是在持久化磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到ACK，你也是可以自己重发的。")]),t._v(" "),a("h2",{attrs:{id:"_2-3-消费者丢失数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-消费者丢失数据"}},[t._v("#")]),t._v(" 2.3 消费者丢失数据")]),t._v(" "),a("p",[t._v("消费者丢失数据，主要是因为打开了AutoAck的机制，消费者会自动通知RabbitMQ，表明自己已经消费完这条数据了，但是如果你消费到了一条消息，还在处理中，还没处理完，此时消费者就会自动AutoAck了，通知RabbitMQ说这条消息已经被消费了，此时不巧的是，消费者系统宕机了，这条消息就会丢失，因为RabbitMQ以为这条消息已经处理掉。")]),t._v(" "),a("p",[t._v("在消费者层面上，我们需要将AutoAck给关闭，然后每次自己确定已经处理完了一条消息后，你再发送ack给RabbitMQ，如果你还没处理完就宕机了，此时RabbitMQ没收到你发的Ack消息，然后RabbitMQ就会将这条消息分配给其它的消费者去处理。")])])}),[],!1,null,null,null);a.default=s.exports}}]);