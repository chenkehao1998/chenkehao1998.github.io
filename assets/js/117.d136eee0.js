(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{723:function(v,_,n){"use strict";n.r(_);var t=n(3),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("给你一个整数数组 nums，将它重新排列成 nums[0] < nums[1] > nums[2] < nums[3]... 的顺序。")]),v._v(" "),_("h2",{attrs:{id:"题目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[v._v("#")]),v._v(" 题目")]),v._v(" "),_("p",[v._v("你可以假设所有输入数组都可以得到满足题目要求的结果。")]),v._v(" "),_("p",[v._v("示例 1：")]),v._v(" "),_("p",[v._v("输入：nums = [1,5,1,1,6,4]\n输出：[1,6,1,5,1,4]\n解释：[1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。\n示例 2：")]),v._v(" "),_("p",[v._v("输入：nums = [1,3,2,2,3,1]\n输出：[2,3,1,3,1,2]")]),v._v(" "),_("p",[v._v("提示：")]),v._v(" "),_("p",[v._v("1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\n题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果")]),v._v(" "),_("p",[v._v("进阶：你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？")]),v._v(" "),_("h2",{attrs:{id:"思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[v._v("#")]),v._v(" 思路")]),v._v(" "),_("p",[v._v("先排序 然后从中间拆成两份 再交叉\n比如 先排序完成之后结果为 "),_("code",[v._v("1 2 3 4 5")]),v._v("\n然后就可以拆成"),_("code",[v._v("1 2 3")]),v._v("和"),_("code",[v._v("4 5")]),v._v("\n穿插之后就是"),_("code",[v._v("1 4 2 5 3")]),v._v("\n但这种方法 有一点很没有必要 就是排序 只需要 根据中位数 拆成左右两部分\n"),_("code",[v._v("2 1 3 5 4")]),v._v(" 依然可以拆成 "),_("code",[v._v("2 1 3")]),v._v("和"),_("code",[v._v("5 4")]),v._v("，然后交叉陈"),_("code",[v._v("2 5 1 4 3")]),v._v("\n而此时可以使用快速选择法 "),_("RouterLink",{attrs:{to:"/01.数据结构与算法/数据结构与算法/搜索/快速选择(Quickselect)算法：寻找第k大的元素.html"}},[v._v("快速选择(Quickselect)算法：寻找第k大的元素")])],1),v._v(" "),_("p",[v._v("注：拆分成两份之后，一定要将两部分反向")]),v._v(" "),_("blockquote",[_("p",[v._v("例如，对于数组[1,1,2,2,3,3],分割为[1,1,2]和[2,3,3]，虽然A和B都出现了2，但穿插后为[1,2,1,3,2,3]，满足要求。\n而如果2的个数再多一些，即[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，最终结果为[1,2,1,2,2,3]，来自A的2和来自B的2出现在了相邻位置。")]),v._v(" "),_("p",[v._v("出现这一问题是因为重复数在A和B中的位置决定的，因为r在A尾部，B头部，所以如果r个数太多（大于等于(length(nums) + 1)/2），就可能在穿插后相邻。要解决这一问题，我们需要使A的r和B的r在穿插后尽可能分开。一种可行的办法是将A和B反序：")]),v._v(" "),_("p",[v._v("例如，对于数组[1,1,2,2,2,3]，分割为[1,1,2]和[2,2,3]，分别反序后得到[2, 1, 1]和[3, 2, 2]，此时2在A头部，B尾部，穿插后就不会发生相邻了。")]),v._v(" "),_("p",[v._v("当然，这只能解决r的个数等于(length(nums) + 1)/2的情况，如果r的个数大于(length(nums) + 1)/2，还是会出现相邻。但实际上，这种情况是不存在有效解的，也就是说，这种数组对于本题来说是非法的")])])])}),[],!1,null,null,null);_.default=s.exports}}]);