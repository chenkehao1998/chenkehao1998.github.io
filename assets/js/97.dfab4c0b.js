(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{607:function(t,s,e){t.exports=e.p+"assets/img/b58046464af61804b1095dfcbf315995.112b0b2a.png"},917:function(t,s,e){"use strict";e.r(s);var r=e(3),a=Object(r.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"什么是redis的分布式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是redis的分布式"}},[t._v("#")]),t._v(" 什么是redis的分布式？")]),t._v(" "),s("p",[t._v("这个也是线上非常常见的一个问题，就是多客户端同时并发写一个key，可能本来应该先到的数据后到了，导致数据版本错了。或者是多客户端同时获取一个key，修改值之后再写回去，只要顺序错了，数据就错了")]),t._v(" "),s("p",[t._v("如下图所示：我们有好几个系统同时取访问缓存，并且发起了一个写缓存的操作")]),t._v(" "),s("p",[t._v("set V1、V2、V3、V4\n我们期望的是它是有顺序的去执行，但是最后却没有顺序了\n变成了：set V1、V3、V4、V2\n"),s("img",{attrs:{src:e(607),alt:"b58046464af61804b1095dfcbf315995.png"}})]),t._v(" "),s("h1",{attrs:{id:"解决方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),s("p",[t._v("使用zookeeper分布式锁，可以使得多个并发不会同时执行\n其次redis的缓存数据都来自于mysql ,之前存数据的时候加入时间戳\n那么redis读取出来的时候就会有时间戳\n将数据读入缓存的时候检查时间戳是否是比现有的缓存新，新就覆盖，否则放弃操作")])])}),[],!1,null,null,null);s.default=a.exports}}]);