(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{401:function(t,a,v){t.exports=v.p+"assets/img/cbc7a608fec0dbe56fceeb91957980fb.0647b943.png"},402:function(t,a,v){t.exports=v.p+"assets/img/29ac797d599eea59af6569b0d042642c.f24b10d5.png"},403:function(t,a,v){t.exports=v.p+"assets/img/dab7ebb7bce1b2d7b77283e9faa59de8.98e0b4d2.png"},404:function(t,a,v){t.exports=v.p+"assets/img/927ef6fb18426b59aacbad996ac81f1f.e2e82f86.png"},748:function(t,a,v){"use strict";v.r(a);var e=v(3),_=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),a("ol",[a("li",[t._v("防止指令重排")]),t._v(" "),a("li",[t._v("解决可见性问题")])]),t._v(" "),a("h3",{attrs:{id:"_1-防止指令重排"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-防止指令重排"}},[t._v("#")]),t._v(" 1. 防止指令重排")]),t._v(" "),a("p",[t._v("重排序：为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。")]),t._v(" "),a("p",[t._v("重排序的类型有哪些呢？源码到最终执行会经过哪些重排序呢？\n"),a("img",{attrs:{src:v(401),alt:"cbc7a608fec0dbe56fceeb91957980fb.png"}})]),t._v(" "),a("p",[t._v("一般重排序可以分为如下三种：")]),t._v(" "),a("ul",[a("li",[t._v("编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;")]),t._v(" "),a("li",[t._v("指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;")]),t._v(" "),a("li",[t._v("内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。")])]),t._v(" "),a("p",[t._v("Volatile是通过内存屏障 "),a("RouterLink",{attrs:{to:"/pages/ecc12f/"}},[t._v("内存屏障")]),t._v(" 来保证不被重排序的")],1),t._v(" "),a("p",[t._v("java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。")]),t._v(" "),a("p",[t._v("为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：\n"),a("img",{attrs:{src:v(402),alt:"29ac797d599eea59af6569b0d042642c.png"}})]),t._v(" "),a("blockquote",[a("p",[t._v("图中NO 代表 不重排序\n需要注意的是："),a("strong",[t._v("volatile写是在前面和后面分别插入内存屏障")]),t._v("，而"),a("strong",[t._v("volatile读操作是在后面插入两个内存屏障")]),t._v("。\n如图：\n写:\n"),a("img",{attrs:{src:v(403),alt:"dab7ebb7bce1b2d7b77283e9faa59de8.png"}}),t._v("\n读：\n"),a("img",{attrs:{src:v(404),alt:"927ef6fb18426b59aacbad996ac81f1f.png"}})])]),t._v(" "),a("h3",{attrs:{id:"_2-解决可见性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-解决可见性问题"}},[t._v("#")]),t._v(" 2. 解决可见性问题")]),t._v(" "),a("p",[t._v("解决可见性问题的两种方法")]),t._v(" "),a("ol",[a("li",[t._v("加锁 "),a("RouterLink",{attrs:{to:"/java/为啥加锁可以解决可见性问题呢？.html"}},[t._v("为啥加锁可以解决可见性问题呢？")])],1),t._v(" "),a("li",[t._v("volalite")])]),t._v(" "),a("h4",{attrs:{id:"_2-1-volalite怎么解决可见性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-volalite怎么解决可见性问题"}},[t._v("#")]),t._v(" 2.1 "),a("code",[t._v("volalite")]),t._v("怎么解决可见性问题？")]),t._v(" "),a("p",[t._v("每个线程操作数据的时候会把数据从"),a("strong",[t._v("主内存读取到自己的工作内存")]),t._v("，如果他操作了数据并且写回了，"),a("strong",[t._v("其他已经读取的线程的变量副本就会失效了")]),t._v("，需要都数据进行操作又要"),a("strong",[t._v("再次去主内存中读取")]),t._v("了。")]),t._v(" "),a("p",[t._v("volatile保证不同线程对共享变量操作的可见性，也就是说"),a("strong",[t._v("一个线程修改了volatile修饰的变量，当修改写回主内存时，另外一个线程立即看到最新的值")]),t._v("。")]),t._v(" "),a("p",[t._v("当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，举例说明变量在多个CPU之间的共享")]),t._v(" "),a("p",[t._v("为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。 "),a("RouterLink",{attrs:{to:"/04.java/操作系统/MESI（缓存一致性协议）.html"}},[t._v("MESI（缓存一致性协议）")])],1),t._v(" "),a("p",[t._v("所以不要大量使用Volatile，因为大量使用volalite会引起总线风暴。至于什么时候去使用Volatile什么时候使用锁，根据场景区分。")]),t._v(" "),a("h2",{attrs:{id:"volalite使用的实际案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volalite使用的实际案例"}},[t._v("#")]),t._v(" volalite使用的实际案例")]),t._v(" "),a("ol",[a("li",[a("RouterLink",{attrs:{to:"/pages/2b7746/"}},[t._v("java:双重检查 线程安全的懒汉式单例模式")])],1)])])}),[],!1,null,null,null);a.default=_.exports}}]);