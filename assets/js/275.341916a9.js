(window.webpackJsonp=window.webpackJsonp||[]).push([[275],{967:function(v,_,t){"use strict";t.r(_);var n=t(3),s=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("strong",[v._v("1.选择合适的字段创建索引：")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("不为 NULL 的字段")]),v._v(" ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。")]),v._v(" "),_("li",[_("strong",[v._v("被频繁查询的字段")]),v._v(" ：我们创建索引的字段应该是查询操作非常频繁的字段。")]),v._v(" "),_("li",[_("strong",[v._v("被作为条件查询的字段")]),v._v(" ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。")]),v._v(" "),_("li",[_("strong",[v._v("频繁需要排序的字段")]),v._v(" ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。")]),v._v(" "),_("li",[_("strong",[v._v("被经常频繁用于连接的字段")]),v._v(" ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。")])]),v._v(" "),_("p",[_("strong",[v._v("2.被频繁更新的字段应该慎重建立索引。")])]),v._v(" "),_("p",[v._v("虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。")]),v._v(" "),_("p",[_("strong",[v._v("3.尽可能的考虑建立联合索引而不是单列索引。")])]),v._v(" "),_("p",[v._v("因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。")]),v._v(" "),_("p",[_("strong",[v._v("4.注意避免冗余索引")]),v._v(" 。")]),v._v(" "),_("p",[v._v("冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。")]),v._v(" "),_("p",[_("strong",[v._v("5.考虑在字符串类型的字段上使用前缀索引代替普通索引。")])]),v._v(" "),_("p",[v._v("前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。")])])}),[],!1,null,null,null);_.default=s.exports}}]);