(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{454:function(v,a,e){v.exports=e.p+"assets/img/f486263d6ba6af582f5a5099a6f32ae4_49680df660a34aa7b.f380ed03.png"},455:function(v,a){v.exports="data:image/png;base64,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"},456:function(v,a,e){v.exports=e.p+"assets/img/3be664e6b9167e361954a15cd1d8edf3_ef011fa6379f42ecb.e4f2a4be.png"},457:function(v,a,e){v.exports=e.p+"assets/img/f3c276f2add5ee43672cae54e99398ff_8a95441ee6424c2da.46fd6046.png"},458:function(v,a,e){v.exports=e.p+"assets/img/340ebc442de393e5d6eada74e0f5cea6_16e108e524d4413c8.6d0d5473.png"},793:function(v,a,e){"use strict";e.r(a);var t=e(3),_=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("ul",[a("li",[a("p",[v._v("1、 计算机的硬件内存结构")])]),v._v(" "),a("li",[a("p",[v._v("2、 Java 内存模型的背景和定义")])]),v._v(" "),a("li",[a("p",[v._v("3、 Java 内存模型 3.1 主内存、工作内存的定义 3.2 内存的交互操作 3.3 JMM 缓存不一致问题")])]),v._v(" "),a("li",[a("p",[v._v("4、 Java 内存模型的实现")])])]),v._v(" "),a("p",[v._v("在学习 Java 内存模型(JMM)前，我们先了解下计算机的硬件内存结构，因为 JMM 结构就是基于此演变而来的。")]),v._v(" "),a("h2",{attrs:{id:"_1、-计算机的硬件内存结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、-计算机的硬件内存结构"}},[v._v("#")]),v._v(" 1、 计算机的硬件内存结构")]),v._v(" "),a("p",[v._v("在单核计算机中，计算机中的 CPU 计算速度是非常快的，但是与计算机中的其它硬件(如 IO、内存等)同 CPU 的速度比起来是相差甚远的，所以协调 CPU 和各个硬件之间的速度差异是非常重要的，要不然 CPU 就一直在等待，浪费资源。单核尚且如此，在多核中，这样的问题会更加的突出。硬件结构如下图所示：")]),v._v(" "),a("img",{attrs:{width:"630",height:"438",src:e(454)}}),v._v(" "),a("p",[v._v("我们先大概梳理下这个流程：当我们的计算机要执行某个任务或者计算某个数字时，主内存会首先从数据库中加载计算机计算所需要的数据，因为内存和 CPU 的速度相差较大，所以有必要在内存和 CPU 间引入缓存(根据实际的需要，可以引入多层缓存)，主内存中的数据会先存放在 CPU 缓存中，当这些数据需要同 CPU 做交互时会加入到 CPU 寄存器中，最后被 CPU 使用。")]),v._v(" "),a("p",[v._v("事实上，在单核情况下，基于缓存的交互可以很好的解决 CPU 与其它硬件之间的速度匹配，但是在多核情况下，各个处理器都要遵循一定的协议来保障内存中的各个处理器的缓存和主内存中的数据一致性问题，这类协议通常被称为缓存一致性协议。")]),v._v(" "),a("p",[a("img",{attrs:{src:e(455),alt:""}})]),v._v(" "),a("h2",{attrs:{id:"_2、-java-内存模型的背景和定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、-java-内存模型的背景和定义"}},[v._v("#")]),v._v(" 2、 Java 内存模型的背景和定义")]),v._v(" "),a("p",[v._v("我们在开发时会经常遇到这样的场景，我们开发完成的代码在我们自己的运行环境上表现良好，但是当我们把它放在其它硬件平台上时，就会出现各种各样的错误，这是因为在不同的硬件生产商和不同的操作系统下，内存的访问逻辑有一定的差异，结果就是当你的代码在某个系统环境下运行良好，并且线程安全，但是换了个系统就出现各种问题。")]),v._v(" "),a("p",[v._v("为了解决这个问题，Java 内存模型(JMM)的概念就被提出来了，它的出现可以屏蔽系统和硬件的差异，让一套代码在不同平台下能到达相同的访问结果，实现平台的一致性，使得 Java 程序能够"),a("strong",[v._v("一次编写，到处运行")]),v._v("。")]),v._v(" "),a("p",[v._v("这样的描述的好像有点熟悉啊，这不是 JVM 的概念描述么，它们两者有什么区别啊?")]),v._v(" "),a("p",[a("strong",[v._v("JVM 与 JMM 间的区别？")])]),v._v(" "),a("p",[v._v("实际上，JMM 是 Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本，本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。而 JVM 则是描述的是 Java 虚拟机内部及各个结构间的关系。")]),v._v(" "),a("p",[v._v("小伙伴这时可能会有疑问，既然 JMM 是定义线程和主内存之间的关系，那么它的出现是不是解决并发领域的问题啊？没错，我们先回顾一下并发领域中的关键问题。")]),v._v(" "),a("p",[a("strong",[v._v("并发领域中的关键问题？")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("线程之间的通信")])])]),v._v(" "),a("p",[v._v("在编程中，线程之间的通信机制有两种，"),a("code",[v._v("共享内存")]),v._v("和"),a("code",[v._v("消息传递")]),v._v("。")]),v._v(" "),a("blockquote",[a("p",[v._v("在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。")]),v._v(" "),a("p",[v._v("消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在 java 中典型的消息传递方式就是 wait()和 notify()。")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("线程间的同步")])])]),v._v(" "),a("blockquote",[a("p",[v._v("同步是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。")])]),v._v(" "),a("p",[v._v("事实上，Java 内存模型(JMM)的并发采用的是共享内存模型。")]),v._v(" "),a("p",[v._v("下面，我们一起来学习 Java 内存模型")]),v._v(" "),a("h2",{attrs:{id:"_3、-java-内存模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、-java-内存模型"}},[v._v("#")]),v._v(" 3、 Java 内存模型")]),v._v(" "),a("p",[v._v("我们先看一张 JMM 的控制模型作图")]),v._v(" "),a("img",{attrs:{width:"630",height:"417",src:e(456)}}),v._v(" "),a("p",[v._v("由此可见，Java 内存模型(JMM)同 CPU 缓存模型结构类似，是基于 CPU 缓存模型来建立的。")]),v._v(" "),a("p",[v._v("我们先梳理一下 JMM 的工作流程，以上图为例，我们假设有一台四核的计算机，cpu1 操作线程 A，cpu2 操作线程 B，cpu3 操作线程 C，当这三个线程都需要对主内存中的共享变量进行操作时，这三条线程分别会将主内存中的共享内存读入自己的工作内存，自己保存一份共享变量的副本供自己线程本身使用。")]),v._v(" "),a("p",[v._v("这时有的小伙伴可能会有以下疑问：")]),v._v(" "),a("ul",[a("li",[a("p",[a("strong",[v._v("主内存、工作内存的定义是什么？")])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("如何将主内存中的共享变量读入自己线程本身的工作内存?")])])]),v._v(" "),a("li",[a("p",[a("strong",[v._v("当其中的某一条线程修改了共享变量后，其余线程中的共享变量值是否变化，如果变化，线程间是怎么保持可见性的？")])])])]),v._v(" "),a("p",[v._v("下面，我们针对这两个疑问一一解答。")]),v._v(" "),a("h3",{attrs:{id:"_3-1-主内存、工作内存的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-主内存、工作内存的定义"}},[v._v("#")]),v._v(" 3.1 主内存、工作内存的定义")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("主内存")])])]),v._v(" "),a("blockquote",[a("p",[v._v("主内存主要存储的是 Java 实例对象，即所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发现线程安全问题。")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("工作内存")])])]),v._v(" "),a("blockquote",[a("p",[v._v("工作内存主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，即每个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当然也包括了字节码行号指示器、相关 Native 方法的信息。注意由于工作内存是每个线程的私有数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。")])]),v._v(" "),a("p",[a("strong",[v._v("NOTE")]),v._v(":这里的主内存、工作内存与 Java 内存区域中的 Java 堆、栈、方法区不是同一层次的内存划分，这两者基本上没有关系。")]),v._v(" "),a("p",[v._v("搞清楚主内存和工作内存后，下一步就需要学习主内存与工作内存的数据交互操作的方式。")]),v._v(" "),a("h3",{attrs:{id:"_3-2-内存的交互操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-内存的交互操作"}},[v._v("#")]),v._v(" 3.2 内存的交互操作")]),v._v(" "),a("p",[v._v("主内存与工作内存的交互操作有 8 种，虚拟机必须保证每一个操作都是原子的，这八种操作分别是：")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("Lock(锁定)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于主内存的变量，把一个变量标识为一条线程独占状态。")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("unlock(解锁)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("read(读取)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("load(载入)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于工作内存的变量，它把 read 操作从主存中变量放入工作内存中")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("use(使用)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("assign(赋值)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("store(存储)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于工作内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的 write 使用")])]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("write(写入)")])])]),v._v(" "),a("blockquote",[a("p",[v._v("作用于主内存中的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中")])]),v._v(" "),a("p",[v._v("单看这八种类型的原子操作可能有点抽象，我们画一个操作流程图仔细梳理下。")]),v._v(" "),a("p",[a("strong",[v._v("操作流程图：")])]),v._v(" "),a("img",{attrs:{width:"630",height:"277",src:e(457)}}),v._v(" "),a("p",[v._v("从图中可以看出，如果要把一个变量从内存中复制到工作内存中，就需要顺序的执行 read 和 load 操作，如果把变量从工作内存同步到主内存中，就需要执行 store 和 write 操作。")]),v._v(" "),a("p",[a("strong",[v._v("NOTE:")]),v._v(" Java 内存模型只要求上述操作必须按顺序执行，却没要求是连续执行。")]),v._v(" "),a("p",[v._v("我们以两个线程为例梳理下操作流程：")]),v._v(" "),a("blockquote",[a("p",[v._v("假设存在两个线程 A 和 B，如果线程 A 要与线程 B 要通信的话，首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去；然后，线程 B 到主内存中读取线程 A 之前已经更新过的共享变量。")])]),v._v(" "),a("p",[v._v("敏锐的小伙伴可能会发现，如果多个线程同时读取修改同一个共享变量，这种情况可能会导致每个线程中的本地内存中缓存变量一致的问题，这个时候该怎么解决呢？")]),v._v(" "),a("h3",{attrs:{id:"_3-3-jmm-缓存不一致问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-jmm-缓存不一致问题"}},[v._v("#")]),v._v(" 3.3 JMM 缓存不一致问题")]),v._v(" "),a("p",[v._v("解决 JMM 中的本地内存变量的缓存不一致问题有两种解决方案，分别是"),a("code",[v._v("总线加锁")]),v._v("和"),a("code",[v._v("MESI缓存一致性协议")]),v._v("。")]),v._v(" "),a("p",[a("strong",[v._v("总线加锁")])]),v._v(" "),a("p",[v._v("总线加锁是 CPU 从主内存读取数据到本地内存时，会先在总线对这个数据加锁，这样其它 CPU 就没法去读或者去写这个数据，直到这个 CPU 使用完数据释放锁后，，其它的 CPU 才能读取该数据。")]),v._v(" "),a("img",{attrs:{width:"630",height:"492",src:e(458)}}),v._v(" "),a("p",[v._v("总线加锁虽然能保证数据一致，但是它却严重降低了系统性能，因为当一个线程多总线加锁后，其它线程都只能等待，将原有的并行操作转成了串行操作。")]),v._v(" "),a("p",[v._v("通常情况下，我们不采用这种方法，而是使用性能较高的缓存一致性协议。")]),v._v(" "),a("p",[a("strong",[v._v("MESI 缓存一致性协议")])]),v._v(" "),a("blockquote",[a("p",[v._v("MESI 缓存一致性协议是多个 CPU 从主内存读取同一个数据到各自的高速缓存中，当其中的某个 CPU 修改了缓存里的数据，该数据会马上同步回主内存，其它 CPU 通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效。")])]),v._v(" "),a("p",[v._v("在并发编程中，如果多个线程对同一个共享变量进行操作是，我们通常会在变量名称前加上关键在"),a("code",[v._v("volatile")]),v._v(",因为它可以保证线程对变量的修改的可见性，保证可见性的基础是多个线程都会监听总线。即当一个线程修改了共享变量后，该变量会立马同步到主内存，其余线程监听到数据变化后会使得自己缓存的原数据失效，并触发"),a("code",[v._v("read")]),v._v("操作读取新修改的变量的值。进而保证了多个线程的数据一致性。事实上，"),a("code",[v._v("volatile")]),v._v("的工作原理就是依赖于 MESI 缓存一致性协议实现的。")]),v._v(" "),a("h2",{attrs:{id:"_4、-java-内存模型的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、-java-内存模型的实现"}},[v._v("#")]),v._v(" 4、 Java 内存模型的实现")]),v._v(" "),a("p",[v._v("在 Java 多线程中，Java 提供了一系列与并发处理相关的关键字，比如"),a("code",[v._v("volatile")]),v._v("、"),a("code",[v._v("synchronized")]),v._v("、"),a("code",[v._v("final")]),v._v("、"),a("code",[v._v("concurren")]),v._v("包等。其实这些就是 Java 内存模型封装了底层的实现后提供给程序员使用的一些关键字")]),v._v(" "),a("p",[v._v("事实上，Java 内存模型的本质是围绕着 Java 并发过程中的如何处理"),a("code",[v._v("原子性")]),v._v("、"),a("code",[v._v("可见性")]),v._v("和"),a("code",[v._v("顺序性")]),v._v("这三个特征来设计的，这三大特性可以直接使用 Java 中提供的关键字实现，它们也是面试中经常被问到的题目。")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("原子性")])])]),v._v(" "),a("blockquote",[a("p",[v._v("原子性的定义是一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态。")])]),v._v(" "),a("p",[v._v("JMM 保证的原子性变量操作包括 read、load、assign、use、store、write")]),v._v(" "),a("p",[a("strong",[v._v("NOTE")]),v._v(":基本类型数据的访问大都是原子操作，long 和 double 类型的变量是 64 位，但是在 32 位 JVM 中，32 位的 JVM 会将 64 位数据的读写操作分为 2 次 32 位的读写操作来进行，这就导致了 long、double 类型的变量在 32 位虚拟机中是非原子操作，数据有可能会被破坏，也就意味着多个线程在并发访问的时候是线程非安全的。")]),v._v(" "),a("p",[v._v("对于非原子操作的基本类型，可以使用 synchronized 来保证方法和代码块内的操作是原子性的。")]),v._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[v._v("`synchronized (this) {` `a=1;` `b=2;``}`\n")])]),v._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[v._v("1")]),a("br")])]),a("p",[v._v("复制代码")]),v._v(" "),a("p",[v._v("如一个线程观察另外一个线程执行上面的代码，只能看到 a、b 都被赋值成功结果，或者 a、b 都尚未被赋值的结果。")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("可见性")])])]),v._v(" "),a("p",[v._v("Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。")]),v._v(" "),a("p",[v._v("Java 中的 volatile 关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用 volatile 来保证多线程操作时变量的可见性。")]),v._v(" "),a("p",[v._v("除了 volatile，Java 中的 synchronized 和 final 两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("有序性")])])]),v._v(" "),a("p",[v._v("在 Java 中，可以使用 synchronized 和 volatile 来保证多线程之间操作的有序性。实现方式有所区别：")]),v._v(" "),a("blockquote",[a("p",[v._v("volatile 关键字会禁止指令重排。synchronized 关键字保证同一时刻只允许一条线程操作。")])]),v._v(" "),a("p",[v._v("好了，这里简单的介绍完了 Java 并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像 synchronized 关键字是万 能的，他可以同时满足以上三种特性，这其实也是很多人滥用 synchronized 的原因。")]),v._v(" "),a("p",[v._v("但是 synchronized 是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。")])])}),[],!1,null,null,null);a.default=_.exports}}]);