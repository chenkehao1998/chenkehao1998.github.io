(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{435:function(a,t,e){a.exports=e.p+"assets/img/v2-55959129c3201541ba90fa29ea902_85a14850a8514fbb8.86b1b0a8.jpg"},436:function(a,t,e){a.exports=e.p+"assets/img/v2-d1f8a25ffc3123df7c4ddb45441cc_48fed06ab915439ab.d1f8a25f.jpg"},437:function(a,t,e){a.exports=e.p+"assets/img/v2-2a07eac94c7617b2c6e92ed682969_27518f7bab554e25a.2a07eac9.jpg"},438:function(a,t,e){a.exports=e.p+"assets/img/v2-789614c75618f2701f742b543cb24_1f3920e1122748039.8a08dbb4.jpg"},439:function(a,t,e){a.exports=e.p+"assets/img/v2-cd9fbfd33a925589f3bd8d4a69f58_5150cd04b7314cdd9.a2e288d5.jpg"},440:function(a,t,e){a.exports=e.p+"assets/img/v2-46aa1b57381b8ad02ea1fc1c8d980_c3c19ecc0b184a238.46aa1b57.jpg"},441:function(a,t,e){a.exports=e.p+"assets/img/v2-ad13ee900d2a22f5976e9cad622ce_0cac3e67276944cca.ad13ee90.jpg"},442:function(a,t,e){a.exports=e.p+"assets/img/v2-d94c2503dcc5d63746e1fd55e9930_5de115b75ba34bd98.f3d5137f.jpg"},774:function(a,t,e){"use strict";e.r(t);var n=e(3),c=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[t("strong",[a._v("1.前提概要")])]),a._v(" "),t("p",[a._v("很多java开发者在使用Spring框架中都见过后缀为FactoryBean的类，比如Mybatis-Spring中的SqlSessionFactoryBean。说到这里就不得不提BeanFactory。FactoryBean和BeanFactory特别容易让人混淆，面试还经常问到这两种概念。其实它们的作用和使用场景是不一样的。")]),a._v(" "),t("p",[t("strong",[a._v("2.BeanFactory")])]),a._v(" "),t("p",[a._v("先来说说BeanFactory。用于访问Spring bean容器的根接口。这是Spring bean容器的基本客户端视图。原来是获取Spring Bean的接口，也就是IoC容器。然后我们看类图。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(435),alt:""}})]),a._v(" "),t("p",[a._v("原来我们更常用的ApplicationContext就是一个BeanFactory。我们通过bean的名称或者类型都可以从BeanFactory来获取bean。对于BeanFactory这么介绍相信都不陌生了。让我们把关注点转向FactoryBean上。")]),a._v(" "),t("p",[t("strong",[a._v("3.FactoryBean")])]),a._v(" "),t("p",[a._v("FactoryBean 是个什么玩意儿呢？来看看源码。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(436),alt:""}})]),a._v(" "),t("ul",[t("li",[a._v("T getObject() 获取泛型T的实例。用来创建Bean。当IoC容器通过getBean方法来FactoryBean创建的实例时实际获取的不是FactoryBean 本身而是具体创建的T泛型实例。等下我们会来验证这个事情。")]),a._v(" "),t("li",[a._v("Class<?> getObjectType() 获取 T getObject()中的返回值 T 的具体类型。这里强烈建议如果T是一个接口，返回其具体实现类的类型。")]),a._v(" "),t("li",[a._v("default boolean isSingleton() 用来规定 Factory创建的的bean是否是单例。这里通过默认方法定义为单例。")])]),a._v(" "),t("p",[t("strong",[a._v("3.1 FactoryBean使用场景")])]),a._v(" "),t("p",[a._v("FactoryBean 用来创建一类bean。比如你有一些同属鸟类的bean需要被创建，但是它们自己有各自的特点，你只需要把他们的特点注入FactoryBean中就可以生产出各种鸟类的实例。举一个更加贴近实际生产的例子。甚至这个例子你可以应用到实际java开发中去。我们需要自己造一个定时任务的轮子。用FactoryBean 再合适不过了。我们来用代码说话一步步来演示FactoryBean的使用场景。")]),a._v(" "),t("p",[t("strong",[a._v("3.2 构建一个FactoryBean")])]),a._v(" "),t("p",[a._v("我们声明定时任务一般具有下列要素：")]),a._v(" "),t("ul",[t("li",[a._v("时间周期，肯定会使用到cron表达式。")]),a._v(" "),t("li",[a._v("一个任务的执行抽象接口。")]),a._v(" "),t("li",[a._v("定时任务具体行为的执行者。")])]),a._v(" "),t("p",[a._v("Task任务执行抽象接口的实现。实现包含两个方面：")]),a._v(" "),t("ul",[t("li",[a._v("SomeService 是具体任务的执行逻辑。")]),a._v(" "),t("li",[a._v("cron时间表达式")])]),a._v(" "),t("p",[t("img",{attrs:{src:e(437),alt:""}})]),a._v(" "),t("p",[a._v("通过以上的定义。任务的时间和任务的逻辑可以根据不同的业务做到差异化配置。然后我们实现一个关于Task的FactoryBean。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(438),alt:""}})]),a._v(" "),t("p",[t("strong",[a._v("3.3 FactoryBean 注入IoC")])]),a._v(" "),t("p",[a._v("你可以使用xml的注入方式，当然也可以使用javaConfig的配置方式。这里我们使用javaConfig注入。我们将两个FactroyBean注入到Spring容器中去。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(439),alt:""}})]),a._v(" "),t("p",[t("strong",[a._v("3.4 FactoryBean的一些特点")])]),a._v(" "),t("p",[a._v("一般如上声明后，@Bean注解如果不显式声明bean名称则方法名作为bean的名称，而且返回值作为注入的Bean。但是我们通过debug发现却是这样的：")]),a._v(" "),t("img",{attrs:{width:"690",height:"80",src:e(440)}}),a._v(" "),t("p",[a._v("也就是说通过方法名是返回FactoryBean 创建的Bean。那么如何返回该FactoryBean呢？上图中也给出了答案在方法前增加引用符“&”。具体的原因还用从BeanFactory中寻找，真是不是冤家不聚头。")]),a._v(" "),t("img",{attrs:{width:"690",height:"199",src:e(441)}}),a._v(" "),t("p",[a._v("我们对上面声明的两个bean进行测试，也出色地完成了不同的定时任务业务逻辑。")]),a._v(" "),t("p",[t("img",{attrs:{src:e(442),alt:""}})])])}),[],!1,null,null,null);t.default=c.exports}}]);