(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{559:function(t,e,r){t.exports=r.p+"assets/img/2022-04-24-14-12-03.1044ae47.png"},560:function(t,e,r){t.exports=r.p+"assets/img/2022-04-24-14-12-37.76c45c6b.png"},561:function(t,e,r){t.exports=r.p+"assets/img/8048507-940b244b5509307a_31fce16382a1407380767c3e7.e7738eee.png"},562:function(t,e,r){t.exports=r.p+"assets/img/8048507-1e9a8b6d228808a3_f577af26da0b4934b8811b29e.4589d038.png"},886:function(t,e,r){"use strict";r.r(e);var i=r(3),s=Object(i.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"git-reset-hard-soft-与-git-revert-的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset-hard-soft-与-git-revert-的作用"}},[t._v("#")]),t._v(" git reset --hard --soft 与 git revert 的作用：")]),t._v(" "),e("ul",[e("li",[e("ol",[e("li",[t._v("文件从暂存区回退到工作区")])])]),t._v(" "),e("li",[e("ol",{attrs:{start:"2"}},[e("li",[t._v("版本回退")])])])]),t._v(" "),e("h2",{attrs:{id:"git简单的分为三个区域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git简单的分为三个区域"}},[t._v("#")]),t._v(" git简单的分为三个区域 ：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("1、工作区（working directory）")])]),t._v(" "),e("li",[e("p",[t._v("2、暂缓区（stage index）")])]),t._v(" "),e("li",[e("p",[t._v("3、历史记录区（history）")])])]),t._v(" "),e("p",[e("img",{attrs:{src:r(559),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"git-reset-hard-xxx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset-hard-xxx"}},[t._v("#")]),t._v(" git reset --hard xxx")]),t._v(" "),e("ul",[e("li",[t._v("hard （修改版本库，修改暂存区，修改工作区）")])]),t._v(" "),e("p",[t._v("--hard HEAD～1 (或是版本号)意为将版本库回退1个版本，但是不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本")]),t._v(" "),e("p",[e("img",{attrs:{src:r(560),alt:""}})]),t._v(" "),e("p",[t._v("hard-修改版本库.png")]),t._v(" "),e("ul",[e("li",[t._v("HEAD 就是当前活跃分支的游标。形象的记忆就是：你现在在哪儿，HEAD 就指向哪儿，所以 Git 才知道你在那儿！\n不过 HEAD 并非只能指向分支的最顶端（时间节点距今最近的那个），实际上它可以指向任何一个节点，它就是 Git 内部用来追踪当前位置的东东。")])]),t._v(" "),e("h2",{attrs:{id:"git-reset-soft-xxx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-reset-soft-xxx"}},[t._v("#")]),t._v(" git reset --soft xxx")]),t._v(" "),e("ul",[e("li",[t._v("soft （修改版本库，保留暂存区，保留工作区）")])]),t._v(" "),e("p",[t._v("--soft HEAD～1 意为将版本库软回退1个版本，所谓软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(561),alt:""}})]),t._v(" "),e("p",[t._v("soft-修改版本库.png")]),t._v(" "),e("h2",{attrs:{id:"git-revert-xxx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-revert-xxx"}},[t._v("#")]),t._v(" git revert xxx")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("revert\n-- git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit，指针向后移动。")]),t._v(" "),e("p",[e("img",{attrs:{src:r(562),alt:""}})]),t._v(" "),e("p",[t._v("revert回滚.png")])])]),t._v(" "),e("h2",{attrs:{id:"git-revert和git-reset的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-revert和git-reset的区别"}},[t._v("#")]),t._v(" git revert和git reset的区别")]),t._v(" "),e("p",[t._v("git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交，而git reset会将撤销点之后的操作都回退到暂存区中。")]),t._v(" "),e("p",[t._v("1、git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。")]),t._v(" "),e("p",[t._v("2、在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。")]),t._v(" "),e("p",[t._v("因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。")]),t._v(" "),e("p",[t._v("3、git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。")]),t._v(" "),e("p",[t._v("附：不得不提的git的其它删除命令（类似于Linux的命令）：")]),t._v(" "),e("ul",[e("li",[t._v("git rm --cached readme.txt 只从缓存区中删除readme.txt，保留物理文件")]),t._v(" "),e("li",[t._v("git rm readme.txt 不但从缓存区中删除，同时删除物理文件")]),t._v(" "),e("li",[t._v("git mv a.txt b.txt 把a.txt改名为b.txt")])])])}),[],!1,null,null,null);e.default=s.exports}}]);